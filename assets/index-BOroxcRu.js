/**
* @vue/shared v3.4.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str, expectsLowerCase) {
  const set2 = new Set(str.split(","));
  return (val) => set2.has(val);
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove$2 = (arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn$1 = (val, key) => hasOwnProperty$2.call(val, key);
const isArray$3 = Array.isArray;
const isMap = (val) => toTypeString$1(val) === "[object Map]";
const isSet = (val) => toTypeString$1(val) === "[object Set]";
const isDate$1 = (val) => toTypeString$1(val) === "[object Date]";
const isFunction$1 = (val) => typeof val === "function";
const isString$3 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$4 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return (isObject$4(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString$1 = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString$1(value).slice(8, -1);
};
const isPlainObject$3 = (val) => toTypeString$1(val) === "[object Object]";
const isIntegerKey = (key) => isString$3(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str) => {
  const s = str ? `on${capitalize$1(str)}` : ``;
  return s;
});
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
const toNumber = (val) => {
  const n2 = isString$3(val) ? Number(val) : NaN;
  return isNaN(n2) ? val : n2;
};
let _globalThis$1;
const getGlobalThis$1 = () => {
  return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray$3(value)) {
    const res = {};
    for (let i2 = 0; i2 < value.length; i2++) {
      const item = value[i2];
      const normalized = isString$3(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$3(value) || isObject$4(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$3(value)) {
    res = value;
  } else if (isArray$3(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      const normalized = normalizeClass(value[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$4(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  let equal = true;
  for (let i2 = 0; equal && i2 < a2.length; i2++) {
    equal = looseEqual(a2[i2], b2[i2]);
  }
  return equal;
}
function looseEqual(a2, b2) {
  if (a2 === b2)
    return true;
  let aValidType = isDate$1(a2);
  let bValidType = isDate$1(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
  }
  aValidType = isSymbol(a2);
  bValidType = isSymbol(b2);
  if (aValidType || bValidType) {
    return a2 === b2;
  }
  aValidType = isArray$3(a2);
  bValidType = isArray$3(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
  }
  aValidType = isObject$4(a2);
  bValidType = isObject$4(b2);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a2).length;
    const bKeysCount = Object.keys(b2).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a2) {
      const aHasKey = a2.hasOwnProperty(key);
      const bHasKey = b2.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b2[key])) {
        return false;
      }
    }
  }
  return String(a2) === String(b2);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString$1 = (val) => {
  return isString$3(val) ? val : val == null ? "" : isArray$3(val) || isObject$4(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i2) => {
          entries[stringifySymbol(key, i2) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject$4(val) && !isArray$3(val) && !isPlainObject$3(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v2, i2 = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v2) ? `Symbol(${(_a = v2.description) != null ? _a : i2})` : v2
  );
};
/**
* @vue/reactivity v3.4.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i2, l2;
      for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
        this.effects[i2].stop();
      }
      for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
        this.cleanups[i2]();
      }
      if (this.scopes) {
        for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
          this.scopes[i2].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last2 = this.parent.scopes.pop();
        if (last2 && last2 !== this) {
          this.parent.scopes[this.index] = last2;
          last2.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
let activeEffect;
class ReactiveEffect {
  constructor(fn, trigger2, scheduler, scope) {
    this.fn = fn;
    this.trigger = trigger2;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this._dirtyLevel = 4;
    this._trackId = 0;
    this._runnings = 0;
    this._shouldSchedule = false;
    this._depsLength = 0;
    recordEffectScope(this, scope);
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1;
      pauseTracking();
      for (let i2 = 0; i2 < this._depsLength; i2++) {
        const dep = this.deps[i2];
        if (dep.computed) {
          triggerComputed(dep.computed);
          if (this._dirtyLevel >= 4) {
            break;
          }
        }
      }
      if (this._dirtyLevel === 1) {
        this._dirtyLevel = 0;
      }
      resetTracking();
    }
    return this._dirtyLevel >= 4;
  }
  set dirty(v2) {
    this._dirtyLevel = v2 ? 4 : 0;
  }
  run() {
    this._dirtyLevel = 0;
    if (!this.active) {
      return this.fn();
    }
    let lastShouldTrack = shouldTrack;
    let lastEffect = activeEffect;
    try {
      shouldTrack = true;
      activeEffect = this;
      this._runnings++;
      preCleanupEffect(this);
      return this.fn();
    } finally {
      postCleanupEffect(this);
      this._runnings--;
      activeEffect = lastEffect;
      shouldTrack = lastShouldTrack;
    }
  }
  stop() {
    if (this.active) {
      preCleanupEffect(this);
      postCleanupEffect(this);
      this.onStop && this.onStop();
      this.active = false;
    }
  }
}
function triggerComputed(computed2) {
  return computed2.value;
}
function preCleanupEffect(effect2) {
  effect2._trackId++;
  effect2._depsLength = 0;
}
function postCleanupEffect(effect2) {
  if (effect2.deps.length > effect2._depsLength) {
    for (let i2 = effect2._depsLength; i2 < effect2.deps.length; i2++) {
      cleanupDepEffect(effect2.deps[i2], effect2);
    }
    effect2.deps.length = effect2._depsLength;
  }
}
function cleanupDepEffect(dep, effect2) {
  const trackId = dep.get(effect2);
  if (trackId !== void 0 && effect2._trackId !== trackId) {
    dep.delete(effect2);
    if (dep.size === 0) {
      dep.cleanup();
    }
  }
}
let shouldTrack = true;
let pauseScheduleStack = 0;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last2 = trackStack.pop();
  shouldTrack = last2 === void 0 ? true : last2;
}
function pauseScheduling() {
  pauseScheduleStack++;
}
function resetScheduling() {
  pauseScheduleStack--;
  while (!pauseScheduleStack && queueEffectSchedulers.length) {
    queueEffectSchedulers.shift()();
  }
}
function trackEffect(effect2, dep, debuggerEventExtraInfo) {
  if (dep.get(effect2) !== effect2._trackId) {
    dep.set(effect2, effect2._trackId);
    const oldDep = effect2.deps[effect2._depsLength];
    if (oldDep !== dep) {
      if (oldDep) {
        cleanupDepEffect(oldDep, effect2);
      }
      effect2.deps[effect2._depsLength++] = dep;
    } else {
      effect2._depsLength++;
    }
  }
}
const queueEffectSchedulers = [];
function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
  pauseScheduling();
  for (const effect2 of dep.keys()) {
    let tracking;
    if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
      effect2._dirtyLevel = dirtyLevel;
    }
    if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      effect2.trigger();
      if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
        effect2._shouldSchedule = false;
        if (effect2.scheduler) {
          queueEffectSchedulers.push(effect2.scheduler);
        }
      }
    }
  }
  resetScheduling();
}
const createDep = (cleanup, computed2) => {
  const dep = /* @__PURE__ */ new Map();
  dep.cleanup = cleanup;
  dep.computed = computed2;
  return dep;
};
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
    }
    trackEffect(
      activeEffect,
      dep
    );
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$3(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$3(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$3(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  pauseScheduling();
  for (const dep of deps) {
    if (dep) {
      triggerEffects(
        dep,
        4
      );
    }
  }
  resetScheduling();
}
function getDepFromReactive(object, key) {
  const depsMap = targetMap.get(object);
  return depsMap && depsMap.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      pauseScheduling();
      const res = toRaw(this)[key].apply(this, args);
      resetScheduling();
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty$1(key) {
  if (!isSymbol(key))
    key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the reciever is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray$3(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn$1(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$1;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$4(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$3(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray$3(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$1(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn$1(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$3(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
  true
);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$1(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap2(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap2(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add$1(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$2(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap2(value), wrap2(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap2(value[0]), wrap2(value[1])] : wrap2(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add: add$1,
    set: set$2,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add: add$1,
    set: set$2,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn$1(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$4(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject$4(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$4(value) ? readonly(value) : value;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this.getter = getter;
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this.effect = new ReactiveEffect(
      () => getter(this._value),
      () => triggerRefValue(
        this,
        this.effect._dirtyLevel === 2 ? 2 : 3
      )
    );
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
      triggerRefValue(self2, 4);
    }
    trackRefValue(self2);
    if (self2.effect._dirtyLevel >= 2) {
      triggerRefValue(self2, 2);
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(v2) {
    this.effect.dirty = v2;
  }
  // #endregion
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$1(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function trackRefValue(ref2) {
  var _a;
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    trackEffect(
      activeEffect,
      (_a = ref2.dep) != null ? _a : ref2.dep = createDep(
        () => ref2.dep = void 0,
        ref2 instanceof ComputedRefImpl ? ref2 : void 0
      )
    );
  }
}
function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    triggerEffects(
      dep,
      dirtyLevel
    );
  }
}
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this, 4);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2, 4);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function toValue$2(source) {
  return isFunction$1(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const { get: get2, set: set2 } = factory(
      () => trackRefValue(this),
      () => triggerRefValue(this)
    );
    this._get = get2;
    this._set = set2;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  const ret = isArray$3(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this.__v_isRef = true;
    this.__v_isReadonly = true;
  }
  get value() {
    return this._getter();
  }
}
function toRef$1(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction$1(source)) {
    return new GetterRefImpl(source);
  } else if (isObject$4(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
/**
* @vue/runtime-core v3.4.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
function warn$1$1(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        msg + args.map((a2) => {
          var _a, _b;
          return (_b = (_a = a2.toString) == null ? void 0 : _a.call(a2)) != null ? _b : JSON.stringify(a2);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last2 = normalizedStack[0];
    if (last2 && last2.vnode === currentVNode) {
      last2.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i2) => {
    logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString$3(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$1(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$1(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray$3(fn)) {
    const values2 = [];
    for (let i2 = 0; i2 < fn.length; i2++) {
      values2.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
    }
    return values2;
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      pauseTracking();
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id2) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id2 || middleJobId === id2 && middleJob.pre) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i2 = queue.indexOf(job);
  if (i2 > flushIndex) {
    queue.splice(i2, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$3(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen2, i2 = isFlushing ? flushIndex + 1 : 0) {
  for (; i2 < queue.length; i2++) {
    const cb = queue[i2];
    if (cb && cb.pre) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue.splice(i2, 1);
      i2--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a2, b2) => getId(a2) - getId(b2)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a2, b2) => {
  const diff = getId(a2) - getId(b2);
  if (diff === 0) {
    if (a2.pre && !b2.pre)
      return -1;
    if (b2.pre && !a2.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number: number2, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a2) => isString$3(a2) ? a2.trim() : a2);
    }
    if (number2) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$4(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$3(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject$4(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$1(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options, hyphenate(key)) || hasOwn$1(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id2) {
  currentScopeId = id2;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render: render2,
    renderCache,
    props,
    data: data2,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render2.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data2,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render22 = Component;
      if (false)
        ;
      result = normalizeVNode(
        render22.length > 1 ? render22(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render22(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
function filterSingleRoot(children, recurse = true) {
  let singleRoot;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    if (isVNode$1(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const COMPONENTS = "components";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$3(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
}
const isSuspense = (type) => type.__isSuspense;
let suspenseId = 0;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
        n2.suspense = n1.suspense;
        n2.suspense.vnode = n2;
        n2.el = n1.el;
        return;
      }
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction$1(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement: createElement2 }
  } = rendererInternals;
  const hiddenContainer = createElement2("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    namespace,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      namespace,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement: createElement2 } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        if (!isHydrating) {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      }
    } else {
      suspense.pendingId = suspenseId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement2("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      if (newBranch.shapeFlag & 512) {
        suspense.pendingId = newBranch.component.suspenseId;
      } else {
        suspense.pendingId = suspenseId++;
      }
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: { parentNode, remove: remove2 }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense && parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
  const initialAnchor = anchor;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    namespace,
    container,
    hiddenContainer,
    deps: 0,
    pendingId: suspenseId++,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !isHydrating,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      let delayEnter = false;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(
                pendingBranch,
                container2,
                anchor === initialAnchor ? next(activeBranch) : anchor,
                0
              );
              queuePostFlushCb(effects);
            }
          };
        }
        if (activeBranch) {
          if (parentNode(activeBranch.el) !== suspense.hiddenContainer) {
            anchor = next(activeBranch);
          }
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor && !delayEnter) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          namespace2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next(instance.subTree),
          suspense,
          namespace,
          optimized
        );
        if (placeholder) {
          remove2(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
  );
  const result = hydrateNode(
    node,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if (isFunction$1(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (isArray$3(s)) {
    const singleChild = filterSingleRoot(s);
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$3(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  let el = branch.el;
  while (!el && branch.component) {
    branch = branch.component.subTree;
    el = branch.el;
  }
  vnode.el = el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function isVNodeSuspensible(vnode) {
  const suspensible = vnode.props && vnode.props.suspensible;
  return suspensible != null && suspensible !== false;
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watchSyncEffect(effect2, options) {
  return doWatch(
    effect2,
    null,
    { flush: "sync" }
  );
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, {
  immediate,
  deep,
  flush,
  once,
  onTrack,
  onTrigger
} = EMPTY_OBJ) {
  if (cb && once) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      unwatch();
    };
  }
  const instance = currentInstance;
  const reactiveGetter = (source2) => deep === true ? source2 : (
    // for deep: false, only traverse root-level properties
    traverse(source2, deep === false ? 1 : void 0)
  );
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray$3(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction$1(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else
        ;
    });
  } else if (isFunction$1(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
      cleanup = effect2.onStop = void 0;
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active || !effect2.dirty) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
  const scope = getCurrentScope();
  const unwatch = () => {
    effect2.stop();
    if (scope) {
      remove$2(scope.effects, effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect2.run.bind(effect2),
      instance && instance.suspense
    );
  } else {
    effect2.run();
  }
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$3(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$1(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
function traverse(value, depth = Infinity, seen2) {
  if (depth <= 0 || !isObject$4(value) || value["__v_skip"]) {
    return value;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value)) {
    return value;
  }
  seen2.add(value);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen2);
  } else if (isArray$3(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      traverse(value[i2], depth, seen2);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v2) => {
      traverse(v2, depth, seen2);
    });
  } else if (isPlainObject$3(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen2);
    }
  }
  return value;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (dir) {
      if (isFunction$1(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction$1(options) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove$2(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function renderList(source, renderItem, cache2, index) {
  let ret;
  const cached = cache2;
  if (isArray$3(source) || isString$3(source)) {
    ret = new Array(source.length);
    for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
      ret[i2] = renderItem(source[i2], i2, void 0, cached);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached);
    }
  } else if (isObject$4(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i2) => renderItem(item, i2, void 0, cached)
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i2 = 0, l2 = keys.length; i2 < l2; i2++) {
        const key = keys[i2];
        ret[i2] = renderItem(source[key], key, i2, cached);
      }
    }
  } else {
    ret = [];
  }
  return ret;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default")
      props.name = name;
    return createVNode("slot", props, fallback);
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name}`
    },
    validSlotContent || [],
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode$1(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i2) => {
  if (!i2)
    return null;
  if (isStatefulComponent(i2))
    return getExposeProxy(i2) || i2.proxy;
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i2) => i2,
    $el: (i2) => i2.vnode.el,
    $data: (i2) => i2.data,
    $props: (i2) => i2.props,
    $attrs: (i2) => i2.attrs,
    $slots: (i2) => i2.slots,
    $refs: (i2) => i2.refs,
    $parent: (i2) => getPublicInstance(i2.parent),
    $root: (i2) => getPublicInstance(i2.root),
    $emit: (i2) => i2.emit,
    $options: (i2) => resolveMergedOptions(i2),
    $forceUpdate: (i2) => i2.f || (i2.f = () => {
      i2.effect.dirty = true;
      queueJob(i2.update);
    }),
    $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
    $watch: (i2) => instanceWatch.bind(i2)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data: data2, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n2 = accessCache[key];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key];
          case 2:
            return data2[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data2 !== EMPTY_OBJ && hasOwn$1(data2, key)) {
        accessCache[key] = 2;
        return data2[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data: data2, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data2 !== EMPTY_OBJ && hasOwn$1(data2, key)) {
      data2[key] = value;
      return true;
    } else if (hasOwn$1(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data: data2, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data2 !== EMPTY_OBJ && hasOwn$1(data2, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn$1(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray$3(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
function mergeModels(a2, b2) {
  if (!a2 || !b2)
    return a2 || b2;
  if (isArray$3(a2) && isArray$3(b2))
    return a2.concat(b2);
  return extend({}, normalizePropsOrEmits(a2), normalizePropsOrEmits(b2));
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$1(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data2 = dataOptions.call(publicThis, publicThis);
    if (!isObject$4(data2))
      ;
    else {
      instance.data = reactive(data2);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v2) => c.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$3(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$3(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$3(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$4(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v2) => injected.value = v2
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$3(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$3(raw)) {
    const handler = ctx[raw];
    if (isFunction$1(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$1(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$4(raw)) {
    if (isArray$3(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
    } else {
      const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$1(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m2) => mergeOptions$1(resolved, m2, optionMergeStrategies, true)
      );
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  if (isObject$4(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
function mergeOptions$1(to, from2, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from2;
  if (extendsOptions) {
    mergeOptions$1(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m2) => mergeOptions$1(to, m2, strats, true)
    );
  }
  for (const key in from2) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from2[key]) : from2[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from2) {
  if (!from2) {
    return to;
  }
  if (!to) {
    return from2;
  }
  return function mergedDataFn() {
    return extend(
      isFunction$1(to) ? to.call(this, this) : to,
      isFunction$1(from2) ? from2.call(this, this) : from2
    );
  };
}
function mergeInject(to, from2) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from2));
}
function normalizeInject(raw) {
  if (isArray$3(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from2) {
  return to ? [...new Set([].concat(to, from2))] : from2;
}
function mergeObjectOptions(to, from2) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from2) : from2;
}
function mergeEmitsOrPropsOptions(to, from2) {
  if (to) {
    if (isArray$3(to) && isArray$3(from2)) {
      return [.../* @__PURE__ */ new Set([...to, ...from2])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from2 != null ? from2 : {})
    );
  } else {
    return from2;
  }
}
function mergeWatchOptions(to, from2) {
  if (!to)
    return from2;
  if (!from2)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from2) {
    merged[key] = mergeAsArray(to[key], from2[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$1(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject$4(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$2,
      get config() {
        return context.config;
      },
      set config(v2) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$1(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction$1(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else
          ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else
      ;
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn$1(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn$1(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn$1(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn$1(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn$1(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn$1(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$4(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$3(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$3(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn$1(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$4(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
function getType(ctor) {
  if (ctor === null) {
    return "null";
  }
  if (typeof ctor === "function") {
    return ctor.name || "";
  } else if (typeof ctor === "object") {
    const name = ctor.constructor && ctor.constructor.name;
    return name || "";
  }
  return "";
}
function isSameType(a2, b2) {
  return getType(a2) === getType(b2);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$3(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type));
  } else if (isFunction$1(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$3(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot$1 = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$1(value)) {
      slots[key] = normalizeSlot$1(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      extend(slots, children);
      def(slots, "_", type, true);
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$3(rawRef)) {
    rawRef.forEach(
      (r2, i2) => setRef(
        r2,
        oldRawRef && (isArray$3(oldRawRef) ? oldRawRef[i2] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref3) {
    if (isString$3(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn$1(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$1(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value, refs]);
  } else {
    const _isString = isString$3(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn$1(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray$3(existing) && remove$2(existing, refValue);
          } else {
            if (!isArray$3(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (hasOwn$1(setupState, ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value;
          if (hasOwn$1(setupState, ref3)) {
            setupState[ref3] = value;
          }
        } else if (_isRef) {
          ref3.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis$1();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else
          ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el,
            key,
            null,
            props[key],
            namespace,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          namespace
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                namespace,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        namespace
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev,
            next,
            namespace,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.effect.dirty = true;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m: m2, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    const effect2 = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      NOOP,
      () => queueJob(update),
      instance.scope
      // track it in component's effect scope
    );
    const update = instance.update = () => {
      if (effect2.dirty) {
        effect2.run();
      }
    };
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(
        c1[i2],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch(
            null,
            c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++)
        newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  let isFlushing2 = false;
  const render2 = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    if (!isFlushing2) {
      isFlushing2 = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing2 = false;
    }
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  return {
    render: render2,
    hydrate,
    createApp: createAppAPI(render2, hydrate)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, update }, allowed) {
  effect2.allowRecurse = update.allowRecurse = allowed;
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$3(ch1) && isArray$3(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j, u, v2, c;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i2] = j;
        result.push(i2);
        continue;
      }
      u = 0;
      v2 = result.length - 1;
      while (u < v2) {
        c = u + v2 >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v2 = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i2] = result[u - 1];
        }
        result[u] = i2;
      }
    }
  }
  u = result.length;
  v2 = result[u - 1];
  while (u-- > 0) {
    result[u] = v2;
    v2 = p2[v2];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
const isTeleport = (type) => type.__isTeleport;
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode$1(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString$3(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$3(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode$1(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString$3(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$4(style2)) {
      if (isProxy(style2) && !isArray$3(style2)) {
        style2 = extend({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString$3(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$4(type) ? 4 : isFunction$1(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray$3(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    cloned.transition = transition.clone(cloned);
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$3(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$3(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$3(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g2 = getGlobalThis$1();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g2[key]))
      setters = g2[key] = [];
    setters.push(setter);
    return (v2) => {
      if (setters.length > 1)
        setters.forEach((set2) => set2(v2));
      else
        setters[0](v2);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v2) => currentInstance = v2
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v2) => isInSSRComponentSetup = v2
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    resetTracking();
    reset();
    if (isPromise$1(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e2) => {
          handleError(e2, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$4(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template2 = Component.template || resolveMergedOptions(instance).template;
      if (template2) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile$1(template2, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match2 = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match2) {
      name = match2[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$1(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c;
};
function useModel(props, name, options = EMPTY_OBJ) {
  const i2 = getCurrentInstance();
  const camelizedName = camelize(name);
  const hyphenatedName = hyphenate(name);
  const res = customRef((track2, trigger2) => {
    let localValue;
    watchSyncEffect(() => {
      const propValue = props[name];
      if (hasChanged(localValue, propValue)) {
        localValue = propValue;
        trigger2();
      }
    });
    return {
      get() {
        track2();
        return options.get ? options.get(localValue) : localValue;
      },
      set(value) {
        const rawProps = i2.vnode.props;
        if (!(rawProps && // check if parent has passed v-model
        (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps)) && hasChanged(value, localValue)) {
          localValue = value;
          trigger2();
        }
        i2.emit(`update:${name}`, options.set ? options.set(value) : value);
      }
    };
  });
  const modifierKey = "modelModifiers";
  res[Symbol.iterator] = () => {
    let i22 = 0;
    return {
      next() {
        if (i22 < 2) {
          return { value: i22++ ? props[modifierKey] || {} : res, done: false };
        } else {
          return { done: true };
        }
      }
    };
  };
  return res;
}
function h$1(type, propsOrChildren, children) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject$4(propsOrChildren) && !isArray$3(propsOrChildren)) {
      if (isVNode$1(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode$1(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const version$2 = "3.4.27";
/**
* @vue/runtime-dom v3.4.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag2, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag2) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag2) : doc.createElement(tag2, is ? { is } : void 0);
    if (tag2 === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector2) => doc.querySelector(selector2),
  setScopeId(el, id2) {
    el.setAttribute(id2, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
      const template2 = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template2.firstChild;
        while (wrapper.firstChild) {
          template2.appendChild(wrapper.firstChild);
        }
        template2.removeChild(wrapper);
      }
      parent.insertBefore(template2, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const vtcKey = Symbol("_vtc");
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const CSS_VAR_TEXT = Symbol("");
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style2 = el.style;
  const isCssString = isString$3(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString$3(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style2, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style2, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style2, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style2[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style2.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style2.display : "";
    if (el[vShowHidden]) {
      style2.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name, val) {
  if (isArray$3(val)) {
    val.forEach((v2) => setStyle(style2, name, v2));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style2.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style2, name);
      if (importantRE.test(val)) {
        style2.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style2) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  const tag2 = el.tagName;
  if (key === "value" && tag2 !== "PROGRESS" && // custom elements may use _value internally
  !tag2.includes("-")) {
    const oldValue = tag2 === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e2) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener$1(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance
      );
      addEventListener$1(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m2;
    while (m2 = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p$1 = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e2) => {
    if (!e2._vts) {
      e2._vts = Date.now();
    } else if (e2._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e2, invoker.value),
      instance,
      5,
      [e2]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e2, value) {
  if (isArray$3(value)) {
    const originalStop = e2.stopImmediatePropagation;
    e2.stopImmediatePropagation = () => {
      originalStop.call(e2);
      e2._stopped = true;
    };
    return value.map(
      (fn) => (e22) => !e22._stopped && fn && fn(e22)
    );
  } else {
    return value;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(
      el,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$1(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag2 = el.tagName;
    if (tag2 === "IMG" || tag2 === "VIDEO" || tag2 === "CANVAS" || tag2 === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString$3(value)) {
    return false;
  }
  return key in el;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$3(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e2) {
  e2.target.composing = true;
}
function onCompositionEnd(e2) {
  const target = e2.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim, number: number2 } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number2 || vnode.props && vnode.props.type === "number";
    addEventListener$1(el, lazy ? "change" : "input", (e2) => {
      if (e2.target.composing)
        return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim) {
      addEventListener$1(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener$1(el, "compositionstart", onCompositionStart);
      addEventListener$1(el, "compositionend", onCompositionEnd);
      addEventListener$1(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, modifiers: { lazy, trim, number: number2 } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing)
      return;
    const elValue = (number2 || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
    const newValue = value == null ? "" : value;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _2, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener$1(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign2 = el[assignKey];
      if (isArray$3(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign2(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign2(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign2(cloned);
      } else {
        assign2(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  if (isArray$3(value)) {
    el.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = looseEqual(value, getCheckboxValue(el, true));
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e2) => e2.stopPropagation(),
  prevent: (e2) => e2.preventDefault(),
  self: (e2) => e2.target !== e2.currentTarget,
  ctrl: (e2) => !e2.ctrlKey,
  shift: (e2) => !e2.shiftKey,
  alt: (e2) => !e2.altKey,
  meta: (e2) => !e2.metaKey,
  left: (e2) => "button" in e2 && e2.button !== 0,
  middle: (e2) => "button" in e2 && e2.button !== 1,
  right: (e2) => "button" in e2 && e2.button !== 2,
  exact: (e2, modifiers) => systemModifiers.some((m2) => e2[`${m2}Key`] && !modifiers.includes(m2))
};
const withModifiers = (fn, modifiers) => {
  const cache2 = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache2[cacheKey] || (cache2[cacheKey] = (event, ...args) => {
    for (let i2 = 0; i2 < modifiers.length; i2++) {
      const guard = modifierGuards[modifiers[i2]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn(event, ...args);
  });
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  const cache2 = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache2[cacheKey] || (cache2[cacheKey] = (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
      return fn(event);
    }
  });
};
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction$1(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString$3(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
/*!
  * vue-router v4.3.2
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser = typeof document !== "undefined";
function isESModule(obj) {
  return obj.__esModule || obj[Symbol.toStringTag] === "Module";
}
const assign$3 = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key in params) {
    const value = params[key];
    newParams[key] = isArray$2(value) ? value.map(fn) : fn(value);
  }
  return newParams;
}
const noop$2 = () => {
};
const isArray$2 = Array.isArray;
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
function decode(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
  }
  return "" + text;
}
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query = {}, searchString = "", hash = "";
  const hashPos = location2.indexOf("#");
  let searchPos = location2.indexOf("?");
  if (hashPos < searchPos && hashPos >= 0) {
    searchPos = -1;
  }
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash,
    path,
    query,
    hash: decode(hash)
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base) {
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
    return pathname;
  return pathname.slice(base.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a2, b2) {
  const aLastIndex = a2.matched.length - 1;
  const bLastIndex = b2.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a2.matched[aLastIndex], b2.matched[bLastIndex]) && isSameRouteLocationParams(a2.params, b2.params) && stringifyQuery2(a2.query) === stringifyQuery2(b2.query) && a2.hash === b2.hash;
}
function isSameRouteRecord(a2, b2) {
  return (a2.aliasOf || a2) === (b2.aliasOf || b2);
}
function isSameRouteLocationParams(a2, b2) {
  if (Object.keys(a2).length !== Object.keys(b2).length)
    return false;
  for (const key in a2) {
    if (!isSameRouteLocationParamsValue(a2[key], b2[key]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a2, b2) {
  return isArray$2(a2) ? isEquivalentArray(a2, b2) : isArray$2(b2) ? isEquivalentArray(b2, a2) : a2 === b2;
}
function isEquivalentArray(a2, b2) {
  return isArray$2(b2) ? a2.length === b2.length && a2.every((value, i2) => value === b2[i2]) : a2.length === 1 && a2[0] === b2;
}
function resolveRelativePath(to, from2) {
  if (to.startsWith("/"))
    return to;
  if (!to)
    return from2;
  const fromSegments = from2.split("/");
  const toSegments = to.split("/");
  const lastToSegment = toSegments[toSegments.length - 1];
  if (lastToSegment === ".." || lastToSegment === ".") {
    toSegments.push("");
  }
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (segment === ".")
      continue;
    if (segment === "..") {
      if (position > 1)
        position--;
    } else
      break;
  }
  return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition).join("/");
}
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base) {
  if (!base) {
    if (isBrowser) {
      const baseEl = document.querySelector("base");
      base = baseEl && baseEl.getAttribute("href") || "/";
      base = base.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base = "/";
    }
  }
  if (base[0] !== "/" && base[0] !== "#")
    base = "/" + base;
  return removeTrailingSlash(base);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location2) {
  return base.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.scrollX,
  top: window.scrollY
});
function scrollToPosition(position) {
  let scrollToOptions;
  if ("el" in position) {
    const positionEl = position.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position);
  } else {
    scrollToOptions = position;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);
  }
}
function getScrollKey(path, delta) {
  const position = history.state ? history.state.position - delta : -1;
  return position + path;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base, location2) {
  const { pathname, search, hash } = location2;
  const hashPos = base.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
    let pathFromHash = hash.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base);
  return path + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace) {
  let listeners = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state }) => {
    const to = createCurrentLocation(base, location);
    const from2 = currentLocation.value;
    const fromState = historyState.value;
    let delta = 0;
    if (state) {
      currentLocation.value = to;
      historyState.value = state;
      if (pauseState && pauseState === from2) {
        pauseState = null;
        return;
      }
      delta = fromState ? state.position - fromState.position : 0;
    } else {
      replace(to);
    }
    listeners.forEach((listener2) => {
      listener2(currentLocation.value, from2, {
        delta,
        type: NavigationType.pop,
        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners.push(callback);
    const teardown = () => {
      const index = listeners.indexOf(callback);
      if (index > -1)
        listeners.splice(index, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign$3({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener, {
    passive: true
  });
  return {
    pauseListeners,
    listen,
    destroy
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      // the length is off by one, we need to decrease it
      position: history2.length - 1,
      replaced: true,
      // don't add a scroll as the user may have an anchor, and we want
      // scrollBehavior to be triggered without a saved position
      scroll: null
    }, true);
  }
  function changeLocation(to, state, replace2) {
    const hashIndex = base.indexOf("#");
    const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
    try {
      history2[replace2 ? "replaceState" : "pushState"](state, "", url);
      historyState.value = state;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace2 ? "replace" : "assign"](url);
    }
  }
  function replace(to, data2) {
    const state = assign$3({}, history2.state, buildState(
      historyState.value.back,
      // keep back and forward entries but override current position
      to,
      historyState.value.forward,
      true
    ), data2, { position: historyState.value.position });
    changeLocation(to, state, true);
    currentLocation.value = to;
  }
  function push(to, data2) {
    const currentState = assign$3(
      {},
      // use current history state to gracefully handle a wrong call to
      // history.replaceState
      // https://github.com/vuejs/router/issues/366
      historyState.value,
      history2.state,
      {
        forward: to,
        scroll: computeScrollPosition()
      }
    );
    changeLocation(currentState.current, currentState, true);
    const state = assign$3({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data2);
    changeLocation(to, state, false);
    currentLocation.value = to;
  }
  return {
    location: currentLocation,
    state: historyState,
    push,
    replace
  };
}
function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta);
  }
  const routerHistory = assign$3({
    // it's overridden right after
    location: "",
    base,
    go,
    createHref: createHref.bind(null, base)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function createWebHashHistory(base) {
  base = location.host ? base || location.pathname + location.search : "";
  if (!base.includes("#"))
    base += "#";
  return createWebHistory(base);
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
const NavigationFailureSymbol = Symbol("");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type, params) {
  {
    return assign$3(new Error(), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error, type) {
  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign$3({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [
      90
      /* PathScore.Root */
    ];
    if (options.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token.type === 1) {
        const { value, repeatable, optional, regexp } = token;
        keys.push({
          name: value,
          repeatable,
          optional
        });
        const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re2 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re2})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
        if (!tokenIndex)
          subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
          // or /:p?-:p2
          optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re2 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i2 = score.length - 1;
    score[i2][score[i2].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern += "/?";
  if (options.end)
    pattern += "$";
  else if (options.strict)
    pattern += "(?:/|$)";
  const re = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse2(path) {
    const match2 = path.match(re);
    const params = {};
    if (!match2)
      return null;
    for (let i2 = 1; i2 < match2.length; i2++) {
      const value = match2[i2] || "";
      const key = keys[i2 - 1];
      params[key.name] = value && key.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token of segment) {
        if (token.type === 0) {
          path += token.value;
        } else if (token.type === 1) {
          const { value, repeatable, optional } = token;
          const param = value in params ? params[value] : "";
          if (isArray$2(param) && !repeatable) {
            throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
          }
          const text = isArray$2(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value}"`);
          }
          path += text;
        }
      }
    }
    return path || "/";
  }
  return {
    re,
    score,
    keys,
    parse: parse2,
    stringify
  };
}
function compareScoreArray(a2, b2) {
  let i2 = 0;
  while (i2 < a2.length && i2 < b2.length) {
    const diff = b2[i2] - a2[i2];
    if (diff)
      return diff;
    i2++;
  }
  if (a2.length < b2.length) {
    return a2.length === 1 && a2[0] === 40 + 40 ? -1 : 1;
  } else if (a2.length > b2.length) {
    return b2.length === 1 && b2[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a2, b2) {
  let i2 = 0;
  const aScore = a2.score;
  const bScore = b2.score;
  while (i2 < aScore.length && i2 < bScore.length) {
    const comp = compareScoreArray(aScore[i2], bScore[i2]);
    if (comp)
      return comp;
    i2++;
  }
  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore))
      return 1;
    if (isLastScoreNegative(bScore))
      return -1;
  }
  return bScore.length - aScore.length;
}
function isLastScoreNegative(score) {
  const last2 = score[score.length - 1];
  return score.length > 0 && last2[last2.length - 1] < 0;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message) {
    throw new Error(`ERR (${state})/"${buffer}": ${message}`);
  }
  let state = 0;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  let i2 = 0;
  let char;
  let buffer = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer)
      return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer = "";
  }
  function addCharToBuffer() {
    buffer += char;
  }
  while (i2 < path.length) {
    char = path[i2++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i2--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i2--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2)
    crash(`Unfinished custom RegExp for param "${buffer}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent, options) {
  const parser2 = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign$3(parser2, {
    record,
    parent,
    // these needs to be populated by the parent
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes2, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) {
        normalizedRecords.push(assign$3({}, mainNormalizedRecord, {
          // this allows us to hold a copy of the `components` option
          // so that async components cache is hold on the original record
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          // we might be the child of an alias
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
          // the aliases are always of the same kind as the original since they
          // are defined on the same record
        }));
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if (mainNormalizedRecord.children) {
        const children = mainNormalizedRecord.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          addRoute(children[i2], matcher, originalRecord && originalRecord.children[i2]);
        }
      }
      originalRecord = originalRecord || matcher;
      if (matcher.record.components && Object.keys(matcher.record.components).length || matcher.record.name || matcher.record.redirect) {
        insertMatcher(matcher);
      }
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop$2;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index = matchers.indexOf(matcherRef);
      if (index > -1) {
        matchers.splice(index, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    let i2 = 0;
    while (i2 < matchers.length && comparePathParserScore(matcher, matchers[i2]) >= 0 && // Adding children with empty path should still appear before the parent
    // https://github.com/vuejs/router/issues/1124
    (matcher.record.path !== matchers[i2].record.path || !isRecordChildOf(matcher, matchers[i2])))
      i2++;
    matchers.splice(i2, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve2(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name = matcher.record.name;
      params = assign$3(
        // paramsFromLocation is a new object
        paramsFromLocation(
          currentLocation.params,
          // only keep params that exist in the resolved location
          // only keep optional params coming from a parent record
          matcher.keys.filter((k2) => !k2.optional).concat(matcher.parent ? matcher.parent.keys.filter((k2) => k2.optional) : []).map((k2) => k2.name)
        ),
        // discard any existing params in the current location that do not exist here
        // #1497 this ensures better active/exact matching
        location2.params && paramsFromLocation(location2.params, matcher.keys.map((k2) => k2.name))
      );
      path = matcher.stringify(params);
    } else if (location2.path != null) {
      path = location2.path;
      matcher = matchers.find((m2) => m2.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m2) => m2.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name = matcher.record.name;
      params = assign$3({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes2.forEach((route) => addRoute(route));
  return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys) {
  const newParams = {};
  for (const key of keys) {
    if (key in params)
      newParams[key] = params[key];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || null : record.component && { default: record.component }
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) {
    propsObject.default = props;
  } else {
    for (const name in record.components)
      propsObject[name] = typeof props === "object" ? props[name] : props;
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign$3(meta, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
  const options = {};
  for (const key in defaults) {
    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
  }
  return options;
}
function isRecordChildOf(record, parent) {
  return parent.children.some((child) => child === record || isRecordChildOf(record, child));
}
function parseQuery(search) {
  const query = {};
  if (search === "" || search === "?")
    return query;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i2 = 0; i2 < searchParams.length; ++i2) {
    const searchParam = searchParams[i2].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!isArray$2(currentValue)) {
        currentValue = query[key] = [currentValue];
      }
      currentValue.push(value);
    } else {
      query[key] = value;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search = "";
  for (let key in query) {
    const value = query[key];
    key = encodeQueryKey(key);
    if (value == null) {
      if (value !== void 0) {
        search += (search.length ? "&" : "") + key;
      }
      continue;
    }
    const values2 = isArray$2(value) ? value.map((v2) => v2 && encodeQueryValue(v2)) : [value && encodeQueryValue(value)];
    values2.forEach((value2) => {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key;
        if (value2 != null)
          search += "=" + value2;
      }
    });
  }
  return search;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value = query[key];
    if (value !== void 0) {
      normalizedQuery[key] = isArray$2(value) ? value.map((v2) => v2 == null ? null : "" + v2) : value == null ? value : "" + value;
    }
  }
  return normalizedQuery;
}
const matchedRouteKey = Symbol("");
const viewDepthKey = Symbol("");
const routerKey = Symbol("");
const routeLocationKey = Symbol("");
const routerViewLocationKey = Symbol("");
function useCallbacks() {
  let handlers2 = [];
  function add2(handler) {
    handlers2.push(handler);
    return () => {
      const i2 = handlers2.indexOf(handler);
      if (i2 > -1)
        handlers2.splice(i2, 1);
    };
  }
  function reset() {
    handlers2 = [];
  }
  return {
    add: add2,
    list: () => handlers2.slice(),
    reset
  };
}
function guardToPromiseFn(guard, to, from2, record, name, runWithContext = (fn) => fn()) {
  const enterCallbackArray = record && // name is defined if record is because of the function overload
  (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve2, reject) => {
    const next = (valid) => {
      if (valid === false) {
        reject(createRouterError(4, {
          from: from2,
          to
        }));
      } else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to,
          to: valid
        }));
      } else {
        if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
        record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
          enterCallbackArray.push(valid);
        }
        resolve2();
      }
    };
    const guardReturn = runWithContext(() => guard.call(record && record.instances[name], to, from2, next));
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to, from2, runWithContext = (fn) => fn()) {
  const guards = [];
  for (const record of matched) {
    for (const name in record.components) {
      let rawComponent = record.components[name];
      if (guardType !== "beforeRouteEnter" && !record.instances[name])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from2, record, name, runWithContext));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to, from2, record, name, runWithContext)();
        }));
      }
    }
  }
  return guards;
}
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function useLink(props) {
  const router2 = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed(() => {
    const to = unref(props.to);
    return router2.resolve(to);
  });
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index > -1)
      return index;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return (
      // we are dealing with nested routes
      length > 1 && // if the parent and matched route have the same path, this link is
      // referring to the empty child. Or we currently are on a different
      // child of the same parent
      getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
      currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index
    );
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e2 = {}) {
    if (guardEvent(e2)) {
      return router2[unref(props.replace) ? "replace" : "push"](
        unref(props.to)
        // avoid uncaught errors are they are logged anyway
      ).catch(noop$2);
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    // inactiveClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink,
  setup(props, { slots }) {
    const link = reactive(useLink(props));
    const { options } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      // [getLinkClass(
      //   props.inactiveClass,
      //   options.linkInactiveClass,
      //   'router-link-inactive'
      // )]: !link.isExactActive,
      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && slots.default(link);
      return props.custom ? children : h$1("a", {
        "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
        href: link.href,
        // this would override user added attrs but Vue will still add
        // the listener, so we end up triggering both
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e2) {
  if (e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey)
    return;
  if (e2.defaultPrevented)
    return;
  if (e2.button !== void 0 && e2.button !== 0)
    return;
  if (e2.currentTarget && e2.currentTarget.getAttribute) {
    const target = e2.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (e2.preventDefault)
    e2.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!isArray$2(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i2) => value !== outerValue[i2]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  // #674 we manually inherit them
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  // Better compat for @vue/compat users
  // https://github.com/vuejs/router/issues/1315
  compatConfig: { MODE: 3 },
  setup(props, { attrs, slots }) {
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const injectedDepth = inject(viewDepthKey, 0);
    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const { matched } = routeToDisplay.value;
      let matchedRoute;
      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
        initialDepth++;
      }
      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from2, oldName]) => {
      if (to) {
        to.instances[name] = instance;
        if (from2 && from2 !== to && instance && instance === oldInstance) {
          if (!to.leaveGuards.size) {
            to.leaveGuards = from2.leaveGuards;
          }
          if (!to.updateGuards.size) {
            to.updateGuards = from2.updateGuards;
          }
        }
      }
      if (instance && to && // if there is no instance but to and from are the same this might be
      // the first visit
      (!from2 || !isSameRouteRecord(to, from2) || !oldInstance)) {
        (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const currentName = props.name;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[currentName];
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[currentName];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h$1(ViewComponent, assign$3({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return (
        // pass the vnode to the slot as a prop.
        // h and <component :is="..."> both accept vnodes
        normalizeSlot(slots.default, { Component: component, route }) || component
      );
    };
  }
});
function normalizeSlot(slot, data2) {
  if (!slot)
    return null;
  const slotContent = slot(data2);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams2 = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = (
    // @ts-expect-error: intentionally avoid the type check
    applyToParams.bind(null, decode)
  );
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }
  function resolve2(rawLocation, currentLocation) {
    currentLocation = assign$3({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      return assign$3(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if (rawLocation.path != null) {
      matcherLocation = assign$3({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign$3({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign$3({}, rawLocation, {
        params: encodeParams(targetParams)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || "";
    matchedRoute.params = normalizeParams2(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign$3({}, rawLocation, {
      hash: encodeHash(hash),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    return assign$3({
      fullPath,
      // keep the hash encoded so fullPath is effectively path + encodedQuery +
      // hash
      hash,
      query: (
        // if the user is using a custom query lib like qs, we might have
        // nested objects, so we keep the query as is, meaning it can contain
        // numbers at `$route.query`, but at the point, the user will have to
        // use their own type anyway.
        // https://github.com/vuejs/router/issues/328#issuecomment-649481567
        stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
      )
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to) {
    return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign$3({}, to);
  }
  function checkCanceledNavigation(to, from2) {
    if (pendingLocation !== to) {
      return createRouterError(8, {
        from: from2,
        to
      });
    }
  }
  function push(to) {
    return pushWithRedirect(to);
  }
  function replace(to) {
    return push(assign$3(locationAsObject(to), { replace: true }));
  }
  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : (
          // force empty params
          { path: newTargetLocation }
        );
        newTargetLocation.params = {};
      }
      return assign$3({
        query: to.query,
        hash: to.hash,
        // avoid transferring params if the redirect has a path
        params: newTargetLocation.path != null ? {} : to.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = pendingLocation = resolve2(to);
    const from2 = currentRoute.value;
    const data2 = to.state;
    const force = to.force;
    const replace2 = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(
        assign$3(locationAsObject(shouldRedirect), {
          state: typeof shouldRedirect === "object" ? assign$3({}, data2, shouldRedirect.state) : data2,
          force,
          replace: replace2
        }),
        // keep original redirectedFrom if it exists
        redirectedFrom || targetLocation
      );
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from2, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from: from2 });
      handleScroll(
        from2,
        from2,
        // this is a push, the only way for it to be triggered from a
        // history.listen is with a redirect, which makes it become a push
        true,
        // This cannot be the first navigation because the initial location
        // cannot be manually navigated to
        false
      );
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from2)).catch((error) => isNavigationFailure(error) ? (
      // navigation redirects still mark the router as ready
      isNavigationFailure(
        error,
        2
        /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
      ) ? error : markAsReady(error)
    ) : (
      // reject any unknown error
      triggerError(error, toLocation, from2)
    )).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(
          failure2,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          return pushWithRedirect(
            // keep options
            assign$3({
              // preserve an existing replacement but allow the redirect to override it
              replace: replace2
            }, locationAsObject(failure2.to), {
              state: typeof failure2.to === "object" ? assign$3({}, data2, failure2.to.state) : data2,
              force
            }),
            // preserve the original redirectedFrom if any
            redirectedFrom || toLocation
          );
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from2, true, replace2, data2);
      }
      triggerAfterEach(toLocation, from2, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to, from2) {
    const error = checkCanceledNavigation(to, from2);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function runWithContext(fn) {
    const app = installedApps.values().next().value;
    return app && typeof app.runWithContext === "function" ? app.runWithContext(fn) : fn();
  }
  function navigate(to, from2) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from2);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from2);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to, from2));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from2);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from2));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from2);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from2));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of enteringRecords) {
        if (record.beforeEnter) {
          if (isArray$2(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from2));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from2));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from2, runWithContext);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from2));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(
      err,
      8
      /* ErrorTypes.NAVIGATION_CANCELLED */
    ) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to, from2, failure) {
    afterGuards.list().forEach((guard) => runWithContext(() => guard(to, from2, failure)));
  }
  function finalizeNavigation(toLocation, from2, isPush, replace2, data2) {
    const error = checkCanceledNavigation(toLocation, from2);
    if (error)
      return error;
    const isFirstNavigation = from2 === START_LOCATION_NORMALIZED;
    const state = !isBrowser ? {} : history.state;
    if (isPush) {
      if (replace2 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign$3({
          scroll: isFirstNavigation && state && state.scroll
        }, data2));
      else
        routerHistory.push(toLocation.fullPath, data2);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from2, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    if (removeHistoryListener)
      return;
    removeHistoryListener = routerHistory.listen((to, _from, info2) => {
      if (!router2.listening)
        return;
      const toLocation = resolve2(to);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign$3(shouldRedirect, { replace: true }), toLocation).catch(noop$2);
        return;
      }
      pendingLocation = toLocation;
      const from2 = currentRoute.value;
      if (isBrowser) {
        saveScrollPosition(getScrollKey(from2.fullPath, info2.delta), computeScrollPosition());
      }
      navigate(toLocation, from2).catch((error) => {
        if (isNavigationFailure(
          error,
          4 | 8
          /* ErrorTypes.NAVIGATION_CANCELLED */
        )) {
          return error;
        }
        if (isNavigationFailure(
          error,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          pushWithRedirect(
            error.to,
            toLocation
            // avoid an uncaught rejection, let push call triggerError
          ).then((failure) => {
            if (isNavigationFailure(
              failure,
              4 | 16
              /* ErrorTypes.NAVIGATION_DUPLICATED */
            ) && !info2.delta && info2.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop$2);
          return Promise.reject();
        }
        if (info2.delta) {
          routerHistory.go(-info2.delta, false);
        }
        return triggerError(error, toLocation, from2);
      }).then((failure) => {
        failure = failure || finalizeNavigation(
          // after navigation, all matched components are resolved
          toLocation,
          from2,
          false
        );
        if (failure) {
          if (info2.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
          // entry while a different route is displayed
          !isNavigationFailure(
            failure,
            8
            /* ErrorTypes.NAVIGATION_CANCELLED */
          )) {
            routerHistory.go(-info2.delta, false);
          } else if (info2.type === NavigationType.pop && isNavigationFailure(
            failure,
            4 | 16
            /* ErrorTypes.NAVIGATION_DUPLICATED */
          )) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from2, failure);
      }).catch(noop$2);
    });
  }
  let readyHandlers = useCallbacks();
  let errorListeners = useCallbacks();
  let ready;
  function triggerError(error, to, from2) {
    markAsReady(error);
    const list = errorListeners.list();
    if (list.length) {
      list.forEach((handler) => handler(error, to, from2));
    } else {
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve22, reject) => {
      readyHandlers.add([resolve22, reject]);
    });
  }
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve22, reject]) => err ? reject(err) : resolve22());
      readyHandlers.reset();
    }
    return err;
  }
  function handleScroll(to, from2, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to, from2, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from2));
  }
  const go = (delta) => routerHistory.go(delta);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router2 = {
    currentRoute,
    listening: true,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve: resolve2,
    options,
    push,
    replace,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorListeners.add,
    isReady,
    install(app) {
      const router22 = this;
      app.component("RouterLink", RouterLink);
      app.component("RouterView", RouterView);
      app.config.globalProperties.$router = router22;
      Object.defineProperty(app.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser && // used for the initial navigation client side to avoid pushing
      // multiple times when the router is used in multiple apps
      !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        Object.defineProperty(reactiveRoute, key, {
          get: () => currentRoute.value[key],
          enumerable: true
        });
      }
      app.provide(routerKey, router22);
      app.provide(routeLocationKey, shallowReactive(reactiveRoute));
      app.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app.unmount;
      installedApps.add(app);
      app.unmount = function() {
        installedApps.delete(app);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  function runGuardQueue(guards) {
    return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
  }
  return router2;
}
function extractChangingRecords(to, from2) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from2.matched.length, to.matched.length);
  for (let i2 = 0; i2 < len; i2++) {
    const recordFrom = from2.matched[i2];
    if (recordFrom) {
      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to.matched[i2];
    if (recordTo) {
      if (!from2.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
function useRouter() {
  return inject(routerKey);
}
function useRoute() {
  return inject(routeLocationKey);
}
var ReadMode = /* @__PURE__ */ ((ReadMode2) => {
  ReadMode2["sroll"] = "sroll";
  ReadMode2["section"] = "section";
  ReadMode2["double"] = "dobule";
  return ReadMode2;
})(ReadMode || {});
var BookshelftMode = /* @__PURE__ */ ((BookshelftMode2) => {
  BookshelftMode2["list"] = "list";
  BookshelftMode2["card"] = "card";
  BookshelftMode2["bookshelf"] = "bookshelf";
  return BookshelftMode2;
})(BookshelftMode || {});
var isVue2 = false;
function computedWithControl(source, fn) {
  let v2 = void 0;
  let track2;
  let trigger2;
  const dirty = ref(true);
  const update = () => {
    dirty.value = true;
    trigger2();
  };
  watch(source, update, { flush: "sync" });
  const get2 = typeof fn === "function" ? fn : fn.get;
  const set2 = typeof fn === "function" ? void 0 : fn.set;
  const result = customRef((_track, _trigger) => {
    track2 = _track;
    trigger2 = _trigger;
    return {
      get() {
        if (dirty.value) {
          v2 = get2();
          dirty.value = false;
        }
        track2();
        return v2;
      },
      set(v22) {
        set2 == null ? void 0 : set2(v22);
      }
    };
  });
  if (Object.isExtensible(result))
    result.trigger = update;
  return result;
}
function tryOnScopeDispose$1(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function get(obj, key) {
  if (key == null)
    return unref(obj);
  return unref(obj)[key];
}
function toValue$1(r2) {
  return typeof r2 === "function" ? r2() : unref(r2);
}
const isClient$1 = typeof window !== "undefined" && typeof document !== "undefined";
typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
const notNullish = (val) => val != null;
const toString$1 = Object.prototype.toString;
const isObject$3 = (val) => toString$1.call(val) === "[object Object]";
const noop$1 = () => {
};
const isIOS = /* @__PURE__ */ getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isClient$1 && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    return new Promise((resolve2, reject) => {
      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve2).catch(reject);
    });
  }
  return wrapper;
}
const bypassFilter = (invoke2) => {
  return invoke2();
};
function debounceFilter(ms2, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop$1;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop$1;
  };
  const filter = (invoke2) => {
    const duration = toValue$1(ms2);
    const maxDuration = toValue$1(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return Promise.resolve(invoke2());
    }
    return new Promise((resolve2, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve2;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve2(invoke2());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve2(invoke2());
      }, duration);
    });
  };
  return filter;
}
function throttleFilter(...args) {
  let lastExec = 0;
  let timer;
  let isLeading = true;
  let lastRejector = noop$1;
  let lastValue;
  let ms2;
  let trailing;
  let leading;
  let rejectOnCancel;
  if (!isRef(args[0]) && typeof args[0] === "object")
    ({ delay: ms2, trailing = true, leading = true, rejectOnCancel = false } = args[0]);
  else
    [ms2, trailing = true, leading = true, rejectOnCancel = false] = args;
  const clear2 = () => {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
      lastRejector();
      lastRejector = noop$1;
    }
  };
  const filter = (_invoke) => {
    const duration = toValue$1(ms2);
    const elapsed = Date.now() - lastExec;
    const invoke2 = () => {
      return lastValue = _invoke();
    };
    clear2();
    if (duration <= 0) {
      lastExec = Date.now();
      return invoke2();
    }
    if (elapsed > duration && (leading || !isLeading)) {
      lastExec = Date.now();
      invoke2();
    } else if (trailing) {
      lastValue = new Promise((resolve2, reject) => {
        lastRejector = rejectOnCancel ? reject : resolve2;
        timer = setTimeout(() => {
          lastExec = Date.now();
          isLeading = true;
          resolve2(invoke2());
          clear2();
        }, Math.max(0, duration - elapsed));
      });
    }
    if (!leading && !timer)
      timer = setTimeout(() => isLeading = true, duration);
    isLeading = false;
    return lastValue;
  };
  return filter;
}
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive: readonly(isActive), pause, resume, eventFilter };
}
const directiveHooks = {
  mounted: "mounted",
  updated: "updated",
  unmounted: "unmounted"
};
function createSingletonPromise(fn) {
  let _promise;
  function wrapper() {
    if (!_promise)
      _promise = fn();
    return _promise;
  }
  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev)
      await _prev;
  };
  return wrapper;
}
function getLifeCycleTarget(target) {
  return getCurrentInstance();
}
function toRef(...args) {
  if (args.length !== 1)
    return toRef$1(...args);
  const r2 = args[0];
  return typeof r2 === "function" ? readonly(customRef(() => ({ get: r2, set: noop$1 }))) : ref(r2);
}
function useDebounceFn(fn, ms2 = 200, options = {}) {
  return createFilterWrapper(
    debounceFilter(ms2, options),
    fn
  );
}
function useThrottleFn(fn, ms2 = 200, trailing = false, leading = true, rejectOnCancel = false) {
  return createFilterWrapper(
    throttleFilter(ms2, trailing, leading, rejectOnCancel),
    fn
  );
}
function set$1(...args) {
  if (args.length === 2) {
    const [ref2, value] = args;
    ref2.value = value;
  }
  if (args.length === 3) {
    {
      const [target, key, value] = args;
      target[key] = value;
    }
  }
}
function watchWithFilter(source, cb, options = {}) {
  const {
    eventFilter = bypassFilter,
    ...watchOptions
  } = options;
  return watch(
    source,
    createFilterWrapper(
      eventFilter,
      cb
    ),
    watchOptions
  );
}
function watchPausable(source, cb, options = {}) {
  const {
    eventFilter: filter,
    ...watchOptions
  } = options;
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);
  const stop = watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter
    }
  );
  return { stop, pause, resume, isActive };
}
function tryOnMounted(fn, sync = true, target) {
  const instance = getLifeCycleTarget();
  if (instance)
    onMounted(fn, target);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true
  } = options;
  const isPending = ref(false);
  let timer = null;
  function clear2() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop() {
    isPending.value = false;
    clear2();
  }
  function start(...args) {
    clear2();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, toValue$1(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient$1)
      start();
  }
  tryOnScopeDispose$1(stop);
  return {
    isPending: readonly(isPending),
    start,
    stop
  };
}
function useToggle(initialValue = false, options = {}) {
  const {
    truthyValue = true,
    falsyValue = false
  } = options;
  const valueIsRef = isRef(initialValue);
  const _value = ref(initialValue);
  function toggle(value) {
    if (arguments.length) {
      _value.value = value;
      return _value.value;
    } else {
      const truthy = toValue$1(truthyValue);
      _value.value = _value.value === truthy ? toValue$1(falsyValue) : truthy;
      return _value.value;
    }
  }
  if (valueIsRef)
    return toggle;
  else
    return [_value, toggle];
}
function unrefElement$1(elRef) {
  var _a;
  const plain = toValue$1(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
const defaultWindow$1 = isClient$1 ? window : void 0;
const defaultDocument = isClient$1 ? window.document : void 0;
const defaultNavigator = isClient$1 ? window.navigator : void 0;
function useEventListener$1(...args) {
  let target;
  let events2;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events2, listeners, options] = args;
    target = defaultWindow$1;
  } else {
    [target, events2, listeners, options] = args;
  }
  if (!target)
    return noop$1;
  if (!Array.isArray(events2))
    events2 = [events2];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener2, options2) => {
    el.addEventListener(event, listener2, options2);
    return () => el.removeEventListener(event, listener2, options2);
  };
  const stopWatch = watch(
    () => [unrefElement$1(target), toValue$1(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject$3(options2) ? { ...options2 } : options2;
      cleanups.push(
        ...events2.flatMap((event) => {
          return listeners.map((listener2) => register(el, event, listener2, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose$1(stop);
  return stop;
}
let _iOSWorkaround$1 = false;
function onClickOutside$1(target, handler, options = {}) {
  const { window: window2 = defaultWindow$1, ignore = [], capture = true, detectIframe = false } = options;
  if (!window2)
    return noop$1;
  if (isIOS && !_iOSWorkaround$1) {
    _iOSWorkaround$1 = true;
    Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop$1));
    window2.document.documentElement.addEventListener("click", noop$1);
  }
  let shouldListen = true;
  const shouldIgnore = (event) => {
    return ignore.some((target2) => {
      if (typeof target2 === "string") {
        return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
      } else {
        const el = unrefElement$1(target2);
        return el && (event.target === el || event.composedPath().includes(el));
      }
    });
  };
  const listener2 = (event) => {
    const el = unrefElement$1(target);
    if (!el || el === event.target || event.composedPath().includes(el))
      return;
    if (event.detail === 0)
      shouldListen = !shouldIgnore(event);
    if (!shouldListen) {
      shouldListen = true;
      return;
    }
    handler(event);
  };
  const cleanup = [
    useEventListener$1(window2, "click", listener2, { passive: true, capture }),
    useEventListener$1(window2, "pointerdown", (e2) => {
      const el = unrefElement$1(target);
      shouldListen = !shouldIgnore(e2) && !!(el && !e2.composedPath().includes(el));
    }, { passive: true }),
    detectIframe && useEventListener$1(window2, "blur", (event) => {
      setTimeout(() => {
        var _a;
        const el = unrefElement$1(target);
        if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
          handler(event);
      }, 0);
    })
  ].filter(Boolean);
  const stop = () => cleanup.forEach((fn) => fn());
  return stop;
}
function createKeyPredicate(keyFilter) {
  if (typeof keyFilter === "function")
    return keyFilter;
  else if (typeof keyFilter === "string")
    return (event) => event.key === keyFilter;
  else if (Array.isArray(keyFilter))
    return (event) => keyFilter.includes(event.key);
  return () => true;
}
function onKeyStroke(...args) {
  let key;
  let handler;
  let options = {};
  if (args.length === 3) {
    key = args[0];
    handler = args[1];
    options = args[2];
  } else if (args.length === 2) {
    if (typeof args[1] === "object") {
      key = true;
      handler = args[0];
      options = args[1];
    } else {
      key = args[0];
      handler = args[1];
    }
  } else {
    key = true;
    handler = args[0];
  }
  const {
    target = defaultWindow$1,
    eventName = "keydown",
    passive = false,
    dedupe = false
  } = options;
  const predicate = createKeyPredicate(key);
  const listener2 = (e2) => {
    if (e2.repeat && toValue$1(dedupe))
      return;
    if (predicate(e2))
      handler(e2);
  };
  return useEventListener$1(target, eventName, listener2, passive);
}
function useMounted() {
  const isMounted = ref(false);
  const instance = getCurrentInstance();
  if (instance) {
    onMounted(() => {
      isMounted.value = true;
    }, instance);
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useMutationObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow$1, ...mutationOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(() => {
    const value = toValue$1(target);
    const items = (Array.isArray(value) ? value : [value]).map(unrefElement$1).filter(notNullish);
    return new Set(items);
  });
  const stopWatch = watch(
    () => targets.value,
    (targets2) => {
      cleanup();
      if (isSupported.value && targets2.size) {
        observer = new MutationObserver(callback);
        targets2.forEach((el) => observer.observe(el, mutationOptions));
      }
    },
    { immediate: true, flush: "post" }
  );
  const takeRecords = () => {
    return observer == null ? void 0 : observer.takeRecords();
  };
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose$1(stop);
  return {
    isSupported,
    stop,
    takeRecords
  };
}
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow$1 } = options;
  const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  let mediaQuery;
  const matches = ref(false);
  const handler = (event) => {
    matches.value = event.matches;
  };
  const cleanup = () => {
    if (!mediaQuery)
      return;
    if ("removeEventListener" in mediaQuery)
      mediaQuery.removeEventListener("change", handler);
    else
      mediaQuery.removeListener(handler);
  };
  const stopWatch = watchEffect(() => {
    if (!isSupported.value)
      return;
    cleanup();
    mediaQuery = window2.matchMedia(toValue$1(query));
    if ("addEventListener" in mediaQuery)
      mediaQuery.addEventListener("change", handler);
    else
      mediaQuery.addListener(handler);
    matches.value = mediaQuery.matches;
  });
  tryOnScopeDispose$1(() => {
    stopWatch();
    cleanup();
    mediaQuery = void 0;
  });
  return matches;
}
function usePermission(permissionDesc, options = {}) {
  const {
    controls = false,
    navigator: navigator2 = defaultNavigator
  } = options;
  const isSupported = useSupported(() => navigator2 && "permissions" in navigator2);
  let permissionStatus;
  const desc = typeof permissionDesc === "string" ? { name: permissionDesc } : permissionDesc;
  const state = ref();
  const onChange = () => {
    if (permissionStatus)
      state.value = permissionStatus.state;
  };
  const query = createSingletonPromise(async () => {
    if (!isSupported.value)
      return;
    if (!permissionStatus) {
      try {
        permissionStatus = await navigator2.permissions.query(desc);
        useEventListener$1(permissionStatus, "change", onChange);
        onChange();
      } catch (e2) {
        state.value = "prompt";
      }
    }
    return permissionStatus;
  });
  query();
  if (controls) {
    return {
      state,
      isSupported,
      query
    };
  } else {
    return state;
  }
}
function useClipboard(options = {}) {
  const {
    navigator: navigator2 = defaultNavigator,
    read = false,
    source,
    copiedDuring = 1500,
    legacy = false
  } = options;
  const isClipboardApiSupported = useSupported(() => navigator2 && "clipboard" in navigator2);
  const permissionRead = usePermission("clipboard-read");
  const permissionWrite = usePermission("clipboard-write");
  const isSupported = computed(() => isClipboardApiSupported.value || legacy);
  const text = ref("");
  const copied = ref(false);
  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);
  function updateText() {
    if (isClipboardApiSupported.value && isAllowed(permissionRead.value)) {
      navigator2.clipboard.readText().then((value) => {
        text.value = value;
      });
    } else {
      text.value = legacyRead();
    }
  }
  if (isSupported.value && read)
    useEventListener$1(["copy", "cut"], updateText);
  async function copy(value = toValue$1(source)) {
    if (isSupported.value && value != null) {
      if (isClipboardApiSupported.value && isAllowed(permissionWrite.value))
        await navigator2.clipboard.writeText(value);
      else
        legacyCopy(value);
      text.value = value;
      copied.value = true;
      timeout.start();
    }
  }
  function legacyCopy(value) {
    const ta = document.createElement("textarea");
    ta.value = value != null ? value : "";
    ta.style.position = "absolute";
    ta.style.opacity = "0";
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    ta.remove();
  }
  function legacyRead() {
    var _a, _b, _c;
    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : "";
  }
  function isAllowed(status) {
    return status === "granted" || status === "prompt";
  }
  return {
    isSupported,
    text,
    copied,
    copy
  };
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
const handlers = /* @__PURE__ */ getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function getSSRHandler(key, fallback) {
  return handlers[key] || fallback;
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
const StorageSerializers = {
  boolean: {
    read: (v2) => v2 === "true",
    write: (v2) => String(v2)
  },
  object: {
    read: (v2) => JSON.parse(v2),
    write: (v2) => JSON.stringify(v2)
  },
  number: {
    read: (v2) => Number.parseFloat(v2),
    write: (v2) => String(v2)
  },
  any: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  string: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  map: {
    read: (v2) => new Map(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2.entries()))
  },
  set: {
    read: (v2) => new Set(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2))
  },
  date: {
    read: (v2) => new Date(v2),
    write: (v2) => v2.toISOString()
  }
};
const customStorageEventName = "vueuse-storage";
function useStorage(key, defaults2, storage, options = {}) {
  var _a;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    shallow,
    window: window2 = defaultWindow$1,
    eventFilter,
    onError = (e2) => {
      console.error(e2);
    },
    initOnMounted
  } = options;
  const data2 = (shallow ? shallowRef : ref)(typeof defaults2 === "function" ? defaults2() : defaults2);
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a2;
        return (_a2 = defaultWindow$1) == null ? void 0 : _a2.localStorage;
      })();
    } catch (e2) {
      onError(e2);
    }
  }
  if (!storage)
    return data2;
  const rawInit = toValue$1(defaults2);
  const type = guessSerializerType(rawInit);
  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];
  const { pause: pauseWatch, resume: resumeWatch } = watchPausable(
    data2,
    () => write(data2.value),
    { flush, deep, eventFilter }
  );
  if (window2 && listenToStorageChanges) {
    tryOnMounted(() => {
      useEventListener$1(window2, "storage", update);
      useEventListener$1(window2, customStorageEventName, updateFromCustomEvent);
      if (initOnMounted)
        update();
    });
  }
  if (!initOnMounted)
    update();
  function dispatchWriteEvent(oldValue, newValue) {
    if (window2) {
      window2.dispatchEvent(new CustomEvent(customStorageEventName, {
        detail: {
          key,
          oldValue,
          newValue,
          storageArea: storage
        }
      }));
    }
  }
  function write(v2) {
    try {
      const oldValue = storage.getItem(key);
      if (v2 == null) {
        dispatchWriteEvent(oldValue, null);
        storage.removeItem(key);
      } else {
        const serialized = serializer.write(v2);
        if (oldValue !== serialized) {
          storage.setItem(key, serialized);
          dispatchWriteEvent(oldValue, serialized);
        }
      }
    } catch (e2) {
      onError(e2);
    }
  }
  function read(event) {
    const rawValue = event ? event.newValue : storage.getItem(key);
    if (rawValue == null) {
      if (writeDefaults && rawInit != null)
        storage.setItem(key, serializer.write(rawInit));
      return rawInit;
    } else if (!event && mergeDefaults) {
      const value = serializer.read(rawValue);
      if (typeof mergeDefaults === "function")
        return mergeDefaults(value, rawInit);
      else if (type === "object" && !Array.isArray(value))
        return { ...rawInit, ...value };
      return value;
    } else if (typeof rawValue !== "string") {
      return rawValue;
    } else {
      return serializer.read(rawValue);
    }
  }
  function update(event) {
    if (event && event.storageArea !== storage)
      return;
    if (event && event.key == null) {
      data2.value = rawInit;
      return;
    }
    if (event && event.key !== key)
      return;
    pauseWatch();
    try {
      if ((event == null ? void 0 : event.newValue) !== serializer.write(data2.value))
        data2.value = read(event);
    } catch (e2) {
      onError(e2);
    } finally {
      if (event)
        nextTick(resumeWatch);
      else
        resumeWatch();
    }
  }
  function updateFromCustomEvent(event) {
    update(event.detail);
  }
  return data2;
}
function useCssVar(prop, target, options = {}) {
  const { window: window2 = defaultWindow$1, initialValue = "", observe = false } = options;
  const variable = ref(initialValue);
  const elRef = computed(() => {
    var _a;
    return unrefElement$1(target) || ((_a = window2 == null ? void 0 : window2.document) == null ? void 0 : _a.documentElement);
  });
  function updateCssVar() {
    var _a;
    const key = toValue$1(prop);
    const el = toValue$1(elRef);
    if (el && window2) {
      const value = (_a = window2.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();
      variable.value = value || initialValue;
    }
  }
  if (observe) {
    useMutationObserver(elRef, updateCssVar, {
      attributeFilter: ["style", "class"],
      window: window2
    });
  }
  watch(
    [elRef, () => toValue$1(prop)],
    updateCssVar,
    { immediate: true }
  );
  watch(
    variable,
    (val) => {
      var _a;
      if ((_a = elRef.value) == null ? void 0 : _a.style)
        elRef.value.style.setProperty(toValue$1(prop), val);
    }
  );
  return variable;
}
function useCurrentElement(rootComponent) {
  const vm = getCurrentInstance();
  const currentElement = computedWithControl(
    () => null,
    () => vm.proxy.$el
  );
  onUpdated(currentElement.trigger);
  onMounted(currentElement.trigger);
  return currentElement;
}
function useResizeObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow$1, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(() => Array.isArray(target) ? target.map((el) => unrefElement$1(el)) : [unrefElement$1(target)]);
  const stopWatch = watch(
    targets,
    (els) => {
      cleanup();
      if (isSupported.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els)
          _el && observer.observe(_el, observerOptions);
      }
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose$1(stop);
  return {
    isSupported,
    stop
  };
}
function useElementBounding(target, options = {}) {
  const {
    reset = true,
    windowResize = true,
    windowScroll = true,
    immediate = true
  } = options;
  const height = ref(0);
  const bottom = ref(0);
  const left = ref(0);
  const right = ref(0);
  const top = ref(0);
  const width = ref(0);
  const x2 = ref(0);
  const y2 = ref(0);
  function update() {
    const el = unrefElement$1(target);
    if (!el) {
      if (reset) {
        height.value = 0;
        bottom.value = 0;
        left.value = 0;
        right.value = 0;
        top.value = 0;
        width.value = 0;
        x2.value = 0;
        y2.value = 0;
      }
      return;
    }
    const rect = el.getBoundingClientRect();
    height.value = rect.height;
    bottom.value = rect.bottom;
    left.value = rect.left;
    right.value = rect.right;
    top.value = rect.top;
    width.value = rect.width;
    x2.value = rect.x;
    y2.value = rect.y;
  }
  useResizeObserver(target, update);
  watch(() => unrefElement$1(target), (ele) => !ele && update());
  useMutationObserver(target, update, {
    attributeFilter: ["style", "class"]
  });
  if (windowScroll)
    useEventListener$1("scroll", update, { capture: true, passive: true });
  if (windowResize)
    useEventListener$1("resize", update, { passive: true });
  tryOnMounted(() => {
    if (immediate)
      update();
  });
  return {
    height,
    bottom,
    left,
    right,
    top,
    width,
    x: x2,
    y: y2,
    update
  };
}
function useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {
  const { window: window2 = defaultWindow$1, box = "content-box" } = options;
  const isSVG = computed(() => {
    var _a, _b;
    return (_b = (_a = unrefElement$1(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes("svg");
  });
  const width = ref(initialSize.width);
  const height = ref(initialSize.height);
  const { stop: stop1 } = useResizeObserver(
    target,
    ([entry]) => {
      const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
      if (window2 && isSVG.value) {
        const $elem = unrefElement$1(target);
        if ($elem) {
          const rect = $elem.getBoundingClientRect();
          width.value = rect.width;
          height.value = rect.height;
        }
      } else {
        if (boxSize) {
          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];
          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
        } else {
          width.value = entry.contentRect.width;
          height.value = entry.contentRect.height;
        }
      }
    },
    options
  );
  tryOnMounted(() => {
    const ele = unrefElement$1(target);
    if (ele) {
      width.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
      height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
    }
  });
  const stop2 = watch(
    () => unrefElement$1(target),
    (ele) => {
      width.value = ele ? initialSize.width : 0;
      height.value = ele ? initialSize.height : 0;
    }
  );
  function stop() {
    stop1();
    stop2();
  }
  return {
    width,
    height,
    stop
  };
}
function useIntersectionObserver(target, callback, options = {}) {
  const {
    root,
    rootMargin = "0px",
    threshold = 0.1,
    window: window2 = defaultWindow$1,
    immediate = true
  } = options;
  const isSupported = useSupported(() => window2 && "IntersectionObserver" in window2);
  const targets = computed(() => {
    const _target = toValue$1(target);
    return (Array.isArray(_target) ? _target : [_target]).map(unrefElement$1).filter(notNullish);
  });
  let cleanup = noop$1;
  const isActive = ref(immediate);
  const stopWatch = isSupported.value ? watch(
    () => [targets.value, unrefElement$1(root), isActive.value],
    ([targets2, root2]) => {
      cleanup();
      if (!isActive.value)
        return;
      if (!targets2.length)
        return;
      const observer = new IntersectionObserver(
        callback,
        {
          root: unrefElement$1(root2),
          rootMargin,
          threshold
        }
      );
      targets2.forEach((el) => el && observer.observe(el));
      cleanup = () => {
        observer.disconnect();
        cleanup = noop$1;
      };
    },
    { immediate, flush: "post" }
  ) : noop$1;
  const stop = () => {
    cleanup();
    stopWatch();
    isActive.value = false;
  };
  tryOnScopeDispose$1(stop);
  return {
    isSupported,
    isActive,
    pause() {
      cleanup();
      isActive.value = false;
    },
    resume() {
      isActive.value = true;
    },
    stop
  };
}
function useFavicon(newIcon = null, options = {}) {
  const {
    baseUrl = "",
    rel = "icon",
    document: document2 = defaultDocument
  } = options;
  const favicon2 = toRef(newIcon);
  const applyIcon = (icon) => {
    const elements = document2 == null ? void 0 : document2.head.querySelectorAll(`link[rel*="${rel}"]`);
    if (!elements || elements.length === 0) {
      const link = document2 == null ? void 0 : document2.createElement("link");
      if (link) {
        link.rel = rel;
        link.href = `${baseUrl}${icon}`;
        link.type = `image/${icon.split(".").pop()}`;
        document2 == null ? void 0 : document2.head.append(link);
      }
      return;
    }
    elements == null ? void 0 : elements.forEach((el) => el.href = `${baseUrl}${icon}`);
  };
  watch(
    favicon2,
    (i2, o2) => {
      if (typeof i2 === "string" && i2 !== o2)
        applyIcon(i2);
    },
    { immediate: true }
  );
  return favicon2;
}
const ARRIVED_STATE_THRESHOLD_PIXELS = 1;
function useScroll(element, options = {}) {
  const {
    throttle = 0,
    idle = 200,
    onStop = noop$1,
    onScroll = noop$1,
    offset = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventListenerOptions = {
      capture: false,
      passive: true
    },
    behavior = "auto",
    window: window2 = defaultWindow$1,
    onError = (e2) => {
      console.error(e2);
    }
  } = options;
  const internalX = ref(0);
  const internalY = ref(0);
  const x2 = computed({
    get() {
      return internalX.value;
    },
    set(x22) {
      scrollTo2(x22, void 0);
    }
  });
  const y2 = computed({
    get() {
      return internalY.value;
    },
    set(y22) {
      scrollTo2(void 0, y22);
    }
  });
  function scrollTo2(_x, _y) {
    var _a, _b, _c, _d;
    if (!window2)
      return;
    const _element = toValue$1(element);
    if (!_element)
      return;
    (_c = _element instanceof Document ? window2.document.body : _element) == null ? void 0 : _c.scrollTo({
      top: (_a = toValue$1(_y)) != null ? _a : y2.value,
      left: (_b = toValue$1(_x)) != null ? _b : x2.value,
      behavior: toValue$1(behavior)
    });
    const scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;
    if (x2 != null)
      internalX.value = scrollContainer.scrollLeft;
    if (y2 != null)
      internalY.value = scrollContainer.scrollTop;
  }
  const isScrolling = ref(false);
  const arrivedState = reactive({
    left: true,
    right: false,
    top: true,
    bottom: false
  });
  const directions = reactive({
    left: false,
    right: false,
    top: false,
    bottom: false
  });
  const onScrollEnd = (e2) => {
    if (!isScrolling.value)
      return;
    isScrolling.value = false;
    directions.left = false;
    directions.right = false;
    directions.top = false;
    directions.bottom = false;
    onStop(e2);
  };
  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);
  const setArrivedState = (target) => {
    var _a;
    if (!window2)
      return;
    const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement$1(target);
    const { display, flexDirection } = getComputedStyle(el);
    const scrollLeft = el.scrollLeft;
    directions.left = scrollLeft < internalX.value;
    directions.right = scrollLeft > internalX.value;
    const left = Math.abs(scrollLeft) <= (offset.left || 0);
    const right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
    if (display === "flex" && flexDirection === "row-reverse") {
      arrivedState.left = right;
      arrivedState.right = left;
    } else {
      arrivedState.left = left;
      arrivedState.right = right;
    }
    internalX.value = scrollLeft;
    let scrollTop = el.scrollTop;
    if (target === window2.document && !scrollTop)
      scrollTop = window2.document.body.scrollTop;
    directions.top = scrollTop < internalY.value;
    directions.bottom = scrollTop > internalY.value;
    const top = Math.abs(scrollTop) <= (offset.top || 0);
    const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
    if (display === "flex" && flexDirection === "column-reverse") {
      arrivedState.top = bottom;
      arrivedState.bottom = top;
    } else {
      arrivedState.top = top;
      arrivedState.bottom = bottom;
    }
    internalY.value = scrollTop;
  };
  const onScrollHandler = (e2) => {
    var _a;
    if (!window2)
      return;
    const eventTarget = (_a = e2.target.documentElement) != null ? _a : e2.target;
    setArrivedState(eventTarget);
    isScrolling.value = true;
    onScrollEndDebounced(e2);
    onScroll(e2);
  };
  useEventListener$1(
    element,
    "scroll",
    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,
    eventListenerOptions
  );
  tryOnMounted(() => {
    try {
      const _element = toValue$1(element);
      if (!_element)
        return;
      setArrivedState(_element);
    } catch (e2) {
      onError(e2);
    }
  });
  useEventListener$1(
    element,
    "scrollend",
    onScrollEnd,
    eventListenerOptions
  );
  return {
    x: x2,
    y: y2,
    isScrolling,
    arrivedState,
    directions,
    measure() {
      const _element = toValue$1(element);
      if (window2 && _element)
        setArrivedState(_element);
    }
  };
}
function useParentElement(element = useCurrentElement()) {
  const parentElement = shallowRef();
  const update = () => {
    const el = unrefElement$1(element);
    if (el)
      parentElement.value = el.parentElement;
  };
  tryOnMounted(update);
  watch(() => toValue$1(element), update);
  return parentElement;
}
function useWindowSize(options = {}) {
  const {
    window: window2 = defaultWindow$1,
    initialWidth = Number.POSITIVE_INFINITY,
    initialHeight = Number.POSITIVE_INFINITY,
    listenOrientation = true,
    includeScrollbar = true
  } = options;
  const width = ref(initialWidth);
  const height = ref(initialHeight);
  const update = () => {
    if (window2) {
      if (includeScrollbar) {
        width.value = window2.innerWidth;
        height.value = window2.innerHeight;
      } else {
        width.value = window2.document.documentElement.clientWidth;
        height.value = window2.document.documentElement.clientHeight;
      }
    }
  };
  update();
  tryOnMounted(update);
  useEventListener$1("resize", update, { passive: true });
  if (listenOrientation) {
    const matches = useMediaQuery("(orientation: portrait)");
    watch(matches, () => update());
  }
  return { width, height };
}
const useBgOpacity = () => {
  const [bgOpacity, setBgOpacity] = useToggle(1);
  const [hoverIndex, setHoverIndex] = useToggle(-1);
  function hoverAction(opacity, index) {
    setBgOpacity(opacity);
    setHoverIndex(index);
  }
  function indexBgOpacity(index) {
    return get(hoverIndex) === index ? get(bgOpacity) : 1;
  }
  return { bgOpacity, indexBgOpacity, hoverAction, hoverIndex };
};
const useDialog = () => {
  const dialogRef = ref(null);
  function openDialog() {
    dialogRef.value?.showModal();
  }
  function closeDialog() {
    dialogRef.value?.close();
  }
  return { dialogRef, openDialog, closeDialog };
};
const useRightClick = () => {
  const rightInfo = shallowReactive({
    show: false,
    top: "0px",
    left: "0px"
  });
  const selectData = ref();
  function rightEvent({ target, clientY, clientX }, value, height = 180) {
    const mid = document.body.clientHeight / 2;
    const { y: y2 } = target.getBoundingClientRect();
    const temp = y2 > mid ? height : 0;
    selectData.value = value;
    rightInfo.show = true;
    rightInfo.top = clientY - temp + "px";
    rightInfo.left = clientX + "px";
  }
  function closeRight() {
    rightInfo.show = false;
  }
  return { rightEvent, closeRight, rightInfo, selectData };
};
function chuankArray(arr, size2) {
  if (arr.length === 0)
    return [];
  if (size2 <= 0)
    return [];
  const result = [];
  for (let i2 = 0; i2 < arr.length; i2 += size2) {
    const end = Math.min(i2 + size2, arr.length);
    result.push(arr.slice(i2, end));
  }
  return result;
}
function concatArrayBuffers(buffer1, buffer2) {
  const totalLength = buffer1.byteLength + buffer2.byteLength;
  const mergedArrayBuffer = new ArrayBuffer(totalLength);
  const view1 = new Uint8Array(buffer1);
  const view2 = new Uint8Array(buffer2);
  const mergedView = new Uint8Array(mergedArrayBuffer);
  mergedView.set(view1, 0);
  mergedView.set(view2, view1.length);
  return mergedArrayBuffer;
}
function cloneBuffer(buffer) {
  return new Uint8Array(buffer).slice().buffer;
}
function arrayBufferToFile(val, fileName) {
  return new File([new Blob([val])], fileName);
}
const convertBlobToUint8Array = async (blob) => {
  if (blob) {
    const arrayBuffer = await blob.arrayBuffer();
    return new Uint8Array(arrayBuffer);
  }
  return new Uint8Array();
};
const convertUint8ArrayToURL = (buffer) => {
  const blob = new Blob([buffer], { type: "application/octet-stream" });
  return URL.createObjectURL(blob);
};
const fileToUint8Array = (file2) => {
  return new Promise((resolve2, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      resolve2(new Uint8Array(reader.result));
    };
    reader.onerror = (error) => {
      reject(error);
    };
    reader.readAsArrayBuffer(file2);
  });
};
const CHANNEL_CODE = "book_wise_channel";
new BroadcastChannel(CHANNEL_CODE);
const MENU_DRAWER = "sidbar-drawer";
const CETALOG_DRAWER = "catalog-drawer";
const NOTE_DRAWER = "note-drawer";
const $ = document.querySelector.bind(document);
const $$ = document.querySelectorAll.bind(document);
function createElement(tagName) {
  return document.createElement(tagName);
}
function remToPx(value) {
  const rootFontSize = parseFloat(getComputedStyle(document.documentElement).fontSize);
  return value * rootFontSize;
}
function isInClientRectTop(node) {
  const bottom = node.getBoundingClientRect().bottom;
  return bottom >= window.innerHeight / 2;
}
function getNoteOffset(node) {
  const { top, left, width } = node.getBoundingClientRect();
  return { top, left: left + width / 2 };
}
function lastElementsToArray(element) {
  const result = [];
  function traverse2(node) {
    if (node.children.length > 0) {
      for (let i2 = 0; i2 < node.children.length; i2++) {
        traverse2(node.children[i2]);
      }
    } else {
      result.push(node);
    }
  }
  traverse2(element);
  return result;
}
function getFirstLastElementChild(node) {
  let result = node.firstElementChild;
  while (result?.firstElementChild) {
    result = result.firstElementChild;
  }
  return result;
}
function findDomIndex(root, target) {
  const nodes = root.querySelectorAll(target.tagName);
  return Array.from(nodes).indexOf(target);
}
const store = /* @__PURE__ */ new WeakMap();
function createDialog(component, value) {
  const app = createApp(component, value);
  let container = $(".dialog-container");
  if (container) {
    const oldApp = store.get(container);
    if (oldApp) {
      oldApp.unmount();
    }
  } else {
    container = createElement("div");
    container.className = "dialog-container";
    document.body.appendChild(container);
  }
  app.mount(container);
  store.set(container, app);
}
const isUndefined = (value) => {
  return typeof value === "undefined";
};
const isElectron = navigator.userAgent.toLowerCase().indexOf("electron/") > -1;
function wait(time = 300) {
  return new Promise((resolve2) => {
    const timer = setTimeout(() => {
      resolve2();
      timer && clearTimeout(timer);
    }, time);
  });
}
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function getInterval(start, end) {
  return +((end - start) / 1e3 / 60).toFixed();
}
function toastError(message) {
  Toast({
    message,
    position: ["toast-top", "toast-center"],
    type: "alert-error"
  });
}
function toastSuccess(message) {
  Toast({
    message,
    position: ["toast-top", "toast-center"],
    type: "alert-success"
  });
}
function toastWarning(message) {
  Toast({
    message,
    position: ["toast-top", "toast-center"],
    type: "alert-warning"
  });
}
function formatFileSize(bytes, decimalPlaces = 2) {
  if (bytes === 0)
    return "0 Bytes";
  const k2 = 1024;
  const dm = decimalPlaces;
  const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
  const i2 = Math.floor(Math.log(bytes) / Math.log(k2));
  return parseFloat((bytes / Math.pow(k2, i2)).toFixed(dm)) + " " + sizes[i2];
}
function formatDecimal(val, decimal = 2) {
  return +Number(val).toFixed(decimal);
}
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
let activePinia;
const setActivePinia = (pinia2) => activePinia = pinia2;
const piniaSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function isPlainObject$2(o2) {
  return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia2 = markRaw({
    install(app) {
      setActivePinia(pinia2);
      {
        pinia2._a = app;
        app.provide(piniaSymbol, pinia2);
        app.config.globalProperties.$pinia = pinia2;
        toBeInstalled.forEach((plugin) => _p.push(plugin));
        toBeInstalled = [];
      }
    },
    use(plugin) {
      if (!this._a && !isVue2) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  return pinia2;
}
const noop = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
const fallbackRunWithContext = (fn) => fn();
function mergeReactiveObjects(target, patchToApply) {
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value, key) => target.set(key, value));
  }
  if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject$2(targetValue) && isPlainObject$2(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
const skipHydrateSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function shouldHydrate(obj) {
  return !isPlainObject$2(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign: assign$2 } = Object;
function isComputed(o2) {
  return !!(isRef(o2) && o2.effect);
}
function createOptionsStore(id2, options, pinia2, hot) {
  const { state, actions, getters } = options;
  const initialState = pinia2.state.value[id2];
  let store2;
  function setup() {
    if (!initialState && true) {
      {
        pinia2.state.value[id2] = state ? state() : {};
      }
    }
    const localState = toRefs(pinia2.state.value[id2]);
    return assign$2(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia2);
        const store22 = pinia2._s.get(id2);
        return getters[name].call(store22, store22);
      }));
      return computedGetters;
    }, {}));
  }
  store2 = createSetupStore(id2, setup, options, pinia2, hot, true);
  return store2;
}
function createSetupStore($id, setup, options = {}, pinia2, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign$2({ actions: {} }, options);
  const $subscribeOptions = {
    deep: true
    // flush: 'post',
  };
  let isListening;
  let isSyncListening;
  let subscriptions = [];
  let actionSubscriptions = [];
  let debuggerEvents;
  const initialState = pinia2.state.value[$id];
  if (!isOptionsStore && !initialState && true) {
    {
      pinia2.state.value[$id] = {};
    }
  }
  ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia2.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
  }
  const $reset = isOptionsStore ? function $reset2() {
    const { state } = options;
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign$2($state, newState);
    });
  } : (
    /* istanbul ignore next */
    noop
  );
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia2._s.delete($id);
  }
  function wrapAction(name, action) {
    return function() {
      setActivePinia(pinia2);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name,
        store: store2,
        after,
        onError
      });
      let ret;
      try {
        ret = action.apply(this && this.$id === $id ? this : store2, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value) => {
          triggerSubscriptions(afterCallbackList, value);
          return value;
        }).catch((error) => {
          triggerSubscriptions(onErrorCallbackList, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
  }
  const partialStore = {
    _p: pinia2,
    // _s: scope,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign$2({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store2 = reactive(partialStore);
  pinia2._s.set($id, store2);
  const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
  const setupStore = runWithContext(() => pinia2._e.run(() => (scope = effectScope()).run(setup)));
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
      if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects(prop, initialState[key]);
          }
        }
        {
          pinia2.state.value[$id][key] = prop;
        }
      }
    } else if (typeof prop === "function") {
      const actionValue = wrapAction(key, prop);
      {
        setupStore[key] = actionValue;
      }
      optionsForPlugin.actions[key] = prop;
    } else
      ;
  }
  {
    assign$2(store2, setupStore);
    assign$2(toRaw(store2), setupStore);
  }
  Object.defineProperty(store2, "$state", {
    get: () => pinia2.state.value[$id],
    set: (state) => {
      $patch(($state) => {
        assign$2($state, state);
      });
    }
  });
  pinia2._p.forEach((extender) => {
    {
      assign$2(store2, scope.run(() => extender({
        store: store2,
        app: pinia2._a,
        pinia: pinia2,
        options: optionsForPlugin
      })));
    }
  });
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store2.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store2;
}
function defineStore(idOrOptions, setup, setupOptions) {
  let id2;
  let options;
  const isSetupStore = typeof setup === "function";
  if (typeof idOrOptions === "string") {
    id2 = idOrOptions;
    options = isSetupStore ? setupOptions : setup;
  } else {
    options = idOrOptions;
    id2 = idOrOptions.id;
  }
  function useStore(pinia2, hot) {
    const hasContext = hasInjectionContext();
    pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    pinia2 || (hasContext ? inject(piniaSymbol, null) : null);
    if (pinia2)
      setActivePinia(pinia2);
    pinia2 = activePinia;
    if (!pinia2._s.has(id2)) {
      if (isSetupStore) {
        createSetupStore(id2, setup, options, pinia2);
      } else {
        createOptionsStore(id2, options, pinia2);
      }
    }
    const store2 = pinia2._s.get(id2);
    return store2;
  }
  useStore.$id = id2;
  return useStore;
}
const bookPositionStore = useStorage("book-wise_book_position", {}, localStorage, {
  mergeDefaults: true
});
const bookReadTimeStore = useStorage("book-wise_book_read_time", {}, localStorage, {
  mergeDefaults: true
});
const useBookPageStore = defineStore("useBookPageStore", () => {
  const page = ref(0);
  function setPage(value) {
    page.value = value;
  }
  return { page, setPage };
});
const useContentCantianerStore = defineStore("useContentCantianerStore", () => {
  const width = ref(100);
  function setWidth(value) {
    width.value = value;
  }
  return { width, setWidth };
});
const defaultState = {
  isOpenNew: true,
  isFoldCatalog: false,
  readMode: ReadMode.sroll,
  bookself: BookshelftMode.bookshelf,
  isOpenRecycleBin: true,
  isNoteShowClass: false,
  isAutoHighlight: true,
  isRemeberPosition: true,
  theme: "light",
  lang: "en",
  pdfScale: 1 * window.devicePixelRatio
};
const settingStore = useStorage(
  "book-wise_setting",
  defaultState,
  localStorage,
  { mergeDefaults: true }
);
const scriptRel = function detectScriptRel() {
  const relList = typeof document !== "undefined" && document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}();
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = Promise.all(deps.map((dep) => {
      dep = assetsURL(dep, importerUrl);
      if (dep in seen)
        return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      const isBaseRelative = !!importerUrl;
      if (isBaseRelative) {
        for (let i2 = links.length - 1; i2 >= 0; i2--) {
          const link2 = links[i2];
          if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
            return;
          }
        }
      } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
        return;
      }
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) {
        link.as = "script";
        link.crossOrigin = "";
      }
      link.href = dep;
      if (cspNonce) {
        link.setAttribute("nonce", cspNonce);
      }
      document.head.appendChild(link);
      if (isCss) {
        return new Promise((res, rej) => {
          link.addEventListener("load", res);
          link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
        });
      }
    }));
  }
  return promise.then(() => baseModule()).catch((err) => {
    const e2 = new Event("vite:preloadError", { cancelable: true });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  });
};
const menu = {
  book: "books",
  note: "notes",
  setting: "set up",
  recycleBin: "recycle bin"
};
const setting = {
  chooseLanguage: "Choose a language",
  chooseTheme: "Select theme",
  language: "language",
  theme: "theme",
  userSetting: "user settings",
  autoHighlightDesc: "After opening, when text is selected, it will be automatically highlighted.",
  autoHighlightTitle: "Whether to automatically highlight",
  bookMode: "bookshelf mode",
  mode: "model",
  noteShowClassDesc: "After closing, the highlight style will only be displayed when the mouse slides over it.",
  noteShowClassTitle: "Whether notes display highlight style",
  openNewDesc: "If not, the reader will only be on the current page.",
  openNewTitle: "Whether the reader opens a new page",
  openRecycleBinDesc: "Close the Recycle Bin. When you delete a book, it will be permanently deleted instead of being moved to the Recycle Bin.",
  openRecycleBinTitle: "Turn on the recycle bin function",
  readMode: "reading mode",
  rememberPositionDesc: "After opening it, entering the reading interface again will automatically jump to the last reading position.",
  rememberPositionTitle: "Whether to remember the last reading position",
  autoHighlight: "Auto highlight"
};
const unfound = {
  desc: "Sorry, we can't find the page. \nYou'll find a lot to explore on the home page.",
  tip: "back to the homepage",
  title: "The page is missing"
};
const file = {
  upload: "upload files",
  choose: "Select a document",
  dragFile: "Drag and drop files here",
  exist: "File already exists",
  releaseMouse: "Release mouse",
  uploadSuccess: "Upload successful",
  supportFormat: "Supported formats:"
};
const common = {
  or: "or",
  addBookshelf: "Add bookshelf",
  addLove: "add favorites",
  detail: "Details",
  edit: "edit",
  forceRemove: "delete permanently",
  remove: "delete",
  removeLove: "Remove favorites",
  restore: "recover",
  score: "score",
  unknown: "unknown",
  close: "closure",
  copySuccess: "Copied successfully",
  cancel: "Cancel",
  sure: "confirm",
  minute: "point",
  addSuccess: "Added successfully",
  empty: "Empty",
  removeSuccess: "Removed successfully",
  removeFail: "failed to delete",
  restoreFail: "Restore failed",
  editFail: "Edit failed",
  updateFail: "Update failed",
  add: "Add to",
  copy: "copy"
};
const readMode = {
  double: "Double page mode",
  scroll: "scroll mode",
  section: "Chapter mode"
};
const bookMode = {
  bookshelf: "bookshelf mode",
  card: "card mode",
  list: "list mode"
};
const book = {
  author: "author",
  bookshelf: "bookshelf",
  createTime: "createTime",
  detail: "Book details",
  highlightLen: "Number of highlights",
  name: "book title",
  notesLen: "Number of notes",
  openCount: "number of times read",
  page: "Number of pages",
  publishTime: "Published date",
  publisher: "Publisher",
  readProgress: "reading progress",
  score: "score",
  size: "size",
  totalReadTime: "Total reading time",
  updateTime: "Update time",
  readDetailFail: "Failed to read book details",
  thisReadTime: "This reading time",
  addToBookshelfFail: "Add to bookshelf failed",
  addToBookshelfSuccess: "Added to bookshelf successfully",
  addToBookshelf: "Add to bookshelf",
  getBookshelfFail: "Failed to get bookshelf",
  neeSelectBookshelf: "Please select bookshelf",
  needBookshelfName: "Please enter the bookshelf name",
  cover: "book cover",
  needAuhor: "Please enter author name",
  needBookName: "Please enter the book title",
  uploadCover: "Upload cover",
  uploadCoverFial: "Failed to upload cover",
  forceRemove: "Delete this book permanently",
  moveToRecycleBin: "Move this book to the trash",
  removeBook: "delete book",
  empty: "Book list is empty",
  needScore: "Please enter rating",
  recycleNoRecord: "There is no record of deleted data in the Recycle Bin!",
  uploadBookTip: "Click the upload button to upload a book locally, and then start immersing yourself in the sea of books!",
  getBookFail: "Failed to get book",
  getBookListFail: "Failed to read book list",
  getBookReadTimeFail: "Failed to read book reading time list",
  getBookReadTimeListFail: "Failed to read book reading time list",
  importBookFail: "Failed to import books",
  recordBookTimeFail: "Failed to record reading time",
  needAuthor: "Please enter author name",
  uploadCoverFail: "Failed to upload cover",
  jumpToBookList: "Jump to book list",
  jumpToLastPosition: "Jump to last reading position"
};
const note = {
  addNoteFail: "Failed to add note",
  getNoteFail: "Failed to read note list",
  getNoteListFail: "Failed to read note list",
  empty: "Note list is empty",
  emptyNoteListTip: "In your book list interface, select a book to read, then select the text that attracts your attention, and enter your thoughts in the pop-up dialog box",
  forceRemove: "Delete this note permanently",
  noteDetail: "Note details",
  removeSuccess: "Note deleted successfully",
  sureRemove: "Confirm note deletion",
  placeholder: "Write down your thoughts at this time...",
  write: "write ideas"
};
const tag = {
  needTag: "Please enter tag",
  removeTagSuccess: "Tag deleted successfully"
};
const statistics = {
  bookUnit: "Book",
  noteUnit: "Chapter",
  readTime: "duration",
  readTimeUnit: "Hour",
  readTotalTime: "total duration",
  readed: "Have read",
  reading: "reading",
  thisMouthNote: "Notes for this month",
  thisMouthReadTime: "Duration of this month",
  thisMouthReaded: "Read this month",
  thisMouthReading: "Reading this month",
  total: "The total amount",
  myLove: "my favourite",
  currentReading: "Reading recently"
};
const line = {
  beeline: "straight line",
  marker: "marker",
  wavy: "wavy lines"
};
const pdf = {
  auto: "Auto scaling",
  pageActual: "actual size",
  pageFit: "Fit to page",
  pageWidth: "Fit to page width"
};
const en$1 = {
  menu,
  setting,
  unfound,
  file,
  common,
  readMode,
  bookMode,
  book,
  note,
  tag,
  statistics,
  line,
  pdf
};
const __vite_glob_0_2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  book,
  bookMode,
  common,
  default: en$1,
  file,
  line,
  menu,
  note,
  pdf,
  readMode,
  setting,
  statistics,
  tag,
  unfound
}, Symbol.toStringTag, { value: "Module" }));
const __variableDynamicImportRuntimeHelper = (glob, path, segs) => {
  const v2 = glob[path];
  if (v2) {
    return typeof v2 === "function" ? v2() : Promise.resolve(v2);
  }
  return new Promise((_2, reject) => {
    (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(reject.bind(null, new Error("Unknown variable dynamic import: " + path + (path.split("/").length !== segs ? ". Note that variables only represent file names one level deep." : ""))));
  });
};
/*!
  * shared v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const inBrowser = typeof window !== "undefined";
const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
const isNumber$1 = (val) => typeof val === "number" && isFinite(val);
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isEmptyObject = (val) => isPlainObject$1(val) && Object.keys(val).length === 0;
const assign$1 = Object.assign;
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function escapeHtml(rawText) {
  return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
const isArray$1 = Array.isArray;
const isFunction = (val) => typeof val === "function";
const isString$2 = (val) => typeof val === "string";
const isBoolean = (val) => typeof val === "boolean";
const isObject$2 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$2(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const isPlainObject$1 = (val) => {
  if (!isObject$2(val))
    return false;
  const proto = Object.getPrototypeOf(val);
  return proto === null || proto.constructor === Object;
};
const toDisplayString = (val) => {
  return val == null ? "" : isArray$1(val) || isPlainObject$1(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
};
function join$1(items, separator = "") {
  return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
}
function incrementer(code2) {
  let current = code2;
  return () => ++current;
}
function warn$1(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
const isNotObjectOrIsArray = (val) => !isObject$2(val) || isArray$1(val);
function deepCopy(src, des) {
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw new Error("Invalid value");
  }
  const stack2 = [{ src, des }];
  while (stack2.length) {
    const { src: src2, des: des2 } = stack2.pop();
    Object.keys(src2).forEach((key) => {
      if (isNotObjectOrIsArray(src2[key]) || isNotObjectOrIsArray(des2[key])) {
        des2[key] = src2[key];
      } else {
        stack2.push({ src: src2[key], des: des2[key] });
      }
    });
  }
}
/*!
  * message-compiler v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function createPosition(line2, column, offset) {
  return { line: line2, column, offset };
}
function createLocation(start, end, source) {
  const loc = { start, end };
  return loc;
}
const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
function format$1(message, ...args) {
  if (args.length === 1 && isObject$1(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message.replace(RE_ARGS, (match2, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
const assign = Object.assign;
const isString$1 = (val) => typeof val === "string";
const isObject$1 = (val) => val !== null && typeof val === "object";
function join(items, separator = "") {
  return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
}
const CompileWarnCodes = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
};
const warnMessages = {
  [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
};
function createCompileWarn(code2, loc, ...args) {
  const msg = format$1(warnMessages[code2], ...args || []);
  const message = { message: String(msg), code: code2 };
  if (loc) {
    message.location = loc;
  }
  return message;
}
const CompileErrorCodes = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
};
const errorMessages = {
  // tokenizer error messages
  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
  // parser error messages
  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
  // generator error messages
  [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
  // minimizer error messages
  [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
};
function createCompileError(code2, loc, options = {}) {
  const { domain, messages, args } = options;
  const msg = format$1((messages || errorMessages)[code2] || "", ...args || []);
  const error = new SyntaxError(String(msg));
  error.code = code2;
  if (loc) {
    error.location = loc;
  }
  error.domain = domain;
  return error;
}
function defaultOnError(error) {
  throw error;
}
const CHAR_SP = " ";
const CHAR_CR = "\r";
const CHAR_LF = "\n";
const CHAR_LS = String.fromCharCode(8232);
const CHAR_PS = String.fromCharCode(8233);
function createScanner(str) {
  const _buf = str;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;
  const isCRLF = (index2) => _buf[index2] === CHAR_CR && _buf[index2 + 1] === CHAR_LF;
  const isLF = (index2) => _buf[index2] === CHAR_LF;
  const isPS = (index2) => _buf[index2] === CHAR_PS;
  const isLS = (index2) => _buf[index2] === CHAR_LS;
  const isLineEnd = (index2) => isCRLF(index2) || isLF(index2) || isPS(index2) || isLS(index2);
  const index = () => _index;
  const line2 = () => _line;
  const column = () => _column;
  const peekOffset = () => _peekOffset;
  const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
  const currentChar = () => charAt(_index);
  const currentPeek = () => charAt(_index + _peekOffset);
  function next() {
    _peekOffset = 0;
    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }
    if (isCRLF(_index)) {
      _index++;
    }
    _index++;
    _column++;
    return _buf[_index];
  }
  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }
    _peekOffset++;
    return _buf[_index + _peekOffset];
  }
  function reset() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }
  function resetPeek(offset = 0) {
    _peekOffset = offset;
  }
  function skipToPeek() {
    const target = _index + _peekOffset;
    while (target !== _index) {
      next();
    }
    _peekOffset = 0;
  }
  return {
    index,
    line: line2,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next,
    peek,
    reset,
    resetPeek,
    skipToPeek
  };
}
const EOF = void 0;
const DOT = ".";
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$3 = "tokenizer";
function createTokenizer(source, options = {}) {
  const location2 = options.location !== false;
  const _scnr = createScanner(source);
  const currentOffset = () => _scnr.index();
  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
  const _initLoc = currentPosition();
  const _initOffset = currentOffset();
  const _context = {
    currentType: 14,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 14,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ""
  };
  const context = () => _context;
  const { onError } = options;
  function emitError(code2, pos, offset, ...args) {
    const ctx = context();
    pos.column += offset;
    pos.offset += offset;
    if (onError) {
      const loc = location2 ? createLocation(ctx.startLoc, pos) : null;
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$3,
        args
      });
      onError(err);
    }
  }
  function getToken(context2, type, value) {
    context2.endLoc = currentPosition();
    context2.currentType = type;
    const token = { type };
    if (location2) {
      token.loc = createLocation(context2.startLoc, context2.endLoc);
    }
    if (value != null) {
      token.value = value;
    }
    return token;
  }
  const getEndToken = (context2) => getToken(
    context2,
    14
    /* TokenTypes.EOF */
  );
  function eat(scnr, ch) {
    if (scnr.currentChar() === ch) {
      scnr.next();
      return ch;
    } else {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      return "";
    }
  }
  function peekSpaces(scnr) {
    let buf = "";
    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf += scnr.currentPeek();
      scnr.peek();
    }
    return buf;
  }
  function skipSpaces(scnr) {
    const buf = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf;
  }
  function isIdentifierStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc === 95;
  }
  function isNumberStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function isNamedIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isListIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch);
    scnr.resetPeek();
    return ret;
  }
  function isLiteralStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDotStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 8) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ".";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedModifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 9) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDelimiterStart(scnr, context2) {
    const { currentType } = context2;
    if (!(currentType === 8 || currentType === 12)) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedReferStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 10) {
      return false;
    }
    const fn = () => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return isIdentifierStart(scnr.peek());
      } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
        return false;
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn();
      } else {
        return isTextStart(scnr, false);
      }
    };
    const ret = fn();
    scnr.resetPeek();
    return ret;
  }
  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|";
    scnr.resetPeek();
    return ret;
  }
  function detectModuloStart(scnr) {
    const spaces = peekSpaces(scnr);
    const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
    scnr.resetPeek();
    return {
      isModulo: ret,
      hasSpace: spaces.length > 0
    };
  }
  function isTextStart(scnr, reset = true) {
    const fn = (hasSpace = false, prev = "", detectModulo = false) => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return prev === "%" ? false : hasSpace;
      } else if (ch === "@" || !ch) {
        return prev === "%" ? true : hasSpace;
      } else if (ch === "%") {
        scnr.peek();
        return fn(hasSpace, "%", true);
      } else if (ch === "|") {
        return prev === "%" || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
      } else if (ch === CHAR_SP) {
        scnr.peek();
        return fn(true, CHAR_SP, detectModulo);
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn(true, CHAR_LF, detectModulo);
      } else {
        return true;
      }
    };
    const ret = fn();
    reset && scnr.resetPeek();
    return ret;
  }
  function takeChar(scnr, fn) {
    const ch = scnr.currentChar();
    if (ch === EOF) {
      return EOF;
    }
    if (fn(ch)) {
      scnr.next();
      return ch;
    }
    return null;
  }
  function isIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36;
  }
  function takeIdentifierChar(scnr) {
    return takeChar(scnr, isIdentifier);
  }
  function isNamedIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36 || // $
    cc === 45;
  }
  function takeNamedIdentifierChar(scnr) {
    return takeChar(scnr, isNamedIdentifier);
  }
  function isDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function takeDigit(scnr) {
    return takeChar(scnr, isDigit);
  }
  function isHexDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57 || // 0-9
    cc >= 65 && cc <= 70 || // A-F
    cc >= 97 && cc <= 102;
  }
  function takeHexDigit(scnr) {
    return takeChar(scnr, isHexDigit);
  }
  function getDigits(scnr) {
    let ch = "";
    let num = "";
    while (ch = takeDigit(scnr)) {
      num += ch;
    }
    return num;
  }
  function readModulo(scnr) {
    skipSpaces(scnr);
    const ch = scnr.currentChar();
    if (ch !== "%") {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
    }
    scnr.next();
    return "%";
  }
  function readText(scnr) {
    let buf = "";
    while (true) {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
        break;
      } else if (ch === "%") {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else {
          break;
        }
      } else if (ch === CHAR_SP || ch === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf += ch;
          scnr.next();
        }
      } else {
        buf += ch;
        scnr.next();
      }
    }
    return buf;
  }
  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let name = "";
    while (ch = takeNamedIdentifierChar(scnr)) {
      name += ch;
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return name;
  }
  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value = "";
    if (scnr.currentChar() === "-") {
      scnr.next();
      value += `-${getDigits(scnr)}`;
    } else {
      value += getDigits(scnr);
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return value;
  }
  function isLiteral2(ch) {
    return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
  }
  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `'`);
    let ch = "";
    let literal = "";
    while (ch = takeChar(scnr, isLiteral2)) {
      if (ch === "\\") {
        literal += readEscapeSequence(scnr);
      } else {
        literal += ch;
      }
    }
    const current = scnr.currentChar();
    if (current === CHAR_LF || current === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
      if (current === CHAR_LF) {
        scnr.next();
        eat(scnr, `'`);
      }
      return literal;
    }
    eat(scnr, `'`);
    return literal;
  }
  function readEscapeSequence(scnr) {
    const ch = scnr.currentChar();
    switch (ch) {
      case "\\":
      case `'`:
        scnr.next();
        return `\\${ch}`;
      case "u":
        return readUnicodeEscapeSequence(scnr, ch, 4);
      case "U":
        return readUnicodeEscapeSequence(scnr, ch, 6);
      default:
        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
        return "";
    }
  }
  function readUnicodeEscapeSequence(scnr, unicode, digits) {
    eat(scnr, unicode);
    let sequence = "";
    for (let i2 = 0; i2 < digits; i2++) {
      const ch = takeHexDigit(scnr);
      if (!ch) {
        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
        break;
      }
      sequence += ch;
    }
    return `\\${unicode}${sequence}`;
  }
  function isInvalidIdentifier(ch) {
    return ch !== "{" && ch !== "}" && ch !== CHAR_SP && ch !== CHAR_LF;
  }
  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let identifiers = "";
    while (ch = takeChar(scnr, isInvalidIdentifier)) {
      identifiers += ch;
    }
    return identifiers;
  }
  function readLinkedModifier(scnr) {
    let ch = "";
    let name = "";
    while (ch = takeIdentifierChar(scnr)) {
      name += ch;
    }
    return name;
  }
  function readLinkedRefer(scnr) {
    const fn = (buf) => {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
        return buf;
      } else if (ch === CHAR_SP) {
        return buf;
      } else if (ch === CHAR_LF || ch === DOT) {
        buf += ch;
        scnr.next();
        return fn(buf);
      } else {
        buf += ch;
        scnr.next();
        return fn(buf);
      }
    };
    return fn("");
  }
  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(
      scnr,
      "|"
      /* TokenChars.Pipe */
    );
    skipSpaces(scnr);
    return plural;
  }
  function readTokenInPlaceholder(scnr, context2) {
    let token = null;
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        if (context2.braceNest >= 1) {
          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          2,
          "{"
          /* TokenChars.BraceLeft */
        );
        skipSpaces(scnr);
        context2.braceNest++;
        return token;
      case "}":
        if (context2.braceNest > 0 && context2.currentType === 2) {
          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
        context2.braceNest--;
        context2.braceNest > 0 && skipSpaces(scnr);
        if (context2.inLinked && context2.braceNest === 0) {
          context2.inLinked = false;
        }
        return token;
      case "@":
        if (context2.braceNest > 0) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        token = readTokenInLinked(scnr, context2) || getEndToken(context2);
        context2.braceNest = 0;
        return token;
      default: {
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;
        if (isPluralStart(scnr)) {
          if (context2.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context2.braceNest = 0;
          return readToken(scnr, context2);
        }
        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
          token = getToken(context2, 5, readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
          token = getToken(context2, 6, readListIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validLiteral = isLiteralStart(scnr, context2)) {
          token = getToken(context2, 7, readLiteral(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          token = getToken(context2, 13, readInvalidIdentifier(scnr));
          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
          skipSpaces(scnr);
          return token;
        }
        break;
      }
    }
    return token;
  }
  function readTokenInLinked(scnr, context2) {
    const { currentType } = context2;
    let token = null;
    const ch = scnr.currentChar();
    if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }
    switch (ch) {
      case "@":
        scnr.next();
        token = getToken(
          context2,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        );
        context2.inLinked = true;
        return token;
      case ".":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context2);
        }
        if (isLinkedModifierStart(scnr, context2)) {
          skipSpaces(scnr);
          return getToken(context2, 12, readLinkedModifier(scnr));
        }
        if (isLinkedReferStart(scnr, context2)) {
          skipSpaces(scnr);
          if (ch === "{") {
            return readTokenInPlaceholder(scnr, context2) || token;
          } else {
            return getToken(context2, 11, readLinkedRefer(scnr));
          }
        }
        if (currentType === 8) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        context2.braceNest = 0;
        context2.inLinked = false;
        return readToken(scnr, context2);
    }
  }
  function readToken(scnr, context2) {
    let token = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (context2.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
    }
    if (context2.inLinked) {
      return readTokenInLinked(scnr, context2) || getEndToken(context2);
    }
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      case "}":
        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      default: {
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        const { isModulo, hasSpace } = detectModuloStart(scnr);
        if (isModulo) {
          return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
        }
        if (isTextStart(scnr)) {
          return getToken(context2, 0, readText(scnr));
        }
        break;
      }
    }
    return token;
  }
  function nextToken() {
    const { currentType, offset, startLoc, endLoc } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();
    if (_scnr.currentChar() === EOF) {
      return getToken(
        _context,
        14
        /* TokenTypes.EOF */
      );
    }
    return readToken(_scnr, _context);
  }
  return {
    nextToken,
    currentOffset,
    currentPosition,
    context
  };
}
const ERROR_DOMAIN$2 = "parser";
const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match2, codePoint4, codePoint6) {
  switch (match2) {
    case `\\\\`:
      return `\\`;
    case `\\'`:
      return `'`;
    default: {
      const codePoint = parseInt(codePoint4 || codePoint6, 16);
      if (codePoint <= 55295 || codePoint >= 57344) {
        return String.fromCodePoint(codePoint);
      }
      return "";
    }
  }
}
function createParser(options = {}) {
  const location2 = options.location !== false;
  const { onError, onWarn } = options;
  function emitError(tokenzer, code2, start, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onError) {
      const loc = location2 ? createLocation(start, end) : null;
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$2,
        args
      });
      onError(err);
    }
  }
  function emitWarn(tokenzer, code2, start, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onWarn) {
      const loc = location2 ? createLocation(start, end) : null;
      onWarn(createCompileWarn(code2, loc, args));
    }
  }
  function startNode(type, offset, loc) {
    const node = { type };
    if (location2) {
      node.start = offset;
      node.end = offset;
      node.loc = { start: loc, end: loc };
    }
    return node;
  }
  function endNode(node, offset, pos, type) {
    if (location2) {
      node.end = offset;
      if (node.loc) {
        node.loc.end = pos;
      }
    }
  }
  function parseText(tokenizer2, value) {
    const context = tokenizer2.context();
    const node = startNode(3, context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return node;
  }
  function parseList(tokenizer2, index) {
    const context = tokenizer2.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(5, offset, loc);
    node.index = parseInt(index, 10);
    tokenizer2.nextToken();
    endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return node;
  }
  function parseNamed(tokenizer2, key, modulo) {
    const context = tokenizer2.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(4, offset, loc);
    node.key = key;
    if (modulo === true) {
      node.modulo = true;
    }
    tokenizer2.nextToken();
    endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return node;
  }
  function parseLiteral(tokenizer2, value) {
    const context = tokenizer2.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(9, offset, loc);
    node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer2.nextToken();
    endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return node;
  }
  function parseLinkedModifier(tokenizer2) {
    const token = tokenizer2.nextToken();
    const context = tokenizer2.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(8, offset, loc);
    if (token.type !== 12) {
      emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
      node.value = "";
      endNode(node, offset, loc);
      return {
        nextConsumeToken: token,
        node
      };
    }
    if (token.value == null) {
      emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    node.value = token.value || "";
    endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return {
      node
    };
  }
  function parseLinkedKey(tokenizer2, value) {
    const context = tokenizer2.context();
    const node = startNode(7, context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return node;
  }
  function parseLinked(tokenizer2) {
    const context = tokenizer2.context();
    const linkedNode = startNode(6, context.offset, context.startLoc);
    let token = tokenizer2.nextToken();
    if (token.type === 9) {
      const parsed = parseLinkedModifier(tokenizer2);
      linkedNode.modifier = parsed.node;
      token = parsed.nextConsumeToken || tokenizer2.nextToken();
    }
    if (token.type !== 10) {
      emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    token = tokenizer2.nextToken();
    if (token.type === 2) {
      token = tokenizer2.nextToken();
    }
    switch (token.type) {
      case 11:
        if (token.value == null) {
          emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLinkedKey(tokenizer2, token.value || "");
        break;
      case 5:
        if (token.value == null) {
          emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseNamed(tokenizer2, token.value || "");
        break;
      case 6:
        if (token.value == null) {
          emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseList(tokenizer2, token.value || "");
        break;
      case 7:
        if (token.value == null) {
          emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLiteral(tokenizer2, token.value || "");
        break;
      default: {
        emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
        const nextContext = tokenizer2.context();
        const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = "";
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token,
          node: linkedNode
        };
      }
    }
    endNode(linkedNode, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return {
      node: linkedNode
    };
  }
  function parseMessage(tokenizer2) {
    const context = tokenizer2.context();
    const startOffset = context.currentType === 1 ? tokenizer2.currentOffset() : context.offset;
    const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
    const node = startNode(2, startOffset, startLoc);
    node.items = [];
    let nextToken = null;
    let modulo = null;
    do {
      const token = nextToken || tokenizer2.nextToken();
      nextToken = null;
      switch (token.type) {
        case 0:
          if (token.value == null) {
            emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseText(tokenizer2, token.value || ""));
          break;
        case 6:
          if (token.value == null) {
            emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseList(tokenizer2, token.value || ""));
          break;
        case 4:
          modulo = true;
          break;
        case 5:
          if (token.value == null) {
            emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseNamed(tokenizer2, token.value || "", !!modulo));
          if (modulo) {
            emitWarn(tokenizer2, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token));
            modulo = null;
          }
          break;
        case 7:
          if (token.value == null) {
            emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseLiteral(tokenizer2, token.value || ""));
          break;
        case 8: {
          const parsed = parseLinked(tokenizer2);
          node.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
        }
      }
    } while (context.currentType !== 14 && context.currentType !== 1);
    const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer2.currentOffset();
    const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer2.currentPosition();
    endNode(node, endOffset, endLoc);
    return node;
  }
  function parsePlural(tokenizer2, offset, loc, msgNode) {
    const context = tokenizer2.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node = startNode(1, offset, loc);
    node.cases = [];
    node.cases.push(msgNode);
    do {
      const msg = parseMessage(tokenizer2);
      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }
      node.cases.push(msg);
    } while (context.currentType !== 14);
    if (hasEmptyMessage) {
      emitError(tokenizer2, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
    }
    endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return node;
  }
  function parseResource(tokenizer2) {
    const context = tokenizer2.context();
    const { offset, startLoc } = context;
    const msgNode = parseMessage(tokenizer2);
    if (context.currentType === 14) {
      return msgNode;
    } else {
      return parsePlural(tokenizer2, offset, startLoc, msgNode);
    }
  }
  function parse2(source) {
    const tokenizer2 = createTokenizer(source, assign({}, options));
    const context = tokenizer2.context();
    const node = startNode(0, context.offset, context.startLoc);
    if (location2 && node.loc) {
      node.loc.source = source;
    }
    node.body = parseResource(tokenizer2);
    if (options.onCacheKey) {
      node.cacheKey = options.onCacheKey(source);
    }
    if (context.currentType !== 14) {
      emitError(tokenizer2, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
    }
    endNode(node, tokenizer2.currentOffset(), tokenizer2.currentPosition());
    return node;
  }
  return { parse: parse2 };
}
function getTokenCaption(token) {
  if (token.type === 14) {
    return "EOF";
  }
  const name = (token.value || "").replace(/\r?\n/gu, "\\n");
  return name.length > 10 ? name.slice(0, 9) + "" : name;
}
function createTransformer(ast, options = {}) {
  const _context = {
    ast,
    helpers: /* @__PURE__ */ new Set()
  };
  const context = () => _context;
  const helper = (name) => {
    _context.helpers.add(name);
    return name;
  };
  return { context, helper };
}
function traverseNodes(nodes, transformer) {
  for (let i2 = 0; i2 < nodes.length; i2++) {
    traverseNode(nodes[i2], transformer);
  }
}
function traverseNode(node, transformer) {
  switch (node.type) {
    case 1:
      traverseNodes(node.cases, transformer);
      transformer.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      traverseNodes(node.items, transformer);
      break;
    case 6: {
      const linked = node;
      traverseNode(linked.key, transformer);
      transformer.helper(
        "linked"
        /* HelperNameMap.LINKED */
      );
      transformer.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function transform(ast, options = {}) {
  const transformer = createTransformer(ast);
  transformer.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  );
  ast.body && traverseNode(ast.body, transformer);
  const context = transformer.context();
  ast.helpers = Array.from(context.helpers);
}
function optimize(ast) {
  const body = ast.body;
  if (body.type === 2) {
    optimizeMessageNode(body);
  } else {
    body.cases.forEach((c) => optimizeMessageNode(c));
  }
  return ast;
}
function optimizeMessageNode(message) {
  if (message.items.length === 1) {
    const item = message.items[0];
    if (item.type === 3 || item.type === 9) {
      message.static = item.value;
      delete item.value;
    }
  } else {
    const values2 = [];
    for (let i2 = 0; i2 < message.items.length; i2++) {
      const item = message.items[i2];
      if (!(item.type === 3 || item.type === 9)) {
        break;
      }
      if (item.value == null) {
        break;
      }
      values2.push(item.value);
    }
    if (values2.length === message.items.length) {
      message.static = join(values2);
      for (let i2 = 0; i2 < message.items.length; i2++) {
        const item = message.items[i2];
        if (item.type === 3 || item.type === 9) {
          delete item.value;
        }
      }
    }
  }
}
const ERROR_DOMAIN$1 = "minifier";
function minify(node) {
  node.t = node.type;
  switch (node.type) {
    case 0: {
      const resource = node;
      minify(resource.body);
      resource.b = resource.body;
      delete resource.body;
      break;
    }
    case 1: {
      const plural = node;
      const cases = plural.cases;
      for (let i2 = 0; i2 < cases.length; i2++) {
        minify(cases[i2]);
      }
      plural.c = cases;
      delete plural.cases;
      break;
    }
    case 2: {
      const message = node;
      const items = message.items;
      for (let i2 = 0; i2 < items.length; i2++) {
        minify(items[i2]);
      }
      message.i = items;
      delete message.items;
      if (message.static) {
        message.s = message.static;
        delete message.static;
      }
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const valueNode = node;
      if (valueNode.value) {
        valueNode.v = valueNode.value;
        delete valueNode.value;
      }
      break;
    }
    case 6: {
      const linked = node;
      minify(linked.key);
      linked.k = linked.key;
      delete linked.key;
      if (linked.modifier) {
        minify(linked.modifier);
        linked.m = linked.modifier;
        delete linked.modifier;
      }
      break;
    }
    case 5: {
      const list = node;
      list.i = list.index;
      delete list.index;
      break;
    }
    case 4: {
      const named = node;
      named.k = named.key;
      delete named.key;
      break;
    }
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: ERROR_DOMAIN$1,
        args: [node.type]
      });
    }
  }
  delete node.type;
}
const ERROR_DOMAIN = "parser";
function createCodeGenerator(ast, options) {
  const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;
  const location2 = options.location !== false;
  const _context = {
    filename,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };
  if (location2 && ast.loc) {
    _context.source = ast.loc.source;
  }
  const context = () => _context;
  function push(code2, node) {
    _context.code += code2;
  }
  function _newline(n2, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : "";
    push(_needIndent ? _breakLineCode + `  `.repeat(n2) : _breakLineCode);
  }
  function indent(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }
  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }
  function newline() {
    _newline(_context.indentLevel);
  }
  const helper = (key) => `_${key}`;
  const needIndent = () => _context.needIndent;
  return {
    context,
    push,
    indent,
    deindent,
    newline,
    helper,
    needIndent
  };
}
function generateLinkedNode(generator, node) {
  const { helper } = generator;
  generator.push(`${helper(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`);
  generateNode(generator, node.key);
  if (node.modifier) {
    generator.push(`, `);
    generateNode(generator, node.modifier);
    generator.push(`, _type`);
  } else {
    generator.push(`, undefined, _type`);
  }
  generator.push(`)`);
}
function generateMessageNode(generator, node) {
  const { helper, needIndent } = generator;
  generator.push(`${helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`);
  generator.indent(needIndent());
  const length = node.items.length;
  for (let i2 = 0; i2 < length; i2++) {
    generateNode(generator, node.items[i2]);
    if (i2 === length - 1) {
      break;
    }
    generator.push(", ");
  }
  generator.deindent(needIndent());
  generator.push("])");
}
function generatePluralNode(generator, node) {
  const { helper, needIndent } = generator;
  if (node.cases.length > 1) {
    generator.push(`${helper(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`);
    generator.indent(needIndent());
    const length = node.cases.length;
    for (let i2 = 0; i2 < length; i2++) {
      generateNode(generator, node.cases[i2]);
      if (i2 === length - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push(`])`);
  }
}
function generateResource(generator, node) {
  if (node.body) {
    generateNode(generator, node.body);
  } else {
    generator.push("null");
  }
}
function generateNode(generator, node) {
  const { helper } = generator;
  switch (node.type) {
    case 0:
      generateResource(generator, node);
      break;
    case 1:
      generatePluralNode(generator, node);
      break;
    case 2:
      generateMessageNode(generator, node);
      break;
    case 6:
      generateLinkedNode(generator, node);
      break;
    case 8:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 7:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 5:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "list"
        /* HelperNameMap.LIST */
      )}(${node.index}))`, node);
      break;
    case 4:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(node.key)}))`, node);
      break;
    case 9:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 3:
      generator.push(JSON.stringify(node.value), node);
      break;
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: ERROR_DOMAIN,
        args: [node.type]
      });
    }
  }
}
const generate = (ast, options = {}) => {
  const mode = isString$1(options.mode) ? options.mode : "normal";
  const filename = isString$1(options.filename) ? options.filename : "message.intl";
  const sourceMap = !!options.sourceMap;
  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
  const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
  const helpers = ast.helpers || [];
  const generator = createCodeGenerator(ast, {
    mode,
    filename,
    sourceMap,
    breakLineCode,
    needIndent
  });
  generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator.indent(needIndent);
  if (helpers.length > 0) {
    generator.push(`const { ${join(helpers.map((s) => `${s}: _${s}`), ", ")} } = ctx`);
    generator.newline();
  }
  generator.push(`return `);
  generateNode(generator, ast);
  generator.deindent(needIndent);
  generator.push(`}`);
  delete ast.helpers;
  const { code: code2, map } = generator.context();
  return {
    ast,
    code: code2,
    map: map ? map.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function baseCompile$1(source, options = {}) {
  const assignedOptions = assign({}, options);
  const jit = !!assignedOptions.jit;
  const enalbeMinify = !!assignedOptions.minify;
  const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
  const parser2 = createParser(assignedOptions);
  const ast = parser2.parse(source);
  if (!jit) {
    transform(ast, assignedOptions);
    return generate(ast, assignedOptions);
  } else {
    enambeOptimize && optimize(ast);
    enalbeMinify && minify(ast);
    return { ast, code: "" };
  }
}
/*!
  * core-base v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function initFeatureFlags$1() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
}
const pathStateMachine = [];
pathStateMachine[
  0
  /* States.BEFORE_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    0
    /* States.BEFORE_PATH */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  1
  /* States.IN_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1
    /* States.IN_PATH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  2
  /* States.BEFORE_IDENT */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  3
  /* States.IN_IDENT */
] = {
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1,
    1
    /* Actions.PUSH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2,
    1
    /* Actions.PUSH */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    1
    /* Actions.PUSH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7,
    1
    /* Actions.PUSH */
  ]
};
pathStateMachine[
  4
  /* States.IN_SUB_PATH */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ],
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* PathCharTypes.RIGHT_BRACKET */
  ]: [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
function stripQuotes(str) {
  const a2 = str.charCodeAt(0);
  const b2 = str.charCodeAt(str.length - 1);
  return a2 === b2 && (a2 === 34 || a2 === 39) ? str.slice(1, -1) : str;
}
function getPathCharType(ch) {
  if (ch === void 0 || ch === null) {
    return "o";
  }
  const code2 = ch.charCodeAt(0);
  switch (code2) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return ch;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse$1(path) {
  const keys = [];
  let index = -1;
  let mode = 0;
  let subPathDepth = 0;
  let c;
  let key;
  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[
    0
    /* Actions.APPEND */
  ] = () => {
    if (key === void 0) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[
    1
    /* Actions.PUSH */
  ] = () => {
    if (key !== void 0) {
      keys.push(key);
      key = void 0;
    }
  };
  actions[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[
      0
      /* Actions.APPEND */
    ]();
    subPathDepth++;
  };
  actions[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4;
      actions[
        0
        /* Actions.APPEND */
      ]();
    } else {
      subPathDepth = 0;
      if (key === void 0) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[
          1
          /* Actions.PUSH */
        ]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index + 1];
    if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
      index++;
      newChar = "\\" + nextChar;
      actions[
        0
        /* Actions.APPEND */
      ]();
      return true;
    }
  }
  while (mode !== null) {
    index++;
    c = path[index];
    if (c === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type = getPathCharType(c);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap[
      "l"
      /* PathCharTypes.ELSE */
    ] || 8;
    if (transition === 8) {
      return;
    }
    mode = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode === 7) {
      return keys;
    }
  }
}
const cache$2 = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path) {
  return isObject$2(obj) ? obj[path] : null;
}
function resolveValue(obj, path) {
  if (!isObject$2(obj)) {
    return null;
  }
  let hit = cache$2.get(path);
  if (!hit) {
    hit = parse$1(path);
    if (hit) {
      cache$2.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last2 = obj;
  let i2 = 0;
  while (i2 < len) {
    const val = last2[hit[i2]];
    if (val === void 0) {
      return null;
    }
    if (isFunction(last2)) {
      return null;
    }
    last2 = val;
    i2++;
  }
  return last2;
}
const DEFAULT_MODIFIER = (str) => str;
const DEFAULT_MESSAGE = (ctx) => "";
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = (values2) => values2.length === 0 ? "" : join$1(values2);
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options) {
  const index = isNumber$1(options.pluralIndex) ? options.pluralIndex : -1;
  return options.named && (isNumber$1(options.named.count) || isNumber$1(options.named.n)) ? isNumber$1(options.named.count) ? options.named.count : isNumber$1(options.named.n) ? options.named.n : index : index;
}
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
function createMessageContext(options = {}) {
  const locale = options.locale;
  const pluralIndex = getPluralIndex(options);
  const pluralRule = isObject$2(options.pluralRules) && isString$2(locale) && isFunction(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
  const orgPluralRule = isObject$2(options.pluralRules) && isString$2(locale) && isFunction(options.pluralRules[locale]) ? pluralDefault : void 0;
  const plural = (messages) => {
    return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
  };
  const _list = options.list || [];
  const list = (index) => _list[index];
  const _named = options.named || {};
  isNumber$1(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = (key) => _named[key];
  function message(key) {
    const msg = isFunction(options.messages) ? options.messages(key) : isObject$2(options.messages) ? options.messages[key] : false;
    return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
  const normalize2 = isPlainObject$1(options.processor) && isFunction(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject$1(options.processor) && isFunction(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = isPlainObject$1(options.processor) && isString$2(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type2 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject$2(arg1)) {
        modifier = arg1.modifier || modifier;
        type2 = arg1.type || type2;
      } else if (isString$2(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString$2(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString$2(arg2)) {
        type2 = arg2 || type2;
      }
    }
    const ret = message(key)(ctx);
    const msg = (
      // The message in vnode resolved with linked are returned as an array by processor.nomalize
      type2 === "vnode" && isArray$1(ret) && modifier ? ret[0] : ret
    );
    return modifier ? _modifier(modifier)(msg, type2) : msg;
  };
  const ctx = {
    [
      "list"
      /* HelperNameMap.LIST */
    ]: list,
    [
      "named"
      /* HelperNameMap.NAMED */
    ]: named,
    [
      "plural"
      /* HelperNameMap.PLURAL */
    ]: plural,
    [
      "linked"
      /* HelperNameMap.LINKED */
    ]: linked,
    [
      "message"
      /* HelperNameMap.MESSAGE */
    ]: message,
    [
      "type"
      /* HelperNameMap.TYPE */
    ]: type,
    [
      "interpolate"
      /* HelperNameMap.INTERPOLATE */
    ]: interpolate,
    [
      "normalize"
      /* HelperNameMap.NORMALIZE */
    ]: normalize2,
    [
      "values"
      /* HelperNameMap.VALUES */
    ]: assign$1({}, _list, _named)
  };
  return ctx;
}
let devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
function initI18nDevTools(i18n2, version2, meta) {
  devtools && devtools.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: i18n2,
    version: version2,
    meta
  });
}
const translateDevTools = /* @__PURE__ */ createDevToolsHook(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
const code$1$1 = CompileWarnCodes.__EXTEND_POINT__;
const inc$1$1 = incrementer(code$1$1);
const CoreWarnCodes = {
  NOT_FOUND_KEY: code$1$1,
  // 2
  FALLBACK_TO_TRANSLATE: inc$1$1(),
  // 3
  CANNOT_FORMAT_NUMBER: inc$1$1(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: inc$1$1(),
  // 5
  CANNOT_FORMAT_DATE: inc$1$1(),
  // 6
  FALLBACK_TO_DATE_FORMAT: inc$1$1(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1$1(),
  // 8
  __EXTEND_POINT__: inc$1$1()
  // 9
};
const code$2 = CompileErrorCodes.__EXTEND_POINT__;
const inc$2 = incrementer(code$2);
const CoreErrorCodes = {
  INVALID_ARGUMENT: code$2,
  // 17
  INVALID_DATE_ARGUMENT: inc$2(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: inc$2(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: inc$2(),
  // 23
  __EXTEND_POINT__: inc$2()
  // 24
};
function createCoreError(code2) {
  return createCompileError(code2, null, void 0);
}
function getLocale(context, options) {
  return options.locale != null ? resolveLocale(options.locale) : resolveLocale(context.locale);
}
let _resolveLocale;
function resolveLocale(locale) {
  if (isString$2(locale)) {
    return locale;
  } else {
    if (isFunction(locale)) {
      if (locale.resolvedOnce && _resolveLocale != null) {
        return _resolveLocale;
      } else if (locale.constructor.name === "Function") {
        const resolve2 = locale();
        if (isPromise(resolve2)) {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        }
        return _resolveLocale = resolve2;
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
      }
    } else {
      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
    }
  }
}
function fallbackWithSimple(ctx, fallback, start) {
  return [.../* @__PURE__ */ new Set([
    start,
    ...isArray$1(fallback) ? fallback : isObject$2(fallback) ? Object.keys(fallback) : isString$2(fallback) ? [fallback] : [start]
  ])];
}
function fallbackWithLocaleChain(ctx, fallback, start) {
  const startLocale = isString$2(start) ? start : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = /* @__PURE__ */ new Map();
  }
  let chain = context.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block = [start];
    while (isArray$1(block)) {
      block = appendBlockToChain(chain, block, fallback);
    }
    const defaults = isArray$1(fallback) || !isPlainObject$1(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block = isString$2(defaults) ? [defaults] : defaults;
    if (isArray$1(block)) {
      appendBlockToChain(chain, block, false);
    }
    context.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
function appendBlockToChain(chain, block, blocks) {
  let follow = true;
  for (let i2 = 0; i2 < block.length && isBoolean(follow); i2++) {
    const locale = block[i2];
    if (isString$2(locale)) {
      follow = appendLocaleToChain(chain, block[i2], blocks);
    }
  }
  return follow;
}
function appendLocaleToChain(chain, locale, blocks) {
  let follow;
  const tokens = locale.split("-");
  do {
    const target = tokens.join("-");
    follow = appendItemToChain(chain, target, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
function appendItemToChain(chain, target, blocks) {
  let follow = false;
  if (!chain.includes(target)) {
    follow = true;
    if (target) {
      follow = target[target.length - 1] !== "!";
      const locale = target.replace(/!/g, "");
      chain.push(locale);
      if ((isArray$1(blocks) || isPlainObject$1(blocks)) && blocks[locale]) {
        follow = blocks[locale];
      }
    }
  }
  return follow;
}
const VERSION$1 = "9.13.1";
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = "en-US";
const MISSING_RESOLVE_VALUE = "";
const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
function getDefaultLinkedModifiers() {
  return {
    upper: (val, type) => {
      return type === "text" && isString$2(val) ? val.toUpperCase() : type === "vnode" && isObject$2(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
    },
    lower: (val, type) => {
      return type === "text" && isString$2(val) ? val.toLowerCase() : type === "vnode" && isObject$2(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type) => {
      return type === "text" && isString$2(val) ? capitalize(val) : type === "vnode" && isObject$2(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
    }
  };
}
let _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
let _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
let _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
let _additionalMeta = null;
const setAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ (meta) => {
  _additionalMeta = meta;
};
const getAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ () => _additionalMeta;
let _fallbackContext = null;
const setFallbackContext = (context) => {
  _fallbackContext = context;
};
const getFallbackContext = () => _fallbackContext;
let _cid = 0;
function createCoreContext(options = {}) {
  const onWarn = isFunction(options.onWarn) ? options.onWarn : warn$1;
  const version2 = isString$2(options.version) ? options.version : VERSION$1;
  const locale = isString$2(options.locale) || isFunction(options.locale) ? options.locale : DEFAULT_LOCALE;
  const _locale = isFunction(locale) ? DEFAULT_LOCALE : locale;
  const fallbackLocale = isArray$1(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || isString$2(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
  const messages = isPlainObject$1(options.messages) ? options.messages : { [_locale]: {} };
  const datetimeFormats = isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : { [_locale]: {} };
  const numberFormats = isPlainObject$1(options.numberFormats) ? options.numberFormats : { [_locale]: {} };
  const modifiers = assign$1({}, options.modifiers || {}, getDefaultLinkedModifiers());
  const pluralRules = options.pluralRules || {};
  const missing = isFunction(options.missing) ? options.missing : null;
  const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const fallbackFormat = !!options.fallbackFormat;
  const unresolving = !!options.unresolving;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const processor = isPlainObject$1(options.processor) ? options.processor : null;
  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const escapeParameter = !!options.escapeParameter;
  const messageCompiler = isFunction(options.messageCompiler) ? options.messageCompiler : _compiler;
  const messageResolver = isFunction(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject$2(options.fallbackContext) ? options.fallbackContext : void 0;
  const internalOptions = options;
  const __datetimeFormatters = isObject$2(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
  const __numberFormatters = isObject$2(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
  const __meta = isObject$2(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version: version2,
    cid: _cid,
    locale,
    fallbackLocale,
    messages,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context, version2, __meta);
  }
  return context;
}
function handleMissing(context, key, locale, missingWarn, type) {
  const { missing, onWarn } = context;
  if (missing !== null) {
    const ret = missing(context, locale, key, type);
    return isString$2(ret) ? ret : key;
  } else {
    return key;
  }
}
function updateFallbackLocale(ctx, locale, fallback) {
  const context = ctx;
  context.__localeChainCache = /* @__PURE__ */ new Map();
  ctx.localeFallbacker(ctx, fallback, locale);
}
function isAlmostSameLocale(locale, compareLocale) {
  if (locale === compareLocale)
    return false;
  return locale.split("-")[0] === compareLocale.split("-")[0];
}
function isImplicitFallback(targetLocale, locales) {
  const index = locales.indexOf(targetLocale);
  if (index === -1) {
    return false;
  }
  for (let i2 = index + 1; i2 < locales.length; i2++) {
    if (isAlmostSameLocale(targetLocale, locales[i2])) {
      return true;
    }
  }
  return false;
}
function format(ast) {
  const msg = (ctx) => formatParts(ctx, ast);
  return msg;
}
function formatParts(ctx, ast) {
  const body = ast.b || ast.body;
  if ((body.t || body.type) === 1) {
    const plural = body;
    const cases = plural.c || plural.cases;
    return ctx.plural(cases.reduce((messages, c) => [
      ...messages,
      formatMessageParts(ctx, c)
    ], []));
  } else {
    return formatMessageParts(ctx, body);
  }
}
function formatMessageParts(ctx, node) {
  const _static = node.s || node.static;
  if (_static) {
    return ctx.type === "text" ? _static : ctx.normalize([_static]);
  } else {
    const messages = (node.i || node.items).reduce((acm, c) => [...acm, formatMessagePart(ctx, c)], []);
    return ctx.normalize(messages);
  }
}
function formatMessagePart(ctx, node) {
  const type = node.t || node.type;
  switch (type) {
    case 3: {
      const text = node;
      return text.v || text.value;
    }
    case 9: {
      const literal = node;
      return literal.v || literal.value;
    }
    case 4: {
      const named = node;
      return ctx.interpolate(ctx.named(named.k || named.key));
    }
    case 5: {
      const list = node;
      return ctx.interpolate(ctx.list(list.i != null ? list.i : list.index));
    }
    case 6: {
      const linked = node;
      const modifier = linked.m || linked.modifier;
      return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
    }
    case 7: {
      const linkedKey = node;
      return linkedKey.v || linkedKey.value;
    }
    case 8: {
      const linkedModifier = node;
      return linkedModifier.v || linkedModifier.value;
    }
    default:
      throw new Error(`unhandled node type on format message part: ${type}`);
  }
}
const defaultOnCacheKey = (message) => message;
let compileCache = /* @__PURE__ */ Object.create(null);
const isMessageAST = (val) => isObject$2(val) && (val.t === 0 || val.type === 0) && ("b" in val || "body" in val);
function baseCompile(message, options = {}) {
  let detectError = false;
  const onError = options.onError || defaultOnError;
  options.onError = (err) => {
    detectError = true;
    onError(err);
  };
  return { ...baseCompile$1(message, options), detectError };
}
const compileToFunction = /* @__NO_SIDE_EFFECTS__ */ (message, context) => {
  if (!isString$2(message)) {
    throw createCoreError(CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE);
  }
  {
    isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { code: code2, detectError } = baseCompile(message, context);
    const msg = new Function(`return ${code2}`)();
    return !detectError ? compileCache[cacheKey] = msg : msg;
  }
};
function compile(message, context) {
  if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && isString$2(message)) {
    isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { ast, detectError } = baseCompile(message, {
      ...context,
      location: false,
      jit: true
    });
    const msg = format(ast);
    return !detectError ? compileCache[cacheKey] = msg : msg;
  } else {
    const cacheKey = message.cacheKey;
    if (cacheKey) {
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      return compileCache[cacheKey] = format(message);
    } else {
      return format(message);
    }
  }
}
const NOOP_MESSAGE_FUNCTION = () => "";
const isMessageFunction = (val) => isFunction(val);
function translate(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages } = context;
  const [key, options] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options.resolvedMessage;
  const defaultMsgOrKey = isString$2(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale = getLocale(context, options);
  escapeParameter && escapeParams(options);
  let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale,
    messages[locale] || {}
  ];
  let format2 = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString$2(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
    if (enableDefaultMsg) {
      format2 = defaultMsgOrKey;
      cacheBaseKey = format2;
    }
  }
  if (!resolvedMessage && (!(isString$2(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$2(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let occurred = false;
  const onError = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
  if (occurred) {
    return format2;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  const ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const payloads = {
      timestamp: Date.now(),
      key: isString$2(key) ? key : isMessageFunction(format2) ? format2.key : "",
      locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
      format: isString$2(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
      message: ret
    };
    payloads.meta = assign$1({}, context.__meta, /* @__PURE__ */ getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
function escapeParams(options) {
  if (isArray$1(options.list)) {
    options.list = options.list.map((item) => isString$2(item) ? escapeHtml(item) : item);
  } else if (isObject$2(options.named)) {
    Object.keys(options.named).forEach((key) => {
      if (isString$2(options.named[key])) {
        options.named[key] = escapeHtml(options.named[key]);
      }
    });
  }
}
function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale);
  let message = {};
  let targetLocale;
  let format2 = null;
  const type = "translate";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = locales[i2];
    message = messages[targetLocale] || {};
    if ((format2 = resolveValue2(message, key)) === null) {
      format2 = message[key];
    }
    if (isString$2(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
      break;
    }
    if (!isImplicitFallback(targetLocale, locales)) {
      const missingRet = handleMissing(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        key,
        targetLocale,
        missingWarn,
        type
      );
      if (missingRet !== key) {
        format2 = missingRet;
      }
    }
  }
  return [format2, targetLocale, message];
}
function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format2)) {
    const msg2 = format2;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = () => format2;
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format2;
  return msg;
}
function evaluateMessage(context, msg, msgCtx) {
  const messaged = msg(msgCtx);
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options = {};
  if (!isString$2(arg1) && !isNumber$1(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber$1(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber$1(arg2)) {
    options.plural = arg2;
  } else if (isString$2(arg2)) {
    options.default = arg2;
  } else if (isPlainObject$1(arg2) && !isEmptyObject(arg2)) {
    options.named = arg2;
  } else if (isArray$1(arg2)) {
    options.list = arg2;
  }
  if (isNumber$1(arg3)) {
    options.plural = arg3;
  } else if (isString$2(arg3)) {
    options.default = arg3;
  } else if (isPlainObject$1(arg3)) {
    assign$1(options, arg3);
  }
  return [key, options];
}
function getCompileContext(context, locale, key, source, warnHtmlMessage, onError) {
  return {
    locale,
    key,
    warnHtmlMessage,
    onError: (err) => {
      onError && onError(err);
      {
        throw err;
      }
    },
    onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
  };
}
function getMessageContextOptions(context, locale, message, options) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
  const resolveMessage = (key) => {
    let val = resolveValue2(message, key);
    if (val == null && fallbackContext) {
      const [, , message2] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue2(message2, key);
    }
    if (isString$2(val) || isMessageAST(val)) {
      let occurred = false;
      const onError = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context, key, locale, val, key, onError);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options.list) {
    ctxOptions.list = options.list;
  }
  if (options.named) {
    ctxOptions.named = options.named;
  }
  if (isNumber$1(options.plural)) {
    ctxOptions.pluralIndex = options.plural;
  }
  return ctxOptions;
}
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  const [key, value, options, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$2(key) || key === "") {
    return new Intl.DateTimeFormat(locale, overrides).format(value);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format2 = null;
  const type = "datetime format";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = locales[i2];
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format2 = datetimeFormat[key];
    if (isPlainObject$1(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
  }
  if (!isPlainObject$1(format2) || !isString$2(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id2 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign$1({}, format2, overrides));
    __datetimeFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = {};
  let overrides = {};
  let value;
  if (isString$2(arg1)) {
    const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches[3] ? matches[3].trim().startsWith("T") ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
    value = new Date(dateTime);
    try {
      value.toISOString();
    } catch (e2) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value = arg1;
  } else if (isNumber$1(arg1)) {
    value = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString$2(arg2)) {
    options.key = arg2;
  } else if (isPlainObject$1(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$2(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject$1(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject$1(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearDateTimeFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id2 = `${locale}__${key}`;
    if (!context.__datetimeFormatters.has(id2)) {
      continue;
    }
    context.__datetimeFormatters.delete(id2);
  }
}
function number(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  const [key, value, options, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$2(key) || key === "") {
    return new Intl.NumberFormat(locale, overrides).format(value);
  }
  let numberFormat = {};
  let targetLocale;
  let format2 = null;
  const type = "number format";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = locales[i2];
    numberFormat = numberFormats[targetLocale] || {};
    format2 = numberFormat[key];
    if (isPlainObject$1(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
  }
  if (!isPlainObject$1(format2) || !isString$2(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id2 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign$1({}, format2, overrides));
    __numberFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = {};
  let overrides = {};
  if (!isNumber$1(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value = arg1;
  if (isString$2(arg2)) {
    options.key = arg2;
  } else if (isPlainObject$1(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$2(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject$1(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject$1(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearNumberFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id2 = `${locale}__${key}`;
    if (!context.__numberFormatters.has(id2)) {
      continue;
    }
    context.__numberFormatters.delete(id2);
  }
}
{
  initFeatureFlags$1();
}
/*!
  * vue-i18n v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const VERSION = "9.13.1";
function initFeatureFlags() {
  if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
    getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
  }
  if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
    getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
const code$1 = CoreWarnCodes.__EXTEND_POINT__;
const inc$1 = incrementer(code$1);
({
  FALLBACK_TO_ROOT: code$1,
  // 9
  NOT_SUPPORTED_PRESERVE: inc$1(),
  // 10
  NOT_SUPPORTED_FORMATTER: inc$1(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
  // 14
  NOT_FOUND_PARENT_SCOPE: inc$1(),
  // 15
  IGNORE_OBJ_FLATTEN: inc$1(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: inc$1(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$1()
  // 18
});
const code = CoreErrorCodes.__EXTEND_POINT__;
const inc = incrementer(code);
const I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: code,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: inc(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: inc(),
  // 26
  NOT_INSTALLED: inc(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
  // 28
  // directive module errors
  REQUIRED_VALUE: inc(),
  // 29
  INVALID_VALUE: inc(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: inc(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: inc(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
  // 37
  // for enhancement
  __EXTEND_POINT__: inc()
  // 38
};
function createI18nError(code2, ...args) {
  return createCompileError(code2, null, void 0);
}
const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
function handleFlatJson(obj) {
  if (!isObject$2(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject$2(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      let hasStringValue = false;
      for (let i2 = 0; i2 < lastIndex; i2++) {
        if (!(subKeys[i2] in currentObj)) {
          currentObj[subKeys[i2]] = {};
        }
        if (!isObject$2(currentObj[subKeys[i2]])) {
          hasStringValue = true;
          break;
        }
        currentObj = currentObj[subKeys[i2]];
      }
      if (!hasStringValue) {
        currentObj[subKeys[lastIndex]] = obj[key];
        delete obj[key];
      }
      if (isObject$2(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }
  return obj;
}
function getLocaleMessages(locale, options) {
  const { messages, __i18n, messageResolver, flatJson } = options;
  const ret = isPlainObject$1(messages) ? messages : isArray$1(__i18n) ? {} : { [locale]: {} };
  if (isArray$1(__i18n)) {
    __i18n.forEach((custom) => {
      if ("locale" in custom && "resource" in custom) {
        const { locale: locale2, resource } = custom;
        if (locale2) {
          ret[locale2] = ret[locale2] || {};
          deepCopy(resource, ret[locale2]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString$2(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
function getComponentOptions(instance) {
  return instance.type;
}
function adjustI18nResources(gl, options, componentOptions) {
  let messages = isObject$2(options.messages) ? options.messages : {};
  if ("__i18nGlobal" in componentOptions) {
    messages = getLocaleMessages(gl.locale.value, {
      messages,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages);
  if (locales.length) {
    locales.forEach((locale) => {
      gl.mergeLocaleMessage(locale, messages[locale]);
    });
  }
  {
    if (isObject$2(options.datetimeFormats)) {
      const locales2 = Object.keys(options.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
        });
      }
    }
    if (isObject$2(options.numberFormats)) {
      const locales2 = Object.keys(options.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeNumberFormat(locale, options.numberFormats[locale]);
        });
      }
    }
  }
}
function createTextNode(key) {
  return createVNode(Text, null, key, 0);
}
const DEVTOOLS_META = "__INTLIFY_META__";
const NOOP_RETURN_ARRAY = () => [];
const NOOP_RETURN_FALSE = () => false;
let composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale, key, type) => {
    return missing(locale, key, getCurrentInstance() || void 0, type);
  };
}
const getMetaInfo = /* @__NO_SIDE_EFFECTS__ */ () => {
  const instance = getCurrentInstance();
  let meta = null;
  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options = {}, VueI18nLegacy) {
  const { __root, __injectWithOption } = options;
  const _isGlobal = __root === void 0;
  const flatJson = options.flatJson;
  const _ref = inBrowser ? ref : shallowRef;
  const translateExistCompatible = !!options.translateExistCompatible;
  let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
  const _locale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.locale.value : isString$2(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.fallbackLocale.value : isString$2(options.fallbackLocale) || isArray$1(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = _ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = _ref(isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = _ref(isPlainObject$1(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  let _fallbackFormat = !!options.fallbackFormat;
  let _missing = isFunction(options.missing) ? options.missing : null;
  let _runtimeMissing = isFunction(options.missing) ? defineCoreMissingHandler(options.missing) : null;
  let _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  let _escapeParameter = !!options.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject$1(options.modifiers) ? options.modifiers : {};
  let _pluralRules = options.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options.messageResolver,
      messageCompiler: options.messageCompiler,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject$1(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject$1(_context) ? _context.__numberFormatters : void 0;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => _locale.value,
    set: (val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  });
  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages = computed(() => _messages.value);
  const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
  const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }
    _missing = handler;
    _context.missing = _runtimeMissing;
  }
  const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    try {
      if (__INTLIFY_PROD_DEVTOOLS__) {
        /* @__PURE__ */ setAdditionalMeta(/* @__PURE__ */ getMetaInfo());
      }
      if (!_isGlobal) {
        _context.fallbackContext = __root ? getFallbackContext() : void 0;
      }
      ret = fn(_context);
    } finally {
      if (__INTLIFY_PROD_DEVTOOLS__)
        ;
      if (!_isGlobal) {
        _context.fallbackContext = void 0;
      }
    }
    if (warnType !== "translate exists" && // for not `te` (e.g `t`)
    isNumber$1(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
      const [key, arg2] = argumentParser();
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  };
  function t2(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root) => Reflect.apply(root.t, root, [...args]), (key) => key, (val) => isString$2(val));
  }
  function rt(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject$2(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t2(...[arg1, arg2, assign$1({ resolvedMessage: true }, arg3 || {})]);
  }
  function d(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root) => Reflect.apply(root.d, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$2(val));
  }
  function n2(...args) {
    return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root) => Reflect.apply(root.n, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$2(val));
  }
  function normalize2(values2) {
    return values2.map((val) => isString$2(val) || isNumber$1(val) || isBoolean(val) ? createTextNode(String(val)) : val);
  }
  const interpolate = (val) => val;
  const processor = {
    normalize: normalize2,
    interpolate,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps(
      (context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      },
      () => parseTranslateArgs(...args),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[TranslateVNodeSymbol](...args),
      (key) => [createTextNode(key)],
      (val) => isArray$1(val)
    );
  }
  function numberParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(number, null, [context, ...args]),
      () => parseNumberArgs(...args),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[NumberPartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$2(val) || isArray$1(val)
    );
  }
  function datetimeParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(datetime, null, [context, ...args]),
      () => parseDateTimeArgs(...args),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[DatetimePartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$2(val) || isArray$1(val)
    );
  }
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  function te(key, locale2) {
    return wrapWithDeps(() => {
      if (!key) {
        return false;
      }
      const targetLocale = isString$2(locale2) ? locale2 : _locale.value;
      const message = getLocaleMessage(targetLocale);
      const resolved = _context.messageResolver(message, key);
      return !translateExistCompatible ? isMessageAST(resolved) || isMessageFunction(resolved) || isString$2(resolved) : resolved != null;
    }, () => [key], "translate exists", (root) => {
      return Reflect.apply(root.te, root, [key, locale2]);
    }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
  }
  function resolveMessages(key) {
    let messages2 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i2 = 0; i2 < locales.length; i2++) {
      const targetLocaleMessages = _messages.value[locales[i2]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages2 = messageValue;
        break;
      }
    }
    return messages2;
  }
  function tm(key) {
    const messages2 = resolveMessages(key);
    return messages2 != null ? messages2 : __root ? __root.tm(key) || {} : {};
  }
  function getLocaleMessage(locale2) {
    return _messages.value[locale2] || {};
  }
  function setLocaleMessage(locale2, message) {
    if (flatJson) {
      const _message = { [locale2]: message };
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message = _message[locale2];
    }
    _messages.value[locale2] = message;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale2, message) {
    _messages.value[locale2] = _messages.value[locale2] || {};
    const _message = { [locale2]: message };
    if (flatJson) {
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
    }
    message = _message[locale2];
    deepCopy(message, _messages.value[locale2]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale2) {
    return _datetimeFormats.value[locale2] || {};
  }
  function setDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = format2;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function mergeDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = assign$1(_datetimeFormats.value[locale2] || {}, format2);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function getNumberFormat(locale2) {
    return _numberFormats.value[locale2] || {};
  }
  function setNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = format2;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  function mergeNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = assign$1(_numberFormats.value[locale2] || {}, format2);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  composerID++;
  if (__root && inBrowser) {
    watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t: t2,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te;
    composer.tm = tm;
    composer.d = d;
    composer.n = n2;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOptionSymbol] = __injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  return composer;
}
function convertComposerOptions(options) {
  const locale = isString$2(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = isString$2(options.fallbackLocale) || isArray$1(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const missing = isFunction(options.missing) ? options.missing : void 0;
  const missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
  const fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
  const fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const fallbackFormat = !!options.formatFallbackMessages;
  const modifiers = isPlainObject$1(options.modifiers) ? options.modifiers : {};
  const pluralizationRules = options.pluralizationRules;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : void 0;
  const warnHtmlMessage = isString$2(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
  const escapeParameter = !!options.escapeParameterHtml;
  const inheritLocale = isBoolean(options.sync) ? options.sync : true;
  let messages = options.messages;
  if (isPlainObject$1(options.sharedMessages)) {
    const sharedMessages = options.sharedMessages;
    const locales = Object.keys(sharedMessages);
    messages = locales.reduce((messages2, locale2) => {
      const message = messages2[locale2] || (messages2[locale2] = {});
      assign$1(message, sharedMessages[locale2]);
      return messages2;
    }, messages || {});
  }
  const { __i18n, __root, __injectWithOption } = options;
  const datetimeFormats = options.datetimeFormats;
  const numberFormats = options.numberFormats;
  const flatJson = options.flatJson;
  const translateExistCompatible = options.translateExistCompatible;
  return {
    locale,
    fallbackLocale,
    messages,
    flatJson,
    datetimeFormats,
    numberFormats,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackRoot,
    fallbackFormat,
    modifiers,
    pluralRules: pluralizationRules,
    postTranslation,
    warnHtmlMessage,
    escapeParameter,
    messageResolver: options.messageResolver,
    inheritLocale,
    translateExistCompatible,
    __i18n,
    __root,
    __injectWithOption
  };
}
function createVueI18n(options = {}, VueI18nLegacy) {
  {
    const composer = createComposer(convertComposerOptions(options));
    const { __extender } = options;
    const vueI18n = {
      // id
      id: composer.id,
      // locale
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      // messages
      get messages() {
        return composer.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },
      // formatter
      get formatter() {
        return {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(val) {
      },
      // missing
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler) {
        composer.setMissingHandler(handler);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean(val) ? !val : val;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean(val) ? !val : val;
      },
      // modifiers
      get modifiers() {
        return composer.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler) {
        composer.setPostTranslationHandler(handler);
      },
      // sync
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      // preserveDirectiveContent
      get preserveDirectiveContent() {
        return true;
      },
      set preserveDirectiveContent(val) {
      },
      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      // for internal
      __composer: composer,
      // t
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = {};
        let list = null;
        let named = null;
        if (!isString$2(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$2(arg2)) {
          options2.locale = arg2;
        } else if (isArray$1(arg2)) {
          list = arg2;
        } else if (isPlainObject$1(arg2)) {
          named = arg2;
        }
        if (isArray$1(arg3)) {
          list = arg3;
        } else if (isPlainObject$1(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },
      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = { plural: 1 };
        let list = null;
        let named = null;
        if (!isString$2(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$2(arg2)) {
          options2.locale = arg2;
        } else if (isNumber$1(arg2)) {
          options2.plural = arg2;
        } else if (isArray$1(arg2)) {
          list = arg2;
        } else if (isPlainObject$1(arg2)) {
          named = arg2;
        }
        if (isString$2(arg3)) {
          options2.locale = arg3;
        } else if (isArray$1(arg3)) {
          list = arg3;
        } else if (isPlainObject$1(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      // te
      te(key, locale) {
        return composer.te(key, locale);
      },
      // tm
      tm(key) {
        return composer.tm(key);
      },
      // getLocaleMessage
      getLocaleMessage(locale) {
        return composer.getLocaleMessage(locale);
      },
      // setLocaleMessage
      setLocaleMessage(locale, message) {
        composer.setLocaleMessage(locale, message);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(locale, message) {
        composer.mergeLocaleMessage(locale, message);
      },
      // d
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },
      // getDateTimeFormat
      getDateTimeFormat(locale) {
        return composer.getDateTimeFormat(locale);
      },
      // setDateTimeFormat
      setDateTimeFormat(locale, format2) {
        composer.setDateTimeFormat(locale, format2);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(locale, format2) {
        composer.mergeDateTimeFormat(locale, format2);
      },
      // n
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },
      // getNumberFormat
      getNumberFormat(locale) {
        return composer.getNumberFormat(locale);
      },
      // setNumberFormat
      setNumberFormat(locale, format2) {
        composer.setNumberFormat(locale, format2);
      },
      // mergeNumberFormat
      mergeNumberFormat(locale, format2) {
        composer.mergeNumberFormat(locale, format2);
      },
      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(choice, choicesLength) {
        return -1;
      }
    };
    vueI18n.__extender = __extender;
    return vueI18n;
  }
}
const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys) {
  if (keys.length === 1 && keys[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        // prettier-ignore
        ...current.type === Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, {});
  }
}
function getFragmentableTag(tag2) {
  return Fragment;
}
const TranslationImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-t",
  props: assign$1({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: (val) => isNumber$1(val) || !isNaN(val)
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const { slots, attrs } = context;
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys = Object.keys(slots).filter((key) => key !== "_");
      const options = {};
      if (props.locale) {
        options.locale = props.locale;
      }
      if (props.plural !== void 0) {
        options.plural = isString$2(props.plural) ? +props.plural : props.plural;
      }
      const arg = getInterpolateArg(context, keys);
      const children = i18n2[TranslateVNodeSymbol](props.keypath, arg, options);
      const assignedAttrs = assign$1({}, attrs);
      const tag2 = isString$2(props.tag) || isObject$2(props.tag) ? props.tag : getFragmentableTag();
      return h$1(tag2, assignedAttrs, children);
    };
  }
});
const Translation = TranslationImpl;
function isVNode(target) {
  return isArray$1(target) && !isString$2(target[0]);
}
function renderFormatter(props, context, slotKeys, partFormatter) {
  const { slots, attrs } = context;
  return () => {
    const options = { part: true };
    let overrides = {};
    if (props.locale) {
      options.locale = props.locale;
    }
    if (isString$2(props.format)) {
      options.key = props.format;
    } else if (isObject$2(props.format)) {
      if (isString$2(props.format.key)) {
        options.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options2, prop) => {
        return slotKeys.includes(prop) ? assign$1({}, options2, { [prop]: props.format[prop] }) : options2;
      }, {});
    }
    const parts = partFormatter(...[props.value, options, overrides]);
    let children = [options.key];
    if (isArray$1(parts)) {
      children = parts.map((part, index) => {
        const slot = slots[part.type];
        const node = slot ? slot({ [part.type]: part.value, index, parts }) : [part.value];
        if (isVNode(node)) {
          node[0].key = `${part.type}-${index}`;
        }
        return node;
      });
    } else if (isString$2(parts)) {
      children = [parts];
    }
    const assignedAttrs = assign$1({}, attrs);
    const tag2 = isString$2(props.tag) || isObject$2(props.tag) ? props.tag : getFragmentableTag();
    return h$1(tag2, assignedAttrs, children);
  };
}
const NumberFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-n",
  props: assign$1({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[NumberPartsSymbol](...args)
    ));
  }
});
const NumberFormat = NumberFormatImpl;
const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-d",
  props: assign$1({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[DatetimePartsSymbol](...args)
    ));
  }
});
const DatetimeFormat = DatetimeFormatImpl;
function getComposer$2(i18n2, instance) {
  const i18nInternal = i18n2;
  if (i18n2.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n2.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
  }
}
function vTDirective(i18n2) {
  const _process = (binding) => {
    const { instance, modifiers, value } = binding;
    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n2, instance.$);
    const parsedValue = parseValue(value);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  };
  const register = (el, binding) => {
    const [textContent, composer] = _process(binding);
    if (inBrowser && i18n2.global === composer) {
      el.__i18nWatcher = watch(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }
    el.__composer = composer;
    el.textContent = textContent;
  };
  const unregister = (el) => {
    if (inBrowser && el.__i18nWatcher) {
      el.__i18nWatcher();
      el.__i18nWatcher = void 0;
      delete el.__i18nWatcher;
    }
    if (el.__composer) {
      el.__composer = void 0;
      delete el.__composer;
    }
  };
  const update = (el, { value }) => {
    if (el.__composer) {
      const composer = el.__composer;
      const parsedValue = parseValue(value);
      el.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  };
  const getSSRProps = (binding) => {
    const [textContent] = _process(binding);
    return { textContent };
  };
  return {
    created: register,
    unmounted: unregister,
    beforeUpdate: update,
    getSSRProps
  };
}
function parseValue(value) {
  if (isString$2(value)) {
    return { path: value };
  } else if (isPlainObject$1(value)) {
    if (!("path" in value)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
function makeParams(value) {
  const { path, locale, args, choice, plural } = value;
  const options = {};
  const named = args || {};
  if (isString$2(locale)) {
    options.locale = locale;
  }
  if (isNumber$1(choice)) {
    options.plural = choice;
  }
  if (isNumber$1(plural)) {
    options.plural = plural;
  }
  return [path, named, options];
}
function apply(app, i18n2, ...options) {
  const pluginOptions = isPlainObject$1(options[0]) ? options[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (globalInstall) {
    [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app.component(name, Translation));
    [NumberFormat.name, "I18nN"].forEach((name) => app.component(name, NumberFormat));
    [DatetimeFormat.name, "I18nD"].forEach((name) => app.component(name, DatetimeFormat));
  }
  {
    app.directive("t", vTDirective(i18n2));
  }
}
function defineMixin(vuei18n, composer, i18n2) {
  return {
    beforeCreate() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const options = this.$options;
      if (options.i18n) {
        const optionsI18n = options.i18n;
        if (options.__i18n) {
          optionsI18n.__i18n = options.__i18n;
        }
        optionsI18n.__root = composer;
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
        } else {
          optionsI18n.__injectWithOption = true;
          optionsI18n.__extender = i18n2.__vueI18nExtend;
          this.$i18n = createVueI18n(optionsI18n);
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else if (options.__i18n) {
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, options);
        } else {
          this.$i18n = createVueI18n({
            __i18n: options.__i18n,
            __injectWithOption: true,
            __extender: i18n2.__vueI18nExtend,
            __root: composer
          });
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else {
        this.$i18n = vuei18n;
      }
      if (options.__i18nGlobal) {
        adjustI18nResources(composer, options, options);
      }
      this.$t = (...args) => this.$i18n.t(...args);
      this.$rt = (...args) => this.$i18n.rt(...args);
      this.$tc = (...args) => this.$i18n.tc(...args);
      this.$te = (key, locale) => this.$i18n.te(key, locale);
      this.$d = (...args) => this.$i18n.d(...args);
      this.$n = (...args) => this.$i18n.n(...args);
      this.$tm = (key) => this.$i18n.tm(key);
      i18n2.__setInstance(instance, this.$i18n);
    },
    mounted() {
    },
    unmounted() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const _vueI18n = this.$i18n;
      delete this.$t;
      delete this.$rt;
      delete this.$tc;
      delete this.$te;
      delete this.$d;
      delete this.$n;
      delete this.$tm;
      if (_vueI18n.__disposer) {
        _vueI18n.__disposer();
        delete _vueI18n.__disposer;
        delete _vueI18n.__extender;
      }
      i18n2.__deleteInstance(instance);
      delete this.$i18n;
    }
  };
}
function mergeToGlobal(g2, options) {
  g2.locale = options.locale || g2.locale;
  g2.fallbackLocale = options.fallbackLocale || g2.fallbackLocale;
  g2.missing = options.missing || g2.missing;
  g2.silentTranslationWarn = options.silentTranslationWarn || g2.silentFallbackWarn;
  g2.silentFallbackWarn = options.silentFallbackWarn || g2.silentFallbackWarn;
  g2.formatFallbackMessages = options.formatFallbackMessages || g2.formatFallbackMessages;
  g2.postTranslation = options.postTranslation || g2.postTranslation;
  g2.warnHtmlInMessage = options.warnHtmlInMessage || g2.warnHtmlInMessage;
  g2.escapeParameterHtml = options.escapeParameterHtml || g2.escapeParameterHtml;
  g2.sync = options.sync || g2.sync;
  g2.__composer[SetPluralRulesSymbol](options.pluralizationRules || g2.pluralizationRules);
  const messages = getLocaleMessages(g2.locale, {
    messages: options.messages,
    __i18n: options.__i18n
  });
  Object.keys(messages).forEach((locale) => g2.mergeLocaleMessage(locale, messages[locale]));
  if (options.datetimeFormats) {
    Object.keys(options.datetimeFormats).forEach((locale) => g2.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
  }
  if (options.numberFormats) {
    Object.keys(options.numberFormats).forEach((locale) => g2.mergeNumberFormat(locale, options.numberFormats[locale]));
  }
  return g2;
}
const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n(options = {}, VueI18nLegacy) {
  const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__;
  const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
  const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options.allowComposition : true;
  const __instances = /* @__PURE__ */ new Map();
  const [globalScope, __global] = createGlobal(options, __legacyMode);
  const symbol = /* @__PURE__ */ makeSymbol("");
  function __getInstance(component) {
    return __instances.get(component) || null;
  }
  function __setInstance(component, instance) {
    __instances.set(component, instance);
  }
  function __deleteInstance(component) {
    __instances.delete(component);
  }
  {
    const i18n2 = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
      },
      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },
      // install plugin
      async install(app, ...options2) {
        app.__VUE_I18N_SYMBOL__ = symbol;
        app.provide(app.__VUE_I18N_SYMBOL__, i18n2);
        if (isPlainObject$1(options2[0])) {
          const opts = options2[0];
          i18n2.__composerExtend = opts.__composerExtend;
          i18n2.__vueI18nExtend = opts.__vueI18nExtend;
        }
        let globalReleaseHandler = null;
        if (!__legacyMode && __globalInjection) {
          globalReleaseHandler = injectGlobalFields(app, i18n2.global);
        }
        if (__VUE_I18N_FULL_INSTALL__) {
          apply(app, i18n2, ...options2);
        }
        if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
          app.mixin(defineMixin(__global, __global.__composer, i18n2));
        }
        const unmountApp = app.unmount;
        app.unmount = () => {
          globalReleaseHandler && globalReleaseHandler();
          i18n2.dispose();
          unmountApp();
        };
      },
      // global accessor
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n2;
  }
}
function useI18n(options = {}) {
  const instance = getCurrentInstance();
  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
  }
  const i18n2 = getI18nInstance(instance);
  const gl = getGlobalComposer(i18n2);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options, componentOptions);
  if (__VUE_I18N_LEGACY_API__) {
    if (i18n2.mode === "legacy" && !options.__useComponent) {
      if (!i18n2.allowComposition) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
      }
      return useI18nForLegacy(instance, scope, gl, options);
    }
  }
  if (scope === "global") {
    adjustI18nResources(gl, options, componentOptions);
    return gl;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n2, instance, options.__useComponent);
    if (composer2 == null) {
      composer2 = gl;
    }
    return composer2;
  }
  const i18nInternal = i18n2;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const composerOptions = assign$1({}, options);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (gl) {
      composerOptions.__root = gl;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
    }
    setupLifeCycle(i18nInternal, instance, composer);
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
function createGlobal(options, legacyMode, VueI18nLegacy) {
  const scope = effectScope();
  {
    const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
}
function getI18nInstance(instance) {
  {
    const i18n2 = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n2) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
    }
    return i18n2;
  }
}
function getScope(options, componentOptions) {
  return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
}
function getGlobalComposer(i18n2) {
  return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
}
function getComposer(i18n2, target, useComponent = false) {
  let composer = null;
  const root = target.root;
  let current = getParentComponentInstance(target, useComponent);
  while (current != null) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    } else {
      if (__VUE_I18N_LEGACY_API__) {
        const vueI18n = i18nInternal.__getInstance(current);
        if (vueI18n != null) {
          composer = vueI18n.__composer;
          if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
            composer = null;
          }
        }
      }
    }
    if (composer != null) {
      break;
    }
    if (root === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
function getParentComponentInstance(target, useComponent = false) {
  if (target == null) {
    return null;
  }
  {
    return !useComponent ? target.parent : target.vnode.ctx || target.parent;
  }
}
function setupLifeCycle(i18n2, target, composer) {
  {
    onMounted(() => {
    }, target);
    onUnmounted(() => {
      const _composer = composer;
      i18n2.__deleteInstance(target);
      const dispose = _composer[DisposeSymbol];
      if (dispose) {
        dispose();
        delete _composer[DisposeSymbol];
      }
    }, target);
  }
}
function useI18nForLegacy(instance, scope, root, options = {}) {
  const isLocalScope = scope === "local";
  const _composer = shallowRef(null);
  if (isLocalScope && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
    throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  }
  const _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : !isString$2(options.locale);
  const _locale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root.locale.value : isString$2(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root.fallbackLocale.value : isString$2(options.fallbackLocale) || isArray$1(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = ref(isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = ref(isPlainObject$1(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  const _missingWarn = isLocalScope ? root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const _fallbackWarn = isLocalScope ? root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const _fallbackRoot = isLocalScope ? root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const _fallbackFormat = !!options.fallbackFormat;
  const _missing = isFunction(options.missing) ? options.missing : null;
  const _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const _warnHtmlMessage = isLocalScope ? root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const _escapeParameter = !!options.escapeParameter;
  const _modifiers = isLocalScope ? root.modifiers : isPlainObject$1(options.modifiers) ? options.modifiers : {};
  const _pluralRules = options.pluralRules || isLocalScope && root.pluralRules;
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => {
      return _composer.value ? _composer.value.locale.value : _locale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.locale.value = val;
      }
      _locale.value = val;
    }
  });
  const fallbackLocale = computed({
    get: () => {
      return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.fallbackLocale.value = val;
      }
      _fallbackLocale.value = val;
    }
  });
  const messages = computed(() => {
    if (_composer.value) {
      return _composer.value.messages.value;
    } else {
      return _messages.value;
    }
  });
  const datetimeFormats = computed(() => _datetimeFormats.value);
  const numberFormats = computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
  }
  function setPostTranslationHandler(handler) {
    if (_composer.value) {
      _composer.value.setPostTranslationHandler(handler);
    }
  }
  function getMissingHandler() {
    return _composer.value ? _composer.value.getMissingHandler() : _missing;
  }
  function setMissingHandler(handler) {
    if (_composer.value) {
      _composer.value.setMissingHandler(handler);
    }
  }
  function warpWithDeps(fn) {
    trackReactivityValues();
    return fn();
  }
  function t2(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
  }
  function rt(...args) {
    return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
  }
  function d(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
  }
  function n2(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
  }
  function tm(key) {
    return _composer.value ? _composer.value.tm(key) : {};
  }
  function te(key, locale2) {
    return _composer.value ? _composer.value.te(key, locale2) : false;
  }
  function getLocaleMessage(locale2) {
    return _composer.value ? _composer.value.getLocaleMessage(locale2) : {};
  }
  function setLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.setLocaleMessage(locale2, message);
      _messages.value[locale2] = message;
    }
  }
  function mergeLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.mergeLocaleMessage(locale2, message);
    }
  }
  function getDateTimeFormat(locale2) {
    return _composer.value ? _composer.value.getDateTimeFormat(locale2) : {};
  }
  function setDateTimeFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.setDateTimeFormat(locale2, format2);
      _datetimeFormats.value[locale2] = format2;
    }
  }
  function mergeDateTimeFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.mergeDateTimeFormat(locale2, format2);
    }
  }
  function getNumberFormat(locale2) {
    return _composer.value ? _composer.value.getNumberFormat(locale2) : {};
  }
  function setNumberFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.setNumberFormat(locale2, format2);
      _numberFormats.value[locale2] = format2;
    }
  }
  function mergeNumberFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.mergeNumberFormat(locale2, format2);
    }
  }
  const wrapper = {
    get id() {
      return _composer.value ? _composer.value.id : -1;
    },
    locale,
    fallbackLocale,
    messages,
    datetimeFormats,
    numberFormats,
    get inheritLocale() {
      return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
    },
    set inheritLocale(val) {
      if (_composer.value) {
        _composer.value.inheritLocale = val;
      }
    },
    get availableLocales() {
      return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
    },
    get modifiers() {
      return _composer.value ? _composer.value.modifiers : _modifiers;
    },
    get pluralRules() {
      return _composer.value ? _composer.value.pluralRules : _pluralRules;
    },
    get isGlobal() {
      return _composer.value ? _composer.value.isGlobal : false;
    },
    get missingWarn() {
      return _composer.value ? _composer.value.missingWarn : _missingWarn;
    },
    set missingWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackWarn() {
      return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
    },
    set fallbackWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackRoot() {
      return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
    },
    set fallbackRoot(val) {
      if (_composer.value) {
        _composer.value.fallbackRoot = val;
      }
    },
    get fallbackFormat() {
      return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
    },
    set fallbackFormat(val) {
      if (_composer.value) {
        _composer.value.fallbackFormat = val;
      }
    },
    get warnHtmlMessage() {
      return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      if (_composer.value) {
        _composer.value.warnHtmlMessage = val;
      }
    },
    get escapeParameter() {
      return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
    },
    set escapeParameter(val) {
      if (_composer.value) {
        _composer.value.escapeParameter = val;
      }
    },
    t: t2,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    rt,
    d,
    n: n2,
    tm,
    te,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getDateTimeFormat,
    setDateTimeFormat,
    mergeDateTimeFormat,
    getNumberFormat,
    setNumberFormat,
    mergeNumberFormat
  };
  function sync(composer) {
    composer.locale.value = _locale.value;
    composer.fallbackLocale.value = _fallbackLocale.value;
    Object.keys(_messages.value).forEach((locale2) => {
      composer.mergeLocaleMessage(locale2, _messages.value[locale2]);
    });
    Object.keys(_datetimeFormats.value).forEach((locale2) => {
      composer.mergeDateTimeFormat(locale2, _datetimeFormats.value[locale2]);
    });
    Object.keys(_numberFormats.value).forEach((locale2) => {
      composer.mergeNumberFormat(locale2, _numberFormats.value[locale2]);
    });
    composer.escapeParameter = _escapeParameter;
    composer.fallbackFormat = _fallbackFormat;
    composer.fallbackRoot = _fallbackRoot;
    composer.fallbackWarn = _fallbackWarn;
    composer.missingWarn = _missingWarn;
    composer.warnHtmlMessage = _warnHtmlMessage;
  }
  onBeforeMount(() => {
    if (instance.proxy == null || instance.proxy.$i18n == null) {
      throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    }
    const composer = _composer.value = instance.proxy.$i18n.__composer;
    if (scope === "global") {
      _locale.value = composer.locale.value;
      _fallbackLocale.value = composer.fallbackLocale.value;
      _messages.value = composer.messages.value;
      _datetimeFormats.value = composer.datetimeFormats.value;
      _numberFormats.value = composer.numberFormats.value;
    } else if (isLocalScope) {
      sync(composer);
    }
  });
  return wrapper;
}
const globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app, composer) {
  const i18n2 = /* @__PURE__ */ Object.create(null);
  globalExportProps.forEach((prop) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap2 = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n2, prop, wrap2);
  });
  app.config.globalProperties.$i18n = i18n2;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app.config.globalProperties, `$${method}`, desc);
  });
  const dispose = () => {
    delete app.config.globalProperties.$i18n;
    globalExportMethods.forEach((method) => {
      delete app.config.globalProperties[`$${method}`];
    });
  };
  return dispose;
}
{
  initFeatureFlags();
}
if (__INTLIFY_JIT_COMPILATION__) {
  registerMessageCompiler(compile);
} else {
  registerMessageCompiler(compileToFunction);
}
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const target = getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
const i18n = createI18n({
  legacy: false,
  // falseComposition API
  locale: "en",
  // 
  fallbackLocale: "en",
  // 
  messages: { en: en$1 }
});
async function loadLocaleMessages(locale) {
  if (i18n.global.locale.value === locale)
    return;
  const messages = await __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "../../assets/locales/ar.json": () => __vitePreload(() => import("./ar-CQULmISv.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/de.json": () => __vitePreload(() => import("./de-C-i-jZ6O.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/en.json": () => __vitePreload(() => Promise.resolve().then(() => __vite_glob_0_2), true ? void 0 : void 0, import.meta.url), "../../assets/locales/es.json": () => __vitePreload(() => import("./es-BnkUSzxd.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/fa.json": () => __vitePreload(() => import("./fa-C4MjqZCw.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/fr.json": () => __vitePreload(() => import("./fr-C__0dHRz.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/id.json": () => __vitePreload(() => import("./id-KsaHJadg.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/it.json": () => __vitePreload(() => import("./it-Cr1SKdDb.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/ja.json": () => __vitePreload(() => import("./ja-Cl5zFsxZ.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/ko.json": () => __vitePreload(() => import("./ko-BkI0EjiB.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/ms.json": () => __vitePreload(() => import("./ms-BHBiWnQq.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/nl.json": () => __vitePreload(() => import("./nl-Znqr-W_O.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/no.json": () => __vitePreload(() => import("./no-DUzoZO1M.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/pl.json": () => __vitePreload(() => import("./pl-DZna2_8X.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/pt.json": () => __vitePreload(() => import("./pt-DO_reLdy.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/ru.json": () => __vitePreload(() => import("./ru-CxX48An7.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/sv.json": () => __vitePreload(() => import("./sv-BvbUQzmw.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/tr.json": () => __vitePreload(() => import("./tr-DsmUI4N7.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/uk.json": () => __vitePreload(() => import("./uk-BrhFXhah.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/vi.json": () => __vitePreload(() => import("./vi-CUBrcp4M.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/zh_hans.json": () => __vitePreload(() => import("./zh_hans-D0L8zsPi.js"), true ? [] : void 0, import.meta.url), "../../assets/locales/zh_hant.json": () => __vitePreload(() => import("./zh_hant-DPKK5zHw.js"), true ? [] : void 0, import.meta.url) }), `../../assets/locales/${locale}.json`, 5);
  i18n.global.setLocaleMessage(locale, messages.default);
  return nextTick();
}
const setI18nLanguage = async (id2) => {
  const html = document.querySelector("html");
  await loadLocaleMessages(id2);
  i18n.global.locale.value = id2;
  if (html) {
    html.setAttribute("lang", id2);
    const dr = ["ar", "fa"].includes(id2) ? "rtl" : "ltr";
    html.setAttribute("dir", dr);
  }
};
const languageMap = {
  en: "English",
  ar: "",
  de: "Deutsch",
  es: "Espaol",
  fa: "",
  fr: "Franais",
  id: "Bahasa Indonesia",
  it: "Italiano",
  ja: "",
  ko: "",
  ms: "Bahasa Melayu",
  nl: "Nederlands",
  no: "Norsk",
  pl: "Polski",
  pt: "Portugus",
  ru: "",
  sv: "Svenska",
  tr: "Trke",
  uk: "",
  vi: "Ting Vit",
  zh_hans: "",
  zh_hant: ""
};
const langs = Object.keys(languageMap).map((key) => ({
  id: key,
  value: languageMap[key]
}));
function t$2(key) {
  return i18n.global.t(key);
}
const readModeList = computed(() => {
  return [
    { id: ReadMode.sroll, value: t$2("readMode.scroll") },
    { id: ReadMode.section, value: t$2("readMode.section") },
    { id: ReadMode.double, value: t$2("readMode.double") }
  ];
});
const getSelectReadMode = (readMode2) => {
  return readModeList.value.find((item) => item.id === readMode2)?.value;
};
const bookshelfModeList = computed(() => {
  return [
    { id: BookshelftMode.bookshelf, value: t$2("bookMode.bookshelf") },
    { id: BookshelftMode.card, value: t$2("bookMode.card") },
    { id: BookshelftMode.list, value: t$2("bookMode.list") }
  ];
});
const data = [
  "light",
  "dark",
  "cupcake",
  "bumblebee",
  "emerald",
  "corporate",
  "synthwave",
  "retro",
  "cyberpunk",
  "valentine",
  "halloween",
  "garden",
  "forest",
  "aqua",
  "lofi",
  "pastel",
  "fantasy",
  "wireframe",
  "black",
  "luxury",
  "dracula",
  "cmyk",
  "autumn",
  "business",
  "acid",
  "lemonade",
  "night",
  "coffee",
  "winter",
  "dim",
  "nord",
  "sunset"
];
const themes = data.map((item) => ({ id: item, value: item }));
const _hoisted_1$E = { class: "absoulte inset-0 h-full overflow-auto scrollbar-thin" };
const _hoisted_2$y = { class: "p-6 grid grid-cols-4 sm:grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 max-w-screen-2xl" };
const _hoisted_3$s = { class: "col-span-full" };
const _hoisted_4$o = { class: "font-bold text-2xl" };
const _hoisted_5$l = { class: "col-span-full lg:col-auto flex flex-col gap-6" };
const _hoisted_6$k = { class: "card w-full bg-base-100 shadow" };
const _hoisted_7$g = { class: "card-body" };
const _hoisted_8$f = { class: "card-title" };
const _hoisted_9$e = { class: "form-control w-full max-w-xs" };
const _hoisted_10$d = { class: "label" };
const _hoisted_11$d = { class: "card w-full bg-base-100 shadow" };
const _hoisted_12$c = { class: "card-body" };
const _hoisted_13$9 = { class: "card-title" };
const _hoisted_14$9 = { class: "col-span-full lg:col-span-2" };
const _hoisted_15$9 = { class: "card bg-base-100 shadow w-full" };
const _hoisted_16$9 = { class: "card-body" };
const _sfc_main$K = /* @__PURE__ */ defineComponent({
  __name: "Setting",
  setup(__props) {
    const textOpacity = { "--tw-text-opacity": 0.6 };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$E, [
        createBaseVNode("div", _hoisted_2$y, [
          createBaseVNode("div", _hoisted_3$s, [
            createBaseVNode("h2", _hoisted_4$o, toDisplayString$1(_ctx.$t("setting.userSetting")), 1)
          ]),
          createBaseVNode("div", _hoisted_5$l, [
            createBaseVNode("div", _hoisted_6$k, [
              createBaseVNode("div", _hoisted_7$g, [
                createBaseVNode("h2", _hoisted_8$f, toDisplayString$1(_ctx.$t("setting.language")) + " & " + toDisplayString$1(_ctx.$t("setting.theme")), 1),
                createVNode(unref(_sfc_main$r), {
                  modelValue: unref(settingStore).lang,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(settingStore).lang = $event),
                  list: unref(langs),
                  label: _ctx.$t("setting.chooseLanguage")
                }, null, 8, ["modelValue", "list", "label"]),
                createBaseVNode("label", _hoisted_9$e, [
                  createBaseVNode("div", _hoisted_10$d, [
                    createBaseVNode("span", {
                      class: "label-text",
                      style: textOpacity
                    }, toDisplayString$1(_ctx.$t("setting.chooseTheme")), 1)
                  ]),
                  createVNode(unref(_sfc_main$s), {
                    modelValue: unref(settingStore).theme,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(settingStore).theme = $event),
                    "is-cloce": false,
                    list: unref(themes)
                  }, null, 8, ["modelValue", "list"])
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_11$d, [
              createBaseVNode("div", _hoisted_12$c, [
                createBaseVNode("h2", _hoisted_13$9, toDisplayString$1(_ctx.$t("setting.mode")), 1),
                createVNode(unref(_sfc_main$r), {
                  modelValue: unref(settingStore).bookself,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(settingStore).bookself = $event),
                  list: unref(bookshelfModeList),
                  label: _ctx.$t("setting.bookMode")
                }, null, 8, ["modelValue", "list", "label"]),
                createVNode(unref(_sfc_main$r), {
                  modelValue: unref(settingStore).readMode,
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(settingStore).readMode = $event),
                  list: unref(readModeList),
                  label: _ctx.$t("setting.readMode")
                }, null, 8, ["modelValue", "list", "label"])
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_14$9, [
            createBaseVNode("div", _hoisted_15$9, [
              createBaseVNode("div", _hoisted_16$9, [
                createVNode(unref(_sfc_main$C), {
                  modelValue: unref(settingStore).isOpenNew,
                  "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(settingStore).isOpenNew = $event),
                  title: _ctx.$t("setting.openNewTitle"),
                  desc: _ctx.$t("setting.openNewDesc")
                }, null, 8, ["modelValue", "title", "desc"]),
                createVNode(unref(_sfc_main$C), {
                  modelValue: unref(settingStore).isOpenRecycleBin,
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => unref(settingStore).isOpenRecycleBin = $event),
                  title: _ctx.$t("setting.openRecycleBinTitle"),
                  desc: _ctx.$t("setting.openRecycleBinDesc")
                }, null, 8, ["modelValue", "title", "desc"]),
                createVNode(unref(_sfc_main$C), {
                  modelValue: unref(settingStore).isNoteShowClass,
                  "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(settingStore).isNoteShowClass = $event),
                  title: _ctx.$t("setting.noteShowClassTitle"),
                  desc: _ctx.$t("setting.noteShowClassDesc")
                }, null, 8, ["modelValue", "title", "desc"]),
                createVNode(unref(_sfc_main$C), {
                  modelValue: unref(settingStore).isAutoHighlight,
                  "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => unref(settingStore).isAutoHighlight = $event),
                  title: "$t('setting.autoHighlightTitle')",
                  desc: _ctx.$t("setting.autoHighlightDesc")
                }, null, 8, ["modelValue", "desc"]),
                createVNode(unref(_sfc_main$C), {
                  modelValue: unref(settingStore).isRemeberPosition,
                  "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => unref(settingStore).isRemeberPosition = $event),
                  title: _ctx.$t("setting.rememberPositionTitle"),
                  desc: _ctx.$t("setting.rememberPositionDesc")
                }, null, 8, ["modelValue", "title", "desc"])
              ])
            ])
          ])
        ])
      ]);
    };
  }
});
function memo(getDeps, fn, opts) {
  let deps = opts.initialDeps ?? [];
  let result;
  return () => {
    var _a, _b, _c, _d;
    let depTime;
    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts)))
      depTime = Date.now();
    const newDeps = getDeps();
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts)))
      resultTime = Date.now();
    result = fn(...newDeps);
    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {
      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
      const resultFpsPercentage = resultEndTime / 16;
      const pad = (str, num) => {
        str = String(str);
        while (str.length < num) {
          str = " " + str;
        }
        return str;
      };
      console.info(
        `%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(
          0,
          Math.min(120 - 120 * resultFpsPercentage, 120)
        )}deg 100% 31%);`,
        opts == null ? void 0 : opts.key
      );
    }
    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);
    return result;
  };
}
function notUndefined(value, msg) {
  if (value === void 0) {
    throw new Error(`Unexpected undefined${""}`);
  } else {
    return value;
  }
}
const approxEqual = (a2, b2) => Math.abs(a2 - b2) < 1;
const debounce = (fn, ms2) => {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), ms2);
  };
};
const defaultKeyExtractor = (index) => index;
const defaultRangeExtractor = (range) => {
  const start = Math.max(range.startIndex - range.overscan, 0);
  const end = Math.min(range.endIndex + range.overscan, range.count - 1);
  const arr = [];
  for (let i2 = start; i2 <= end; i2++) {
    arr.push(i2);
  }
  return arr;
};
const observeElementRect = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const handler = (rect) => {
    const { width, height } = rect;
    cb({ width: Math.round(width), height: Math.round(height) });
  };
  handler(element.getBoundingClientRect());
  if (typeof ResizeObserver === "undefined") {
    return () => {
    };
  }
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    if (entry == null ? void 0 : entry.borderBoxSize) {
      const box = entry.borderBoxSize[0];
      if (box) {
        handler({ width: box.inlineSize, height: box.blockSize });
        return;
      }
    }
    handler(element.getBoundingClientRect());
  });
  observer.observe(element, { box: "border-box" });
  return () => {
    observer.unobserve(element);
  };
};
const addEventListenerOptions = {
  passive: true
};
const supportsScrollend = typeof window == "undefined" ? true : "onscrollend" in window;
const observeElementOffset = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  let offset = 0;
  const fallback = supportsScrollend ? () => void 0 : debounce(() => {
    cb(offset, false);
  }, instance.options.isScrollingResetDelay);
  const createHandler = (isScrolling) => () => {
    offset = element[instance.options.horizontal ? "scrollLeft" : "scrollTop"];
    fallback();
    cb(offset, isScrolling);
  };
  const handler = createHandler(true);
  const endHandler = createHandler(false);
  endHandler();
  element.addEventListener("scroll", handler, addEventListenerOptions);
  element.addEventListener("scrollend", endHandler, addEventListenerOptions);
  return () => {
    element.removeEventListener("scroll", handler);
    element.removeEventListener("scrollend", endHandler);
  };
};
const measureElement = (element, entry, instance) => {
  if (entry == null ? void 0 : entry.borderBoxSize) {
    const box = entry.borderBoxSize[0];
    if (box) {
      const size2 = Math.round(
        box[instance.options.horizontal ? "inlineSize" : "blockSize"]
      );
      return size2;
    }
  }
  return Math.round(
    element.getBoundingClientRect()[instance.options.horizontal ? "width" : "height"]
  );
};
const elementScroll = (offset, {
  adjustments = 0,
  behavior
}, instance) => {
  var _a, _b;
  const toOffset = offset + adjustments;
  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {
    [instance.options.horizontal ? "left" : "top"]: toOffset,
    behavior
  });
};
class Virtualizer {
  constructor(opts) {
    this.unsubs = [];
    this.scrollElement = null;
    this.isScrolling = false;
    this.scrollToIndexTimeoutId = null;
    this.measurementsCache = [];
    this.itemSizeCache = /* @__PURE__ */ new Map();
    this.pendingMeasuredCacheIndexes = [];
    this.scrollDirection = null;
    this.scrollAdjustments = 0;
    this.measureElementCache = /* @__PURE__ */ new Map();
    this.observer = /* @__PURE__ */ (() => {
      let _ro = null;
      const get2 = () => {
        if (_ro) {
          return _ro;
        } else if (typeof ResizeObserver !== "undefined") {
          return _ro = new ResizeObserver((entries) => {
            entries.forEach((entry) => {
              this._measureElement(entry.target, entry);
            });
          });
        } else {
          return null;
        }
      };
      return {
        disconnect: () => {
          var _a;
          return (_a = get2()) == null ? void 0 : _a.disconnect();
        },
        observe: (target) => {
          var _a;
          return (_a = get2()) == null ? void 0 : _a.observe(target, { box: "border-box" });
        },
        unobserve: (target) => {
          var _a;
          return (_a = get2()) == null ? void 0 : _a.unobserve(target);
        }
      };
    })();
    this.range = null;
    this.setOptions = (opts2) => {
      Object.entries(opts2).forEach(([key, value]) => {
        if (typeof value === "undefined")
          delete opts2[key];
      });
      this.options = {
        debug: false,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: false,
        getItemKey: defaultKeyExtractor,
        rangeExtractor: defaultRangeExtractor,
        onChange: () => {
        },
        measureElement,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        isScrollingResetDelay: 150,
        ...opts2
      };
    };
    this.notify = (force, sync) => {
      var _a, _b;
      const { startIndex, endIndex } = this.range ?? {
        startIndex: void 0,
        endIndex: void 0
      };
      const range = this.calculateRange();
      if (force || startIndex !== (range == null ? void 0 : range.startIndex) || endIndex !== (range == null ? void 0 : range.endIndex)) {
        (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);
      }
    };
    this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((d) => d());
      this.unsubs = [];
      this.scrollElement = null;
    };
    this._didMount = () => {
      this.measureElementCache.forEach(this.observer.observe);
      return () => {
        this.observer.disconnect();
        this.cleanup();
      };
    };
    this._willUpdate = () => {
      const scrollElement = this.options.getScrollElement();
      if (this.scrollElement !== scrollElement) {
        this.cleanup();
        this.scrollElement = scrollElement;
        this._scrollToOffset(this.scrollOffset, {
          adjustments: void 0,
          behavior: void 0
        });
        this.unsubs.push(
          this.options.observeElementRect(this, (rect) => {
            this.scrollRect = rect;
            this.notify(false, false);
          })
        );
        this.unsubs.push(
          this.options.observeElementOffset(this, (offset, isScrolling) => {
            this.scrollAdjustments = 0;
            this.scrollDirection = isScrolling ? this.scrollOffset < offset ? "forward" : "backward" : null;
            this.scrollOffset = offset;
            const prevIsScrolling = this.isScrolling;
            this.isScrolling = isScrolling;
            this.notify(prevIsScrolling !== isScrolling, isScrolling);
          })
        );
      }
    };
    this.getSize = () => {
      return this.scrollRect[this.options.horizontal ? "width" : "height"];
    };
    this.getMeasurementOptions = memo(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey
      ],
      (count, paddingStart, scrollMargin, getItemKey) => {
        this.pendingMeasuredCacheIndexes = [];
        return {
          count,
          paddingStart,
          scrollMargin,
          getItemKey
        };
      },
      {
        key: false
      }
    );
    this.getFurthestMeasurement = (measurements, index) => {
      const furthestMeasurementsFound = /* @__PURE__ */ new Map();
      const furthestMeasurements = /* @__PURE__ */ new Map();
      for (let m2 = index - 1; m2 >= 0; m2--) {
        const measurement = measurements[m2];
        if (furthestMeasurementsFound.has(measurement.lane)) {
          continue;
        }
        const previousFurthestMeasurement = furthestMeasurements.get(
          measurement.lane
        );
        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {
          furthestMeasurements.set(measurement.lane, measurement);
        } else if (measurement.end < previousFurthestMeasurement.end) {
          furthestMeasurementsFound.set(measurement.lane, true);
        }
        if (furthestMeasurementsFound.size === this.options.lanes) {
          break;
        }
      }
      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a2, b2) => {
        if (a2.end === b2.end) {
          return a2.index - b2.index;
        }
        return a2.end - b2.end;
      })[0] : void 0;
    };
    this.getMeasurements = memo(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count, paddingStart, scrollMargin, getItemKey }, itemSizeCache) => {
        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        const measurements = this.measurementsCache.slice(0, min);
        for (let i2 = min; i2 < count; i2++) {
          const key = getItemKey(i2);
          const furthestMeasurement = this.options.lanes === 1 ? measurements[i2 - 1] : this.getFurthestMeasurement(measurements, i2);
          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;
          const measuredSize = itemSizeCache.get(key);
          const size2 = typeof measuredSize === "number" ? measuredSize : this.options.estimateSize(i2);
          const end = start + size2;
          const lane = furthestMeasurement ? furthestMeasurement.lane : i2 % this.options.lanes;
          measurements[i2] = {
            index: i2,
            start,
            size: size2,
            end,
            key,
            lane
          };
        }
        this.measurementsCache = measurements;
        return measurements;
      },
      {
        key: false,
        debug: () => this.options.debug
      }
    );
    this.calculateRange = memo(
      () => [this.getMeasurements(), this.getSize(), this.scrollOffset],
      (measurements, outerSize, scrollOffset) => {
        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({
          measurements,
          outerSize,
          scrollOffset
        }) : null;
      },
      {
        key: false,
        debug: () => this.options.debug
      }
    );
    this.getIndexes = memo(
      () => [
        this.options.rangeExtractor,
        this.calculateRange(),
        this.options.overscan,
        this.options.count
      ],
      (rangeExtractor, range, overscan, count) => {
        return range === null ? [] : rangeExtractor({
          startIndex: range.startIndex,
          endIndex: range.endIndex,
          overscan,
          count
        });
      },
      {
        key: false,
        debug: () => this.options.debug
      }
    );
    this.indexFromElement = (node) => {
      const attributeName = this.options.indexAttribute;
      const indexStr = node.getAttribute(attributeName);
      if (!indexStr) {
        console.warn(
          `Missing attribute name '${attributeName}={index}' on measured element.`
        );
        return -1;
      }
      return parseInt(indexStr, 10);
    };
    this._measureElement = (node, entry) => {
      const item = this.measurementsCache[this.indexFromElement(node)];
      if (!item || !node.isConnected) {
        this.measureElementCache.forEach((cached, key) => {
          if (cached === node) {
            this.observer.unobserve(node);
            this.measureElementCache.delete(key);
          }
        });
        return;
      }
      const prevNode = this.measureElementCache.get(item.key);
      if (prevNode !== node) {
        if (prevNode) {
          this.observer.unobserve(prevNode);
        }
        this.observer.observe(node);
        this.measureElementCache.set(item.key, node);
      }
      const measuredItemSize = this.options.measureElement(node, entry, this);
      this.resizeItem(item, measuredItemSize);
    };
    this.resizeItem = (item, size2) => {
      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;
      const delta = size2 - itemSize;
      if (delta !== 0) {
        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.scrollOffset + this.scrollAdjustments) {
          this._scrollToOffset(this.scrollOffset, {
            adjustments: this.scrollAdjustments += delta,
            behavior: void 0
          });
        }
        this.pendingMeasuredCacheIndexes.push(item.index);
        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size2));
        this.notify(true, false);
      }
    };
    this.measureElement = (node) => {
      if (!node) {
        return;
      }
      this._measureElement(node, void 0);
    };
    this.getVirtualItems = memo(
      () => [this.getIndexes(), this.getMeasurements()],
      (indexes, measurements) => {
        const virtualItems = [];
        for (let k2 = 0, len = indexes.length; k2 < len; k2++) {
          const i2 = indexes[k2];
          const measurement = measurements[i2];
          virtualItems.push(measurement);
        }
        return virtualItems;
      },
      {
        key: false,
        debug: () => this.options.debug
      }
    );
    this.getVirtualItemForOffset = (offset) => {
      const measurements = this.getMeasurements();
      return notUndefined(
        measurements[findNearestBinarySearch(
          0,
          measurements.length - 1,
          (index) => notUndefined(measurements[index]).start,
          offset
        )]
      );
    };
    this.getOffsetForAlignment = (toOffset, align) => {
      const size2 = this.getSize();
      if (align === "auto") {
        if (toOffset <= this.scrollOffset) {
          align = "start";
        } else if (toOffset >= this.scrollOffset + size2) {
          align = "end";
        } else {
          align = "start";
        }
      }
      if (align === "start") {
        toOffset = toOffset;
      } else if (align === "end") {
        toOffset = toOffset - size2;
      } else if (align === "center") {
        toOffset = toOffset - size2 / 2;
      }
      const scrollSizeProp = this.options.horizontal ? "scrollWidth" : "scrollHeight";
      const scrollSize = this.scrollElement ? "document" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;
      const maxOffset = scrollSize - this.getSize();
      return Math.max(Math.min(maxOffset, toOffset), 0);
    };
    this.getOffsetForIndex = (index, align = "auto") => {
      index = Math.max(0, Math.min(index, this.options.count - 1));
      const measurement = notUndefined(this.getMeasurements()[index]);
      if (align === "auto") {
        if (measurement.end >= this.scrollOffset + this.getSize() - this.options.scrollPaddingEnd) {
          align = "end";
        } else if (measurement.start <= this.scrollOffset + this.options.scrollPaddingStart) {
          align = "start";
        } else {
          return [this.scrollOffset, align];
        }
      }
      const toOffset = align === "end" ? measurement.end + this.options.scrollPaddingEnd : measurement.start - this.options.scrollPaddingStart;
      return [this.getOffsetForAlignment(toOffset, align), align];
    };
    this.isDynamicMode = () => this.measureElementCache.size > 0;
    this.cancelScrollToIndex = () => {
      if (this.scrollToIndexTimeoutId !== null) {
        clearTimeout(this.scrollToIndexTimeoutId);
        this.scrollToIndexTimeoutId = null;
      }
    };
    this.scrollToOffset = (toOffset, { align = "start", behavior } = {}) => {
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {
        adjustments: void 0,
        behavior
      });
    };
    this.scrollToIndex = (index, { align: initialAlign = "auto", behavior } = {}) => {
      index = Math.max(0, Math.min(index, this.options.count - 1));
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      const [toOffset, align] = this.getOffsetForIndex(index, initialAlign);
      this._scrollToOffset(toOffset, { adjustments: void 0, behavior });
      if (behavior !== "smooth" && this.isDynamicMode()) {
        this.scrollToIndexTimeoutId = setTimeout(() => {
          this.scrollToIndexTimeoutId = null;
          const elementInDOM = this.measureElementCache.has(
            this.options.getItemKey(index)
          );
          if (elementInDOM) {
            const [toOffset2] = this.getOffsetForIndex(index, align);
            if (!approxEqual(toOffset2, this.scrollOffset)) {
              this.scrollToIndex(index, { align, behavior });
            }
          } else {
            this.scrollToIndex(index, { align, behavior });
          }
        });
      }
    };
    this.scrollBy = (delta, { behavior } = {}) => {
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.scrollOffset + delta, {
        adjustments: void 0,
        behavior
      });
    };
    this.getTotalSize = () => {
      var _a;
      const measurements = this.getMeasurements();
      let end;
      if (measurements.length === 0) {
        end = this.options.paddingStart;
      } else {
        end = this.options.lanes === 1 ? ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0 : Math.max(
          ...measurements.slice(-this.options.lanes).map((m2) => m2.end)
        );
      }
      return end - this.options.scrollMargin + this.options.paddingEnd;
    };
    this._scrollToOffset = (offset, {
      adjustments,
      behavior
    }) => {
      this.options.scrollToFn(offset, { behavior, adjustments }, this);
    };
    this.measure = () => {
      var _a, _b;
      this.itemSizeCache = /* @__PURE__ */ new Map();
      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, false);
    };
    this.setOptions(opts);
    this.scrollRect = this.options.initialRect;
    this.scrollOffset = typeof this.options.initialOffset === "function" ? this.options.initialOffset() : this.options.initialOffset;
    this.measurementsCache = this.options.initialMeasurementsCache;
    this.measurementsCache.forEach((item) => {
      this.itemSizeCache.set(item.key, item.size);
    });
    this.notify(false, false);
  }
}
const findNearestBinarySearch = (low, high, getCurrentValue, value) => {
  while (low <= high) {
    const middle = (low + high) / 2 | 0;
    const currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange({
  measurements,
  outerSize,
  scrollOffset
}) {
  const count = measurements.length - 1;
  const getOffset = (index) => measurements[index].start;
  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);
  let endIndex = startIndex;
  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {
    endIndex++;
  }
  return { startIndex, endIndex };
}
function useVirtualizerBase(options) {
  const virtualizer = new Virtualizer(unref(options));
  const state = shallowRef(virtualizer);
  const cleanup = virtualizer._didMount();
  watch(
    () => unref(options).getScrollElement(),
    (el) => {
      if (el) {
        virtualizer._willUpdate();
      }
    },
    {
      immediate: true
    }
  );
  watch(
    () => unref(options),
    (options2) => {
      virtualizer.setOptions({
        ...options2,
        onChange: (instance, sync) => {
          var _a;
          triggerRef(state);
          (_a = options2.onChange) == null ? void 0 : _a.call(options2, instance, sync);
        }
      });
      virtualizer._willUpdate();
      triggerRef(state);
    },
    {
      immediate: true
    }
  );
  onScopeDispose(cleanup);
  return state;
}
function useVirtualizer(options) {
  return useVirtualizerBase(
    computed(() => ({
      observeElementRect,
      observeElementOffset,
      scrollToFn: elementScroll,
      ...unref(options)
    }))
  );
}
function unrefElement(elRef) {
  var _a;
  const plain = toValue$1(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
const defaultWindow = isClient$1 ? window : void 0;
function useEventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop$1;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener2, options2) => {
    el.addEventListener(event, listener2, options2);
    return () => el.removeEventListener(event, listener2, options2);
  };
  const stopWatch = watch(
    () => [unrefElement(target), toValue$1(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject$3(options2) ? { ...options2 } : options2;
      cleanups.push(
        ...events.flatMap((event) => {
          return listeners.map((listener2) => register(el, event, listener2, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose$1(stop);
  return stop;
}
let _iOSWorkaround = false;
function onClickOutside(target, handler, options = {}) {
  const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
  if (!window2)
    return noop$1;
  if (isIOS && !_iOSWorkaround) {
    _iOSWorkaround = true;
    Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop$1));
    window2.document.documentElement.addEventListener("click", noop$1);
  }
  let shouldListen = true;
  const shouldIgnore = (event) => {
    return ignore.some((target2) => {
      if (typeof target2 === "string") {
        return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
      } else {
        const el = unrefElement(target2);
        return el && (event.target === el || event.composedPath().includes(el));
      }
    });
  };
  const listener2 = (event) => {
    const el = unrefElement(target);
    if (!el || el === event.target || event.composedPath().includes(el))
      return;
    if (event.detail === 0)
      shouldListen = !shouldIgnore(event);
    if (!shouldListen) {
      shouldListen = true;
      return;
    }
    handler(event);
  };
  const cleanup = [
    useEventListener(window2, "click", listener2, { passive: true, capture }),
    useEventListener(window2, "pointerdown", (e2) => {
      const el = unrefElement(target);
      shouldListen = !shouldIgnore(e2) && !!(el && !e2.composedPath().includes(el));
    }, { passive: true }),
    detectIframe && useEventListener(window2, "blur", (event) => {
      setTimeout(() => {
        var _a;
        const el = unrefElement(target);
        if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
          handler(event);
      }, 0);
    })
  ].filter(Boolean);
  const stop = () => cleanup.forEach((fn) => fn());
  return stop;
}
const vOnClickOutside = {
  [directiveHooks.mounted](el, binding) {
    const capture = !binding.modifiers.bubble;
    if (typeof binding.value === "function") {
      el.__onClickOutside_stop = onClickOutside(el, binding.value, { capture });
    } else {
      const [handler, options] = binding.value;
      el.__onClickOutside_stop = onClickOutside(el, handler, Object.assign({ capture }, options));
    }
  },
  [directiveHooks.unmounted](el) {
    el.__onClickOutside_stop();
  }
};
function resolveElement(el) {
  if (typeof Window !== "undefined" && el instanceof Window)
    return el.document.documentElement;
  if (typeof Document !== "undefined" && el instanceof Document)
    return el.documentElement;
  return el;
}
function checkOverflowScroll(ele) {
  const style2 = window.getComputedStyle(ele);
  if (style2.overflowX === "scroll" || style2.overflowY === "scroll" || style2.overflowX === "auto" && ele.clientWidth < ele.scrollWidth || style2.overflowY === "auto" && ele.clientHeight < ele.scrollHeight) {
    return true;
  } else {
    const parent = ele.parentNode;
    if (!parent || parent.tagName === "BODY")
      return false;
    return checkOverflowScroll(parent);
  }
}
function preventDefault(rawEvent) {
  const e2 = rawEvent || window.event;
  const _target = e2.target;
  if (checkOverflowScroll(_target))
    return false;
  if (e2.touches.length > 1)
    return true;
  if (e2.preventDefault)
    e2.preventDefault();
  return false;
}
const elInitialOverflow = /* @__PURE__ */ new WeakMap();
function useScrollLock(element, initialState = false) {
  const isLocked = ref(initialState);
  let stopTouchMoveListener = null;
  let initialOverflow = "";
  watch(toRef(element), (el) => {
    const target = resolveElement(toValue$1(el));
    if (target) {
      const ele = target;
      if (!elInitialOverflow.get(ele))
        elInitialOverflow.set(ele, ele.style.overflow);
      if (ele.style.overflow !== "hidden")
        initialOverflow = ele.style.overflow;
      if (ele.style.overflow === "hidden")
        return isLocked.value = true;
      if (isLocked.value)
        return ele.style.overflow = "hidden";
    }
  }, {
    immediate: true
  });
  const lock = () => {
    const el = resolveElement(toValue$1(element));
    if (!el || isLocked.value)
      return;
    if (isIOS) {
      stopTouchMoveListener = useEventListener(
        el,
        "touchmove",
        (e2) => {
          preventDefault(e2);
        },
        { passive: false }
      );
    }
    el.style.overflow = "hidden";
    isLocked.value = true;
  };
  const unlock = () => {
    const el = resolveElement(toValue$1(element));
    if (!el || !isLocked.value)
      return;
    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());
    el.style.overflow = initialOverflow;
    elInitialOverflow.delete(el);
    isLocked.value = false;
  };
  tryOnScopeDispose$1(unlock);
  return computed({
    get() {
      return isLocked.value;
    },
    set(v2) {
      if (v2)
        lock();
      else
        unlock();
    }
  });
}
function onScrollLock() {
  let isMounted = false;
  const state = ref(false);
  return (el, binding) => {
    state.value = binding.value;
    if (isMounted)
      return;
    isMounted = true;
    const isLocked = useScrollLock(el, binding.value);
    watch(state, (v2) => isLocked.value = v2);
  };
}
onScrollLock();
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Icon = ({ size: size2, strokeWidth = 2, absoluteStrokeWidth, color, iconNode, name, class: classes, ...props }, { slots }) => {
  return h$1(
    "svg",
    {
      ...defaultAttributes,
      width: size2 || defaultAttributes.width,
      height: size2 || defaultAttributes.height,
      stroke: color || defaultAttributes.stroke,
      "stroke-width": absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
      class: ["lucide", `lucide-${toKebabCase(name ?? "icon")}`],
      ...props
    },
    [...iconNode.map((child) => h$1(...child)), ...slots.default ? [slots.default()] : []]
  );
};
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createLucideIcon = (iconName, iconNode) => (props, { slots }) => h$1(
  Icon,
  {
    ...props,
    iconNode,
    name: iconName
  },
  slots
);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const AArrowDown = createLucideIcon("AArrowDownIcon", [
  ["path", { d: "M3.5 13h6", key: "p1my2r" }],
  ["path", { d: "m2 16 4.5-9 4.5 9", key: "ndf0b3" }],
  ["path", { d: "M18 7v9", key: "pknjwm" }],
  ["path", { d: "m14 12 4 4 4-4", key: "buelq4" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const AArrowUp = createLucideIcon("AArrowUpIcon", [
  ["path", { d: "M3.5 13h6", key: "p1my2r" }],
  ["path", { d: "m2 16 4.5-9 4.5 9", key: "ndf0b3" }],
  ["path", { d: "M18 16V7", key: "ty0viw" }],
  ["path", { d: "m14 11 4-4 4 4", key: "1pu57t" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const AlignJustify = createLucideIcon("AlignJustifyIcon", [
  ["line", { x1: "3", x2: "21", y1: "6", y2: "6", key: "4m8b97" }],
  ["line", { x1: "3", x2: "21", y1: "12", y2: "12", key: "10d38w" }],
  ["line", { x1: "3", x2: "21", y1: "18", y2: "18", key: "kwyyxn" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Annoyed = createLucideIcon("AnnoyedIcon", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M8 15h8", key: "45n4r" }],
  ["path", { d: "M8 9h2", key: "1g203m" }],
  ["path", { d: "M14 9h2", key: "116p9w" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Baseline = createLucideIcon("BaselineIcon", [
  ["path", { d: "M4 20h16", key: "14thso" }],
  ["path", { d: "m6 16 6-12 6 12", key: "1b4byz" }],
  ["path", { d: "M8 12h8", key: "1wcyev" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const BellElectric = createLucideIcon("BellElectricIcon", [
  ["path", { d: "M18.8 4A6.3 8.7 0 0 1 20 9", key: "xve1fh" }],
  ["path", { d: "M9 9h.01", key: "1q5me6" }],
  ["circle", { cx: "9", cy: "9", r: "7", key: "p2h5vp" }],
  ["rect", { width: "10", height: "6", x: "4", y: "16", rx: "2", key: "17f3te" }],
  ["path", { d: "M14 19c3 0 4.6-1.6 4.6-1.6", key: "n7odp6" }],
  ["circle", { cx: "20", cy: "16", r: "2", key: "1v9bxh" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Bolt = createLucideIcon("BoltIcon", [
  [
    "path",
    {
      d: "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z",
      key: "yt0hxn"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "4", key: "4exip2" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Book = createLucideIcon("BookIcon", [
  ["path", { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20", key: "t4utmx" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CircleCheckBig = createLucideIcon("CircleCheckBigIcon", [
  ["path", { d: "M22 11.08V12a10 10 0 1 1-5.93-9.14", key: "g774vq" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Clock = createLucideIcon("ClockIcon", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Copy = createLucideIcon("CopyIcon", [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ellipsis = createLucideIcon("EllipsisIcon", [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
  ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Flag = createLucideIcon("FlagIcon", [
  ["path", { d: "M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z", key: "i9b6wo" }],
  ["line", { x1: "4", x2: "4", y1: "22", y2: "15", key: "1cm3nv" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const HeartOff = createLucideIcon("HeartOffIcon", [
  ["line", { x1: "2", y1: "2", x2: "22", y2: "22", key: "1w4vcy" }],
  [
    "path",
    { d: "M16.5 16.5 12 21l-7-7c-1.5-1.45-3-3.2-3-5.5a5.5 5.5 0 0 1 2.14-4.35", key: "3mpagl" }
  ],
  [
    "path",
    {
      d: "M8.76 3.1c1.15.22 2.13.78 3.24 1.9 1.5-1.5 2.74-2 4.5-2A5.5 5.5 0 0 1 22 8.5c0 2.12-1.3 3.78-2.67 5.17",
      key: "1gh3v3"
    }
  ]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Heart = createLucideIcon("HeartIcon", [
  [
    "path",
    {
      d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z",
      key: "c3ymky"
    }
  ]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Highlighter = createLucideIcon("HighlighterIcon", [
  ["path", { d: "m9 11-6 6v3h9l3-3", key: "1a3l36" }],
  ["path", { d: "m22 12-4.6 4.6a2 2 0 0 1-2.8 0l-5.2-5.2a2 2 0 0 1 0-2.8L14 4", key: "14a9rk" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const MessageSquareMore = createLucideIcon("MessageSquareMoreIcon", [
  ["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z", key: "1lielz" }],
  ["path", { d: "M8 10h.01", key: "19clt8" }],
  ["path", { d: "M12 10h.01", key: "1nrarc" }],
  ["path", { d: "M16 10h.01", key: "1m94wz" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Minus = createLucideIcon("MinusIcon", [["path", { d: "M5 12h14", key: "1ays0h" }]]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const MoveUp = createLucideIcon("MoveUpIcon", [
  ["path", { d: "M8 6L12 2L16 6", key: "1yvkyx" }],
  ["path", { d: "M12 2V22", key: "r89rzk" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const NotebookPen = createLucideIcon("NotebookPenIcon", [
  ["path", { d: "M13.4 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-7.4", key: "re6nr2" }],
  ["path", { d: "M2 6h4", key: "aawbzj" }],
  ["path", { d: "M2 10h4", key: "l0bgd4" }],
  ["path", { d: "M2 14h4", key: "1gsvsf" }],
  ["path", { d: "M2 18h4", key: "1bu2t1" }],
  ["path", { d: "M18.4 2.6a2.17 2.17 0 0 1 3 3L16 11l-4 1 1-4Z", key: "1dba1m" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const PencilLine = createLucideIcon("PencilLineIcon", [
  ["path", { d: "M12 20h9", key: "t2du7b" }],
  ["path", { d: "M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z", key: "ymcmye" }],
  ["path", { d: "m15 5 3 3", key: "1w25hb" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Plus = createLucideIcon("PlusIcon", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Search = createLucideIcon("SearchIcon", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Settings = createLucideIcon("SettingsIcon", [
  [
    "path",
    {
      d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
      key: "1qme2f"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SkipBack = createLucideIcon("SkipBackIcon", [
  ["polygon", { points: "19 20 9 12 19 4 19 20", key: "o2sva" }],
  ["line", { x1: "5", x2: "5", y1: "19", y2: "5", key: "1ocqjk" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SpellCheck2 = createLucideIcon("SpellCheck2Icon", [
  ["path", { d: "m6 16 6-12 6 12", key: "1b4byz" }],
  ["path", { d: "M8 12h8", key: "1wcyev" }],
  [
    "path",
    {
      d: "M4 21c1.1 0 1.1-1 2.3-1s1.1 1 2.3 1c1.1 0 1.1-1 2.3-1 1.1 0 1.1 1 2.3 1 1.1 0 1.1-1 2.3-1 1.1 0 1.1 1 2.3 1 1.1 0 1.1-1 2.3-1",
      key: "8mdmtu"
    }
  ]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SquareLibrary = createLucideIcon("SquareLibraryIcon", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M7 7v10", key: "d5nglc" }],
  ["path", { d: "M11 7v10", key: "pptsnr" }],
  ["path", { d: "m15 7 2 10", key: "1m7qm5" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Star = createLucideIcon("StarIcon", [
  [
    "polygon",
    {
      points: "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2",
      key: "8f66p6"
    }
  ]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Trash2 = createLucideIcon("Trash2Icon", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Trash = createLucideIcon("TrashIcon", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const UndoDot = createLucideIcon("UndoDotIcon", [
  ["circle", { cx: "12", cy: "17", r: "1", key: "1ixnty" }],
  ["path", { d: "M3 7v6h6", key: "1v2h90" }],
  ["path", { d: "M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13", key: "1r6uu6" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Upload = createLucideIcon("UploadIcon", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "17 8 12 3 7 8", key: "t8dd8p" }],
  ["line", { x1: "12", x2: "12", y1: "3", y2: "15", key: "widbto" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const X = createLucideIcon("XIcon", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ZoomIn = createLucideIcon("ZoomInIcon", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "11", x2: "11", y1: "8", y2: "14", key: "1vmskp" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]);
/**
 * @license lucide-vue-next v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ZoomOut = createLucideIcon("ZoomOutIcon", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var dexie_min = { exports: {} };
(function(module, exports) {
  (function(e2, t2) {
    module.exports = t2();
  })(commonjsGlobal, function() {
    var s = function(e3, t3) {
      return (s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, t4) {
        e4.__proto__ = t4;
      } || function(e4, t4) {
        for (var n3 in t4)
          Object.prototype.hasOwnProperty.call(t4, n3) && (e4[n3] = t4[n3]);
      })(e3, t3);
    };
    var w2 = function() {
      return (w2 = Object.assign || function(e3) {
        for (var t3, n3 = 1, r3 = arguments.length; n3 < r3; n3++)
          for (var i3 in t3 = arguments[n3])
            Object.prototype.hasOwnProperty.call(t3, i3) && (e3[i3] = t3[i3]);
        return e3;
      }).apply(this, arguments);
    };
    function i2(e3, t3, n3) {
      for (var r3, i3 = 0, o3 = t3.length; i3 < o3; i3++)
        !r3 && i3 in t3 || ((r3 = r3 || Array.prototype.slice.call(t3, 0, i3))[i3] = t3[i3]);
      return e3.concat(r3 || Array.prototype.slice.call(t3));
    }
    var f2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : commonjsGlobal, _2 = Object.keys, x2 = Array.isArray;
    function a2(t3, n3) {
      return "object" != typeof n3 || _2(n3).forEach(function(e3) {
        t3[e3] = n3[e3];
      }), t3;
    }
    "undefined" == typeof Promise || f2.Promise || (f2.Promise = Promise);
    var c = Object.getPrototypeOf, n2 = {}.hasOwnProperty;
    function m2(e3, t3) {
      return n2.call(e3, t3);
    }
    function r2(t3, n3) {
      "function" == typeof n3 && (n3 = n3(c(t3))), ("undefined" == typeof Reflect ? _2 : Reflect.ownKeys)(n3).forEach(function(e3) {
        l2(t3, e3, n3[e3]);
      });
    }
    var u = Object.defineProperty;
    function l2(e3, t3, n3, r3) {
      u(e3, t3, a2(n3 && m2(n3, "get") && "function" == typeof n3.get ? { get: n3.get, set: n3.set, configurable: true } : { value: n3, configurable: true, writable: true }, r3));
    }
    function o2(t3) {
      return { from: function(e3) {
        return t3.prototype = Object.create(e3.prototype), l2(t3.prototype, "constructor", t3), { extend: r2.bind(null, t3.prototype) };
      } };
    }
    var h2 = Object.getOwnPropertyDescriptor;
    var d = [].slice;
    function b2(e3, t3, n3) {
      return d.call(e3, t3, n3);
    }
    function p2(e3, t3) {
      return t3(e3);
    }
    function y2(e3) {
      if (!e3)
        throw new Error("Assertion Failed");
    }
    function v2(e3) {
      f2.setImmediate ? setImmediate(e3) : setTimeout(e3, 0);
    }
    function k2(e3, t3) {
      if ("string" == typeof t3 && m2(e3, t3))
        return e3[t3];
      if (!t3)
        return e3;
      if ("string" != typeof t3) {
        for (var n3 = [], r3 = 0, i3 = t3.length; r3 < i3; ++r3) {
          var o3 = k2(e3, t3[r3]);
          n3.push(o3);
        }
        return n3;
      }
      var a3 = t3.indexOf(".");
      if (-1 !== a3) {
        var u2 = e3[t3.substr(0, a3)];
        return null == u2 ? void 0 : k2(u2, t3.substr(a3 + 1));
      }
    }
    function P(e3, t3, n3) {
      if (e3 && void 0 !== t3 && !("isFrozen" in Object && Object.isFrozen(e3)))
        if ("string" != typeof t3 && "length" in t3) {
          y2("string" != typeof n3 && "length" in n3);
          for (var r3 = 0, i3 = t3.length; r3 < i3; ++r3)
            P(e3, t3[r3], n3[r3]);
        } else {
          var o3, a3, u2 = t3.indexOf(".");
          -1 !== u2 ? (o3 = t3.substr(0, u2), "" === (a3 = t3.substr(u2 + 1)) ? void 0 === n3 ? x2(e3) && !isNaN(parseInt(o3)) ? e3.splice(o3, 1) : delete e3[o3] : e3[o3] = n3 : P(u2 = !(u2 = e3[o3]) || !m2(e3, o3) ? e3[o3] = {} : u2, a3, n3)) : void 0 === n3 ? x2(e3) && !isNaN(parseInt(t3)) ? e3.splice(t3, 1) : delete e3[t3] : e3[t3] = n3;
        }
    }
    function g2(e3) {
      var t3, n3 = {};
      for (t3 in e3)
        m2(e3, t3) && (n3[t3] = e3[t3]);
      return n3;
    }
    var t2 = [].concat;
    function O(e3) {
      return t2.apply([], e3);
    }
    var e2 = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(O([8, 16, 32, 64].map(function(t3) {
      return ["Int", "Uint", "Float"].map(function(e3) {
        return e3 + t3 + "Array";
      });
    }))).filter(function(e3) {
      return f2[e3];
    }), E2 = new Set(e2.map(function(e3) {
      return f2[e3];
    }));
    var K = null;
    function S2(e3) {
      K = /* @__PURE__ */ new WeakMap();
      e3 = function e4(t3) {
        if (!t3 || "object" != typeof t3)
          return t3;
        var n3 = K.get(t3);
        if (n3)
          return n3;
        if (x2(t3)) {
          n3 = [], K.set(t3, n3);
          for (var r3 = 0, i3 = t3.length; r3 < i3; ++r3)
            n3.push(e4(t3[r3]));
        } else if (E2.has(t3.constructor))
          n3 = t3;
        else {
          var o3, a3 = c(t3);
          for (o3 in n3 = a3 === Object.prototype ? {} : Object.create(a3), K.set(t3, n3), t3)
            m2(t3, o3) && (n3[o3] = e4(t3[o3]));
        }
        return n3;
      }(e3);
      return K = null, e3;
    }
    var j = {}.toString;
    function A(e3) {
      return j.call(e3).slice(8, -1);
    }
    var C = "undefined" != typeof Symbol ? Symbol.iterator : "@@iterator", D = "symbol" == typeof C ? function(e3) {
      var t3;
      return null != e3 && (t3 = e3[C]) && t3.apply(e3);
    } : function() {
      return null;
    };
    function T2(e3, t3) {
      t3 = e3.indexOf(t3);
      return 0 <= t3 && e3.splice(t3, 1), 0 <= t3;
    }
    var q = {};
    function I(e3) {
      var t3, n3, r3, i3;
      if (1 === arguments.length) {
        if (x2(e3))
          return e3.slice();
        if (this === q && "string" == typeof e3)
          return [e3];
        if (i3 = D(e3)) {
          for (n3 = []; !(r3 = i3.next()).done; )
            n3.push(r3.value);
          return n3;
        }
        if (null == e3)
          return [e3];
        if ("number" != typeof (t3 = e3.length))
          return [e3];
        for (n3 = new Array(t3); t3--; )
          n3[t3] = e3[t3];
        return n3;
      }
      for (t3 = arguments.length, n3 = new Array(t3); t3--; )
        n3[t3] = arguments[t3];
      return n3;
    }
    var B = "undefined" != typeof Symbol ? function(e3) {
      return "AsyncFunction" === e3[Symbol.toStringTag];
    } : function() {
      return false;
    }, R = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], F = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(R), M = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
    function N(e3, t3) {
      this.name = e3, this.message = t3;
    }
    function L(e3, t3) {
      return e3 + ". Errors: " + Object.keys(t3).map(function(e4) {
        return t3[e4].toString();
      }).filter(function(e4, t4, n3) {
        return n3.indexOf(e4) === t4;
      }).join("\n");
    }
    function U2(e3, t3, n3, r3) {
      this.failures = t3, this.failedKeys = r3, this.successCount = n3, this.message = L(e3, t3);
    }
    function z2(e3, t3) {
      this.name = "BulkError", this.failures = Object.keys(t3).map(function(e4) {
        return t3[e4];
      }), this.failuresByPos = t3, this.message = L(e3, this.failures);
    }
    o2(N).from(Error).extend({ toString: function() {
      return this.name + ": " + this.message;
    } }), o2(U2).from(N), o2(z2).from(N);
    var V = F.reduce(function(e3, t3) {
      return e3[t3] = t3 + "Error", e3;
    }, {}), W = N, Y = F.reduce(function(e3, n3) {
      var r3 = n3 + "Error";
      function t3(e4, t4) {
        this.name = r3, e4 ? "string" == typeof e4 ? (this.message = "".concat(e4).concat(t4 ? "\n " + t4 : ""), this.inner = t4 || null) : "object" == typeof e4 && (this.message = "".concat(e4.name, " ").concat(e4.message), this.inner = e4) : (this.message = M[n3] || r3, this.inner = null);
      }
      return o2(t3).from(W), e3[n3] = t3, e3;
    }, {});
    Y.Syntax = SyntaxError, Y.Type = TypeError, Y.Range = RangeError;
    var $2 = R.reduce(function(e3, t3) {
      return e3[t3 + "Error"] = Y[t3], e3;
    }, {});
    var Q = F.reduce(function(e3, t3) {
      return -1 === ["Syntax", "Type", "Range"].indexOf(t3) && (e3[t3 + "Error"] = Y[t3]), e3;
    }, {});
    function G() {
    }
    function X2(e3) {
      return e3;
    }
    function H(t3, n3) {
      return null == t3 || t3 === X2 ? n3 : function(e3) {
        return n3(t3(e3));
      };
    }
    function J(e3, t3) {
      return function() {
        e3.apply(this, arguments), t3.apply(this, arguments);
      };
    }
    function Z(i3, o3) {
      return i3 === G ? o3 : function() {
        var e3 = i3.apply(this, arguments);
        void 0 !== e3 && (arguments[0] = e3);
        var t3 = this.onsuccess, n3 = this.onerror;
        this.onsuccess = null, this.onerror = null;
        var r3 = o3.apply(this, arguments);
        return t3 && (this.onsuccess = this.onsuccess ? J(t3, this.onsuccess) : t3), n3 && (this.onerror = this.onerror ? J(n3, this.onerror) : n3), void 0 !== r3 ? r3 : e3;
      };
    }
    function ee(n3, r3) {
      return n3 === G ? r3 : function() {
        n3.apply(this, arguments);
        var e3 = this.onsuccess, t3 = this.onerror;
        this.onsuccess = this.onerror = null, r3.apply(this, arguments), e3 && (this.onsuccess = this.onsuccess ? J(e3, this.onsuccess) : e3), t3 && (this.onerror = this.onerror ? J(t3, this.onerror) : t3);
      };
    }
    function te(i3, o3) {
      return i3 === G ? o3 : function(e3) {
        var t3 = i3.apply(this, arguments);
        a2(e3, t3);
        var n3 = this.onsuccess, r3 = this.onerror;
        this.onsuccess = null, this.onerror = null;
        e3 = o3.apply(this, arguments);
        return n3 && (this.onsuccess = this.onsuccess ? J(n3, this.onsuccess) : n3), r3 && (this.onerror = this.onerror ? J(r3, this.onerror) : r3), void 0 === t3 ? void 0 === e3 ? void 0 : e3 : a2(t3, e3);
      };
    }
    function ne(e3, t3) {
      return e3 === G ? t3 : function() {
        return false !== t3.apply(this, arguments) && e3.apply(this, arguments);
      };
    }
    function re(i3, o3) {
      return i3 === G ? o3 : function() {
        var e3 = i3.apply(this, arguments);
        if (e3 && "function" == typeof e3.then) {
          for (var t3 = this, n3 = arguments.length, r3 = new Array(n3); n3--; )
            r3[n3] = arguments[n3];
          return e3.then(function() {
            return o3.apply(t3, r3);
          });
        }
        return o3.apply(this, arguments);
      };
    }
    Q.ModifyError = U2, Q.DexieError = N, Q.BulkError = z2;
    var ie = "undefined" != typeof location && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
    function oe(e3) {
      ie = e3;
    }
    var ae = {}, ue = 100, e2 = "undefined" == typeof Promise ? [] : function() {
      var e3 = Promise.resolve();
      if ("undefined" == typeof crypto || !crypto.subtle)
        return [e3, c(e3), e3];
      var t3 = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
      return [t3, c(t3), e3];
    }(), R = e2[0], F = e2[1], e2 = e2[2], F = F && F.then, se = R && R.constructor, ce = !!e2;
    var le = function(e3, t3) {
      be.push([e3, t3]), he && (queueMicrotask(Se), he = false);
    }, fe = true, he = true, de2 = [], pe = [], ye = X2, ve = { id: "global", global: true, ref: 0, unhandleds: [], onunhandled: G, pgp: false, env: {}, finalize: G }, me = ve, be = [], ge = 0, we = [];
    function _e(e3) {
      if ("object" != typeof this)
        throw new TypeError("Promises must be constructed via new");
      this._listeners = [], this._lib = false;
      var t3 = this._PSD = me;
      if ("function" != typeof e3) {
        if (e3 !== ae)
          throw new TypeError("Not a function");
        return this._state = arguments[1], this._value = arguments[2], void (false === this._state && Oe(this, this._value));
      }
      this._state = null, this._value = null, ++t3.ref, function t4(r3, e4) {
        try {
          e4(function(n3) {
            if (null === r3._state) {
              if (n3 === r3)
                throw new TypeError("A promise cannot be resolved with itself.");
              var e5 = r3._lib && je();
              n3 && "function" == typeof n3.then ? t4(r3, function(e6, t5) {
                n3 instanceof _e ? n3._then(e6, t5) : n3.then(e6, t5);
              }) : (r3._state = true, r3._value = n3, Pe(r3)), e5 && Ae();
            }
          }, Oe.bind(null, r3));
        } catch (e5) {
          Oe(r3, e5);
        }
      }(this, e3);
    }
    var xe = { get: function() {
      var u2 = me, t3 = Fe;
      function e3(n3, r3) {
        var i3 = this, o3 = !u2.global && (u2 !== me || t3 !== Fe), a3 = o3 && !Ue(), e4 = new _e(function(e5, t4) {
          Ee(i3, new ke(Qe(n3, u2, o3, a3), Qe(r3, u2, o3, a3), e5, t4, u2));
        });
        return this._consoleTask && (e4._consoleTask = this._consoleTask), e4;
      }
      return e3.prototype = ae, e3;
    }, set: function(e3) {
      l2(this, "then", e3 && e3.prototype === ae ? xe : { get: function() {
        return e3;
      }, set: xe.set });
    } };
    function ke(e3, t3, n3, r3, i3) {
      this.onFulfilled = "function" == typeof e3 ? e3 : null, this.onRejected = "function" == typeof t3 ? t3 : null, this.resolve = n3, this.reject = r3, this.psd = i3;
    }
    function Oe(e3, t3) {
      var n3, r3;
      pe.push(t3), null === e3._state && (n3 = e3._lib && je(), t3 = ye(t3), e3._state = false, e3._value = t3, r3 = e3, de2.some(function(e4) {
        return e4._value === r3._value;
      }) || de2.push(r3), Pe(e3), n3 && Ae());
    }
    function Pe(e3) {
      var t3 = e3._listeners;
      e3._listeners = [];
      for (var n3 = 0, r3 = t3.length; n3 < r3; ++n3)
        Ee(e3, t3[n3]);
      var i3 = e3._PSD;
      --i3.ref || i3.finalize(), 0 === ge && (++ge, le(function() {
        0 == --ge && Ce();
      }, []));
    }
    function Ee(e3, t3) {
      if (null !== e3._state) {
        var n3 = e3._state ? t3.onFulfilled : t3.onRejected;
        if (null === n3)
          return (e3._state ? t3.resolve : t3.reject)(e3._value);
        ++t3.psd.ref, ++ge, le(Ke, [n3, e3, t3]);
      } else
        e3._listeners.push(t3);
    }
    function Ke(e3, t3, n3) {
      try {
        var r3, i3 = t3._value;
        !t3._state && pe.length && (pe = []), r3 = ie && t3._consoleTask ? t3._consoleTask.run(function() {
          return e3(i3);
        }) : e3(i3), t3._state || -1 !== pe.indexOf(i3) || function(e4) {
          var t4 = de2.length;
          for (; t4; )
            if (de2[--t4]._value === e4._value)
              return de2.splice(t4, 1);
        }(t3), n3.resolve(r3);
      } catch (e4) {
        n3.reject(e4);
      } finally {
        0 == --ge && Ce(), --n3.psd.ref || n3.psd.finalize();
      }
    }
    function Se() {
      $e(ve, function() {
        je() && Ae();
      });
    }
    function je() {
      var e3 = fe;
      return he = fe = false, e3;
    }
    function Ae() {
      var e3, t3, n3;
      do {
        for (; 0 < be.length; )
          for (e3 = be, be = [], n3 = e3.length, t3 = 0; t3 < n3; ++t3) {
            var r3 = e3[t3];
            r3[0].apply(null, r3[1]);
          }
      } while (0 < be.length);
      he = fe = true;
    }
    function Ce() {
      var e3 = de2;
      de2 = [], e3.forEach(function(e4) {
        e4._PSD.onunhandled.call(null, e4._value, e4);
      });
      for (var t3 = we.slice(0), n3 = t3.length; n3; )
        t3[--n3]();
    }
    function De(e3) {
      return new _e(ae, false, e3);
    }
    function Te(n3, r3) {
      var i3 = me;
      return function() {
        var e3 = je(), t3 = me;
        try {
          return We(i3, true), n3.apply(this, arguments);
        } catch (e4) {
          r3 && r3(e4);
        } finally {
          We(t3, false), e3 && Ae();
        }
      };
    }
    r2(_e.prototype, { then: xe, _then: function(e3, t3) {
      Ee(this, new ke(null, null, e3, t3, me));
    }, catch: function(e3) {
      if (1 === arguments.length)
        return this.then(null, e3);
      var t3 = e3, n3 = arguments[1];
      return "function" == typeof t3 ? this.then(null, function(e4) {
        return (e4 instanceof t3 ? n3 : De)(e4);
      }) : this.then(null, function(e4) {
        return (e4 && e4.name === t3 ? n3 : De)(e4);
      });
    }, finally: function(t3) {
      return this.then(function(e3) {
        return _e.resolve(t3()).then(function() {
          return e3;
        });
      }, function(e3) {
        return _e.resolve(t3()).then(function() {
          return De(e3);
        });
      });
    }, timeout: function(r3, i3) {
      var o3 = this;
      return r3 < 1 / 0 ? new _e(function(e3, t3) {
        var n3 = setTimeout(function() {
          return t3(new Y.Timeout(i3));
        }, r3);
        o3.then(e3, t3).finally(clearTimeout.bind(null, n3));
      }) : this;
    } }), "undefined" != typeof Symbol && Symbol.toStringTag && l2(_e.prototype, Symbol.toStringTag, "Dexie.Promise"), ve.env = Ye(), r2(_e, { all: function() {
      var o3 = I.apply(null, arguments).map(ze);
      return new _e(function(n3, r3) {
        0 === o3.length && n3([]);
        var i3 = o3.length;
        o3.forEach(function(e3, t3) {
          return _e.resolve(e3).then(function(e4) {
            o3[t3] = e4, --i3 || n3(o3);
          }, r3);
        });
      });
    }, resolve: function(n3) {
      return n3 instanceof _e ? n3 : n3 && "function" == typeof n3.then ? new _e(function(e3, t3) {
        n3.then(e3, t3);
      }) : new _e(ae, true, n3);
    }, reject: De, race: function() {
      var e3 = I.apply(null, arguments).map(ze);
      return new _e(function(t3, n3) {
        e3.map(function(e4) {
          return _e.resolve(e4).then(t3, n3);
        });
      });
    }, PSD: { get: function() {
      return me;
    }, set: function(e3) {
      return me = e3;
    } }, totalEchoes: { get: function() {
      return Fe;
    } }, newPSD: Ne, usePSD: $e, scheduler: { get: function() {
      return le;
    }, set: function(e3) {
      le = e3;
    } }, rejectionMapper: { get: function() {
      return ye;
    }, set: function(e3) {
      ye = e3;
    } }, follow: function(i3, n3) {
      return new _e(function(e3, t3) {
        return Ne(function(n4, r3) {
          var e4 = me;
          e4.unhandleds = [], e4.onunhandled = r3, e4.finalize = J(function() {
            var t4, e5 = this;
            t4 = function() {
              0 === e5.unhandleds.length ? n4() : r3(e5.unhandleds[0]);
            }, we.push(function e6() {
              t4(), we.splice(we.indexOf(e6), 1);
            }), ++ge, le(function() {
              0 == --ge && Ce();
            }, []);
          }, e4.finalize), i3();
        }, n3, e3, t3);
      });
    } }), se && (se.allSettled && l2(_e, "allSettled", function() {
      var e3 = I.apply(null, arguments).map(ze);
      return new _e(function(n3) {
        0 === e3.length && n3([]);
        var r3 = e3.length, i3 = new Array(r3);
        e3.forEach(function(e4, t3) {
          return _e.resolve(e4).then(function(e5) {
            return i3[t3] = { status: "fulfilled", value: e5 };
          }, function(e5) {
            return i3[t3] = { status: "rejected", reason: e5 };
          }).then(function() {
            return --r3 || n3(i3);
          });
        });
      });
    }), se.any && "undefined" != typeof AggregateError && l2(_e, "any", function() {
      var e3 = I.apply(null, arguments).map(ze);
      return new _e(function(n3, r3) {
        0 === e3.length && r3(new AggregateError([]));
        var i3 = e3.length, o3 = new Array(i3);
        e3.forEach(function(e4, t3) {
          return _e.resolve(e4).then(function(e5) {
            return n3(e5);
          }, function(e5) {
            o3[t3] = e5, --i3 || r3(new AggregateError(o3));
          });
        });
      });
    }));
    var qe = { awaits: 0, echoes: 0, id: 0 }, Ie = 0, Be = [], Re = 0, Fe = 0, Me = 0;
    function Ne(e3, t3, n3, r3) {
      var i3 = me, o3 = Object.create(i3);
      o3.parent = i3, o3.ref = 0, o3.global = false, o3.id = ++Me, ve.env, o3.env = ce ? { Promise: _e, PromiseProp: { value: _e, configurable: true, writable: true }, all: _e.all, race: _e.race, allSettled: _e.allSettled, any: _e.any, resolve: _e.resolve, reject: _e.reject } : {}, t3 && a2(o3, t3), ++i3.ref, o3.finalize = function() {
        --this.parent.ref || this.parent.finalize();
      };
      r3 = $e(o3, e3, n3, r3);
      return 0 === o3.ref && o3.finalize(), r3;
    }
    function Le() {
      return qe.id || (qe.id = ++Ie), ++qe.awaits, qe.echoes += ue, qe.id;
    }
    function Ue() {
      return !!qe.awaits && (0 == --qe.awaits && (qe.id = 0), qe.echoes = qe.awaits * ue, true);
    }
    function ze(e3) {
      return qe.echoes && e3 && e3.constructor === se ? (Le(), e3.then(function(e4) {
        return Ue(), e4;
      }, function(e4) {
        return Ue(), Xe(e4);
      })) : e3;
    }
    function Ve() {
      var e3 = Be[Be.length - 1];
      Be.pop(), We(e3, false);
    }
    function We(e3, t3) {
      var n3, r3 = me;
      (t3 ? !qe.echoes || Re++ && e3 === me : !Re || --Re && e3 === me) || queueMicrotask(t3 ? function(e4) {
        ++Fe, qe.echoes && 0 != --qe.echoes || (qe.echoes = qe.awaits = qe.id = 0), Be.push(me), We(e4, true);
      }.bind(null, e3) : Ve), e3 !== me && (me = e3, r3 === ve && (ve.env = Ye()), ce && (n3 = ve.env.Promise, t3 = e3.env, (r3.global || e3.global) && (Object.defineProperty(f2, "Promise", t3.PromiseProp), n3.all = t3.all, n3.race = t3.race, n3.resolve = t3.resolve, n3.reject = t3.reject, t3.allSettled && (n3.allSettled = t3.allSettled), t3.any && (n3.any = t3.any))));
    }
    function Ye() {
      var e3 = f2.Promise;
      return ce ? { Promise: e3, PromiseProp: Object.getOwnPropertyDescriptor(f2, "Promise"), all: e3.all, race: e3.race, allSettled: e3.allSettled, any: e3.any, resolve: e3.resolve, reject: e3.reject } : {};
    }
    function $e(e3, t3, n3, r3, i3) {
      var o3 = me;
      try {
        return We(e3, true), t3(n3, r3, i3);
      } finally {
        We(o3, false);
      }
    }
    function Qe(t3, n3, r3, i3) {
      return "function" != typeof t3 ? t3 : function() {
        var e3 = me;
        r3 && Le(), We(n3, true);
        try {
          return t3.apply(this, arguments);
        } finally {
          We(e3, false), i3 && queueMicrotask(Ue);
        }
      };
    }
    function Ge(e3) {
      Promise === se && 0 === qe.echoes ? 0 === Re ? e3() : enqueueNativeMicroTask(e3) : setTimeout(e3, 0);
    }
    -1 === ("" + F).indexOf("[native code]") && (Le = Ue = G);
    var Xe = _e.reject;
    var He = String.fromCharCode(65535), Je = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Ze = "String expected.", et = [], tt = "__dbnames", nt = "readonly", rt = "readwrite";
    function it2(e3, t3) {
      return e3 ? t3 ? function() {
        return e3.apply(this, arguments) && t3.apply(this, arguments);
      } : e3 : t3;
    }
    var ot = { type: 3, lower: -1 / 0, lowerOpen: false, upper: [[]], upperOpen: false };
    function at(t3) {
      return "string" != typeof t3 || /\./.test(t3) ? function(e3) {
        return e3;
      } : function(e3) {
        return void 0 === e3[t3] && t3 in e3 && delete (e3 = S2(e3))[t3], e3;
      };
    }
    function ut() {
      throw Y.Type();
    }
    function st(e3, t3) {
      try {
        var n3 = ct(e3), r3 = ct(t3);
        if (n3 !== r3)
          return "Array" === n3 ? 1 : "Array" === r3 ? -1 : "binary" === n3 ? 1 : "binary" === r3 ? -1 : "string" === n3 ? 1 : "string" === r3 ? -1 : "Date" === n3 ? 1 : "Date" !== r3 ? NaN : -1;
        switch (n3) {
          case "number":
          case "Date":
          case "string":
            return t3 < e3 ? 1 : e3 < t3 ? -1 : 0;
          case "binary":
            return function(e4, t4) {
              for (var n4 = e4.length, r4 = t4.length, i3 = n4 < r4 ? n4 : r4, o3 = 0; o3 < i3; ++o3)
                if (e4[o3] !== t4[o3])
                  return e4[o3] < t4[o3] ? -1 : 1;
              return n4 === r4 ? 0 : n4 < r4 ? -1 : 1;
            }(lt(e3), lt(t3));
          case "Array":
            return function(e4, t4) {
              for (var n4 = e4.length, r4 = t4.length, i3 = n4 < r4 ? n4 : r4, o3 = 0; o3 < i3; ++o3) {
                var a3 = st(e4[o3], t4[o3]);
                if (0 !== a3)
                  return a3;
              }
              return n4 === r4 ? 0 : n4 < r4 ? -1 : 1;
            }(e3, t3);
        }
      } catch (e4) {
      }
      return NaN;
    }
    function ct(e3) {
      var t3 = typeof e3;
      if ("object" != t3)
        return t3;
      if (ArrayBuffer.isView(e3))
        return "binary";
      e3 = A(e3);
      return "ArrayBuffer" === e3 ? "binary" : e3;
    }
    function lt(e3) {
      return e3 instanceof Uint8Array ? e3 : ArrayBuffer.isView(e3) ? new Uint8Array(e3.buffer, e3.byteOffset, e3.byteLength) : new Uint8Array(e3);
    }
    var ft = (ht.prototype._trans = function(e3, r3, t3) {
      var n3 = this._tx || me.trans, i3 = this.name, o3 = ie && "undefined" != typeof console && console.createTask && console.createTask("Dexie: ".concat("readonly" === e3 ? "read" : "write", " ").concat(this.name));
      function a3(e4, t4, n4) {
        if (!n4.schema[i3])
          throw new Y.NotFound("Table " + i3 + " not part of transaction");
        return r3(n4.idbtrans, n4);
      }
      var u2 = je();
      try {
        var s2 = n3 && n3.db._novip === this.db._novip ? n3 === me.trans ? n3._promise(e3, a3, t3) : Ne(function() {
          return n3._promise(e3, a3, t3);
        }, { trans: n3, transless: me.transless || me }) : function t4(n4, r4, i4, o4) {
          if (n4.idbdb && (n4._state.openComplete || me.letThrough || n4._vip)) {
            var a4 = n4._createTransaction(r4, i4, n4._dbSchema);
            try {
              a4.create(), n4._state.PR1398_maxLoop = 3;
            } catch (e4) {
              return e4.name === V.InvalidState && n4.isOpen() && 0 < --n4._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), n4.close({ disableAutoOpen: false }), n4.open().then(function() {
                return t4(n4, r4, i4, o4);
              })) : Xe(e4);
            }
            return a4._promise(r4, function(e4, t5) {
              return Ne(function() {
                return me.trans = a4, o4(e4, t5, a4);
              });
            }).then(function(e4) {
              if ("readwrite" === r4)
                try {
                  a4.idbtrans.commit();
                } catch (e5) {
                }
              return "readonly" === r4 ? e4 : a4._completion.then(function() {
                return e4;
              });
            });
          }
          if (n4._state.openComplete)
            return Xe(new Y.DatabaseClosed(n4._state.dbOpenError));
          if (!n4._state.isBeingOpened) {
            if (!n4._state.autoOpen)
              return Xe(new Y.DatabaseClosed());
            n4.open().catch(G);
          }
          return n4._state.dbReadyPromise.then(function() {
            return t4(n4, r4, i4, o4);
          });
        }(this.db, e3, [this.name], a3);
        return o3 && (s2._consoleTask = o3, s2 = s2.catch(function(e4) {
          return console.trace(e4), Xe(e4);
        })), s2;
      } finally {
        u2 && Ae();
      }
    }, ht.prototype.get = function(t3, e3) {
      var n3 = this;
      return t3 && t3.constructor === Object ? this.where(t3).first(e3) : null == t3 ? Xe(new Y.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(e4) {
        return n3.core.get({ trans: e4, key: t3 }).then(function(e5) {
          return n3.hook.reading.fire(e5);
        });
      }).then(e3);
    }, ht.prototype.where = function(o3) {
      if ("string" == typeof o3)
        return new this.db.WhereClause(this, o3);
      if (x2(o3))
        return new this.db.WhereClause(this, "[".concat(o3.join("+"), "]"));
      var n3 = _2(o3);
      if (1 === n3.length)
        return this.where(n3[0]).equals(o3[n3[0]]);
      var e3 = this.schema.indexes.concat(this.schema.primKey).filter(function(t4) {
        if (t4.compound && n3.every(function(e5) {
          return 0 <= t4.keyPath.indexOf(e5);
        })) {
          for (var e4 = 0; e4 < n3.length; ++e4)
            if (-1 === n3.indexOf(t4.keyPath[e4]))
              return false;
          return true;
        }
        return false;
      }).sort(function(e4, t4) {
        return e4.keyPath.length - t4.keyPath.length;
      })[0];
      if (e3 && this.db._maxKey !== He) {
        var t3 = e3.keyPath.slice(0, n3.length);
        return this.where(t3).equals(t3.map(function(e4) {
          return o3[e4];
        }));
      }
      !e3 && ie && console.warn("The query ".concat(JSON.stringify(o3), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(n3.join("+"), "]"));
      var a3 = this.schema.idxByName, r3 = this.db._deps.indexedDB;
      function u2(e4, t4) {
        return 0 === r3.cmp(e4, t4);
      }
      var i3 = n3.reduce(function(e4, t4) {
        var n4 = e4[0], r4 = e4[1], e4 = a3[t4], i4 = o3[t4];
        return [n4 || e4, n4 || !e4 ? it2(r4, e4 && e4.multi ? function(e5) {
          e5 = k2(e5, t4);
          return x2(e5) && e5.some(function(e6) {
            return u2(i4, e6);
          });
        } : function(e5) {
          return u2(i4, k2(e5, t4));
        }) : r4];
      }, [null, null]), t3 = i3[0], i3 = i3[1];
      return t3 ? this.where(t3.name).equals(o3[t3.keyPath]).filter(i3) : e3 ? this.filter(i3) : this.where(n3).equals("");
    }, ht.prototype.filter = function(e3) {
      return this.toCollection().and(e3);
    }, ht.prototype.count = function(e3) {
      return this.toCollection().count(e3);
    }, ht.prototype.offset = function(e3) {
      return this.toCollection().offset(e3);
    }, ht.prototype.limit = function(e3) {
      return this.toCollection().limit(e3);
    }, ht.prototype.each = function(e3) {
      return this.toCollection().each(e3);
    }, ht.prototype.toArray = function(e3) {
      return this.toCollection().toArray(e3);
    }, ht.prototype.toCollection = function() {
      return new this.db.Collection(new this.db.WhereClause(this));
    }, ht.prototype.orderBy = function(e3) {
      return new this.db.Collection(new this.db.WhereClause(this, x2(e3) ? "[".concat(e3.join("+"), "]") : e3));
    }, ht.prototype.reverse = function() {
      return this.toCollection().reverse();
    }, ht.prototype.mapToClass = function(r3) {
      var e3, t3 = this.db, n3 = this.name;
      function i3() {
        return null !== e3 && e3.apply(this, arguments) || this;
      }
      (this.schema.mappedClass = r3).prototype instanceof ut && (function(e4, t4) {
        if ("function" != typeof t4 && null !== t4)
          throw new TypeError("Class extends value " + String(t4) + " is not a constructor or null");
        function n4() {
          this.constructor = e4;
        }
        s(e4, t4), e4.prototype = null === t4 ? Object.create(t4) : (n4.prototype = t4.prototype, new n4());
      }(i3, e3 = r3), Object.defineProperty(i3.prototype, "db", { get: function() {
        return t3;
      }, enumerable: false, configurable: true }), i3.prototype.table = function() {
        return n3;
      }, r3 = i3);
      for (var o3 = /* @__PURE__ */ new Set(), a3 = r3.prototype; a3; a3 = c(a3))
        Object.getOwnPropertyNames(a3).forEach(function(e4) {
          return o3.add(e4);
        });
      function u2(e4) {
        if (!e4)
          return e4;
        var t4, n4 = Object.create(r3.prototype);
        for (t4 in e4)
          if (!o3.has(t4))
            try {
              n4[t4] = e4[t4];
            } catch (e5) {
            }
        return n4;
      }
      return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = u2, this.hook("reading", u2), r3;
    }, ht.prototype.defineClass = function() {
      return this.mapToClass(function(e3) {
        a2(this, e3);
      });
    }, ht.prototype.add = function(t3, n3) {
      var r3 = this, e3 = this.schema.primKey, i3 = e3.auto, o3 = e3.keyPath, a3 = t3;
      return o3 && i3 && (a3 = at(o3)(t3)), this._trans("readwrite", function(e4) {
        return r3.core.mutate({ trans: e4, type: "add", keys: null != n3 ? [n3] : null, values: [a3] });
      }).then(function(e4) {
        return e4.numFailures ? _e.reject(e4.failures[0]) : e4.lastResult;
      }).then(function(e4) {
        if (o3)
          try {
            P(t3, o3, e4);
          } catch (e5) {
          }
        return e4;
      });
    }, ht.prototype.update = function(e3, t3) {
      if ("object" != typeof e3 || x2(e3))
        return this.where(":id").equals(e3).modify(t3);
      e3 = k2(e3, this.schema.primKey.keyPath);
      return void 0 === e3 ? Xe(new Y.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e3).modify(t3);
    }, ht.prototype.put = function(t3, n3) {
      var r3 = this, e3 = this.schema.primKey, i3 = e3.auto, o3 = e3.keyPath, a3 = t3;
      return o3 && i3 && (a3 = at(o3)(t3)), this._trans("readwrite", function(e4) {
        return r3.core.mutate({ trans: e4, type: "put", values: [a3], keys: null != n3 ? [n3] : null });
      }).then(function(e4) {
        return e4.numFailures ? _e.reject(e4.failures[0]) : e4.lastResult;
      }).then(function(e4) {
        if (o3)
          try {
            P(t3, o3, e4);
          } catch (e5) {
          }
        return e4;
      });
    }, ht.prototype.delete = function(t3) {
      var n3 = this;
      return this._trans("readwrite", function(e3) {
        return n3.core.mutate({ trans: e3, type: "delete", keys: [t3] });
      }).then(function(e3) {
        return e3.numFailures ? _e.reject(e3.failures[0]) : void 0;
      });
    }, ht.prototype.clear = function() {
      var t3 = this;
      return this._trans("readwrite", function(e3) {
        return t3.core.mutate({ trans: e3, type: "deleteRange", range: ot });
      }).then(function(e3) {
        return e3.numFailures ? _e.reject(e3.failures[0]) : void 0;
      });
    }, ht.prototype.bulkGet = function(t3) {
      var n3 = this;
      return this._trans("readonly", function(e3) {
        return n3.core.getMany({ keys: t3, trans: e3 }).then(function(e4) {
          return e4.map(function(e5) {
            return n3.hook.reading.fire(e5);
          });
        });
      });
    }, ht.prototype.bulkAdd = function(r3, e3, t3) {
      var o3 = this, a3 = Array.isArray(e3) ? e3 : void 0, u2 = (t3 = t3 || (a3 ? void 0 : e3)) ? t3.allKeys : void 0;
      return this._trans("readwrite", function(e4) {
        var t4 = o3.schema.primKey, n3 = t4.auto, t4 = t4.keyPath;
        if (t4 && a3)
          throw new Y.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
        if (a3 && a3.length !== r3.length)
          throw new Y.InvalidArgument("Arguments objects and keys must have the same length");
        var i3 = r3.length, t4 = t4 && n3 ? r3.map(at(t4)) : r3;
        return o3.core.mutate({ trans: e4, type: "add", keys: a3, values: t4, wantResults: u2 }).then(function(e5) {
          var t5 = e5.numFailures, n4 = e5.results, r4 = e5.lastResult, e5 = e5.failures;
          if (0 === t5)
            return u2 ? n4 : r4;
          throw new z2("".concat(o3.name, ".bulkAdd(): ").concat(t5, " of ").concat(i3, " operations failed"), e5);
        });
      });
    }, ht.prototype.bulkPut = function(r3, e3, t3) {
      var o3 = this, a3 = Array.isArray(e3) ? e3 : void 0, u2 = (t3 = t3 || (a3 ? void 0 : e3)) ? t3.allKeys : void 0;
      return this._trans("readwrite", function(e4) {
        var t4 = o3.schema.primKey, n3 = t4.auto, t4 = t4.keyPath;
        if (t4 && a3)
          throw new Y.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
        if (a3 && a3.length !== r3.length)
          throw new Y.InvalidArgument("Arguments objects and keys must have the same length");
        var i3 = r3.length, t4 = t4 && n3 ? r3.map(at(t4)) : r3;
        return o3.core.mutate({ trans: e4, type: "put", keys: a3, values: t4, wantResults: u2 }).then(function(e5) {
          var t5 = e5.numFailures, n4 = e5.results, r4 = e5.lastResult, e5 = e5.failures;
          if (0 === t5)
            return u2 ? n4 : r4;
          throw new z2("".concat(o3.name, ".bulkPut(): ").concat(t5, " of ").concat(i3, " operations failed"), e5);
        });
      });
    }, ht.prototype.bulkUpdate = function(t3) {
      var h3 = this, n3 = this.core, r3 = t3.map(function(e3) {
        return e3.key;
      }), i3 = t3.map(function(e3) {
        return e3.changes;
      }), d2 = [];
      return this._trans("readwrite", function(e3) {
        return n3.getMany({ trans: e3, keys: r3, cache: "clone" }).then(function(c2) {
          var l3 = [], f3 = [];
          t3.forEach(function(e4, t4) {
            var n4 = e4.key, r4 = e4.changes, i4 = c2[t4];
            if (i4) {
              for (var o3 = 0, a3 = Object.keys(r4); o3 < a3.length; o3++) {
                var u2 = a3[o3], s3 = r4[u2];
                if (u2 === h3.schema.primKey.keyPath) {
                  if (0 !== st(s3, n4))
                    throw new Y.Constraint("Cannot update primary key in bulkUpdate()");
                } else
                  P(i4, u2, s3);
              }
              d2.push(t4), l3.push(n4), f3.push(i4);
            }
          });
          var s2 = l3.length;
          return n3.mutate({ trans: e3, type: "put", keys: l3, values: f3, updates: { keys: r3, changeSpecs: i3 } }).then(function(e4) {
            var t4 = e4.numFailures, n4 = e4.failures;
            if (0 === t4)
              return s2;
            for (var r4 = 0, i4 = Object.keys(n4); r4 < i4.length; r4++) {
              var o3, a3 = i4[r4], u2 = d2[Number(a3)];
              null != u2 && (o3 = n4[a3], delete n4[a3], n4[u2] = o3);
            }
            throw new z2("".concat(h3.name, ".bulkUpdate(): ").concat(t4, " of ").concat(s2, " operations failed"), n4);
          });
        });
      });
    }, ht.prototype.bulkDelete = function(t3) {
      var r3 = this, i3 = t3.length;
      return this._trans("readwrite", function(e3) {
        return r3.core.mutate({ trans: e3, type: "delete", keys: t3 });
      }).then(function(e3) {
        var t4 = e3.numFailures, n3 = e3.lastResult, e3 = e3.failures;
        if (0 === t4)
          return n3;
        throw new z2("".concat(r3.name, ".bulkDelete(): ").concat(t4, " of ").concat(i3, " operations failed"), e3);
      });
    }, ht);
    function ht() {
    }
    function dt(i3) {
      function t3(e4, t4) {
        if (t4) {
          for (var n4 = arguments.length, r3 = new Array(n4 - 1); --n4; )
            r3[n4 - 1] = arguments[n4];
          return a3[e4].subscribe.apply(null, r3), i3;
        }
        if ("string" == typeof e4)
          return a3[e4];
      }
      var a3 = {};
      t3.addEventType = u2;
      for (var e3 = 1, n3 = arguments.length; e3 < n3; ++e3)
        u2(arguments[e3]);
      return t3;
      function u2(e4, n4, r3) {
        if ("object" != typeof e4) {
          var i4;
          n4 = n4 || ne;
          var o3 = { subscribers: [], fire: r3 = r3 || G, subscribe: function(e5) {
            -1 === o3.subscribers.indexOf(e5) && (o3.subscribers.push(e5), o3.fire = n4(o3.fire, e5));
          }, unsubscribe: function(t4) {
            o3.subscribers = o3.subscribers.filter(function(e5) {
              return e5 !== t4;
            }), o3.fire = o3.subscribers.reduce(n4, r3);
          } };
          return a3[e4] = t3[e4] = o3;
        }
        _2(i4 = e4).forEach(function(e5) {
          var t4 = i4[e5];
          if (x2(t4))
            u2(e5, i4[e5][0], i4[e5][1]);
          else {
            if ("asap" !== t4)
              throw new Y.InvalidArgument("Invalid event config");
            var n5 = u2(e5, X2, function() {
              for (var e6 = arguments.length, t5 = new Array(e6); e6--; )
                t5[e6] = arguments[e6];
              n5.subscribers.forEach(function(e7) {
                v2(function() {
                  e7.apply(null, t5);
                });
              });
            });
          }
        });
      }
    }
    function pt2(e3, t3) {
      return o2(t3).from({ prototype: e3 }), t3;
    }
    function yt(e3, t3) {
      return !(e3.filter || e3.algorithm || e3.or) && (t3 ? e3.justLimit : !e3.replayFilter);
    }
    function vt(e3, t3) {
      e3.filter = it2(e3.filter, t3);
    }
    function mt(e3, t3, n3) {
      var r3 = e3.replayFilter;
      e3.replayFilter = r3 ? function() {
        return it2(r3(), t3());
      } : t3, e3.justLimit = n3 && !r3;
    }
    function bt(e3, t3) {
      if (e3.isPrimKey)
        return t3.primaryKey;
      var n3 = t3.getIndexByKeyPath(e3.index);
      if (!n3)
        throw new Y.Schema("KeyPath " + e3.index + " on object store " + t3.name + " is not indexed");
      return n3;
    }
    function gt(e3, t3, n3) {
      var r3 = bt(e3, t3.schema);
      return t3.openCursor({ trans: n3, values: !e3.keysOnly, reverse: "prev" === e3.dir, unique: !!e3.unique, query: { index: r3, range: e3.range } });
    }
    function wt(e3, o3, t3, n3) {
      var a3 = e3.replayFilter ? it2(e3.filter, e3.replayFilter()) : e3.filter;
      if (e3.or) {
        var u2 = {}, r3 = function(e4, t4, n4) {
          var r4, i3;
          a3 && !a3(t4, n4, function(e5) {
            return t4.stop(e5);
          }, function(e5) {
            return t4.fail(e5);
          }) || ("[object ArrayBuffer]" === (i3 = "" + (r4 = t4.primaryKey)) && (i3 = "" + new Uint8Array(r4)), m2(u2, i3) || (u2[i3] = true, o3(e4, t4, n4)));
        };
        return Promise.all([e3.or._iterate(r3, t3), _t(gt(e3, n3, t3), e3.algorithm, r3, !e3.keysOnly && e3.valueMapper)]);
      }
      return _t(gt(e3, n3, t3), it2(e3.algorithm, a3), o3, !e3.keysOnly && e3.valueMapper);
    }
    function _t(e3, r3, i3, o3) {
      var a3 = Te(o3 ? function(e4, t3, n3) {
        return i3(o3(e4), t3, n3);
      } : i3);
      return e3.then(function(n3) {
        if (n3)
          return n3.start(function() {
            var t3 = function() {
              return n3.continue();
            };
            r3 && !r3(n3, function(e4) {
              return t3 = e4;
            }, function(e4) {
              n3.stop(e4), t3 = G;
            }, function(e4) {
              n3.fail(e4), t3 = G;
            }) || a3(n3.value, n3, function(e4) {
              return t3 = e4;
            }), t3();
          });
      });
    }
    var e2 = Symbol(), xt = (kt.prototype.execute = function(e3) {
      if (void 0 !== this.add) {
        var t3 = this.add;
        if (x2(t3))
          return i2(i2([], x2(e3) ? e3 : [], true), t3).sort();
        if ("number" == typeof t3)
          return (Number(e3) || 0) + t3;
        if ("bigint" == typeof t3)
          try {
            return BigInt(e3) + t3;
          } catch (e4) {
            return BigInt(0) + t3;
          }
        throw new TypeError("Invalid term ".concat(t3));
      }
      if (void 0 !== this.remove) {
        var n3 = this.remove;
        if (x2(n3))
          return x2(e3) ? e3.filter(function(e4) {
            return !n3.includes(e4);
          }).sort() : [];
        if ("number" == typeof n3)
          return Number(e3) - n3;
        if ("bigint" == typeof n3)
          try {
            return BigInt(e3) - n3;
          } catch (e4) {
            return BigInt(0) - n3;
          }
        throw new TypeError("Invalid subtrahend ".concat(n3));
      }
      t3 = null === (t3 = this.replacePrefix) || void 0 === t3 ? void 0 : t3[0];
      return t3 && "string" == typeof e3 && e3.startsWith(t3) ? this.replacePrefix[1] + e3.substring(t3.length) : e3;
    }, kt);
    function kt(e3) {
      Object.assign(this, e3);
    }
    var Ot = (Pt.prototype._read = function(e3, t3) {
      var n3 = this._ctx;
      return n3.error ? n3.table._trans(null, Xe.bind(null, n3.error)) : n3.table._trans("readonly", e3).then(t3);
    }, Pt.prototype._write = function(e3) {
      var t3 = this._ctx;
      return t3.error ? t3.table._trans(null, Xe.bind(null, t3.error)) : t3.table._trans("readwrite", e3, "locked");
    }, Pt.prototype._addAlgorithm = function(e3) {
      var t3 = this._ctx;
      t3.algorithm = it2(t3.algorithm, e3);
    }, Pt.prototype._iterate = function(e3, t3) {
      return wt(this._ctx, e3, t3, this._ctx.table.core);
    }, Pt.prototype.clone = function(e3) {
      var t3 = Object.create(this.constructor.prototype), n3 = Object.create(this._ctx);
      return e3 && a2(n3, e3), t3._ctx = n3, t3;
    }, Pt.prototype.raw = function() {
      return this._ctx.valueMapper = null, this;
    }, Pt.prototype.each = function(t3) {
      var n3 = this._ctx;
      return this._read(function(e3) {
        return wt(n3, t3, e3, n3.table.core);
      });
    }, Pt.prototype.count = function(e3) {
      var i3 = this;
      return this._read(function(e4) {
        var t3 = i3._ctx, n3 = t3.table.core;
        if (yt(t3, true))
          return n3.count({ trans: e4, query: { index: bt(t3, n3.schema), range: t3.range } }).then(function(e5) {
            return Math.min(e5, t3.limit);
          });
        var r3 = 0;
        return wt(t3, function() {
          return ++r3, false;
        }, e4, n3).then(function() {
          return r3;
        });
      }).then(e3);
    }, Pt.prototype.sortBy = function(e3, t3) {
      var n3 = e3.split(".").reverse(), r3 = n3[0], i3 = n3.length - 1;
      function o3(e4, t4) {
        return t4 ? o3(e4[n3[t4]], t4 - 1) : e4[r3];
      }
      var a3 = "next" === this._ctx.dir ? 1 : -1;
      function u2(e4, t4) {
        e4 = o3(e4, i3), t4 = o3(t4, i3);
        return e4 < t4 ? -a3 : t4 < e4 ? a3 : 0;
      }
      return this.toArray(function(e4) {
        return e4.sort(u2);
      }).then(t3);
    }, Pt.prototype.toArray = function(e3) {
      var o3 = this;
      return this._read(function(e4) {
        var t3 = o3._ctx;
        if ("next" === t3.dir && yt(t3, true) && 0 < t3.limit) {
          var n3 = t3.valueMapper, r3 = bt(t3, t3.table.core.schema);
          return t3.table.core.query({ trans: e4, limit: t3.limit, values: true, query: { index: r3, range: t3.range } }).then(function(e5) {
            e5 = e5.result;
            return n3 ? e5.map(n3) : e5;
          });
        }
        var i3 = [];
        return wt(t3, function(e5) {
          return i3.push(e5);
        }, e4, t3.table.core).then(function() {
          return i3;
        });
      }, e3);
    }, Pt.prototype.offset = function(t3) {
      var e3 = this._ctx;
      return t3 <= 0 || (e3.offset += t3, yt(e3) ? mt(e3, function() {
        var n3 = t3;
        return function(e4, t4) {
          return 0 === n3 || (1 === n3 ? --n3 : t4(function() {
            e4.advance(n3), n3 = 0;
          }), false);
        };
      }) : mt(e3, function() {
        var e4 = t3;
        return function() {
          return --e4 < 0;
        };
      })), this;
    }, Pt.prototype.limit = function(e3) {
      return this._ctx.limit = Math.min(this._ctx.limit, e3), mt(this._ctx, function() {
        var r3 = e3;
        return function(e4, t3, n3) {
          return --r3 <= 0 && t3(n3), 0 <= r3;
        };
      }, true), this;
    }, Pt.prototype.until = function(r3, i3) {
      return vt(this._ctx, function(e3, t3, n3) {
        return !r3(e3.value) || (t3(n3), i3);
      }), this;
    }, Pt.prototype.first = function(e3) {
      return this.limit(1).toArray(function(e4) {
        return e4[0];
      }).then(e3);
    }, Pt.prototype.last = function(e3) {
      return this.reverse().first(e3);
    }, Pt.prototype.filter = function(t3) {
      var e3;
      return vt(this._ctx, function(e4) {
        return t3(e4.value);
      }), (e3 = this._ctx).isMatch = it2(e3.isMatch, t3), this;
    }, Pt.prototype.and = function(e3) {
      return this.filter(e3);
    }, Pt.prototype.or = function(e3) {
      return new this.db.WhereClause(this._ctx.table, e3, this);
    }, Pt.prototype.reverse = function() {
      return this._ctx.dir = "prev" === this._ctx.dir ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
    }, Pt.prototype.desc = function() {
      return this.reverse();
    }, Pt.prototype.eachKey = function(n3) {
      var e3 = this._ctx;
      return e3.keysOnly = !e3.isMatch, this.each(function(e4, t3) {
        n3(t3.key, t3);
      });
    }, Pt.prototype.eachUniqueKey = function(e3) {
      return this._ctx.unique = "unique", this.eachKey(e3);
    }, Pt.prototype.eachPrimaryKey = function(n3) {
      var e3 = this._ctx;
      return e3.keysOnly = !e3.isMatch, this.each(function(e4, t3) {
        n3(t3.primaryKey, t3);
      });
    }, Pt.prototype.keys = function(e3) {
      var t3 = this._ctx;
      t3.keysOnly = !t3.isMatch;
      var n3 = [];
      return this.each(function(e4, t4) {
        n3.push(t4.key);
      }).then(function() {
        return n3;
      }).then(e3);
    }, Pt.prototype.primaryKeys = function(e3) {
      var n3 = this._ctx;
      if ("next" === n3.dir && yt(n3, true) && 0 < n3.limit)
        return this._read(function(e4) {
          var t3 = bt(n3, n3.table.core.schema);
          return n3.table.core.query({ trans: e4, values: false, limit: n3.limit, query: { index: t3, range: n3.range } });
        }).then(function(e4) {
          return e4.result;
        }).then(e3);
      n3.keysOnly = !n3.isMatch;
      var r3 = [];
      return this.each(function(e4, t3) {
        r3.push(t3.primaryKey);
      }).then(function() {
        return r3;
      }).then(e3);
    }, Pt.prototype.uniqueKeys = function(e3) {
      return this._ctx.unique = "unique", this.keys(e3);
    }, Pt.prototype.firstKey = function(e3) {
      return this.limit(1).keys(function(e4) {
        return e4[0];
      }).then(e3);
    }, Pt.prototype.lastKey = function(e3) {
      return this.reverse().firstKey(e3);
    }, Pt.prototype.distinct = function() {
      var e3 = this._ctx, e3 = e3.index && e3.table.schema.idxByName[e3.index];
      if (!e3 || !e3.multi)
        return this;
      var n3 = {};
      return vt(this._ctx, function(e4) {
        var t3 = e4.primaryKey.toString(), e4 = m2(n3, t3);
        return n3[t3] = true, !e4;
      }), this;
    }, Pt.prototype.modify = function(w3) {
      var n3 = this, r3 = this._ctx;
      return this._write(function(d2) {
        var a3, u2, p3;
        p3 = "function" == typeof w3 ? w3 : (a3 = _2(w3), u2 = a3.length, function(e4) {
          for (var t4 = false, n4 = 0; n4 < u2; ++n4) {
            var r4 = a3[n4], i3 = w3[r4], o3 = k2(e4, r4);
            i3 instanceof xt ? (P(e4, r4, i3.execute(o3)), t4 = true) : o3 !== i3 && (P(e4, r4, i3), t4 = true);
          }
          return t4;
        });
        function y3(e4, t4) {
          var n4 = t4.failures, t4 = t4.numFailures;
          c2 += e4 - t4;
          for (var r4 = 0, i3 = _2(n4); r4 < i3.length; r4++) {
            var o3 = i3[r4];
            s2.push(n4[o3]);
          }
        }
        var v3 = r3.table.core, e3 = v3.schema.primaryKey, m3 = e3.outbound, b3 = e3.extractKey, g3 = n3.db._options.modifyChunkSize || 200, s2 = [], c2 = 0, t3 = [];
        return n3.clone().primaryKeys().then(function(l3) {
          function f3(s3) {
            var c3 = Math.min(g3, l3.length - s3);
            return v3.getMany({ trans: d2, keys: l3.slice(s3, s3 + c3), cache: "immutable" }).then(function(e4) {
              for (var n4 = [], t4 = [], r4 = m3 ? [] : null, i3 = [], o3 = 0; o3 < c3; ++o3) {
                var a4 = e4[o3], u3 = { value: S2(a4), primKey: l3[s3 + o3] };
                false !== p3.call(u3, u3.value, u3) && (null == u3.value ? i3.push(l3[s3 + o3]) : m3 || 0 === st(b3(a4), b3(u3.value)) ? (t4.push(u3.value), m3 && r4.push(l3[s3 + o3])) : (i3.push(l3[s3 + o3]), n4.push(u3.value)));
              }
              return Promise.resolve(0 < n4.length && v3.mutate({ trans: d2, type: "add", values: n4 }).then(function(e5) {
                for (var t5 in e5.failures)
                  i3.splice(parseInt(t5), 1);
                y3(n4.length, e5);
              })).then(function() {
                return (0 < t4.length || h3 && "object" == typeof w3) && v3.mutate({ trans: d2, type: "put", keys: r4, values: t4, criteria: h3, changeSpec: "function" != typeof w3 && w3, isAdditionalChunk: 0 < s3 }).then(function(e5) {
                  return y3(t4.length, e5);
                });
              }).then(function() {
                return (0 < i3.length || h3 && w3 === Et) && v3.mutate({ trans: d2, type: "delete", keys: i3, criteria: h3, isAdditionalChunk: 0 < s3 }).then(function(e5) {
                  return y3(i3.length, e5);
                });
              }).then(function() {
                return l3.length > s3 + c3 && f3(s3 + g3);
              });
            });
          }
          var h3 = yt(r3) && r3.limit === 1 / 0 && ("function" != typeof w3 || w3 === Et) && { index: r3.index, range: r3.range };
          return f3(0).then(function() {
            if (0 < s2.length)
              throw new U2("Error modifying one or more objects", s2, c2, t3);
            return l3.length;
          });
        });
      });
    }, Pt.prototype.delete = function() {
      var i3 = this._ctx, n3 = i3.range;
      return yt(i3) && (i3.isPrimKey || 3 === n3.type) ? this._write(function(e3) {
        var t3 = i3.table.core.schema.primaryKey, r3 = n3;
        return i3.table.core.count({ trans: e3, query: { index: t3, range: r3 } }).then(function(n4) {
          return i3.table.core.mutate({ trans: e3, type: "deleteRange", range: r3 }).then(function(e4) {
            var t4 = e4.failures;
            e4.lastResult, e4.results;
            e4 = e4.numFailures;
            if (e4)
              throw new U2("Could not delete some values", Object.keys(t4).map(function(e5) {
                return t4[e5];
              }), n4 - e4);
            return n4 - e4;
          });
        });
      }) : this.modify(Et);
    }, Pt);
    function Pt() {
    }
    var Et = function(e3, t3) {
      return t3.value = null;
    };
    function Kt(e3, t3) {
      return e3 < t3 ? -1 : e3 === t3 ? 0 : 1;
    }
    function St(e3, t3) {
      return t3 < e3 ? -1 : e3 === t3 ? 0 : 1;
    }
    function jt(e3, t3, n3) {
      e3 = e3 instanceof qt ? new e3.Collection(e3) : e3;
      return e3._ctx.error = new (n3 || TypeError)(t3), e3;
    }
    function At(e3) {
      return new e3.Collection(e3, function() {
        return Tt("");
      }).limit(0);
    }
    function Ct(e3, s2, n3, r3) {
      var i3, c2, l3, f3, h3, d2, p3, y3 = n3.length;
      if (!n3.every(function(e4) {
        return "string" == typeof e4;
      }))
        return jt(e3, Ze);
      function t3(e4) {
        i3 = "next" === e4 ? function(e5) {
          return e5.toUpperCase();
        } : function(e5) {
          return e5.toLowerCase();
        }, c2 = "next" === e4 ? function(e5) {
          return e5.toLowerCase();
        } : function(e5) {
          return e5.toUpperCase();
        }, l3 = "next" === e4 ? Kt : St;
        var t4 = n3.map(function(e5) {
          return { lower: c2(e5), upper: i3(e5) };
        }).sort(function(e5, t5) {
          return l3(e5.lower, t5.lower);
        });
        f3 = t4.map(function(e5) {
          return e5.upper;
        }), h3 = t4.map(function(e5) {
          return e5.lower;
        }), p3 = "next" === (d2 = e4) ? "" : r3;
      }
      t3("next");
      e3 = new e3.Collection(e3, function() {
        return Dt(f3[0], h3[y3 - 1] + r3);
      });
      e3._ondirectionchange = function(e4) {
        t3(e4);
      };
      var v3 = 0;
      return e3._addAlgorithm(function(e4, t4, n4) {
        var r4 = e4.key;
        if ("string" != typeof r4)
          return false;
        var i4 = c2(r4);
        if (s2(i4, h3, v3))
          return true;
        for (var o3 = null, a3 = v3; a3 < y3; ++a3) {
          var u2 = function(e5, t5, n5, r5, i5, o4) {
            for (var a4 = Math.min(e5.length, r5.length), u3 = -1, s3 = 0; s3 < a4; ++s3) {
              var c3 = t5[s3];
              if (c3 !== r5[s3])
                return i5(e5[s3], n5[s3]) < 0 ? e5.substr(0, s3) + n5[s3] + n5.substr(s3 + 1) : i5(e5[s3], r5[s3]) < 0 ? e5.substr(0, s3) + r5[s3] + n5.substr(s3 + 1) : 0 <= u3 ? e5.substr(0, u3) + t5[u3] + n5.substr(u3 + 1) : null;
              i5(e5[s3], c3) < 0 && (u3 = s3);
            }
            return a4 < r5.length && "next" === o4 ? e5 + n5.substr(e5.length) : a4 < e5.length && "prev" === o4 ? e5.substr(0, n5.length) : u3 < 0 ? null : e5.substr(0, u3) + r5[u3] + n5.substr(u3 + 1);
          }(r4, i4, f3[a3], h3[a3], l3, d2);
          null === u2 && null === o3 ? v3 = a3 + 1 : (null === o3 || 0 < l3(o3, u2)) && (o3 = u2);
        }
        return t4(null !== o3 ? function() {
          e4.continue(o3 + p3);
        } : n4), false;
      }), e3;
    }
    function Dt(e3, t3, n3, r3) {
      return { type: 2, lower: e3, upper: t3, lowerOpen: n3, upperOpen: r3 };
    }
    function Tt(e3) {
      return { type: 1, lower: e3, upper: e3 };
    }
    var qt = (Object.defineProperty(It.prototype, "Collection", { get: function() {
      return this._ctx.table.db.Collection;
    }, enumerable: false, configurable: true }), It.prototype.between = function(e3, t3, n3, r3) {
      n3 = false !== n3, r3 = true === r3;
      try {
        return 0 < this._cmp(e3, t3) || 0 === this._cmp(e3, t3) && (n3 || r3) && (!n3 || !r3) ? At(this) : new this.Collection(this, function() {
          return Dt(e3, t3, !n3, !r3);
        });
      } catch (e4) {
        return jt(this, Je);
      }
    }, It.prototype.equals = function(e3) {
      return null == e3 ? jt(this, Je) : new this.Collection(this, function() {
        return Tt(e3);
      });
    }, It.prototype.above = function(e3) {
      return null == e3 ? jt(this, Je) : new this.Collection(this, function() {
        return Dt(e3, void 0, true);
      });
    }, It.prototype.aboveOrEqual = function(e3) {
      return null == e3 ? jt(this, Je) : new this.Collection(this, function() {
        return Dt(e3, void 0, false);
      });
    }, It.prototype.below = function(e3) {
      return null == e3 ? jt(this, Je) : new this.Collection(this, function() {
        return Dt(void 0, e3, false, true);
      });
    }, It.prototype.belowOrEqual = function(e3) {
      return null == e3 ? jt(this, Je) : new this.Collection(this, function() {
        return Dt(void 0, e3);
      });
    }, It.prototype.startsWith = function(e3) {
      return "string" != typeof e3 ? jt(this, Ze) : this.between(e3, e3 + He, true, true);
    }, It.prototype.startsWithIgnoreCase = function(e3) {
      return "" === e3 ? this.startsWith(e3) : Ct(this, function(e4, t3) {
        return 0 === e4.indexOf(t3[0]);
      }, [e3], He);
    }, It.prototype.equalsIgnoreCase = function(e3) {
      return Ct(this, function(e4, t3) {
        return e4 === t3[0];
      }, [e3], "");
    }, It.prototype.anyOfIgnoreCase = function() {
      var e3 = I.apply(q, arguments);
      return 0 === e3.length ? At(this) : Ct(this, function(e4, t3) {
        return -1 !== t3.indexOf(e4);
      }, e3, "");
    }, It.prototype.startsWithAnyOfIgnoreCase = function() {
      var e3 = I.apply(q, arguments);
      return 0 === e3.length ? At(this) : Ct(this, function(t3, e4) {
        return e4.some(function(e5) {
          return 0 === t3.indexOf(e5);
        });
      }, e3, He);
    }, It.prototype.anyOf = function() {
      var t3 = this, i3 = I.apply(q, arguments), o3 = this._cmp;
      try {
        i3.sort(o3);
      } catch (e4) {
        return jt(this, Je);
      }
      if (0 === i3.length)
        return At(this);
      var e3 = new this.Collection(this, function() {
        return Dt(i3[0], i3[i3.length - 1]);
      });
      e3._ondirectionchange = function(e4) {
        o3 = "next" === e4 ? t3._ascending : t3._descending, i3.sort(o3);
      };
      var a3 = 0;
      return e3._addAlgorithm(function(e4, t4, n3) {
        for (var r3 = e4.key; 0 < o3(r3, i3[a3]); )
          if (++a3 === i3.length)
            return t4(n3), false;
        return 0 === o3(r3, i3[a3]) || (t4(function() {
          e4.continue(i3[a3]);
        }), false);
      }), e3;
    }, It.prototype.notEqual = function(e3) {
      return this.inAnyRange([[-1 / 0, e3], [e3, this.db._maxKey]], { includeLowers: false, includeUppers: false });
    }, It.prototype.noneOf = function() {
      var e3 = I.apply(q, arguments);
      if (0 === e3.length)
        return new this.Collection(this);
      try {
        e3.sort(this._ascending);
      } catch (e4) {
        return jt(this, Je);
      }
      var t3 = e3.reduce(function(e4, t4) {
        return e4 ? e4.concat([[e4[e4.length - 1][1], t4]]) : [[-1 / 0, t4]];
      }, null);
      return t3.push([e3[e3.length - 1], this.db._maxKey]), this.inAnyRange(t3, { includeLowers: false, includeUppers: false });
    }, It.prototype.inAnyRange = function(e3, t3) {
      var o3 = this, a3 = this._cmp, u2 = this._ascending, n3 = this._descending, s2 = this._min, c2 = this._max;
      if (0 === e3.length)
        return At(this);
      if (!e3.every(function(e4) {
        return void 0 !== e4[0] && void 0 !== e4[1] && u2(e4[0], e4[1]) <= 0;
      }))
        return jt(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Y.InvalidArgument);
      var r3 = !t3 || false !== t3.includeLowers, i3 = t3 && true === t3.includeUppers;
      var l3, f3 = u2;
      function h3(e4, t4) {
        return f3(e4[0], t4[0]);
      }
      try {
        (l3 = e3.reduce(function(e4, t4) {
          for (var n4 = 0, r4 = e4.length; n4 < r4; ++n4) {
            var i4 = e4[n4];
            if (a3(t4[0], i4[1]) < 0 && 0 < a3(t4[1], i4[0])) {
              i4[0] = s2(i4[0], t4[0]), i4[1] = c2(i4[1], t4[1]);
              break;
            }
          }
          return n4 === r4 && e4.push(t4), e4;
        }, [])).sort(h3);
      } catch (e4) {
        return jt(this, Je);
      }
      var d2 = 0, p3 = i3 ? function(e4) {
        return 0 < u2(e4, l3[d2][1]);
      } : function(e4) {
        return 0 <= u2(e4, l3[d2][1]);
      }, y3 = r3 ? function(e4) {
        return 0 < n3(e4, l3[d2][0]);
      } : function(e4) {
        return 0 <= n3(e4, l3[d2][0]);
      };
      var v3 = p3, e3 = new this.Collection(this, function() {
        return Dt(l3[0][0], l3[l3.length - 1][1], !r3, !i3);
      });
      return e3._ondirectionchange = function(e4) {
        f3 = "next" === e4 ? (v3 = p3, u2) : (v3 = y3, n3), l3.sort(h3);
      }, e3._addAlgorithm(function(e4, t4, n4) {
        for (var r4, i4 = e4.key; v3(i4); )
          if (++d2 === l3.length)
            return t4(n4), false;
        return !p3(r4 = i4) && !y3(r4) || (0 === o3._cmp(i4, l3[d2][1]) || 0 === o3._cmp(i4, l3[d2][0]) || t4(function() {
          f3 === u2 ? e4.continue(l3[d2][0]) : e4.continue(l3[d2][1]);
        }), false);
      }), e3;
    }, It.prototype.startsWithAnyOf = function() {
      var e3 = I.apply(q, arguments);
      return e3.every(function(e4) {
        return "string" == typeof e4;
      }) ? 0 === e3.length ? At(this) : this.inAnyRange(e3.map(function(e4) {
        return [e4, e4 + He];
      })) : jt(this, "startsWithAnyOf() only works with strings");
    }, It);
    function It() {
    }
    function Bt(t3) {
      return Te(function(e3) {
        return Rt(e3), t3(e3.target.error), false;
      });
    }
    function Rt(e3) {
      e3.stopPropagation && e3.stopPropagation(), e3.preventDefault && e3.preventDefault();
    }
    var Ft = "storagemutated", Mt = "x-storagemutated-1", Nt = dt(null, Ft), Lt = (Ut.prototype._lock = function() {
      return y2(!me.global), ++this._reculock, 1 !== this._reculock || me.global || (me.lockOwnerFor = this), this;
    }, Ut.prototype._unlock = function() {
      if (y2(!me.global), 0 == --this._reculock)
        for (me.global || (me.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var e3 = this._blockedFuncs.shift();
          try {
            $e(e3[1], e3[0]);
          } catch (e4) {
          }
        }
      return this;
    }, Ut.prototype._locked = function() {
      return this._reculock && me.lockOwnerFor !== this;
    }, Ut.prototype.create = function(t3) {
      var n3 = this;
      if (!this.mode)
        return this;
      var e3 = this.db.idbdb, r3 = this.db._state.dbOpenError;
      if (y2(!this.idbtrans), !t3 && !e3)
        switch (r3 && r3.name) {
          case "DatabaseClosedError":
            throw new Y.DatabaseClosed(r3);
          case "MissingAPIError":
            throw new Y.MissingAPI(r3.message, r3);
          default:
            throw new Y.OpenFailed(r3);
        }
      if (!this.active)
        throw new Y.TransactionInactive();
      return y2(null === this._completion._state), (t3 = this.idbtrans = t3 || (this.db.core || e3).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Te(function(e4) {
        Rt(e4), n3._reject(t3.error);
      }), t3.onabort = Te(function(e4) {
        Rt(e4), n3.active && n3._reject(new Y.Abort(t3.error)), n3.active = false, n3.on("abort").fire(e4);
      }), t3.oncomplete = Te(function() {
        n3.active = false, n3._resolve(), "mutatedParts" in t3 && Nt.storagemutated.fire(t3.mutatedParts);
      }), this;
    }, Ut.prototype._promise = function(n3, r3, i3) {
      var o3 = this;
      if ("readwrite" === n3 && "readwrite" !== this.mode)
        return Xe(new Y.ReadOnly("Transaction is readonly"));
      if (!this.active)
        return Xe(new Y.TransactionInactive());
      if (this._locked())
        return new _e(function(e4, t3) {
          o3._blockedFuncs.push([function() {
            o3._promise(n3, r3, i3).then(e4, t3);
          }, me]);
        });
      if (i3)
        return Ne(function() {
          var e4 = new _e(function(e5, t3) {
            o3._lock();
            var n4 = r3(e5, t3, o3);
            n4 && n4.then && n4.then(e5, t3);
          });
          return e4.finally(function() {
            return o3._unlock();
          }), e4._lib = true, e4;
        });
      var e3 = new _e(function(e4, t3) {
        var n4 = r3(e4, t3, o3);
        n4 && n4.then && n4.then(e4, t3);
      });
      return e3._lib = true, e3;
    }, Ut.prototype._root = function() {
      return this.parent ? this.parent._root() : this;
    }, Ut.prototype.waitFor = function(e3) {
      var t3, r3 = this._root(), i3 = _e.resolve(e3);
      r3._waitingFor ? r3._waitingFor = r3._waitingFor.then(function() {
        return i3;
      }) : (r3._waitingFor = i3, r3._waitingQueue = [], t3 = r3.idbtrans.objectStore(r3.storeNames[0]), function e4() {
        for (++r3._spinCount; r3._waitingQueue.length; )
          r3._waitingQueue.shift()();
        r3._waitingFor && (t3.get(-1 / 0).onsuccess = e4);
      }());
      var o3 = r3._waitingFor;
      return new _e(function(t4, n3) {
        i3.then(function(e4) {
          return r3._waitingQueue.push(Te(t4.bind(null, e4)));
        }, function(e4) {
          return r3._waitingQueue.push(Te(n3.bind(null, e4)));
        }).finally(function() {
          r3._waitingFor === o3 && (r3._waitingFor = null);
        });
      });
    }, Ut.prototype.abort = function() {
      this.active && (this.active = false, this.idbtrans && this.idbtrans.abort(), this._reject(new Y.Abort()));
    }, Ut.prototype.table = function(e3) {
      var t3 = this._memoizedTables || (this._memoizedTables = {});
      if (m2(t3, e3))
        return t3[e3];
      var n3 = this.schema[e3];
      if (!n3)
        throw new Y.NotFound("Table " + e3 + " not part of transaction");
      n3 = new this.db.Table(e3, n3, this);
      return n3.core = this.db.core.table(e3), t3[e3] = n3;
    }, Ut);
    function Ut() {
    }
    function zt(e3, t3, n3, r3, i3, o3, a3) {
      return { name: e3, keyPath: t3, unique: n3, multi: r3, auto: i3, compound: o3, src: (n3 && !a3 ? "&" : "") + (r3 ? "*" : "") + (i3 ? "++" : "") + Vt(t3) };
    }
    function Vt(e3) {
      return "string" == typeof e3 ? e3 : e3 ? "[" + [].join.call(e3, "+") + "]" : "";
    }
    function Wt(e3, t3, n3) {
      return { name: e3, primKey: t3, indexes: n3, mappedClass: null, idxByName: (r3 = function(e4) {
        return [e4.name, e4];
      }, n3.reduce(function(e4, t4, n4) {
        n4 = r3(t4, n4);
        return n4 && (e4[n4[0]] = n4[1]), e4;
      }, {})) };
      var r3;
    }
    var Yt = function(e3) {
      try {
        return e3.only([[]]), Yt = function() {
          return [[]];
        }, [[]];
      } catch (e4) {
        return Yt = function() {
          return He;
        }, He;
      }
    };
    function $t(t3) {
      return null == t3 ? function() {
      } : "string" == typeof t3 ? 1 === (n3 = t3).split(".").length ? function(e3) {
        return e3[n3];
      } : function(e3) {
        return k2(e3, n3);
      } : function(e3) {
        return k2(e3, t3);
      };
      var n3;
    }
    function Qt(e3) {
      return [].slice.call(e3);
    }
    var Gt = 0;
    function Xt(e3) {
      return null == e3 ? ":id" : "string" == typeof e3 ? e3 : "[".concat(e3.join("+"), "]");
    }
    function Ht(e3, i3, t3) {
      function _3(e4) {
        if (3 === e4.type)
          return null;
        if (4 === e4.type)
          throw new Error("Cannot convert never type to IDBKeyRange");
        var t4 = e4.lower, n4 = e4.upper, r4 = e4.lowerOpen, e4 = e4.upperOpen;
        return void 0 === t4 ? void 0 === n4 ? null : i3.upperBound(n4, !!e4) : void 0 === n4 ? i3.lowerBound(t4, !!r4) : i3.bound(t4, n4, !!r4, !!e4);
      }
      function n3(e4) {
        var h3, w3 = e4.name;
        return { name: w3, schema: e4, mutate: function(e5) {
          var y3 = e5.trans, v3 = e5.type, m3 = e5.keys, b3 = e5.values, g3 = e5.range;
          return new Promise(function(t4, e6) {
            t4 = Te(t4);
            var n4 = y3.objectStore(w3), r4 = null == n4.keyPath, i4 = "put" === v3 || "add" === v3;
            if (!i4 && "delete" !== v3 && "deleteRange" !== v3)
              throw new Error("Invalid operation type: " + v3);
            var o4, a4 = (m3 || b3 || { length: 1 }).length;
            if (m3 && b3 && m3.length !== b3.length)
              throw new Error("Given keys array must have same length as given values array.");
            if (0 === a4)
              return t4({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
            function u3(e7) {
              ++l3, Rt(e7);
            }
            var s3 = [], c3 = [], l3 = 0;
            if ("deleteRange" === v3) {
              if (4 === g3.type)
                return t4({ numFailures: l3, failures: c3, results: [], lastResult: void 0 });
              3 === g3.type ? s3.push(o4 = n4.clear()) : s3.push(o4 = n4.delete(_3(g3)));
            } else {
              var r4 = i4 ? r4 ? [b3, m3] : [b3, null] : [m3, null], f3 = r4[0], h4 = r4[1];
              if (i4)
                for (var d2 = 0; d2 < a4; ++d2)
                  s3.push(o4 = h4 && void 0 !== h4[d2] ? n4[v3](f3[d2], h4[d2]) : n4[v3](f3[d2])), o4.onerror = u3;
              else
                for (d2 = 0; d2 < a4; ++d2)
                  s3.push(o4 = n4[v3](f3[d2])), o4.onerror = u3;
            }
            function p3(e7) {
              e7 = e7.target.result, s3.forEach(function(e8, t5) {
                return null != e8.error && (c3[t5] = e8.error);
              }), t4({ numFailures: l3, failures: c3, results: "delete" === v3 ? m3 : s3.map(function(e8) {
                return e8.result;
              }), lastResult: e7 });
            }
            o4.onerror = function(e7) {
              u3(e7), p3(e7);
            }, o4.onsuccess = p3;
          });
        }, getMany: function(e5) {
          var f3 = e5.trans, h4 = e5.keys;
          return new Promise(function(t4, e6) {
            t4 = Te(t4);
            for (var n4, r4 = f3.objectStore(w3), i4 = h4.length, o4 = new Array(i4), a4 = 0, u3 = 0, s3 = function(e7) {
              e7 = e7.target;
              o4[e7._pos] = e7.result, ++u3 === a4 && t4(o4);
            }, c3 = Bt(e6), l3 = 0; l3 < i4; ++l3)
              null != h4[l3] && ((n4 = r4.get(h4[l3]))._pos = l3, n4.onsuccess = s3, n4.onerror = c3, ++a4);
            0 === a4 && t4(o4);
          });
        }, get: function(e5) {
          var r4 = e5.trans, i4 = e5.key;
          return new Promise(function(t4, e6) {
            t4 = Te(t4);
            var n4 = r4.objectStore(w3).get(i4);
            n4.onsuccess = function(e7) {
              return t4(e7.target.result);
            }, n4.onerror = Bt(e6);
          });
        }, query: (h3 = s2, function(f3) {
          return new Promise(function(n4, e5) {
            n4 = Te(n4);
            var r4, i4, o4, t4 = f3.trans, a4 = f3.values, u3 = f3.limit, s3 = f3.query, c3 = u3 === 1 / 0 ? void 0 : u3, l3 = s3.index, s3 = s3.range, t4 = t4.objectStore(w3), l3 = l3.isPrimaryKey ? t4 : t4.index(l3.name), s3 = _3(s3);
            if (0 === u3)
              return n4({ result: [] });
            h3 ? ((c3 = a4 ? l3.getAll(s3, c3) : l3.getAllKeys(s3, c3)).onsuccess = function(e6) {
              return n4({ result: e6.target.result });
            }, c3.onerror = Bt(e5)) : (r4 = 0, i4 = !a4 && "openKeyCursor" in l3 ? l3.openKeyCursor(s3) : l3.openCursor(s3), o4 = [], i4.onsuccess = function(e6) {
              var t5 = i4.result;
              return t5 ? (o4.push(a4 ? t5.value : t5.primaryKey), ++r4 === u3 ? n4({ result: o4 }) : void t5.continue()) : n4({ result: o4 });
            }, i4.onerror = Bt(e5));
          });
        }), openCursor: function(e5) {
          var c3 = e5.trans, o4 = e5.values, a4 = e5.query, u3 = e5.reverse, l3 = e5.unique;
          return new Promise(function(t4, n4) {
            t4 = Te(t4);
            var e6 = a4.index, r4 = a4.range, i4 = c3.objectStore(w3), i4 = e6.isPrimaryKey ? i4 : i4.index(e6.name), e6 = u3 ? l3 ? "prevunique" : "prev" : l3 ? "nextunique" : "next", s3 = !o4 && "openKeyCursor" in i4 ? i4.openKeyCursor(_3(r4), e6) : i4.openCursor(_3(r4), e6);
            s3.onerror = Bt(n4), s3.onsuccess = Te(function(e7) {
              var r5, i5, o5, a5, u4 = s3.result;
              u4 ? (u4.___id = ++Gt, u4.done = false, r5 = u4.continue.bind(u4), i5 = (i5 = u4.continuePrimaryKey) && i5.bind(u4), o5 = u4.advance.bind(u4), a5 = function() {
                throw new Error("Cursor not stopped");
              }, u4.trans = c3, u4.stop = u4.continue = u4.continuePrimaryKey = u4.advance = function() {
                throw new Error("Cursor not started");
              }, u4.fail = Te(n4), u4.next = function() {
                var e8 = this, t5 = 1;
                return this.start(function() {
                  return t5-- ? e8.continue() : e8.stop();
                }).then(function() {
                  return e8;
                });
              }, u4.start = function(e8) {
                function t5() {
                  if (s3.result)
                    try {
                      e8();
                    } catch (e9) {
                      u4.fail(e9);
                    }
                  else
                    u4.done = true, u4.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, u4.stop();
                }
                var n5 = new Promise(function(t6, e9) {
                  t6 = Te(t6), s3.onerror = Bt(e9), u4.fail = e9, u4.stop = function(e10) {
                    u4.stop = u4.continue = u4.continuePrimaryKey = u4.advance = a5, t6(e10);
                  };
                });
                return s3.onsuccess = Te(function(e9) {
                  s3.onsuccess = t5, t5();
                }), u4.continue = r5, u4.continuePrimaryKey = i5, u4.advance = o5, t5(), n5;
              }, t4(u4)) : t4(null);
            }, n4);
          });
        }, count: function(e5) {
          var t4 = e5.query, i4 = e5.trans, o4 = t4.index, a4 = t4.range;
          return new Promise(function(t5, e6) {
            var n4 = i4.objectStore(w3), r4 = o4.isPrimaryKey ? n4 : n4.index(o4.name), n4 = _3(a4), r4 = n4 ? r4.count(n4) : r4.count();
            r4.onsuccess = Te(function(e7) {
              return t5(e7.target.result);
            }), r4.onerror = Bt(e6);
          });
        } };
      }
      var r3, o3, a3, u2 = (o3 = t3, a3 = Qt((r3 = e3).objectStoreNames), { schema: { name: r3.name, tables: a3.map(function(e4) {
        return o3.objectStore(e4);
      }).map(function(t4) {
        var e4 = t4.keyPath, n4 = t4.autoIncrement, r4 = x2(e4), i4 = {}, n4 = { name: t4.name, primaryKey: { name: null, isPrimaryKey: true, outbound: null == e4, compound: r4, keyPath: e4, autoIncrement: n4, unique: true, extractKey: $t(e4) }, indexes: Qt(t4.indexNames).map(function(e5) {
          return t4.index(e5);
        }).map(function(e5) {
          var t5 = e5.name, n5 = e5.unique, r5 = e5.multiEntry, e5 = e5.keyPath, r5 = { name: t5, compound: x2(e5), keyPath: e5, unique: n5, multiEntry: r5, extractKey: $t(e5) };
          return i4[Xt(e5)] = r5;
        }), getIndexByKeyPath: function(e5) {
          return i4[Xt(e5)];
        } };
        return i4[":id"] = n4.primaryKey, null != e4 && (i4[Xt(e4)] = n4.primaryKey), n4;
      }) }, hasGetAll: 0 < a3.length && "getAll" in o3.objectStore(a3[0]) && !("undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), t3 = u2.schema, s2 = u2.hasGetAll, u2 = t3.tables.map(n3), c2 = {};
      return u2.forEach(function(e4) {
        return c2[e4.name] = e4;
      }), { stack: "dbcore", transaction: e3.transaction.bind(e3), table: function(e4) {
        if (!c2[e4])
          throw new Error("Table '".concat(e4, "' not found"));
        return c2[e4];
      }, MIN_KEY: -1 / 0, MAX_KEY: Yt(i3), schema: t3 };
    }
    function Jt(e3, t3, n3, r3) {
      var i3 = n3.IDBKeyRange;
      return n3.indexedDB, { dbcore: (r3 = Ht(t3, i3, r3), e3.dbcore.reduce(function(e4, t4) {
        t4 = t4.create;
        return w2(w2({}, e4), t4(e4));
      }, r3)) };
    }
    function Zt(n3, e3) {
      var t3 = e3.db, e3 = Jt(n3._middlewares, t3, n3._deps, e3);
      n3.core = e3.dbcore, n3.tables.forEach(function(e4) {
        var t4 = e4.name;
        n3.core.schema.tables.some(function(e5) {
          return e5.name === t4;
        }) && (e4.core = n3.core.table(t4), n3[t4] instanceof n3.Table && (n3[t4].core = e4.core));
      });
    }
    function en2(i3, e3, t3, o3) {
      t3.forEach(function(n3) {
        var r3 = o3[n3];
        e3.forEach(function(e4) {
          var t4 = function e5(t5, n4) {
            return h2(t5, n4) || (t5 = c(t5)) && e5(t5, n4);
          }(e4, n3);
          (!t4 || "value" in t4 && void 0 === t4.value) && (e4 === i3.Transaction.prototype || e4 instanceof i3.Transaction ? l2(e4, n3, { get: function() {
            return this.table(n3);
          }, set: function(e5) {
            u(this, n3, { value: e5, writable: true, configurable: true, enumerable: true });
          } }) : e4[n3] = new i3.Table(n3, r3));
        });
      });
    }
    function tn(n3, e3) {
      e3.forEach(function(e4) {
        for (var t3 in e4)
          e4[t3] instanceof n3.Table && delete e4[t3];
      });
    }
    function nn(e3, t3) {
      return e3._cfg.version - t3._cfg.version;
    }
    function rn(n3, r3, i3, e3) {
      var o3 = n3._dbSchema;
      i3.objectStoreNames.contains("$meta") && !o3.$meta && (o3.$meta = Wt("$meta", hn("")[0], []), n3._storeNames.push("$meta"));
      var a3 = n3._createTransaction("readwrite", n3._storeNames, o3);
      a3.create(i3), a3._completion.catch(e3);
      var u2 = a3._reject.bind(a3), s2 = me.transless || me;
      Ne(function() {
        return me.trans = a3, me.transless = s2, 0 !== r3 ? (Zt(n3, i3), t3 = r3, ((e4 = a3).storeNames.includes("$meta") ? e4.table("$meta").get("version").then(function(e5) {
          return null != e5 ? e5 : t3;
        }) : _e.resolve(t3)).then(function(e5) {
          return c2 = e5, l3 = a3, f3 = i3, t4 = [], e5 = (s3 = n3)._versions, h3 = s3._dbSchema = ln(0, s3.idbdb, f3), 0 !== (e5 = e5.filter(function(e6) {
            return e6._cfg.version >= c2;
          })).length ? (e5.forEach(function(u3) {
            t4.push(function() {
              var t5 = h3, e6 = u3._cfg.dbschema;
              fn(s3, t5, f3), fn(s3, e6, f3), h3 = s3._dbSchema = e6;
              var n4 = an(t5, e6);
              n4.add.forEach(function(e7) {
                un(f3, e7[0], e7[1].primKey, e7[1].indexes);
              }), n4.change.forEach(function(e7) {
                if (e7.recreate)
                  throw new Y.Upgrade("Not yet support for changing primary key");
                var t6 = f3.objectStore(e7.name);
                e7.add.forEach(function(e8) {
                  return cn(t6, e8);
                }), e7.change.forEach(function(e8) {
                  t6.deleteIndex(e8.name), cn(t6, e8);
                }), e7.del.forEach(function(e8) {
                  return t6.deleteIndex(e8);
                });
              });
              var r4 = u3._cfg.contentUpgrade;
              if (r4 && u3._cfg.version > c2) {
                Zt(s3, f3), l3._memoizedTables = {};
                var i4 = g2(e6);
                n4.del.forEach(function(e7) {
                  i4[e7] = t5[e7];
                }), tn(s3, [s3.Transaction.prototype]), en2(s3, [s3.Transaction.prototype], _2(i4), i4), l3.schema = i4;
                var o4, a4 = B(r4);
                a4 && Le();
                n4 = _e.follow(function() {
                  var e7;
                  (o4 = r4(l3)) && a4 && (e7 = Ue.bind(null, null), o4.then(e7, e7));
                });
                return o4 && "function" == typeof o4.then ? _e.resolve(o4) : n4.then(function() {
                  return o4;
                });
              }
            }), t4.push(function(e6) {
              var t5, n4, r4 = u3._cfg.dbschema;
              t5 = r4, n4 = e6, [].slice.call(n4.db.objectStoreNames).forEach(function(e7) {
                return null == t5[e7] && n4.db.deleteObjectStore(e7);
              }), tn(s3, [s3.Transaction.prototype]), en2(s3, [s3.Transaction.prototype], s3._storeNames, s3._dbSchema), l3.schema = s3._dbSchema;
            }), t4.push(function(e6) {
              s3.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(s3.idbdb.version / 10) === u3._cfg.version ? (s3.idbdb.deleteObjectStore("$meta"), delete s3._dbSchema.$meta, s3._storeNames = s3._storeNames.filter(function(e7) {
                return "$meta" !== e7;
              })) : e6.objectStore("$meta").put(u3._cfg.version, "version"));
            });
          }), function e6() {
            return t4.length ? _e.resolve(t4.shift()(l3.idbtrans)).then(e6) : _e.resolve();
          }().then(function() {
            sn(h3, f3);
          })) : _e.resolve();
          var s3, c2, l3, f3, t4, h3;
        }).catch(u2)) : (_2(o3).forEach(function(e5) {
          un(i3, e5, o3[e5].primKey, o3[e5].indexes);
        }), Zt(n3, i3), void _e.follow(function() {
          return n3.on.populate.fire(a3);
        }).catch(u2));
        var e4, t3;
      });
    }
    function on(e3, r3) {
      sn(e3._dbSchema, r3), r3.db.version % 10 != 0 || r3.objectStoreNames.contains("$meta") || r3.db.createObjectStore("$meta").add(Math.ceil(r3.db.version / 10 - 1), "version");
      var t3 = ln(0, e3.idbdb, r3);
      fn(e3, e3._dbSchema, r3);
      for (var n3 = 0, i3 = an(t3, e3._dbSchema).change; n3 < i3.length; n3++) {
        var o3 = function(t4) {
          if (t4.change.length || t4.recreate)
            return console.warn("Unable to patch indexes of table ".concat(t4.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
          var n4 = r3.objectStore(t4.name);
          t4.add.forEach(function(e4) {
            ie && console.debug("Dexie upgrade patch: Creating missing index ".concat(t4.name, ".").concat(e4.src)), cn(n4, e4);
          });
        }(i3[n3]);
        if ("object" == typeof o3)
          return o3.value;
      }
    }
    function an(e3, t3) {
      var n3, r3 = { del: [], add: [], change: [] };
      for (n3 in e3)
        t3[n3] || r3.del.push(n3);
      for (n3 in t3) {
        var i3 = e3[n3], o3 = t3[n3];
        if (i3) {
          var a3 = { name: n3, def: o3, recreate: false, del: [], add: [], change: [] };
          if ("" + (i3.primKey.keyPath || "") != "" + (o3.primKey.keyPath || "") || i3.primKey.auto !== o3.primKey.auto)
            a3.recreate = true, r3.change.push(a3);
          else {
            var u2 = i3.idxByName, s2 = o3.idxByName, c2 = void 0;
            for (c2 in u2)
              s2[c2] || a3.del.push(c2);
            for (c2 in s2) {
              var l3 = u2[c2], f3 = s2[c2];
              l3 ? l3.src !== f3.src && a3.change.push(f3) : a3.add.push(f3);
            }
            (0 < a3.del.length || 0 < a3.add.length || 0 < a3.change.length) && r3.change.push(a3);
          }
        } else
          r3.add.push([n3, o3]);
      }
      return r3;
    }
    function un(e3, t3, n3, r3) {
      var i3 = e3.db.createObjectStore(t3, n3.keyPath ? { keyPath: n3.keyPath, autoIncrement: n3.auto } : { autoIncrement: n3.auto });
      return r3.forEach(function(e4) {
        return cn(i3, e4);
      }), i3;
    }
    function sn(t3, n3) {
      _2(t3).forEach(function(e3) {
        n3.db.objectStoreNames.contains(e3) || (ie && console.debug("Dexie: Creating missing table", e3), un(n3, e3, t3[e3].primKey, t3[e3].indexes));
      });
    }
    function cn(e3, t3) {
      e3.createIndex(t3.name, t3.keyPath, { unique: t3.unique, multiEntry: t3.multi });
    }
    function ln(e3, t3, u2) {
      var s2 = {};
      return b2(t3.objectStoreNames, 0).forEach(function(e4) {
        for (var t4 = u2.objectStore(e4), n3 = zt(Vt(a3 = t4.keyPath), a3 || "", true, false, !!t4.autoIncrement, a3 && "string" != typeof a3, true), r3 = [], i3 = 0; i3 < t4.indexNames.length; ++i3) {
          var o3 = t4.index(t4.indexNames[i3]), a3 = o3.keyPath, o3 = zt(o3.name, a3, !!o3.unique, !!o3.multiEntry, false, a3 && "string" != typeof a3, false);
          r3.push(o3);
        }
        s2[e4] = Wt(e4, n3, r3);
      }), s2;
    }
    function fn(e3, t3, n3) {
      for (var r3 = n3.db.objectStoreNames, i3 = 0; i3 < r3.length; ++i3) {
        var o3 = r3[i3], a3 = n3.objectStore(o3);
        e3._hasGetAll = "getAll" in a3;
        for (var u2 = 0; u2 < a3.indexNames.length; ++u2) {
          var s2 = a3.indexNames[u2], c2 = a3.index(s2).keyPath, l3 = "string" == typeof c2 ? c2 : "[" + b2(c2).join("+") + "]";
          !t3[o3] || (c2 = t3[o3].idxByName[l3]) && (c2.name = s2, delete t3[o3].idxByName[l3], t3[o3].idxByName[s2] = c2);
        }
      }
      "undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && f2.WorkerGlobalScope && f2 instanceof f2.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e3._hasGetAll = false);
    }
    function hn(e3) {
      return e3.split(",").map(function(e4, t3) {
        var n3 = (e4 = e4.trim()).replace(/([&*]|\+\+)/g, ""), r3 = /^\[/.test(n3) ? n3.match(/^\[(.*)\]$/)[1].split("+") : n3;
        return zt(n3, r3 || null, /\&/.test(e4), /\*/.test(e4), /\+\+/.test(e4), x2(r3), 0 === t3);
      });
    }
    var dn = (pn.prototype._parseStoresSpec = function(r3, i3) {
      _2(r3).forEach(function(e3) {
        if (null !== r3[e3]) {
          var t3 = hn(r3[e3]), n3 = t3.shift();
          if (n3.unique = true, n3.multi)
            throw new Y.Schema("Primary key cannot be multi-valued");
          t3.forEach(function(e4) {
            if (e4.auto)
              throw new Y.Schema("Only primary key can be marked as autoIncrement (++)");
            if (!e4.keyPath)
              throw new Y.Schema("Index must have a name and cannot be an empty string");
          }), i3[e3] = Wt(e3, n3, t3);
        }
      });
    }, pn.prototype.stores = function(e3) {
      var t3 = this.db;
      this._cfg.storesSource = this._cfg.storesSource ? a2(this._cfg.storesSource, e3) : e3;
      var e3 = t3._versions, n3 = {}, r3 = {};
      return e3.forEach(function(e4) {
        a2(n3, e4._cfg.storesSource), r3 = e4._cfg.dbschema = {}, e4._parseStoresSpec(n3, r3);
      }), t3._dbSchema = r3, tn(t3, [t3._allTables, t3, t3.Transaction.prototype]), en2(t3, [t3._allTables, t3, t3.Transaction.prototype, this._cfg.tables], _2(r3), r3), t3._storeNames = _2(r3), this;
    }, pn.prototype.upgrade = function(e3) {
      return this._cfg.contentUpgrade = re(this._cfg.contentUpgrade || G, e3), this;
    }, pn);
    function pn() {
    }
    function yn(e3, t3) {
      var n3 = e3._dbNamesDB;
      return n3 || (n3 = e3._dbNamesDB = new er(tt, { addons: [], indexedDB: e3, IDBKeyRange: t3 })).version(1).stores({ dbnames: "name" }), n3.table("dbnames");
    }
    function vn(e3) {
      return e3 && "function" == typeof e3.databases;
    }
    function mn(e3) {
      return Ne(function() {
        return me.letThrough = true, e3();
      });
    }
    function bn(e3) {
      return !("from" in e3);
    }
    var gn = function(e3, t3) {
      if (!this) {
        var n3 = new gn();
        return e3 && "d" in e3 && a2(n3, e3), n3;
      }
      a2(this, arguments.length ? { d: 1, from: e3, to: 1 < arguments.length ? t3 : e3 } : { d: 0 });
    };
    function wn(e3, t3, n3) {
      var r3 = st(t3, n3);
      if (!isNaN(r3)) {
        if (0 < r3)
          throw RangeError();
        if (bn(e3))
          return a2(e3, { from: t3, to: n3, d: 1 });
        var i3 = e3.l, r3 = e3.r;
        if (st(n3, e3.from) < 0)
          return i3 ? wn(i3, t3, n3) : e3.l = { from: t3, to: n3, d: 1, l: null, r: null }, On(e3);
        if (0 < st(t3, e3.to))
          return r3 ? wn(r3, t3, n3) : e3.r = { from: t3, to: n3, d: 1, l: null, r: null }, On(e3);
        st(t3, e3.from) < 0 && (e3.from = t3, e3.l = null, e3.d = r3 ? r3.d + 1 : 1), 0 < st(n3, e3.to) && (e3.to = n3, e3.r = null, e3.d = e3.l ? e3.l.d + 1 : 1);
        n3 = !e3.r;
        i3 && !e3.l && _n(e3, i3), r3 && n3 && _n(e3, r3);
      }
    }
    function _n(e3, t3) {
      bn(t3) || function e4(t4, n3) {
        var r3 = n3.from, i3 = n3.to, o3 = n3.l, n3 = n3.r;
        wn(t4, r3, i3), o3 && e4(t4, o3), n3 && e4(t4, n3);
      }(e3, t3);
    }
    function xn(e3, t3) {
      var n3 = kn(t3), r3 = n3.next();
      if (r3.done)
        return false;
      for (var i3 = r3.value, o3 = kn(e3), a3 = o3.next(i3.from), u2 = a3.value; !r3.done && !a3.done; ) {
        if (st(u2.from, i3.to) <= 0 && 0 <= st(u2.to, i3.from))
          return true;
        st(i3.from, u2.from) < 0 ? i3 = (r3 = n3.next(u2.from)).value : u2 = (a3 = o3.next(i3.from)).value;
      }
      return false;
    }
    function kn(e3) {
      var n3 = bn(e3) ? null : { s: 0, n: e3 };
      return { next: function(e4) {
        for (var t3 = 0 < arguments.length; n3; )
          switch (n3.s) {
            case 0:
              if (n3.s = 1, t3)
                for (; n3.n.l && st(e4, n3.n.from) < 0; )
                  n3 = { up: n3, n: n3.n.l, s: 1 };
              else
                for (; n3.n.l; )
                  n3 = { up: n3, n: n3.n.l, s: 1 };
            case 1:
              if (n3.s = 2, !t3 || st(e4, n3.n.to) <= 0)
                return { value: n3.n, done: false };
            case 2:
              if (n3.n.r) {
                n3.s = 3, n3 = { up: n3, n: n3.n.r, s: 0 };
                continue;
              }
            case 3:
              n3 = n3.up;
          }
        return { done: true };
      } };
    }
    function On(e3) {
      var t3, n3, r3 = ((null === (t3 = e3.r) || void 0 === t3 ? void 0 : t3.d) || 0) - ((null === (n3 = e3.l) || void 0 === n3 ? void 0 : n3.d) || 0), i3 = 1 < r3 ? "r" : r3 < -1 ? "l" : "";
      i3 && (t3 = "r" == i3 ? "l" : "r", n3 = w2({}, e3), r3 = e3[i3], e3.from = r3.from, e3.to = r3.to, e3[i3] = r3[i3], n3[i3] = r3[t3], (e3[t3] = n3).d = Pn(n3)), e3.d = Pn(e3);
    }
    function Pn(e3) {
      var t3 = e3.r, e3 = e3.l;
      return (t3 ? e3 ? Math.max(t3.d, e3.d) : t3.d : e3 ? e3.d : 0) + 1;
    }
    function En(t3, n3) {
      return _2(n3).forEach(function(e3) {
        t3[e3] ? _n(t3[e3], n3[e3]) : t3[e3] = function e4(t4) {
          var n4, r3, i3 = {};
          for (n4 in t4)
            m2(t4, n4) && (r3 = t4[n4], i3[n4] = !r3 || "object" != typeof r3 || E2.has(r3.constructor) ? r3 : e4(r3));
          return i3;
        }(n3[e3]);
      }), t3;
    }
    function Kn(t3, n3) {
      return t3.all || n3.all || Object.keys(t3).some(function(e3) {
        return n3[e3] && xn(n3[e3], t3[e3]);
      });
    }
    r2(gn.prototype, ((F = { add: function(e3) {
      return _n(this, e3), this;
    }, addKey: function(e3) {
      return wn(this, e3, e3), this;
    }, addKeys: function(e3) {
      var t3 = this;
      return e3.forEach(function(e4) {
        return wn(t3, e4, e4);
      }), this;
    } })[C] = function() {
      return kn(this);
    }, F));
    var Sn = {}, jn = {}, An = false;
    function Cn(e3) {
      En(jn, e3), An || (An = true, setTimeout(function() {
        An = false, Dn(jn, !(jn = {}));
      }, 0));
    }
    function Dn(e3, t3) {
      void 0 === t3 && (t3 = false);
      var n3 = /* @__PURE__ */ new Set();
      if (e3.all)
        for (var r3 = 0, i3 = Object.values(Sn); r3 < i3.length; r3++)
          Tn(a3 = i3[r3], e3, n3, t3);
      else
        for (var o3 in e3) {
          var a3, u2 = /^idb\:\/\/(.*)\/(.*)\//.exec(o3);
          u2 && (o3 = u2[1], u2 = u2[2], (a3 = Sn["idb://".concat(o3, "/").concat(u2)]) && Tn(a3, e3, n3, t3));
        }
      n3.forEach(function(e4) {
        return e4();
      });
    }
    function Tn(e3, t3, n3, r3) {
      for (var i3 = [], o3 = 0, a3 = Object.entries(e3.queries.query); o3 < a3.length; o3++) {
        for (var u2 = a3[o3], s2 = u2[0], c2 = [], l3 = 0, f3 = u2[1]; l3 < f3.length; l3++) {
          var h3 = f3[l3];
          Kn(t3, h3.obsSet) ? h3.subscribers.forEach(function(e4) {
            return n3.add(e4);
          }) : r3 && c2.push(h3);
        }
        r3 && i3.push([s2, c2]);
      }
      if (r3)
        for (var d2 = 0, p3 = i3; d2 < p3.length; d2++) {
          var y3 = p3[d2], s2 = y3[0], c2 = y3[1];
          e3.queries.query[s2] = c2;
        }
    }
    function qn(f3) {
      var h3 = f3._state, r3 = f3._deps.indexedDB;
      if (h3.isBeingOpened || f3.idbdb)
        return h3.dbReadyPromise.then(function() {
          return h3.dbOpenError ? Xe(h3.dbOpenError) : f3;
        });
      h3.isBeingOpened = true, h3.dbOpenError = null, h3.openComplete = false;
      var t3 = h3.openCanceller, d2 = Math.round(10 * f3.verno), p3 = false;
      function e3() {
        if (h3.openCanceller !== t3)
          throw new Y.DatabaseClosed("db.open() was cancelled");
      }
      function y3() {
        return new _e(function(s2, n4) {
          if (e3(), !r3)
            throw new Y.MissingAPI();
          var c2 = f3.name, l3 = h3.autoSchema || !d2 ? r3.open(c2) : r3.open(c2, d2);
          if (!l3)
            throw new Y.MissingAPI();
          l3.onerror = Bt(n4), l3.onblocked = Te(f3._fireOnBlocked), l3.onupgradeneeded = Te(function(e4) {
            var t4;
            v3 = l3.transaction, h3.autoSchema && !f3._options.allowEmptyDB ? (l3.onerror = Rt, v3.abort(), l3.result.close(), (t4 = r3.deleteDatabase(c2)).onsuccess = t4.onerror = Te(function() {
              n4(new Y.NoSuchDatabase("Database ".concat(c2, " doesnt exist")));
            })) : (v3.onerror = Bt(n4), e4 = e4.oldVersion > Math.pow(2, 62) ? 0 : e4.oldVersion, m3 = e4 < 1, f3.idbdb = l3.result, p3 && on(f3, v3), rn(f3, e4 / 10, v3, n4));
          }, n4), l3.onsuccess = Te(function() {
            v3 = null;
            var e4, t4, n5, r4, i4, o3 = f3.idbdb = l3.result, a3 = b2(o3.objectStoreNames);
            if (0 < a3.length)
              try {
                var u2 = o3.transaction(1 === (r4 = a3).length ? r4[0] : r4, "readonly");
                if (h3.autoSchema)
                  t4 = o3, n5 = u2, (e4 = f3).verno = t4.version / 10, n5 = e4._dbSchema = ln(0, t4, n5), e4._storeNames = b2(t4.objectStoreNames, 0), en2(e4, [e4._allTables], _2(n5), n5);
                else if (fn(f3, f3._dbSchema, u2), ((i4 = an(ln(0, (i4 = f3).idbdb, u2), i4._dbSchema)).add.length || i4.change.some(function(e5) {
                  return e5.add.length || e5.change.length;
                })) && !p3)
                  return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), o3.close(), d2 = o3.version + 1, p3 = true, s2(y3());
                Zt(f3, u2);
              } catch (e5) {
              }
            et.push(f3), o3.onversionchange = Te(function(e5) {
              h3.vcFired = true, f3.on("versionchange").fire(e5);
            }), o3.onclose = Te(function(e5) {
              f3.on("close").fire(e5);
            }), m3 && (i4 = f3._deps, u2 = c2, o3 = i4.indexedDB, i4 = i4.IDBKeyRange, vn(o3) || u2 === tt || yn(o3, i4).put({ name: u2 }).catch(G)), s2();
          }, n4);
        }).catch(function(e4) {
          switch (null == e4 ? void 0 : e4.name) {
            case "UnknownError":
              if (0 < h3.PR1398_maxLoop)
                return h3.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), y3();
              break;
            case "VersionError":
              if (0 < d2)
                return d2 = 0, y3();
          }
          return _e.reject(e4);
        });
      }
      var n3, i3 = h3.dbReadyResolve, v3 = null, m3 = false;
      return _e.race([t3, ("undefined" == typeof navigator ? _e.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(e4) {
        function t4() {
          return indexedDB.databases().finally(e4);
        }
        n3 = setInterval(t4, 100), t4();
      }).finally(function() {
        return clearInterval(n3);
      }) : Promise.resolve()).then(y3)]).then(function() {
        return e3(), h3.onReadyBeingFired = [], _e.resolve(mn(function() {
          return f3.on.ready.fire(f3.vip);
        })).then(function e4() {
          if (0 < h3.onReadyBeingFired.length) {
            var t4 = h3.onReadyBeingFired.reduce(re, G);
            return h3.onReadyBeingFired = [], _e.resolve(mn(function() {
              return t4(f3.vip);
            })).then(e4);
          }
        });
      }).finally(function() {
        h3.openCanceller === t3 && (h3.onReadyBeingFired = null, h3.isBeingOpened = false);
      }).catch(function(e4) {
        h3.dbOpenError = e4;
        try {
          v3 && v3.abort();
        } catch (e5) {
        }
        return t3 === h3.openCanceller && f3._close(), Xe(e4);
      }).finally(function() {
        h3.openComplete = true, i3();
      }).then(function() {
        var n4;
        return m3 && (n4 = {}, f3.tables.forEach(function(t4) {
          t4.schema.indexes.forEach(function(e4) {
            e4.name && (n4["idb://".concat(f3.name, "/").concat(t4.name, "/").concat(e4.name)] = new gn(-1 / 0, [[[]]]));
          }), n4["idb://".concat(f3.name, "/").concat(t4.name, "/")] = n4["idb://".concat(f3.name, "/").concat(t4.name, "/:dels")] = new gn(-1 / 0, [[[]]]);
        }), Nt(Ft).fire(n4), Dn(n4, true)), f3;
      });
    }
    function In(t3) {
      function e3(e4) {
        return t3.next(e4);
      }
      var r3 = n3(e3), i3 = n3(function(e4) {
        return t3.throw(e4);
      });
      function n3(n4) {
        return function(e4) {
          var t4 = n4(e4), e4 = t4.value;
          return t4.done ? e4 : e4 && "function" == typeof e4.then ? e4.then(r3, i3) : x2(e4) ? Promise.all(e4).then(r3, i3) : r3(e4);
        };
      }
      return n3(e3)();
    }
    function Bn(e3, t3, n3) {
      for (var r3 = x2(e3) ? e3.slice() : [e3], i3 = 0; i3 < n3; ++i3)
        r3.push(t3);
      return r3;
    }
    var Rn = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(f3) {
      return w2(w2({}, f3), { table: function(e3) {
        var a3 = f3.table(e3), t3 = a3.schema, u2 = {}, s2 = [];
        function c2(e4, t4, n4) {
          var r4 = Xt(e4), i4 = u2[r4] = u2[r4] || [], o3 = null == e4 ? 0 : "string" == typeof e4 ? 1 : e4.length, a4 = 0 < t4, a4 = w2(w2({}, n4), { name: a4 ? "".concat(r4, "(virtual-from:").concat(n4.name, ")") : n4.name, lowLevelIndex: n4, isVirtual: a4, keyTail: t4, keyLength: o3, extractKey: $t(e4), unique: !a4 && n4.unique });
          return i4.push(a4), a4.isPrimaryKey || s2.push(a4), 1 < o3 && c2(2 === o3 ? e4[0] : e4.slice(0, o3 - 1), t4 + 1, n4), i4.sort(function(e5, t5) {
            return e5.keyTail - t5.keyTail;
          }), a4;
        }
        e3 = c2(t3.primaryKey.keyPath, 0, t3.primaryKey);
        u2[":id"] = [e3];
        for (var n3 = 0, r3 = t3.indexes; n3 < r3.length; n3++) {
          var i3 = r3[n3];
          c2(i3.keyPath, 0, i3);
        }
        function l3(e4) {
          var t4, n4 = e4.query.index;
          return n4.isVirtual ? w2(w2({}, e4), { query: { index: n4.lowLevelIndex, range: (t4 = e4.query.range, n4 = n4.keyTail, { type: 1 === t4.type ? 2 : t4.type, lower: Bn(t4.lower, t4.lowerOpen ? f3.MAX_KEY : f3.MIN_KEY, n4), lowerOpen: true, upper: Bn(t4.upper, t4.upperOpen ? f3.MIN_KEY : f3.MAX_KEY, n4), upperOpen: true }) } }) : e4;
        }
        return w2(w2({}, a3), { schema: w2(w2({}, t3), { primaryKey: e3, indexes: s2, getIndexByKeyPath: function(e4) {
          return (e4 = u2[Xt(e4)]) && e4[0];
        } }), count: function(e4) {
          return a3.count(l3(e4));
        }, query: function(e4) {
          return a3.query(l3(e4));
        }, openCursor: function(t4) {
          var e4 = t4.query.index, r4 = e4.keyTail, n4 = e4.isVirtual, i4 = e4.keyLength;
          return n4 ? a3.openCursor(l3(t4)).then(function(e5) {
            return e5 && o3(e5);
          }) : a3.openCursor(t4);
          function o3(n5) {
            return Object.create(n5, { continue: { value: function(e5) {
              null != e5 ? n5.continue(Bn(e5, t4.reverse ? f3.MAX_KEY : f3.MIN_KEY, r4)) : t4.unique ? n5.continue(n5.key.slice(0, i4).concat(t4.reverse ? f3.MIN_KEY : f3.MAX_KEY, r4)) : n5.continue();
            } }, continuePrimaryKey: { value: function(e5, t5) {
              n5.continuePrimaryKey(Bn(e5, f3.MAX_KEY, r4), t5);
            } }, primaryKey: { get: function() {
              return n5.primaryKey;
            } }, key: { get: function() {
              var e5 = n5.key;
              return 1 === i4 ? e5[0] : e5.slice(0, i4);
            } }, value: { get: function() {
              return n5.value;
            } } });
          }
        } });
      } });
    } };
    function Fn(i3, o3, a3, u2) {
      return a3 = a3 || {}, u2 = u2 || "", _2(i3).forEach(function(e3) {
        var t3, n3, r3;
        m2(o3, e3) ? (t3 = i3[e3], n3 = o3[e3], "object" == typeof t3 && "object" == typeof n3 && t3 && n3 ? (r3 = A(t3)) !== A(n3) ? a3[u2 + e3] = o3[e3] : "Object" === r3 ? Fn(t3, n3, a3, u2 + e3 + ".") : t3 !== n3 && (a3[u2 + e3] = o3[e3]) : t3 !== n3 && (a3[u2 + e3] = o3[e3])) : a3[u2 + e3] = void 0;
      }), _2(o3).forEach(function(e3) {
        m2(i3, e3) || (a3[u2 + e3] = o3[e3]);
      }), a3;
    }
    function Mn(e3, t3) {
      return "delete" === t3.type ? t3.keys : t3.keys || t3.values.map(e3.extractKey);
    }
    var Nn = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e3) {
      return w2(w2({}, e3), { table: function(r3) {
        var y3 = e3.table(r3), v3 = y3.schema.primaryKey;
        return w2(w2({}, y3), { mutate: function(e4) {
          var t3 = me.trans, n3 = t3.table(r3).hook, h3 = n3.deleting, d2 = n3.creating, p3 = n3.updating;
          switch (e4.type) {
            case "add":
              if (d2.fire === G)
                break;
              return t3._promise("readwrite", function() {
                return a3(e4);
              }, true);
            case "put":
              if (d2.fire === G && p3.fire === G)
                break;
              return t3._promise("readwrite", function() {
                return a3(e4);
              }, true);
            case "delete":
              if (h3.fire === G)
                break;
              return t3._promise("readwrite", function() {
                return a3(e4);
              }, true);
            case "deleteRange":
              if (h3.fire === G)
                break;
              return t3._promise("readwrite", function() {
                return function n4(r4, i3, o3) {
                  return y3.query({ trans: r4, values: false, query: { index: v3, range: i3 }, limit: o3 }).then(function(e5) {
                    var t4 = e5.result;
                    return a3({ type: "delete", keys: t4, trans: r4 }).then(function(e6) {
                      return 0 < e6.numFailures ? Promise.reject(e6.failures[0]) : t4.length < o3 ? { failures: [], numFailures: 0, lastResult: void 0 } : n4(r4, w2(w2({}, i3), { lower: t4[t4.length - 1], lowerOpen: true }), o3);
                    });
                  });
                }(e4.trans, e4.range, 1e4);
              }, true);
          }
          return y3.mutate(e4);
          function a3(c2) {
            var e5, t4, n4, l3 = me.trans, f3 = c2.keys || Mn(v3, c2);
            if (!f3)
              throw new Error("Keys missing");
            return "delete" !== (c2 = "add" === c2.type || "put" === c2.type ? w2(w2({}, c2), { keys: f3 }) : w2({}, c2)).type && (c2.values = i2([], c2.values)), c2.keys && (c2.keys = i2([], c2.keys)), e5 = y3, n4 = f3, ("add" === (t4 = c2).type ? Promise.resolve([]) : e5.getMany({ trans: t4.trans, keys: n4, cache: "immutable" })).then(function(u2) {
              var s2 = f3.map(function(e6, t5) {
                var n5, r4, i3, o3 = u2[t5], a4 = { onerror: null, onsuccess: null };
                return "delete" === c2.type ? h3.fire.call(a4, e6, o3, l3) : "add" === c2.type || void 0 === o3 ? (n5 = d2.fire.call(a4, e6, c2.values[t5], l3), null == e6 && null != n5 && (c2.keys[t5] = e6 = n5, v3.outbound || P(c2.values[t5], v3.keyPath, e6))) : (n5 = Fn(o3, c2.values[t5]), (r4 = p3.fire.call(a4, n5, e6, o3, l3)) && (i3 = c2.values[t5], Object.keys(r4).forEach(function(e7) {
                  m2(i3, e7) ? i3[e7] = r4[e7] : P(i3, e7, r4[e7]);
                }))), a4;
              });
              return y3.mutate(c2).then(function(e6) {
                for (var t5 = e6.failures, n5 = e6.results, r4 = e6.numFailures, e6 = e6.lastResult, i3 = 0; i3 < f3.length; ++i3) {
                  var o3 = (n5 || f3)[i3], a4 = s2[i3];
                  null == o3 ? a4.onerror && a4.onerror(t5[i3]) : a4.onsuccess && a4.onsuccess("put" === c2.type && u2[i3] ? c2.values[i3] : o3);
                }
                return { failures: t5, results: n5, numFailures: r4, lastResult: e6 };
              }).catch(function(t5) {
                return s2.forEach(function(e6) {
                  return e6.onerror && e6.onerror(t5);
                }), Promise.reject(t5);
              });
            });
          }
        } });
      } });
    } };
    function Ln(e3, t3, n3) {
      try {
        if (!t3)
          return null;
        if (t3.keys.length < e3.length)
          return null;
        for (var r3 = [], i3 = 0, o3 = 0; i3 < t3.keys.length && o3 < e3.length; ++i3)
          0 === st(t3.keys[i3], e3[o3]) && (r3.push(n3 ? S2(t3.values[i3]) : t3.values[i3]), ++o3);
        return r3.length === e3.length ? r3 : null;
      } catch (e4) {
        return null;
      }
    }
    var Un = { stack: "dbcore", level: -1, create: function(t3) {
      return { table: function(e3) {
        var n3 = t3.table(e3);
        return w2(w2({}, n3), { getMany: function(t4) {
          if (!t4.cache)
            return n3.getMany(t4);
          var e4 = Ln(t4.keys, t4.trans._cache, "clone" === t4.cache);
          return e4 ? _e.resolve(e4) : n3.getMany(t4).then(function(e5) {
            return t4.trans._cache = { keys: t4.keys, values: "clone" === t4.cache ? S2(e5) : e5 }, e5;
          });
        }, mutate: function(e4) {
          return "add" !== e4.type && (e4.trans._cache = null), n3.mutate(e4);
        } });
      } };
    } };
    function zn(e3, t3) {
      return "readonly" === e3.trans.mode && !!e3.subscr && !e3.trans.explicit && "disabled" !== e3.trans.db._options.cache && !t3.schema.primaryKey.outbound;
    }
    function Vn(e3, t3) {
      switch (e3) {
        case "query":
          return t3.values && !t3.unique;
        case "get":
        case "getMany":
        case "count":
        case "openCursor":
          return false;
      }
    }
    var Wn = { stack: "dbcore", level: 0, name: "Observability", create: function(r3) {
      var b3 = r3.schema.name, g3 = new gn(r3.MIN_KEY, r3.MAX_KEY);
      return w2(w2({}, r3), { transaction: function(e3, t3, n3) {
        if (me.subscr && "readonly" !== t3)
          throw new Y.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(me.querier));
        return r3.transaction(e3, t3, n3);
      }, table: function(d2) {
        var p3 = r3.table(d2), y3 = p3.schema, v3 = y3.primaryKey, e3 = y3.indexes, c2 = v3.extractKey, l3 = v3.outbound, m3 = v3.autoIncrement && e3.filter(function(e4) {
          return e4.compound && e4.keyPath.includes(v3.keyPath);
        }), t3 = w2(w2({}, p3), { mutate: function(i3) {
          function o3(e5) {
            return e5 = "idb://".concat(b3, "/").concat(d2, "/").concat(e5), n3[e5] || (n3[e5] = new gn());
          }
          var e4, a3, u2, t4 = i3.trans, n3 = i3.mutatedParts || (i3.mutatedParts = {}), r4 = o3(""), s2 = o3(":dels"), c3 = i3.type, l4 = "deleteRange" === i3.type ? [i3.range] : "delete" === i3.type ? [i3.keys] : i3.values.length < 50 ? [Mn(v3, i3).filter(function(e5) {
            return e5;
          }), i3.values] : [], f4 = l4[0], h3 = l4[1], l4 = i3.trans._cache;
          return x2(f4) ? (r4.addKeys(f4), (l4 = "delete" === c3 || f4.length === h3.length ? Ln(f4, l4) : null) || s2.addKeys(f4), (l4 || h3) && (e4 = o3, a3 = l4, u2 = h3, y3.indexes.forEach(function(t5) {
            var n4 = e4(t5.name || "");
            function r5(e5) {
              return null != e5 ? t5.extractKey(e5) : null;
            }
            function i4(e5) {
              return t5.multiEntry && x2(e5) ? e5.forEach(function(e6) {
                return n4.addKey(e6);
              }) : n4.addKey(e5);
            }
            (a3 || u2).forEach(function(e5, t6) {
              var n5 = a3 && r5(a3[t6]), t6 = u2 && r5(u2[t6]);
              0 !== st(n5, t6) && (null != n5 && i4(n5), null != t6 && i4(t6));
            });
          }))) : f4 ? (h3 = { from: f4.lower, to: f4.upper }, s2.add(h3), r4.add(h3)) : (r4.add(g3), s2.add(g3), y3.indexes.forEach(function(e5) {
            return o3(e5.name).add(g3);
          })), p3.mutate(i3).then(function(e5) {
            return !f4 || "add" !== i3.type && "put" !== i3.type || (r4.addKeys(e5.results), m3 && m3.forEach(function(t5) {
              var n4 = i3.values.map(function(e6) {
                return t5.extractKey(e6);
              }), r5 = t5.keyPath.findIndex(function(e6) {
                return e6 === v3.keyPath;
              });
              e5.results.forEach(function(e6) {
                return n4[r5] = e6;
              }), o3(t5.name).addKeys(n4);
            })), t4.mutatedParts = En(t4.mutatedParts || {}, n3), e5;
          });
        } }), e3 = function(e4) {
          var t4 = e4.query, e4 = t4.index, t4 = t4.range;
          return [e4, new gn(null !== (e4 = t4.lower) && void 0 !== e4 ? e4 : r3.MIN_KEY, null !== (t4 = t4.upper) && void 0 !== t4 ? t4 : r3.MAX_KEY)];
        }, f3 = { get: function(e4) {
          return [v3, new gn(e4.key)];
        }, getMany: function(e4) {
          return [v3, new gn().addKeys(e4.keys)];
        }, count: e3, query: e3, openCursor: e3 };
        return _2(f3).forEach(function(s2) {
          t3[s2] = function(i3) {
            var e4 = me.subscr, t4 = !!e4, n3 = zn(me, p3) && Vn(s2, i3) ? i3.obsSet = {} : e4;
            if (t4) {
              var r4 = function(e5) {
                e5 = "idb://".concat(b3, "/").concat(d2, "/").concat(e5);
                return n3[e5] || (n3[e5] = new gn());
              }, o3 = r4(""), a3 = r4(":dels"), e4 = f3[s2](i3), t4 = e4[0], e4 = e4[1];
              if (("query" === s2 && t4.isPrimaryKey && !i3.values ? a3 : r4(t4.name || "")).add(e4), !t4.isPrimaryKey) {
                if ("count" !== s2) {
                  var u2 = "query" === s2 && l3 && i3.values && p3.query(w2(w2({}, i3), { values: false }));
                  return p3[s2].apply(this, arguments).then(function(t5) {
                    if ("query" === s2) {
                      if (l3 && i3.values)
                        return u2.then(function(e6) {
                          e6 = e6.result;
                          return o3.addKeys(e6), t5;
                        });
                      var e5 = i3.values ? t5.result.map(c2) : t5.result;
                      (i3.values ? o3 : a3).addKeys(e5);
                    } else if ("openCursor" === s2) {
                      var n4 = t5, r5 = i3.values;
                      return n4 && Object.create(n4, { key: { get: function() {
                        return a3.addKey(n4.primaryKey), n4.key;
                      } }, primaryKey: { get: function() {
                        var e6 = n4.primaryKey;
                        return a3.addKey(e6), e6;
                      } }, value: { get: function() {
                        return r5 && o3.addKey(n4.primaryKey), n4.value;
                      } } });
                    }
                    return t5;
                  });
                }
                a3.add(g3);
              }
            }
            return p3[s2].apply(this, arguments);
          };
        }), t3;
      } });
    } };
    function Yn(e3, t3, n3) {
      if (0 === n3.numFailures)
        return t3;
      if ("deleteRange" === t3.type)
        return null;
      var r3 = t3.keys ? t3.keys.length : "values" in t3 && t3.values ? t3.values.length : 1;
      if (n3.numFailures === r3)
        return null;
      t3 = w2({}, t3);
      return x2(t3.keys) && (t3.keys = t3.keys.filter(function(e4, t4) {
        return !(t4 in n3.failures);
      })), "values" in t3 && x2(t3.values) && (t3.values = t3.values.filter(function(e4, t4) {
        return !(t4 in n3.failures);
      })), t3;
    }
    function $n(e3, t3) {
      return n3 = e3, (void 0 === (r3 = t3).lower || (r3.lowerOpen ? 0 < st(n3, r3.lower) : 0 <= st(n3, r3.lower))) && (e3 = e3, void 0 === (t3 = t3).upper || (t3.upperOpen ? st(e3, t3.upper) < 0 : st(e3, t3.upper) <= 0));
      var n3, r3;
    }
    function Qn(e3, u2, t3, n3, r3, s2) {
      if (!t3 || 0 === t3.length)
        return e3;
      var i3 = u2.query.index, c2 = i3.multiEntry, l3 = u2.query.range, f3 = n3.schema.primaryKey.extractKey, h3 = i3.extractKey, o3 = (i3.lowLevelIndex || i3).extractKey, t3 = t3.reduce(function(e4, t4) {
        var n4 = e4, r4 = "add" === t4.type || "put" === t4.type ? t4.values.filter(function(e5) {
          e5 = h3(e5);
          return c2 && x2(e5) ? e5.some(function(e6) {
            return $n(e6, l3);
          }) : $n(e5, l3);
        }).map(function(e5) {
          return e5 = S2(e5), s2 && Object.freeze(e5), e5;
        }) : [];
        switch (t4.type) {
          case "add":
            n4 = e4.concat(u2.values ? r4 : r4.map(function(e5) {
              return f3(e5);
            }));
            break;
          case "put":
            var i4 = new gn().addKeys(t4.values.map(function(e5) {
              return f3(e5);
            })), n4 = e4.filter(function(e5) {
              e5 = u2.values ? f3(e5) : e5;
              return !xn(new gn(e5), i4);
            }).concat(u2.values ? r4 : r4.map(function(e5) {
              return f3(e5);
            }));
            break;
          case "delete":
            var o4 = new gn().addKeys(t4.keys);
            n4 = e4.filter(function(e5) {
              e5 = u2.values ? f3(e5) : e5;
              return !xn(new gn(e5), o4);
            });
            break;
          case "deleteRange":
            var a3 = t4.range;
            n4 = e4.filter(function(e5) {
              return !$n(f3(e5), a3);
            });
        }
        return n4;
      }, e3);
      return t3 === e3 ? e3 : (t3.sort(function(e4, t4) {
        return st(o3(e4), o3(t4)) || st(f3(e4), f3(t4));
      }), u2.limit && u2.limit < 1 / 0 && (t3.length > u2.limit ? t3.length = u2.limit : e3.length === u2.limit && t3.length < u2.limit && (r3.dirty = true)), s2 ? Object.freeze(t3) : t3);
    }
    function Gn(e3, t3) {
      return 0 === st(e3.lower, t3.lower) && 0 === st(e3.upper, t3.upper) && !!e3.lowerOpen == !!t3.lowerOpen && !!e3.upperOpen == !!t3.upperOpen;
    }
    function Xn(e3, t3) {
      return function(e4, t4, n3, r3) {
        if (void 0 === e4)
          return void 0 !== t4 ? -1 : 0;
        if (void 0 === t4)
          return 1;
        if (0 === (t4 = st(e4, t4))) {
          if (n3 && r3)
            return 0;
          if (n3)
            return 1;
          if (r3)
            return -1;
        }
        return t4;
      }(e3.lower, t3.lower, e3.lowerOpen, t3.lowerOpen) <= 0 && 0 <= function(e4, t4, n3, r3) {
        if (void 0 === e4)
          return void 0 !== t4 ? 1 : 0;
        if (void 0 === t4)
          return -1;
        if (0 === (t4 = st(e4, t4))) {
          if (n3 && r3)
            return 0;
          if (n3)
            return -1;
          if (r3)
            return 1;
        }
        return t4;
      }(e3.upper, t3.upper, e3.upperOpen, t3.upperOpen);
    }
    function Hn(n3, r3, i3, e3) {
      n3.subscribers.add(i3), e3.addEventListener("abort", function() {
        var e4, t3;
        n3.subscribers.delete(i3), 0 === n3.subscribers.size && (e4 = n3, t3 = r3, setTimeout(function() {
          0 === e4.subscribers.size && T2(t3, e4);
        }, 3e3));
      });
    }
    var Jn = { stack: "dbcore", level: 0, name: "Cache", create: function(k3) {
      var O2 = k3.schema.name;
      return w2(w2({}, k3), { transaction: function(g3, w3, e3) {
        var _3, t3, x3 = k3.transaction(g3, w3, e3);
        return "readwrite" === w3 && (t3 = (_3 = new AbortController()).signal, e3 = function(b3) {
          return function() {
            if (_3.abort(), "readwrite" === w3) {
              for (var t4 = /* @__PURE__ */ new Set(), e4 = 0, n3 = g3; e4 < n3.length; e4++) {
                var r3 = n3[e4], i3 = Sn["idb://".concat(O2, "/").concat(r3)];
                if (i3) {
                  var o3 = k3.table(r3), a3 = i3.optimisticOps.filter(function(e5) {
                    return e5.trans === x3;
                  });
                  if (x3._explicit && b3 && x3.mutatedParts)
                    for (var u2 = 0, s2 = Object.values(i3.queries.query); u2 < s2.length; u2++)
                      for (var c2 = 0, l3 = (d2 = s2[u2]).slice(); c2 < l3.length; c2++)
                        Kn((p3 = l3[c2]).obsSet, x3.mutatedParts) && (T2(d2, p3), p3.subscribers.forEach(function(e5) {
                          return t4.add(e5);
                        }));
                  else if (0 < a3.length) {
                    i3.optimisticOps = i3.optimisticOps.filter(function(e5) {
                      return e5.trans !== x3;
                    });
                    for (var f3 = 0, h3 = Object.values(i3.queries.query); f3 < h3.length; f3++)
                      for (var d2, p3, y3, v3 = 0, m3 = (d2 = h3[f3]).slice(); v3 < m3.length; v3++)
                        null != (p3 = m3[v3]).res && x3.mutatedParts && (b3 && !p3.dirty ? (y3 = Object.isFrozen(p3.res), y3 = Qn(p3.res, p3.req, a3, o3, p3, y3), p3.dirty ? (T2(d2, p3), p3.subscribers.forEach(function(e5) {
                          return t4.add(e5);
                        })) : y3 !== p3.res && (p3.res = y3, p3.promise = _e.resolve({ result: y3 }))) : (p3.dirty && T2(d2, p3), p3.subscribers.forEach(function(e5) {
                          return t4.add(e5);
                        })));
                  }
                }
              }
              t4.forEach(function(e5) {
                return e5();
              });
            }
          };
        }, x3.addEventListener("abort", e3(false), { signal: t3 }), x3.addEventListener("error", e3(false), { signal: t3 }), x3.addEventListener("complete", e3(true), { signal: t3 })), x3;
      }, table: function(c2) {
        var l3 = k3.table(c2), i3 = l3.schema.primaryKey;
        return w2(w2({}, l3), { mutate: function(t3) {
          var e3 = me.trans;
          if (i3.outbound || "disabled" === e3.db._options.cache || e3.explicit)
            return l3.mutate(t3);
          var n3 = Sn["idb://".concat(O2, "/").concat(c2)];
          if (!n3)
            return l3.mutate(t3);
          e3 = l3.mutate(t3);
          return "add" !== t3.type && "put" !== t3.type || !(50 <= t3.values.length || Mn(i3, t3).some(function(e4) {
            return null == e4;
          })) ? (n3.optimisticOps.push(t3), t3.mutatedParts && Cn(t3.mutatedParts), e3.then(function(e4) {
            0 < e4.numFailures && (T2(n3.optimisticOps, t3), (e4 = Yn(0, t3, e4)) && n3.optimisticOps.push(e4), t3.mutatedParts && Cn(t3.mutatedParts));
          }), e3.catch(function() {
            T2(n3.optimisticOps, t3), t3.mutatedParts && Cn(t3.mutatedParts);
          })) : e3.then(function(r3) {
            var e4 = Yn(0, w2(w2({}, t3), { values: t3.values.map(function(e5, t4) {
              var n4, e5 = null !== (n4 = i3.keyPath) && void 0 !== n4 && n4.includes(".") ? S2(e5) : w2({}, e5);
              return P(e5, i3.keyPath, r3.results[t4]), e5;
            }) }), r3);
            n3.optimisticOps.push(e4), queueMicrotask(function() {
              return t3.mutatedParts && Cn(t3.mutatedParts);
            });
          }), e3;
        }, query: function(t3) {
          if (!zn(me, l3) || !Vn("query", t3))
            return l3.query(t3);
          var i4 = "immutable" === (null === (o3 = me.trans) || void 0 === o3 ? void 0 : o3.db._options.cache), e3 = me, n3 = e3.requery, r3 = e3.signal, o3 = function(e4, t4, n4, r4) {
            var i5 = Sn["idb://".concat(e4, "/").concat(t4)];
            if (!i5)
              return [];
            if (!(t4 = i5.queries[n4]))
              return [null, false, i5, null];
            var o4 = t4[(r4.query ? r4.query.index.name : null) || ""];
            if (!o4)
              return [null, false, i5, null];
            switch (n4) {
              case "query":
                var a4 = o4.find(function(e5) {
                  return e5.req.limit === r4.limit && e5.req.values === r4.values && Gn(e5.req.query.range, r4.query.range);
                });
                return a4 ? [a4, true, i5, o4] : [o4.find(function(e5) {
                  return ("limit" in e5.req ? e5.req.limit : 1 / 0) >= r4.limit && (!r4.values || e5.req.values) && Xn(e5.req.query.range, r4.query.range);
                }), false, i5, o4];
              case "count":
                a4 = o4.find(function(e5) {
                  return Gn(e5.req.query.range, r4.query.range);
                });
                return [a4, !!a4, i5, o4];
            }
          }(O2, c2, "query", t3), a3 = o3[0], e3 = o3[1], u2 = o3[2], s2 = o3[3];
          return a3 && e3 ? a3.obsSet = t3.obsSet : (e3 = l3.query(t3).then(function(e4) {
            var t4 = e4.result;
            if (a3 && (a3.res = t4), i4) {
              for (var n4 = 0, r4 = t4.length; n4 < r4; ++n4)
                Object.freeze(t4[n4]);
              Object.freeze(t4);
            } else
              e4.result = S2(t4);
            return e4;
          }).catch(function(e4) {
            return s2 && a3 && T2(s2, a3), Promise.reject(e4);
          }), a3 = { obsSet: t3.obsSet, promise: e3, subscribers: /* @__PURE__ */ new Set(), type: "query", req: t3, dirty: false }, s2 ? s2.push(a3) : (s2 = [a3], (u2 = u2 || (Sn["idb://".concat(O2, "/").concat(c2)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[t3.query.index.name || ""] = s2)), Hn(a3, s2, n3, r3), a3.promise.then(function(e4) {
            return { result: Qn(e4.result, t3, null == u2 ? void 0 : u2.optimisticOps, l3, a3, i4) };
          });
        } });
      } });
    } };
    function Zn(e3, r3) {
      return new Proxy(e3, { get: function(e4, t3, n3) {
        return "db" === t3 ? r3 : Reflect.get(e4, t3, n3);
      } });
    }
    var er = (tr2.prototype.version = function(t3) {
      if (isNaN(t3) || t3 < 0.1)
        throw new Y.Type("Given version is not a positive number");
      if (t3 = Math.round(10 * t3) / 10, this.idbdb || this._state.isBeingOpened)
        throw new Y.Schema("Cannot add version when database is open");
      this.verno = Math.max(this.verno, t3);
      var e3 = this._versions, n3 = e3.filter(function(e4) {
        return e4._cfg.version === t3;
      })[0];
      return n3 || (n3 = new this.Version(t3), e3.push(n3), e3.sort(nn), n3.stores({}), this._state.autoSchema = false, n3);
    }, tr2.prototype._whenReady = function(e3) {
      var n3 = this;
      return this.idbdb && (this._state.openComplete || me.letThrough || this._vip) ? e3() : new _e(function(e4, t3) {
        if (n3._state.openComplete)
          return t3(new Y.DatabaseClosed(n3._state.dbOpenError));
        if (!n3._state.isBeingOpened) {
          if (!n3._state.autoOpen)
            return void t3(new Y.DatabaseClosed());
          n3.open().catch(G);
        }
        n3._state.dbReadyPromise.then(e4, t3);
      }).then(e3);
    }, tr2.prototype.use = function(e3) {
      var t3 = e3.stack, n3 = e3.create, r3 = e3.level, i3 = e3.name;
      i3 && this.unuse({ stack: t3, name: i3 });
      e3 = this._middlewares[t3] || (this._middlewares[t3] = []);
      return e3.push({ stack: t3, create: n3, level: null == r3 ? 10 : r3, name: i3 }), e3.sort(function(e4, t4) {
        return e4.level - t4.level;
      }), this;
    }, tr2.prototype.unuse = function(e3) {
      var t3 = e3.stack, n3 = e3.name, r3 = e3.create;
      return t3 && this._middlewares[t3] && (this._middlewares[t3] = this._middlewares[t3].filter(function(e4) {
        return r3 ? e4.create !== r3 : !!n3 && e4.name !== n3;
      })), this;
    }, tr2.prototype.open = function() {
      var e3 = this;
      return $e(ve, function() {
        return qn(e3);
      });
    }, tr2.prototype._close = function() {
      var n3 = this._state, e3 = et.indexOf(this);
      if (0 <= e3 && et.splice(e3, 1), this.idbdb) {
        try {
          this.idbdb.close();
        } catch (e4) {
        }
        this.idbdb = null;
      }
      n3.isBeingOpened || (n3.dbReadyPromise = new _e(function(e4) {
        n3.dbReadyResolve = e4;
      }), n3.openCanceller = new _e(function(e4, t3) {
        n3.cancelOpen = t3;
      }));
    }, tr2.prototype.close = function(e3) {
      var t3 = (void 0 === e3 ? { disableAutoOpen: true } : e3).disableAutoOpen, e3 = this._state;
      t3 ? (e3.isBeingOpened && e3.cancelOpen(new Y.DatabaseClosed()), this._close(), e3.autoOpen = false, e3.dbOpenError = new Y.DatabaseClosed()) : (this._close(), e3.autoOpen = this._options.autoOpen || e3.isBeingOpened, e3.openComplete = false, e3.dbOpenError = null);
    }, tr2.prototype.delete = function(n3) {
      var i3 = this;
      void 0 === n3 && (n3 = { disableAutoOpen: true });
      var o3 = 0 < arguments.length && "object" != typeof arguments[0], a3 = this._state;
      return new _e(function(r3, t3) {
        function e3() {
          i3.close(n3);
          var e4 = i3._deps.indexedDB.deleteDatabase(i3.name);
          e4.onsuccess = Te(function() {
            var e5, t4, n4;
            e5 = i3._deps, t4 = i3.name, n4 = e5.indexedDB, e5 = e5.IDBKeyRange, vn(n4) || t4 === tt || yn(n4, e5).delete(t4).catch(G), r3();
          }), e4.onerror = Bt(t3), e4.onblocked = i3._fireOnBlocked;
        }
        if (o3)
          throw new Y.InvalidArgument("Invalid closeOptions argument to db.delete()");
        a3.isBeingOpened ? a3.dbReadyPromise.then(e3) : e3();
      });
    }, tr2.prototype.backendDB = function() {
      return this.idbdb;
    }, tr2.prototype.isOpen = function() {
      return null !== this.idbdb;
    }, tr2.prototype.hasBeenClosed = function() {
      var e3 = this._state.dbOpenError;
      return e3 && "DatabaseClosed" === e3.name;
    }, tr2.prototype.hasFailed = function() {
      return null !== this._state.dbOpenError;
    }, tr2.prototype.dynamicallyOpened = function() {
      return this._state.autoSchema;
    }, Object.defineProperty(tr2.prototype, "tables", { get: function() {
      var t3 = this;
      return _2(this._allTables).map(function(e3) {
        return t3._allTables[e3];
      });
    }, enumerable: false, configurable: true }), tr2.prototype.transaction = function() {
      var e3 = function(e4, t3, n3) {
        var r3 = arguments.length;
        if (r3 < 2)
          throw new Y.InvalidArgument("Too few arguments");
        for (var i3 = new Array(r3 - 1); --r3; )
          i3[r3 - 1] = arguments[r3];
        return n3 = i3.pop(), [e4, O(i3), n3];
      }.apply(this, arguments);
      return this._transaction.apply(this, e3);
    }, tr2.prototype._transaction = function(e3, t3, n3) {
      var r3 = this, i3 = me.trans;
      i3 && i3.db === this && -1 === e3.indexOf("!") || (i3 = null);
      var o3, a3, u2 = -1 !== e3.indexOf("?");
      e3 = e3.replace("!", "").replace("?", "");
      try {
        if (a3 = t3.map(function(e4) {
          e4 = e4 instanceof r3.Table ? e4.name : e4;
          if ("string" != typeof e4)
            throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
          return e4;
        }), "r" == e3 || e3 === nt)
          o3 = nt;
        else {
          if ("rw" != e3 && e3 != rt)
            throw new Y.InvalidArgument("Invalid transaction mode: " + e3);
          o3 = rt;
        }
        if (i3) {
          if (i3.mode === nt && o3 === rt) {
            if (!u2)
              throw new Y.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
            i3 = null;
          }
          i3 && a3.forEach(function(e4) {
            if (i3 && -1 === i3.storeNames.indexOf(e4)) {
              if (!u2)
                throw new Y.SubTransaction("Table " + e4 + " not included in parent transaction.");
              i3 = null;
            }
          }), u2 && i3 && !i3.active && (i3 = null);
        }
      } catch (n4) {
        return i3 ? i3._promise(null, function(e4, t4) {
          t4(n4);
        }) : Xe(n4);
      }
      var s2 = function i4(o4, a4, u3, s3, c2) {
        return _e.resolve().then(function() {
          var e4 = me.transless || me, t4 = o4._createTransaction(a4, u3, o4._dbSchema, s3);
          if (t4.explicit = true, e4 = { trans: t4, transless: e4 }, s3)
            t4.idbtrans = s3.idbtrans;
          else
            try {
              t4.create(), t4.idbtrans._explicit = true, o4._state.PR1398_maxLoop = 3;
            } catch (e5) {
              return e5.name === V.InvalidState && o4.isOpen() && 0 < --o4._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), o4.close({ disableAutoOpen: false }), o4.open().then(function() {
                return i4(o4, a4, u3, null, c2);
              })) : Xe(e5);
            }
          var n4, r4 = B(c2);
          return r4 && Le(), e4 = _e.follow(function() {
            var e5;
            (n4 = c2.call(t4, t4)) && (r4 ? (e5 = Ue.bind(null, null), n4.then(e5, e5)) : "function" == typeof n4.next && "function" == typeof n4.throw && (n4 = In(n4)));
          }, e4), (n4 && "function" == typeof n4.then ? _e.resolve(n4).then(function(e5) {
            return t4.active ? e5 : Xe(new Y.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
          }) : e4.then(function() {
            return n4;
          })).then(function(e5) {
            return s3 && t4._resolve(), t4._completion.then(function() {
              return e5;
            });
          }).catch(function(e5) {
            return t4._reject(e5), Xe(e5);
          });
        });
      }.bind(null, this, o3, a3, i3, n3);
      return i3 ? i3._promise(o3, s2, "lock") : me.trans ? $e(me.transless, function() {
        return r3._whenReady(s2);
      }) : this._whenReady(s2);
    }, tr2.prototype.table = function(e3) {
      if (!m2(this._allTables, e3))
        throw new Y.InvalidTable("Table ".concat(e3, " does not exist"));
      return this._allTables[e3];
    }, tr2);
    function tr2(e3, t3) {
      var o3 = this;
      this._middlewares = {}, this.verno = 0;
      var n3 = tr2.dependencies;
      this._options = t3 = w2({ addons: tr2.addons, autoOpen: true, indexedDB: n3.indexedDB, IDBKeyRange: n3.IDBKeyRange, cache: "cloned" }, t3), this._deps = { indexedDB: t3.indexedDB, IDBKeyRange: t3.IDBKeyRange };
      n3 = t3.addons;
      this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
      var a3, r3, u2, i3, s2, c2 = { dbOpenError: null, isBeingOpened: false, onReadyBeingFired: null, openComplete: false, dbReadyResolve: G, dbReadyPromise: null, cancelOpen: G, openCanceller: null, autoSchema: true, PR1398_maxLoop: 3, autoOpen: t3.autoOpen };
      c2.dbReadyPromise = new _e(function(e4) {
        c2.dbReadyResolve = e4;
      }), c2.openCanceller = new _e(function(e4, t4) {
        c2.cancelOpen = t4;
      }), this._state = c2, this.name = e3, this.on = dt(this, "populate", "blocked", "versionchange", "close", { ready: [re, G] }), this.on.ready.subscribe = p2(this.on.ready.subscribe, function(i4) {
        return function(n4, r4) {
          tr2.vip(function() {
            var t4, e4 = o3._state;
            e4.openComplete ? (e4.dbOpenError || _e.resolve().then(n4), r4 && i4(n4)) : e4.onReadyBeingFired ? (e4.onReadyBeingFired.push(n4), r4 && i4(n4)) : (i4(n4), t4 = o3, r4 || i4(function e5() {
              t4.on.ready.unsubscribe(n4), t4.on.ready.unsubscribe(e5);
            }));
          });
        };
      }), this.Collection = (a3 = this, pt2(Ot.prototype, function(e4, t4) {
        this.db = a3;
        var n4 = ot, r4 = null;
        if (t4)
          try {
            n4 = t4();
          } catch (e5) {
            r4 = e5;
          }
        var i4 = e4._ctx, t4 = i4.table, e4 = t4.hook.reading.fire;
        this._ctx = { table: t4, index: i4.index, isPrimKey: !i4.index || t4.schema.primKey.keyPath && i4.index === t4.schema.primKey.name, range: n4, keysOnly: false, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: true, isMatch: null, offset: 0, limit: 1 / 0, error: r4, or: i4.or, valueMapper: e4 !== X2 ? e4 : null };
      })), this.Table = (r3 = this, pt2(ft.prototype, function(e4, t4, n4) {
        this.db = r3, this._tx = n4, this.name = e4, this.schema = t4, this.hook = r3._allTables[e4] ? r3._allTables[e4].hook : dt(null, { creating: [Z, G], reading: [H, X2], updating: [te, G], deleting: [ee, G] });
      })), this.Transaction = (u2 = this, pt2(Lt.prototype, function(e4, t4, n4, r4, i4) {
        var o4 = this;
        this.db = u2, this.mode = e4, this.storeNames = t4, this.schema = n4, this.chromeTransactionDurability = r4, this.idbtrans = null, this.on = dt(this, "complete", "error", "abort"), this.parent = i4 || null, this.active = true, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new _e(function(e5, t5) {
          o4._resolve = e5, o4._reject = t5;
        }), this._completion.then(function() {
          o4.active = false, o4.on.complete.fire();
        }, function(e5) {
          var t5 = o4.active;
          return o4.active = false, o4.on.error.fire(e5), o4.parent ? o4.parent._reject(e5) : t5 && o4.idbtrans && o4.idbtrans.abort(), Xe(e5);
        });
      })), this.Version = (i3 = this, pt2(dn.prototype, function(e4) {
        this.db = i3, this._cfg = { version: e4, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
      })), this.WhereClause = (s2 = this, pt2(qt.prototype, function(e4, t4, n4) {
        if (this.db = s2, this._ctx = { table: e4, index: ":id" === t4 ? null : t4, or: n4 }, this._cmp = this._ascending = st, this._descending = function(e5, t5) {
          return st(t5, e5);
        }, this._max = function(e5, t5) {
          return 0 < st(e5, t5) ? e5 : t5;
        }, this._min = function(e5, t5) {
          return st(e5, t5) < 0 ? e5 : t5;
        }, this._IDBKeyRange = s2._deps.IDBKeyRange, !this._IDBKeyRange)
          throw new Y.MissingAPI();
      })), this.on("versionchange", function(e4) {
        0 < e4.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o3.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o3.name, "'. Closing db now to resume the delete request.")), o3.close({ disableAutoOpen: false });
      }), this.on("blocked", function(e4) {
        !e4.newVersion || e4.newVersion < e4.oldVersion ? console.warn("Dexie.delete('".concat(o3.name, "') was blocked")) : console.warn("Upgrade '".concat(o3.name, "' blocked by other connection holding version ").concat(e4.oldVersion / 10));
      }), this._maxKey = Yt(t3.IDBKeyRange), this._createTransaction = function(e4, t4, n4, r4) {
        return new o3.Transaction(e4, t4, n4, o3._options.chromeTransactionDurability, r4);
      }, this._fireOnBlocked = function(t4) {
        o3.on("blocked").fire(t4), et.filter(function(e4) {
          return e4.name === o3.name && e4 !== o3 && !e4._state.vcFired;
        }).map(function(e4) {
          return e4.on("versionchange").fire(t4);
        });
      }, this.use(Un), this.use(Jn), this.use(Wn), this.use(Rn), this.use(Nn);
      var l3 = new Proxy(this, { get: function(e4, t4, n4) {
        if ("_vip" === t4)
          return true;
        if ("table" === t4)
          return function(e5) {
            return Zn(o3.table(e5), l3);
          };
        var r4 = Reflect.get(e4, t4, n4);
        return r4 instanceof ft ? Zn(r4, l3) : "tables" === t4 ? r4.map(function(e5) {
          return Zn(e5, l3);
        }) : "_createTransaction" === t4 ? function() {
          return Zn(r4.apply(this, arguments), l3);
        } : r4;
      } });
      this.vip = l3, n3.forEach(function(e4) {
        return e4(o3);
      });
    }
    var nr, F = "undefined" != typeof Symbol && "observable" in Symbol ? Symbol.observable : "@@observable", rr = (ir.prototype.subscribe = function(e3, t3, n3) {
      return this._subscribe(e3 && "function" != typeof e3 ? e3 : { next: e3, error: t3, complete: n3 });
    }, ir.prototype[F] = function() {
      return this;
    }, ir);
    function ir(e3) {
      this._subscribe = e3;
    }
    try {
      nr = { indexedDB: f2.indexedDB || f2.mozIndexedDB || f2.webkitIndexedDB || f2.msIndexedDB, IDBKeyRange: f2.IDBKeyRange || f2.webkitIDBKeyRange };
    } catch (e3) {
      nr = { indexedDB: null, IDBKeyRange: null };
    }
    function or(h3) {
      var d2, p3 = false, e3 = new rr(function(r3) {
        var i3 = B(h3);
        var o3, a3 = false, u2 = {}, s2 = {}, e4 = { get closed() {
          return a3;
        }, unsubscribe: function() {
          a3 || (a3 = true, o3 && o3.abort(), c2 && Nt.storagemutated.unsubscribe(f3));
        } };
        r3.start && r3.start(e4);
        var c2 = false, l3 = function() {
          return Ge(t3);
        };
        var f3 = function(e5) {
          En(u2, e5), Kn(s2, u2) && l3();
        }, t3 = function() {
          var t4, n3, e5;
          !a3 && nr.indexedDB && (u2 = {}, t4 = {}, o3 && o3.abort(), o3 = new AbortController(), e5 = function(e6) {
            var t5 = je();
            try {
              i3 && Le();
              var n4 = Ne(h3, e6);
              return n4 = i3 ? n4.finally(Ue) : n4;
            } finally {
              t5 && Ae();
            }
          }(n3 = { subscr: t4, signal: o3.signal, requery: l3, querier: h3, trans: null }), Promise.resolve(e5).then(function(e6) {
            p3 = true, d2 = e6, a3 || n3.signal.aborted || (u2 = {}, function(e7) {
              for (var t5 in e7)
                if (m2(e7, t5))
                  return;
              return 1;
            }(s2 = t4) || c2 || (Nt(Ft, f3), c2 = true), Ge(function() {
              return !a3 && r3.next && r3.next(e6);
            }));
          }, function(e6) {
            p3 = false, ["DatabaseClosedError", "AbortError"].includes(null == e6 ? void 0 : e6.name) || a3 || Ge(function() {
              a3 || r3.error && r3.error(e6);
            });
          }));
        };
        return setTimeout(l3, 0), e4;
      });
      return e3.hasValue = function() {
        return p3;
      }, e3.getValue = function() {
        return d2;
      }, e3;
    }
    var ar2 = er;
    function ur(e3) {
      var t3 = cr;
      try {
        cr = true, Nt.storagemutated.fire(e3), Dn(e3, true);
      } finally {
        cr = t3;
      }
    }
    r2(ar2, w2(w2({}, Q), { delete: function(e3) {
      return new ar2(e3, { addons: [] }).delete();
    }, exists: function(e3) {
      return new ar2(e3, { addons: [] }).open().then(function(e4) {
        return e4.close(), true;
      }).catch("NoSuchDatabaseError", function() {
        return false;
      });
    }, getDatabaseNames: function(e3) {
      try {
        return t3 = ar2.dependencies, n3 = t3.indexedDB, t3 = t3.IDBKeyRange, (vn(n3) ? Promise.resolve(n3.databases()).then(function(e4) {
          return e4.map(function(e5) {
            return e5.name;
          }).filter(function(e5) {
            return e5 !== tt;
          });
        }) : yn(n3, t3).toCollection().primaryKeys()).then(e3);
      } catch (e4) {
        return Xe(new Y.MissingAPI());
      }
      var t3, n3;
    }, defineClass: function() {
      return function(e3) {
        a2(this, e3);
      };
    }, ignoreTransaction: function(e3) {
      return me.trans ? $e(me.transless, e3) : e3();
    }, vip: mn, async: function(t3) {
      return function() {
        try {
          var e3 = In(t3.apply(this, arguments));
          return e3 && "function" == typeof e3.then ? e3 : _e.resolve(e3);
        } catch (e4) {
          return Xe(e4);
        }
      };
    }, spawn: function(e3, t3, n3) {
      try {
        var r3 = In(e3.apply(n3, t3 || []));
        return r3 && "function" == typeof r3.then ? r3 : _e.resolve(r3);
      } catch (e4) {
        return Xe(e4);
      }
    }, currentTransaction: { get: function() {
      return me.trans || null;
    } }, waitFor: function(e3, t3) {
      t3 = _e.resolve("function" == typeof e3 ? ar2.ignoreTransaction(e3) : e3).timeout(t3 || 6e4);
      return me.trans ? me.trans.waitFor(t3) : t3;
    }, Promise: _e, debug: { get: function() {
      return ie;
    }, set: function(e3) {
      oe(e3);
    } }, derive: o2, extend: a2, props: r2, override: p2, Events: dt, on: Nt, liveQuery: or, extendObservabilitySet: En, getByKeyPath: k2, setByKeyPath: P, delByKeyPath: function(t3, e3) {
      "string" == typeof e3 ? P(t3, e3, void 0) : "length" in e3 && [].map.call(e3, function(e4) {
        P(t3, e4, void 0);
      });
    }, shallowClone: g2, deepClone: S2, getObjectDiff: Fn, cmp: st, asap: v2, minKey: -1 / 0, addons: [], connections: et, errnames: V, dependencies: nr, cache: Sn, semVer: "4.0.7", version: "4.0.7".split(".").map(function(e3) {
      return parseInt(e3);
    }).reduce(function(e3, t3, n3) {
      return e3 + t3 / Math.pow(10, 2 * n3);
    }) })), ar2.maxKey = Yt(ar2.dependencies.IDBKeyRange), "undefined" != typeof dispatchEvent && "undefined" != typeof addEventListener && (Nt(Ft, function(e3) {
      cr || (e3 = new CustomEvent(Mt, { detail: e3 }), cr = true, dispatchEvent(e3), cr = false);
    }), addEventListener(Mt, function(e3) {
      e3 = e3.detail;
      cr || ur(e3);
    }));
    var sr, cr = false, lr = function() {
    };
    return "undefined" != typeof BroadcastChannel && ((lr = function() {
      (sr = new BroadcastChannel(Mt)).onmessage = function(e3) {
        return e3.data && ur(e3.data);
      };
    })(), "function" == typeof sr.unref && sr.unref(), Nt(Ft, function(e3) {
      cr || sr.postMessage(e3);
    })), "undefined" != typeof addEventListener && (addEventListener("pagehide", function(e3) {
      if (!er.disableBfCache && e3.persisted) {
        ie && console.debug("Dexie: handling persisted pagehide"), null != sr && sr.close();
        for (var t3 = 0, n3 = et; t3 < n3.length; t3++)
          n3[t3].close({ disableAutoOpen: false });
      }
    }), addEventListener("pageshow", function(e3) {
      !er.disableBfCache && e3.persisted && (ie && console.debug("Dexie: handling persisted pageshow"), lr(), ur({ all: new gn(-1 / 0, [[]]) }));
    })), _e.rejectionMapper = function(e3, t3) {
      return !e3 || e3 instanceof N || e3 instanceof TypeError || e3 instanceof SyntaxError || !e3.name || !$2[e3.name] ? e3 : (t3 = new $2[e3.name](t3 || e3.message, e3), "stack" in e3 && l2(t3, "stack", { get: function() {
        return this.inner.stack;
      } }), t3);
    }, oe(ie), w2(er, Object.freeze({ __proto__: null, Dexie: er, liveQuery: or, Entity: ut, cmp: st, PropModSymbol: e2, PropModification: xt, replacePrefix: function(e3, t3) {
      return new xt({ replacePrefix: [e3, t3] });
    }, add: function(e3) {
      return new xt({ add: e3 });
    }, remove: function(e3) {
      return new xt({ remove: e3 });
    }, default: er, RangeSet: gn, mergeRanges: _n, rangesOverlap: xn }), { default: er }), er;
  });
})(dexie_min);
var dexie_minExports = dexie_min.exports;
const _Dexie = /* @__PURE__ */ getDefaultExportFromCjs(dexie_minExports);
const DexieSymbol = Symbol.for("Dexie");
const Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = _Dexie);
if (_Dexie.semVer !== Dexie.semVer) {
  throw new Error(`Two different versions of Dexie loaded in the same app: ${_Dexie.semVer} and ${Dexie.semVer}`);
}
const {
  liveQuery,
  mergeRanges,
  rangesOverlap,
  RangeSet,
  cmp,
  Entity,
  PropModSymbol,
  PropModification,
  replacePrefix,
  add,
  remove: remove$1
} = Dexie;
const schemaBook = "&id, name, author, cover, description, category, size, pages, path, language, publisher, publishTime, createTime, updateTime, isDelete, &md5, count, lastReadPosition,score,progress,group";
const schemaBookId2 = schemaBook + ",isReadDone,format,isLove";
const schemaBookContent = "&bookId, content";
const schemaBookshelf = "&id, createTime,updateTime,isDelete,name";
const schemaNote = "&id, eBookId,sourceId, chapterIndex, chapterName, bookText, notes, domSource, createTime, updateTime, isDelete, colorName, tag";
const schemeReadTime = "&id, eBookId,creatTime,startTime,endTime";
const schemaTag = "&id, createTime,updateTime,isDelete,tagName";
const db = new Dexie("__BookWiseDatabase__");
db.version(1).stores({
  books: schemaBook,
  //
  bookContents: schemaBookContent,
  // 
  notes: schemaNote,
  // 
  readTime: schemeReadTime,
  // 
  tag: schemaTag
  // 
});
db.version(3).stores({
  books: schemaBookId2,
  //
  bookContents: schemaBookContent,
  // 
  notes: schemaNote,
  // 
  readTime: schemeReadTime,
  // 
  tag: schemaTag,
  // 
  bookshelf: schemaBookshelf
  // 
}).upgrade((transaction) => {
  transaction.table("books").toCollection().modify((item) => {
    item.isReadDone = false;
    item.format = "";
  });
});
function useObservable(observable, options) {
  const value = ref(void 0);
  const subscription = observable.subscribe({
    next: (val) => value.value = val,
    error: void 0
  });
  tryOnScopeDispose$1(() => {
    subscription.unsubscribe();
  });
  return value;
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
class BookAction {
  static bulkAdd(book2) {
    try {
      return db.books.bulkAdd(book2);
    } catch (error) {
      toastError(t$2("book.importBookFail") + error);
      return Promise.reject(error);
    }
  }
  static removeOne(id2, isForce) {
    try {
      if (isForce) {
        return db.books.delete(id2);
      } else {
        return db.books.update(id2, { isDelete: now() });
      }
    } catch (error) {
      toastError("common.removeFail" + error);
      return Promise.reject(error);
    }
  }
  static update(id2, value) {
    try {
      return db.books.update(id2, { ...value, updateTime: now() });
    } catch (error) {
      toastError(t$2("common.editFail") + error);
      return Promise.reject(error);
    }
  }
  static restoreOne(id2) {
    try {
      return db.books.update(id2, { isDelete: null });
    } catch (error) {
      toastError(t$2("common.restoreFail") + error);
      return Promise.reject(error);
    }
  }
  static fineOne(id2) {
    try {
      return db.books.get(id2);
    } catch (error) {
      toastError(t$2("book.getBookFail") + error);
      return Promise.reject(error);
    }
  }
  static getAll() {
    try {
      return db.books.toArray();
    } catch (error) {
      toastError(t$2("book.getBookListFail") + error);
      return Promise.reject(error);
    }
  }
  static observableOne(id2) {
    try {
      return useObservable(
        liveQuery(async () => (await db.books.toArray()).find((item) => item.id === id2))
      );
    } catch (error) {
      toastError(t$2("book.getBookFail") + error);
      return void 0;
    }
  }
  static observable(isDelete = false) {
    try {
      return useObservable(
        liveQuery(
          async () => (await db.books.toArray()).filter((item) => isDelete ? item.isDelete : !item.isDelete)
        )
      );
    } catch (error) {
      toastError(t$2("book.getBookListFail") + error);
      return [];
    }
  }
}
function bookJump(id2) {
  const isBlank = settingStore.value.isOpenNew;
  if (isElectron) {
    if (isBlank) {
      const { href } = router.resolve({ name: RouterName.Reader, params: { id: id2 } });
      window.open(href, "_blank");
    } else {
      router.push({ name: RouterName.Reader, params: { id: id2 } });
    }
  } else {
    if (isBlank) {
      const { href } = router.resolve({ name: RouterName.Reader, params: { id: id2 } });
      window.open(href, "_blank");
    } else {
      router.push({ name: RouterName.Reader, params: { id: id2 } });
    }
  }
}
class BookContentAction {
  static bulkAdd(bookContentList) {
    try {
      return db.bookContents.bulkPut(bookContentList);
    } catch (error) {
      toastError(t$2("book.importBookFail") + error);
      return Promise.reject(error);
    }
  }
  static async findOne(bookId) {
    return await db.bookContents.where("bookId").equals(bookId).first();
  }
}
class BookReadTimeAction {
  static add(value) {
    try {
      const time = {
        id: v4(),
        ...value,
        creatTime: now()
      };
      return db.readTime.put(time);
    } catch (error) {
      toastError(t$2("book.recordBookTimeFail") + error);
      return Promise.reject(error);
    }
  }
  static async getAll() {
    return db.readTime.toArray();
  }
  static observableOne(eBookId) {
    try {
      return useObservable(
        liveQuery(
          async () => (await db.readTime.toArray()).filter((item) => item.eBookId === eBookId)
        )
      );
    } catch (error) {
      toastError(t$2("book.getBookReadTimeFail") + error);
      return [];
    }
  }
  static findByEbookId(eBookId) {
    try {
      return db.readTime.where("eBookId").equals(eBookId).toArray();
    } catch (error) {
      toastError(t$2("book.getBookReadTimeListFail") + error);
      return [];
    }
  }
}
const t$1 = (t2) => "object" == typeof t2 && null != t2 && 1 === t2.nodeType, e$2 = (t2, e2) => (!e2 || "hidden" !== t2) && ("visible" !== t2 && "clip" !== t2), n$1 = (t2, n2) => {
  if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
    const o2 = getComputedStyle(t2, null);
    return e$2(o2.overflowY, n2) || e$2(o2.overflowX, n2) || ((t3) => {
      const e2 = ((t4) => {
        if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
          return null;
        try {
          return t4.ownerDocument.defaultView.frameElement;
        } catch (t5) {
          return null;
        }
      })(t3);
      return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
    })(t2);
  }
  return false;
}, o$2 = (t2, e2, n2, o2, l2, r2, i2, s) => r2 < t2 && i2 > e2 || r2 > t2 && i2 < e2 ? 0 : r2 <= t2 && s <= n2 || i2 >= e2 && s >= n2 ? r2 - t2 - o2 : i2 > e2 && s < n2 || r2 < t2 && s > n2 ? i2 - e2 + l2 : 0, l$1 = (t2) => {
  const e2 = t2.parentElement;
  return null == e2 ? t2.getRootNode().host || null : e2;
}, r$1 = (e2, r2) => {
  var i2, s, d, h2;
  if ("undefined" == typeof document)
    return [];
  const { scrollMode: c, block: f2, inline: u, boundary: a2, skipOverflowHiddenElements: g2 } = r2, p2 = "function" == typeof a2 ? a2 : (t2) => t2 !== a2;
  if (!t$1(e2))
    throw new TypeError("Invalid target");
  const m2 = document.scrollingElement || document.documentElement, w2 = [];
  let W = e2;
  for (; t$1(W) && p2(W); ) {
    if (W = l$1(W), W === m2) {
      w2.push(W);
      break;
    }
    null != W && W === document.body && n$1(W) && !n$1(document.documentElement) || null != W && n$1(W, g2) && w2.push(W);
  }
  const b2 = null != (s = null == (i2 = window.visualViewport) ? void 0 : i2.width) ? s : innerWidth, H = null != (h2 = null == (d = window.visualViewport) ? void 0 : d.height) ? h2 : innerHeight, { scrollX: y2, scrollY: M } = window, { height: v2, width: E2, top: x2, right: C, bottom: I, left: R } = e2.getBoundingClientRect(), { top: T2, right: B, bottom: F, left: V } = ((t2) => {
    const e3 = window.getComputedStyle(t2);
    return { top: parseFloat(e3.scrollMarginTop) || 0, right: parseFloat(e3.scrollMarginRight) || 0, bottom: parseFloat(e3.scrollMarginBottom) || 0, left: parseFloat(e3.scrollMarginLeft) || 0 };
  })(e2);
  let k2 = "start" === f2 || "nearest" === f2 ? x2 - T2 : "end" === f2 ? I + F : x2 + v2 / 2 - T2 + F, D = "center" === u ? R + E2 / 2 - V + B : "end" === u ? C + B : R - V;
  const L = [];
  for (let t2 = 0; t2 < w2.length; t2++) {
    const e3 = w2[t2], { height: n2, width: l2, top: r3, right: i3, bottom: s2, left: d2 } = e3.getBoundingClientRect();
    if ("if-needed" === c && x2 >= 0 && R >= 0 && I <= H && C <= b2 && x2 >= r3 && I <= s2 && R >= d2 && C <= i3)
      return L;
    const h3 = getComputedStyle(e3), a3 = parseInt(h3.borderLeftWidth, 10), g3 = parseInt(h3.borderTopWidth, 10), p3 = parseInt(h3.borderRightWidth, 10), W2 = parseInt(h3.borderBottomWidth, 10);
    let T3 = 0, B2 = 0;
    const F2 = "offsetWidth" in e3 ? e3.offsetWidth - e3.clientWidth - a3 - p3 : 0, V2 = "offsetHeight" in e3 ? e3.offsetHeight - e3.clientHeight - g3 - W2 : 0, S2 = "offsetWidth" in e3 ? 0 === e3.offsetWidth ? 0 : l2 / e3.offsetWidth : 0, X2 = "offsetHeight" in e3 ? 0 === e3.offsetHeight ? 0 : n2 / e3.offsetHeight : 0;
    if (m2 === e3)
      T3 = "start" === f2 ? k2 : "end" === f2 ? k2 - H : "nearest" === f2 ? o$2(M, M + H, H, g3, W2, M + k2, M + k2 + v2, v2) : k2 - H / 2, B2 = "start" === u ? D : "center" === u ? D - b2 / 2 : "end" === u ? D - b2 : o$2(y2, y2 + b2, b2, a3, p3, y2 + D, y2 + D + E2, E2), T3 = Math.max(0, T3 + M), B2 = Math.max(0, B2 + y2);
    else {
      T3 = "start" === f2 ? k2 - r3 - g3 : "end" === f2 ? k2 - s2 + W2 + V2 : "nearest" === f2 ? o$2(r3, s2, n2, g3, W2 + V2, k2, k2 + v2, v2) : k2 - (r3 + n2 / 2) + V2 / 2, B2 = "start" === u ? D - d2 - a3 : "center" === u ? D - (d2 + l2 / 2) + F2 / 2 : "end" === u ? D - i3 + p3 + F2 : o$2(d2, i3, l2, a3, p3 + F2, D, D + E2, E2);
      const { scrollLeft: t3, scrollTop: h4 } = e3;
      T3 = 0 === X2 ? 0 : Math.max(0, Math.min(h4 + T3 / X2, e3.scrollHeight - n2 / X2 + V2)), B2 = 0 === S2 ? 0 : Math.max(0, Math.min(t3 + B2 / S2, e3.scrollWidth - l2 / S2 + F2)), k2 += h4 - T3, D += t3 - B2;
    }
    L.push({ el: e3, top: T3, left: B2 });
  }
  return L;
};
const o$1 = (t2) => false === t2 ? { block: "end", inline: "nearest" } : ((t3) => t3 === Object(t3) && 0 !== Object.keys(t3).length)(t2) ? t2 : { block: "start", inline: "nearest" };
function e$1(e2, r2) {
  if (!e2.isConnected || !((t2) => {
    let o2 = t2;
    for (; o2 && o2.parentNode; ) {
      if (o2.parentNode === document)
        return true;
      o2 = o2.parentNode instanceof ShadowRoot ? o2.parentNode.host : o2.parentNode;
    }
    return false;
  })(e2))
    return;
  const n2 = ((t2) => {
    const o2 = window.getComputedStyle(t2);
    return { top: parseFloat(o2.scrollMarginTop) || 0, right: parseFloat(o2.scrollMarginRight) || 0, bottom: parseFloat(o2.scrollMarginBottom) || 0, left: parseFloat(o2.scrollMarginLeft) || 0 };
  })(e2);
  if (((t2) => "object" == typeof t2 && "function" == typeof t2.behavior)(r2))
    return r2.behavior(r$1(e2, r2));
  const l2 = "boolean" == typeof r2 || null == r2 ? void 0 : r2.behavior;
  for (const { el: a2, top: i2, left: s } of r$1(e2, o$1(r2))) {
    const t2 = i2 - n2.top + n2.bottom, o2 = s - n2.left + n2.right;
    a2.scroll({ top: t2, left: o2, behavior: l2 });
  }
}
const _hoisted_1$D = { class: "flex flex-row justify-between items-center mb-5" };
const _hoisted_2$x = { class: "font-bold text-lg" };
const _hoisted_3$r = /* @__PURE__ */ createBaseVNode("kbd", { class: "kbd cursor-pointer" }, "Esc", -1);
const _hoisted_4$n = [
  _hoisted_3$r
];
const _hoisted_5$k = {
  key: 0,
  class: "flex flex-col gap-2 py-4"
};
const _hoisted_6$j = /* @__PURE__ */ createBaseVNode("div", { class: "skeleton h-12 w-full" }, null, -1);
const _hoisted_7$f = /* @__PURE__ */ createBaseVNode("div", { class: "skeleton h-12 w-full" }, null, -1);
const _hoisted_8$e = [
  _hoisted_6$j,
  _hoisted_7$f
];
const _hoisted_9$d = { key: 1 };
const _hoisted_10$c = { class: "flex flex-col gap-2" };
const _hoisted_11$c = { class: "min-h-12 px-4 rounded-lg bg-base-200 flex flex-row gap-2 items-center" };
const _hoisted_12$b = { class: "flex-1" };
const _hoisted_13$8 = { class: "mt-6" };
const _hoisted_14$8 = {
  key: 0,
  class: "badge badge-accent"
};
const _hoisted_15$8 = ["placeholder"];
const _hoisted_16$8 = {
  key: 0,
  class: "label"
};
const _hoisted_17$8 = { class: "label-text text-error" };
const _hoisted_18$8 = ["onClick"];
const _hoisted_19$8 = { class: "modal-action" };
const _hoisted_20$7 = {
  key: 0,
  class: "loading loading-spinner"
};
const _sfc_main$J = /* @__PURE__ */ defineComponent({
  __name: "Bookshelf",
  props: {
    book: {}
  },
  setup(__props) {
    const props = __props;
    const { dialogRef, openDialog, closeDialog } = useDialog();
    const listContianer = ref(null);
    const inputRef = ref(null);
    const allGrops = ref([]);
    const groupValue = ref("");
    const chooseGroup = ref("");
    const placeholderOption = computed(() => {
      const val = get(chooseGroup);
      if (!val)
        return [];
      return allGrops.value.filter((item) => item.name.includes(val));
    });
    const groupError = ref("");
    const activePlaceholder = ref(-1);
    const [loading, setLoading] = useToggle(false);
    const [submitLoading, setSubmitLoading] = useToggle(false);
    const addAction = (val) => {
      set$1(groupValue, BookshelfAction.toJSON(val));
      set$1(activePlaceholder, -1);
      set$1(chooseGroup, "");
    };
    const onPlaceholder = (val) => addAction(val);
    const activeToView = () => {
      const node = get(listContianer);
      if (!node)
        return;
      const { scrollHeight, clientHeight } = node;
      if (scrollHeight <= clientHeight)
        return;
      const target = node.children[get(activePlaceholder)]?.firstElementChild;
      if (!target)
        return;
      e$1(target, { behavior: "smooth", scrollMode: "if-needed" });
    };
    const onAdd = useThrottleFn(async () => {
      const index = get(activePlaceholder);
      if (index !== -1) {
        addAction(get(placeholderOption)[index]);
        return;
      }
      const val = get(chooseGroup).trim();
      if (val) {
        const all = get(allGrops);
        const isExist = all.find((item) => item.name === val);
        if (!isExist) {
          const res = await BookshelfAction.add(val);
          if (res) {
            addAction(get(res));
          }
        } else {
          addAction(get(isExist));
        }
      }
    }, 150);
    const onDown = () => {
      const index = get(activePlaceholder);
      const len = get(placeholderOption).length;
      if (index < len - 1) {
        set$1(activePlaceholder, index + 1);
        activeToView();
      }
    };
    const onUp = () => {
      const index = get(activePlaceholder);
      if (index <= 0) {
        set$1(activePlaceholder, 0);
      } else {
        set$1(activePlaceholder, index - 1);
      }
      activeToView();
    };
    const onTab = () => {
      const index = get(activePlaceholder);
      if (index !== -1) {
        addAction(get(placeholderOption)[index]);
      }
    };
    const init = async () => {
      try {
        setLoading(true);
        const val = props.book.group;
        set$1(groupValue, val);
        openDialog();
        await nextTick();
        openDialog();
        const res = await BookshelfAction.getAll();
        set$1(allGrops, res);
      } catch (err) {
        toastError(`t('book.getBookshelfFail'): ${err}`);
      } finally {
        setLoading(false);
        await nextTick();
        if (!props.book.group) {
          get(inputRef)?.focus();
        }
      }
    };
    const submit = async () => {
      try {
        if (get(submitLoading))
          return;
        setSubmitLoading(true);
        const group = get(groupValue);
        if (!group) {
          set$1(groupError, t$2("book.neeSelectBookshelf"));
          return;
        }
        await BookAction.update(props.book.id, { group });
        toastSuccess(t$2("book.addToBookshelfSuccess"));
        closeDialog();
      } catch (err) {
        toastError(`${t$2("book.addToBookshelfFail")}: ${err}`);
      } finally {
        setSubmitLoading(false);
      }
    };
    init();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("dialog", {
        class: "modal",
        ref_key: "dialogRef",
        ref: dialogRef
      }, [
        withDirectives((openBlock(), createElementBlock("div", {
          class: "modal-box max-w-fit",
          onContextmenu: _cache[7] || (_cache[7] = withModifiers(() => {
          }, ["prevent"]))
        }, [
          createBaseVNode("div", _hoisted_1$D, [
            createBaseVNode("h3", _hoisted_2$x, toDisplayString$1(unref(t$2)("book.addToBookshelf")), 1),
            createBaseVNode("div", {
              onClick: _cache[0] || (_cache[0] = //@ts-ignore
              (...args) => unref(closeDialog) && unref(closeDialog)(...args))
            }, _hoisted_4$n)
          ]),
          unref(loading) ? (openBlock(), createElementBlock("div", _hoisted_5$k, _hoisted_8$e)) : (openBlock(), createElementBlock("form", _hoisted_9$d, [
            createBaseVNode("div", _hoisted_10$c, [
              createBaseVNode("div", _hoisted_11$c, [
                createBaseVNode("span", null, toDisplayString$1(unref(t$2)("book.name")), 1),
                createBaseVNode("div", _hoisted_12$b, toDisplayString$1(_ctx.book.name), 1)
              ]),
              createBaseVNode("div", _hoisted_13$8, [
                createBaseVNode("label", {
                  class: normalizeClass(["input input-bordered flex items-center gap-2", { "input-error": groupError.value }])
                }, [
                  createTextVNode(toDisplayString$1(unref(t$2)("book.bookshelf")) + " ", 1),
                  groupValue.value ? (openBlock(), createElementBlock("span", _hoisted_14$8, toDisplayString$1(unref(BookshelfAction).toBookshelf(groupValue.value).name), 1)) : createCommentVNode("", true),
                  withDirectives(createBaseVNode("input", {
                    type: "text",
                    class: "grow",
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => chooseGroup.value = $event),
                    placeholder: unref(t$2)("book.needBookshelfName"),
                    ref_key: "inputRef",
                    ref: inputRef,
                    onKeydown: [
                      _cache[2] || (_cache[2] = withKeys(($event) => unref(onAdd)(), ["enter"])),
                      _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => onDown(), ["prevent"]), ["down"])),
                      _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => onUp(), ["prevent"]), ["up"])),
                      _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => onTab(), ["prevent"]), ["tab"]))
                    ]
                  }, null, 40, _hoisted_15$8), [
                    [vModelText, chooseGroup.value]
                  ])
                ], 2),
                groupError.value ? (openBlock(), createElementBlock("div", _hoisted_16$8, [
                  createBaseVNode("span", _hoisted_17$8, toDisplayString$1(groupError.value), 1)
                ])) : createCommentVNode("", true),
                placeholderOption.value.length ? (openBlock(), createElementBlock("ul", {
                  key: 1,
                  ref_key: "listContianer",
                  ref: listContianer,
                  class: "p-2 mt-2 z-[10] max-h-60 md:max-h-72 lg:max-h-96 w-full overflow-auto border border-accent rounded-md menu flex-nowrap bg-base-100 shadow-2xl gap-1 scrollbar-thin"
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(placeholderOption.value, (item, index) => {
                    return openBlock(), createElementBlock("li", {
                      key: item.id,
                      onClick: ($event) => onPlaceholder(item),
                      class: "text-base-content"
                    }, [
                      createBaseVNode("a", {
                        class: normalizeClass({ active: activePlaceholder.value === index })
                      }, toDisplayString$1(item.name), 3)
                    ], 8, _hoisted_18$8);
                  }), 128))
                ], 512)) : createCommentVNode("", true)
              ])
            ]),
            createBaseVNode("div", _hoisted_19$8, [
              createBaseVNode("button", {
                class: "btn btn-outline",
                type: "button",
                onClick: _cache[6] || (_cache[6] = //@ts-ignore
                (...args) => unref(closeDialog) && unref(closeDialog)(...args))
              }, toDisplayString$1(unref(t$2)("common.cancel")), 1),
              createBaseVNode("button", {
                class: "btn btn-success ml-4",
                type: "button",
                onClick: submit
              }, [
                unref(submitLoading) ? (openBlock(), createElementBlock("span", _hoisted_20$7)) : createCommentVNode("", true),
                createTextVNode(" " + toDisplayString$1(unref(t$2)("common.sure")), 1)
              ])
            ])
          ]))
        ], 32)), [
          [unref(vOnClickOutside), unref(closeDialog)]
        ])
      ], 512);
    };
  }
});
const bookshelfDialog = (book2) => createDialog(_sfc_main$J, { book: book2 });
var dayjs_min = { exports: {} };
var hasRequiredDayjs_min;
function requireDayjs_min() {
  if (hasRequiredDayjs_min)
    return dayjs_min.exports;
  hasRequiredDayjs_min = 1;
  (function(module, exports) {
    !function(t2, e2) {
      module.exports = e2();
    }(commonjsGlobal, function() {
      var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s = "minute", u = "hour", a2 = "day", o2 = "week", c = "month", f2 = "quarter", h2 = "year", d = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
        var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
        return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
      } }, m2 = function(t3, e3, n3) {
        var r3 = String(t3);
        return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
      }, v2 = { s: m2, z: function(t3) {
        var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
        return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
      }, m: function t3(e3, n3) {
        if (e3.date() < n3.date())
          return -t3(n3, e3);
        var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, c), s2 = n3 - i3 < 0, u2 = e3.clone().add(r3 + (s2 ? -1 : 1), c);
        return +(-(r3 + (n3 - i3) / (s2 ? i3 - u2 : u2 - i3)) || 0);
      }, a: function(t3) {
        return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
      }, p: function(t3) {
        return { M: c, y: h2, w: o2, d: a2, D: d, h: u, m: s, s: i2, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t3) {
        return void 0 === t3;
      } }, g2 = "en", D = {};
      D[g2] = M;
      var p2 = "$isDayjsObject", S2 = function(t3) {
        return t3 instanceof _2 || !(!t3 || !t3[p2]);
      }, w2 = function t3(e3, n3, r3) {
        var i3;
        if (!e3)
          return g2;
        if ("string" == typeof e3) {
          var s2 = e3.toLowerCase();
          D[s2] && (i3 = s2), n3 && (D[s2] = n3, i3 = s2);
          var u2 = e3.split("-");
          if (!i3 && u2.length > 1)
            return t3(u2[0]);
        } else {
          var a3 = e3.name;
          D[a3] = e3, i3 = a3;
        }
        return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
      }, O = function(t3, e3) {
        if (S2(t3))
          return t3.clone();
        var n3 = "object" == typeof e3 ? e3 : {};
        return n3.date = t3, n3.args = arguments, new _2(n3);
      }, b2 = v2;
      b2.l = w2, b2.i = S2, b2.w = function(t3, e3) {
        return O(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
      };
      var _2 = function() {
        function M2(t3) {
          this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
        }
        var m3 = M2.prototype;
        return m3.parse = function(t3) {
          this.$d = function(t4) {
            var e3 = t4.date, n3 = t4.utc;
            if (null === e3)
              return /* @__PURE__ */ new Date(NaN);
            if (b2.u(e3))
              return /* @__PURE__ */ new Date();
            if (e3 instanceof Date)
              return new Date(e3);
            if ("string" == typeof e3 && !/Z$/i.test(e3)) {
              var r3 = e3.match($2);
              if (r3) {
                var i3 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
              }
            }
            return new Date(e3);
          }(t3), this.init();
        }, m3.init = function() {
          var t3 = this.$d;
          this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
        }, m3.$utils = function() {
          return b2;
        }, m3.isValid = function() {
          return !(this.$d.toString() === l2);
        }, m3.isSame = function(t3, e3) {
          var n3 = O(t3);
          return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
        }, m3.isAfter = function(t3, e3) {
          return O(t3) < this.startOf(e3);
        }, m3.isBefore = function(t3, e3) {
          return this.endOf(e3) < O(t3);
        }, m3.$g = function(t3, e3, n3) {
          return b2.u(t3) ? this[e3] : this.set(n3, t3);
        }, m3.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m3.valueOf = function() {
          return this.$d.getTime();
        }, m3.startOf = function(t3, e3) {
          var n3 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t3), l3 = function(t4, e4) {
            var i3 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
            return r3 ? i3 : i3.endOf(a2);
          }, $3 = function(t4, e4) {
            return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
          }, y3 = this.$W, M3 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
          switch (f3) {
            case h2:
              return r3 ? l3(1, 0) : l3(31, 11);
            case c:
              return r3 ? l3(1, M3) : l3(0, M3 + 1);
            case o2:
              var g3 = this.$locale().weekStart || 0, D2 = (y3 < g3 ? y3 + 7 : y3) - g3;
              return l3(r3 ? m4 - D2 : m4 + (6 - D2), M3);
            case a2:
            case d:
              return $3(v3 + "Hours", 0);
            case u:
              return $3(v3 + "Minutes", 1);
            case s:
              return $3(v3 + "Seconds", 2);
            case i2:
              return $3(v3 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m3.endOf = function(t3) {
          return this.startOf(t3, false);
        }, m3.$set = function(t3, e3) {
          var n3, o3 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f3 + "Date", n3[d] = f3 + "Date", n3[c] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u] = f3 + "Hours", n3[s] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $3 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
          if (o3 === c || o3 === h2) {
            var y3 = this.clone().set(d, 1);
            y3.$d[l3]($3), y3.init(), this.$d = y3.set(d, Math.min(this.$D, y3.daysInMonth())).$d;
          } else
            l3 && this.$d[l3]($3);
          return this.init(), this;
        }, m3.set = function(t3, e3) {
          return this.clone().$set(t3, e3);
        }, m3.get = function(t3) {
          return this[b2.p(t3)]();
        }, m3.add = function(r3, f3) {
          var d2, l3 = this;
          r3 = Number(r3);
          var $3 = b2.p(f3), y3 = function(t3) {
            var e3 = O(l3);
            return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
          };
          if ($3 === c)
            return this.set(c, this.$M + r3);
          if ($3 === h2)
            return this.set(h2, this.$y + r3);
          if ($3 === a2)
            return y3(1);
          if ($3 === o2)
            return y3(7);
          var M3 = (d2 = {}, d2[s] = e2, d2[u] = n2, d2[i2] = t2, d2)[$3] || 1, m4 = this.$d.getTime() + r3 * M3;
          return b2.w(m4, this);
        }, m3.subtract = function(t3, e3) {
          return this.add(-1 * t3, e3);
        }, m3.format = function(t3) {
          var e3 = this, n3 = this.$locale();
          if (!this.isValid())
            return n3.invalidDate || l2;
          var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b2.z(this), s2 = this.$H, u2 = this.$m, a3 = this.$M, o3 = n3.weekdays, c2 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i4, s3) {
            return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s3);
          }, d2 = function(t4) {
            return b2.s(s2 % 12 || 12, t4, "0");
          }, $3 = f3 || function(t4, e4, n4) {
            var r4 = t4 < 12 ? "AM" : "PM";
            return n4 ? r4.toLowerCase() : r4;
          };
          return r3.replace(y2, function(t4, r4) {
            return r4 || function(t5) {
              switch (t5) {
                case "YY":
                  return String(e3.$y).slice(-2);
                case "YYYY":
                  return b2.s(e3.$y, 4, "0");
                case "M":
                  return a3 + 1;
                case "MM":
                  return b2.s(a3 + 1, 2, "0");
                case "MMM":
                  return h3(n3.monthsShort, a3, c2, 3);
                case "MMMM":
                  return h3(c2, a3);
                case "D":
                  return e3.$D;
                case "DD":
                  return b2.s(e3.$D, 2, "0");
                case "d":
                  return String(e3.$W);
                case "dd":
                  return h3(n3.weekdaysMin, e3.$W, o3, 2);
                case "ddd":
                  return h3(n3.weekdaysShort, e3.$W, o3, 3);
                case "dddd":
                  return o3[e3.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b2.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $3(s2, u2, true);
                case "A":
                  return $3(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b2.s(u2, 2, "0");
                case "s":
                  return String(e3.$s);
                case "ss":
                  return b2.s(e3.$s, 2, "0");
                case "SSS":
                  return b2.s(e3.$ms, 3, "0");
                case "Z":
                  return i3;
              }
              return null;
            }(t4) || i3.replace(":", "");
          });
        }, m3.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m3.diff = function(r3, d2, l3) {
          var $3, y3 = this, M3 = b2.p(d2), m4 = O(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D2 = function() {
            return b2.m(y3, m4);
          };
          switch (M3) {
            case h2:
              $3 = D2() / 12;
              break;
            case c:
              $3 = D2();
              break;
            case f2:
              $3 = D2() / 3;
              break;
            case o2:
              $3 = (g3 - v3) / 6048e5;
              break;
            case a2:
              $3 = (g3 - v3) / 864e5;
              break;
            case u:
              $3 = g3 / n2;
              break;
            case s:
              $3 = g3 / e2;
              break;
            case i2:
              $3 = g3 / t2;
              break;
            default:
              $3 = g3;
          }
          return l3 ? $3 : b2.a($3);
        }, m3.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m3.$locale = function() {
          return D[this.$L];
        }, m3.locale = function(t3, e3) {
          if (!t3)
            return this.$L;
          var n3 = this.clone(), r3 = w2(t3, e3, true);
          return r3 && (n3.$L = r3), n3;
        }, m3.clone = function() {
          return b2.w(this.$d, this);
        }, m3.toDate = function() {
          return new Date(this.valueOf());
        }, m3.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m3.toISOString = function() {
          return this.$d.toISOString();
        }, m3.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k2 = _2.prototype;
      return O.prototype = k2, [["$ms", r2], ["$s", i2], ["$m", s], ["$H", u], ["$W", a2], ["$M", c], ["$y", h2], ["$D", d]].forEach(function(t3) {
        k2[t3[1]] = function(e3) {
          return this.$g(e3, t3[0], t3[1]);
        };
      }), O.extend = function(t3, e3) {
        return t3.$i || (t3(e3, _2, O), t3.$i = true), O;
      }, O.locale = w2, O.isDayjs = S2, O.unix = function(t3) {
        return O(1e3 * t3);
      }, O.en = D[g2], O.Ls = D, O.p = {}, O;
    });
  })(dayjs_min);
  return dayjs_min.exports;
}
var dayjs_minExports = requireDayjs_min();
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
class BookshelfAction {
  static async add(name) {
    try {
      const val = {
        id: v4(),
        name,
        createTime: now(),
        updateTime: now(),
        isDelete: null
      };
      await db.bookshelf.put(val);
      return await this.findOne(val.id);
    } catch (error) {
      toastError("" + error);
      return Promise.reject(error);
    }
  }
  static getAll() {
    return db.bookshelf.toArray();
  }
  static findOne(id2) {
    return db.bookshelf.where("id").equals(id2).first();
  }
  static toJSON(tag2) {
    return JSON.stringify(tag2);
  }
  static toBookshelf(val) {
    try {
      return val ? JSON.parse(val) : "";
    } catch (error) {
      return "";
    }
  }
}
class NoteAction {
  static async add({
    sources,
    eBookId,
    chapterName,
    notes,
    tag: tag2
  }) {
    try {
      if (sources.length === 0)
        return null;
      const sourceId = sources[0].id;
      const isExist = await this.findBySourceId(sourceId);
      if (isExist)
        return null;
      const res = {
        id: v4(),
        sourceId,
        eBookId,
        notes,
        chapterName,
        domSource: JSON.stringify(sources),
        createTime: now(),
        updateTime: now(),
        tag: tag2,
        isDelete: null
      };
      await db.notes.put(res);
      return res;
    } catch (error) {
      toastError(t$2("note.addNoteFail"));
      return Promise.reject(error);
    }
  }
  static removeOne(id2) {
    try {
      return db.notes.delete(id2);
    } catch (error) {
      toastError(t$2("common.removeFail"));
      return Promise.reject(error);
    }
  }
  static removeBySoureIds(sourceId) {
    return db.notes.where("sourceId").anyOf(sourceId).delete();
  }
  static update(id2, value) {
    try {
      return db.notes.update(id2, { ...value, updateTime: now() });
    } catch (error) {
      toastError(t$2("common.updateFail"));
      return Promise.reject(error);
    }
  }
  static async updateBySourceId(sourceId, value) {
    try {
      const note2 = await this.findBySourceId(sourceId);
      if (note2) {
        await this.update(note2.id, value);
        return true;
      }
      return false;
    } catch (error) {
      toastError(t$2("common.updateFail"));
      return Promise.reject(error);
    }
  }
  static observable() {
    try {
      return useObservable(
        liveQuery(async () => (await db.notes.toArray()).filter((item) => !item.isDelete))
      );
    } catch (error) {
      toastError(t$2("note.getNoteFail"));
      return ref([]);
    }
  }
  static observableByEBookId(eBookId) {
    try {
      return useObservable(
        liveQuery(
          async () => (await db.notes.where("eBookId").equals(eBookId).toArray()).filter(
            (item) => !item.isDelete
          )
        )
      );
    } catch (error) {
      toastError(t$2("note.getNoteListFail"));
      return ref([]);
    }
  }
  static async findByEBookId(eBookId) {
    return await db.notes.where("eBookId").equals(eBookId).toArray();
  }
  static async findBySourceId(id2) {
    return await db.notes.where("sourceId").equals(id2).first();
  }
  static async findBySourceIds(ids) {
    return await db.notes.where("sourceId").anyOf(ids).toArray();
  }
  static async findBookPageNotes(eBookId, page) {
    const bookNotes = await this.findByEBookId(eBookId);
    const result = [];
    for (const note2 of bookNotes) {
      const source = this.getDomSource(note2.domSource);
      const pageNote = source.find((item) => item.page === page);
      if (pageNote) {
        result.push({ ...note2, domSource: JSON.stringify([pageNote]) });
      }
    }
    return result;
  }
  static getAll() {
    return db.notes.toArray();
  }
  static noteToDomSource(note2) {
    const source = this.getDomSource(note2.domSource)[0];
    return {
      id: note2.sourceId,
      text: source.text,
      className: source.className,
      tagName: "span",
      startDomMeta: source.startDomMeta,
      endDomMeta: source.endDomMeta,
      page: source.page
    };
  }
  static getDomSource(value) {
    if (!value)
      return [];
    return JSON.parse(value);
  }
  static getNoteText(value) {
    if (!value)
      return [];
    return JSON.parse(value);
  }
}
const _hoisted_1$C = { class: "modal-box max-w-fit" };
const _hoisted_2$w = { class: "flex flex-row justify-between items-center mb-5" };
const _hoisted_3$q = { class: "font-bold text-lg" };
const _hoisted_4$m = /* @__PURE__ */ createBaseVNode("kbd", { class: "kbd cursor-pointer" }, "Esc", -1);
const _hoisted_5$j = [
  _hoisted_4$m
];
const _hoisted_6$i = {
  key: 1,
  class: "hero"
};
const _hoisted_7$e = { class: "hero-content flex-col lg:flex-row" };
const _hoisted_8$d = { class: "w-32 min-h-44 rounded mr-4" };
const _hoisted_9$c = ["src"];
const _hoisted_10$b = { class: "columns-1 lg:columns-2 gap-x-8 gap-y-6 flex-1" };
const _hoisted_11$b = { class: "flex gap-4 mb-3" };
const _hoisted_12$a = { class: "stat-title whitespace-normal flex-1" };
const _hoisted_13$7 = { class: "flex gap-4 mb-3" };
const _hoisted_14$7 = { class: "stat-title whitespace-normal flex-1" };
const _hoisted_15$7 = { class: "flex gap-4 mb-3" };
const _hoisted_16$7 = { class: "stat-title" };
const _hoisted_17$7 = { class: "flex gap-4 mb-3" };
const _hoisted_18$7 = { class: "stat-title" };
const _hoisted_19$7 = { class: "flex gap-4 mb-3" };
const _hoisted_20$6 = {
  key: 0,
  class: "stat-title whitespace-normal flex-1"
};
const _hoisted_21$6 = {
  key: 1,
  class: "stat-title whitespace-normal flex-1"
};
const _hoisted_22$6 = { class: "flex gap-4 mb-3" };
const _hoisted_23$6 = {
  key: 0,
  class: "stat-title"
};
const _hoisted_24$6 = {
  key: 1,
  class: "stat-title"
};
const _hoisted_25$5 = {
  key: 0,
  class: "flex gap-4 mb-3"
};
const _hoisted_26$5 = { class: "stat-title" };
const _hoisted_27$5 = {
  key: 1,
  class: "flex gap-4 mb-3"
};
const _hoisted_28$5 = { class: "stat-title" };
const _hoisted_29$4 = { class: "flex gap-4 mb-3" };
const _hoisted_30$4 = { class: "rating rating-md rating-half" };
const _hoisted_31$3 = { class: "text-orange-400" };
const _hoisted_32$3 = { class: "flex gap-4 mb-3" };
const _hoisted_33$2 = { class: "stat-title" };
const _hoisted_34$2 = { class: "flex gap-4 mb-3" };
const _hoisted_35$2 = { class: "stat-title" };
const _hoisted_36$2 = { class: "flex gap-4 mb-3" };
const _hoisted_37$1 = { class: "stat-title" };
const _hoisted_38 = { class: "flex gap-4 mb-3" };
const _hoisted_39 = { class: "stat-title" };
const _hoisted_40 = { class: "flex gap-4 mb-3" };
const _hoisted_41 = { class: "stat-title" };
const _hoisted_42 = {
  key: 2,
  class: "flex gap-4 mb-3"
};
const _hoisted_43 = { class: "badge badge-accent" };
const _hoisted_44 = { class: "modal-action" };
const _sfc_main$I = /* @__PURE__ */ defineComponent({
  __name: "Detail",
  props: {
    book: {}
  },
  setup(__props) {
    const props = __props;
    const { dialogRef, openDialog, closeDialog } = useDialog();
    const [loading, setLoading] = useToggle(false);
    const totalReadTime = ref(0);
    const highlightLen = ref(0);
    const notesLen = ref(0);
    const initEdite = async () => {
      try {
        setLoading(true);
        openDialog();
        await nextTick();
        openDialog();
        const id2 = props.book.id;
        const [readTimeList, notes] = await Promise.all([
          BookReadTimeAction.findByEbookId(id2),
          NoteAction.findByEBookId(id2)
        ]);
        const totalTime = readTimeList.reduce((pre, cur) => pre + getInterval(cur.startTime, cur.endTime), 0);
        totalReadTime.value = +totalTime.toFixed(0);
        highlightLen.value = notes.filter((item) => item.notes === "").length;
        notesLen.value = notes.filter((item) => item.notes !== "").length;
      } catch (err) {
        toastError(`${t$2("book.readDetailFail")}: ${err}`);
      } finally {
        setLoading(false);
      }
    };
    const getScore = (val) => isUndefined(val) || val === -1 ? t$2("common.unknown") : val;
    initEdite();
    return (_ctx, _cache) => {
      const _component_SkeletonView = resolveComponent("SkeletonView");
      const _component_ScoreInputView = resolveComponent("ScoreInputView");
      return openBlock(), createElementBlock("dialog", {
        class: "modal",
        ref_key: "dialogRef",
        ref: dialogRef
      }, [
        withDirectives((openBlock(), createElementBlock("div", _hoisted_1$C, [
          createBaseVNode("div", _hoisted_2$w, [
            createBaseVNode("h3", _hoisted_3$q, toDisplayString$1(unref(t$2)("book.detail")), 1),
            createBaseVNode("div", {
              onClick: _cache[0] || (_cache[0] = //@ts-ignore
              (...args) => unref(closeDialog) && unref(closeDialog)(...args))
            }, _hoisted_5$j)
          ]),
          unref(loading) ? (openBlock(), createBlock(_component_SkeletonView, { key: 0 })) : (openBlock(), createElementBlock("div", _hoisted_6$i, [
            createBaseVNode("div", _hoisted_7$e, [
              createBaseVNode("div", _hoisted_8$d, [
                createBaseVNode("img", {
                  src: unref(convertUint8ArrayToURL)(_ctx.book.cover)
                }, null, 8, _hoisted_9$c)
              ]),
              createBaseVNode("div", _hoisted_10$b, [
                createBaseVNode("div", _hoisted_11$b, [
                  createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.name")), 1),
                  createBaseVNode("div", _hoisted_12$a, toDisplayString$1(_ctx.book.name), 1)
                ]),
                createBaseVNode("div", _hoisted_13$7, [
                  createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.author")), 1),
                  createBaseVNode("div", _hoisted_14$7, toDisplayString$1(_ctx.book.author), 1)
                ]),
                createBaseVNode("div", _hoisted_15$7, [
                  createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.size")), 1),
                  createBaseVNode("div", _hoisted_16$7, toDisplayString$1(unref(formatFileSize)(_ctx.book.size)), 1)
                ]),
                createBaseVNode("div", _hoisted_17$7, [
                  createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.page")), 1),
                  createBaseVNode("div", _hoisted_18$7, toDisplayString$1(_ctx.book.pages), 1)
                ]),
                createBaseVNode("div", _hoisted_19$7, [
                  createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.publisher")), 1),
                  _ctx.book.publisher ? (openBlock(), createElementBlock("div", _hoisted_20$6, toDisplayString$1(_ctx.book.publisher), 1)) : (openBlock(), createElementBlock("div", _hoisted_21$6, toDisplayString$1(unref(t$2)("common.unknown")), 1))
                ]),
                createBaseVNode("div", _hoisted_22$6, [
                  createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.publishTime")), 1),
                  _ctx.book.publishTime ? (openBlock(), createElementBlock("div", _hoisted_23$6, toDisplayString$1(unref(dayjs)(_ctx.book.publishTime).format("L LT")), 1)) : (openBlock(), createElementBlock("div", _hoisted_24$6, toDisplayString$1(unref(t$2)("common.unknown")), 1))
                ]),
                _ctx.book.createTime ? (openBlock(), createElementBlock("div", _hoisted_25$5, [
                  createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.createTime")), 1),
                  createBaseVNode("div", _hoisted_26$5, toDisplayString$1(unref(dayjs)(_ctx.book.createTime).format("L LT")), 1)
                ])) : createCommentVNode("", true),
                _ctx.book.updateTime ? (openBlock(), createElementBlock("div", _hoisted_27$5, [
                  createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.updateTime")), 1),
                  createBaseVNode("div", _hoisted_28$5, toDisplayString$1(unref(dayjs)(_ctx.book.updateTime).format("L LT")), 1)
                ])) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_29$4, [
                  createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.score")), 1),
                  createBaseVNode("div", _hoisted_30$4, [
                    createVNode(_component_ScoreInputView, {
                      value: _ctx.book.score,
                      readonly: true
                    }, null, 8, ["value"])
                  ]),
                  createBaseVNode("div", _hoisted_31$3, toDisplayString$1(getScore(_ctx.book.score)), 1)
                ]),
                createBaseVNode("div", _hoisted_32$3, [
                  createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.openCount")), 1),
                  createBaseVNode("div", _hoisted_33$2, toDisplayString$1(_ctx.book.count), 1)
                ]),
                createBaseVNode("div", _hoisted_34$2, [
                  createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.readProgress")), 1),
                  createBaseVNode("div", _hoisted_35$2, toDisplayString$1(unref(formatDecimal)(_ctx.book.progress * 100)) + "%", 1)
                ]),
                createBaseVNode("div", _hoisted_36$2, [
                  createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.totalReadTime")), 1),
                  createBaseVNode("div", _hoisted_37$1, toDisplayString$1(totalReadTime.value) + toDisplayString$1(unref(t$2)("common.minute")), 1)
                ]),
                createBaseVNode("div", _hoisted_38, [
                  createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.highlightLen")), 1),
                  createBaseVNode("div", _hoisted_39, toDisplayString$1(highlightLen.value), 1)
                ]),
                createBaseVNode("div", _hoisted_40, [
                  createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.notesLen")), 1),
                  createBaseVNode("div", _hoisted_41, toDisplayString$1(notesLen.value), 1)
                ]),
                _ctx.book.group ? (openBlock(), createElementBlock("div", _hoisted_42, [
                  createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.bookshelf")), 1),
                  createBaseVNode("div", _hoisted_43, toDisplayString$1(unref(BookshelfAction).toBookshelf(_ctx.book.group).name), 1)
                ])) : createCommentVNode("", true)
              ])
            ])
          ])),
          createBaseVNode("div", _hoisted_44, [
            createBaseVNode("button", {
              class: "btn btn-outline",
              onClick: _cache[1] || (_cache[1] = //@ts-ignore
              (...args) => unref(closeDialog) && unref(closeDialog)(...args))
            }, toDisplayString$1(unref(t$2)("common.close")), 1)
          ])
        ])), [
          [unref(vOnClickOutside), unref(closeDialog)]
        ])
      ], 512);
    };
  }
});
const detailDialog = (book2) => createDialog(_sfc_main$I, { book: book2 });
/**
  * vee-validate v4.13.1
  * (c) 2024 Abdelrahman Awad
  * @license MIT
  */
function isCallable(fn) {
  return typeof fn === "function";
}
function isNullOrUndefined(value) {
  return value === null || value === void 0;
}
const isObject = (obj) => obj !== null && !!obj && typeof obj === "object" && !Array.isArray(obj);
function isIndex(value) {
  return Number(value) >= 0;
}
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function getTag(value) {
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return Object.prototype.toString.call(value);
}
function isPlainObject(value) {
  if (!isObjectLike(value) || getTag(value) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
function merge(target, source) {
  Object.keys(source).forEach((key) => {
    if (isPlainObject(source[key]) && isPlainObject(target[key])) {
      if (!target[key]) {
        target[key] = {};
      }
      merge(target[key], source[key]);
      return;
    }
    target[key] = source[key];
  });
  return target;
}
function normalizeFormPath(path) {
  const pathArr = path.split(".");
  if (!pathArr.length) {
    return "";
  }
  let fullPath = String(pathArr[0]);
  for (let i2 = 1; i2 < pathArr.length; i2++) {
    if (isIndex(pathArr[i2])) {
      fullPath += `[${pathArr[i2]}]`;
      continue;
    }
    fullPath += `.${pathArr[i2]}`;
  }
  return fullPath;
}
const RULES = {};
function resolveRule(id2) {
  return RULES[id2];
}
function set(obj, key, val) {
  if (typeof val.value === "object")
    val.value = klona(val.value);
  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
    Object.defineProperty(obj, key, val);
  } else
    obj[key] = val.value;
}
function klona(x2) {
  if (typeof x2 !== "object")
    return x2;
  var i2 = 0, k2, list, tmp, str = Object.prototype.toString.call(x2);
  if (str === "[object Object]") {
    tmp = Object.create(x2.__proto__ || null);
  } else if (str === "[object Array]") {
    tmp = Array(x2.length);
  } else if (str === "[object Set]") {
    tmp = /* @__PURE__ */ new Set();
    x2.forEach(function(val) {
      tmp.add(klona(val));
    });
  } else if (str === "[object Map]") {
    tmp = /* @__PURE__ */ new Map();
    x2.forEach(function(val, key) {
      tmp.set(klona(key), klona(val));
    });
  } else if (str === "[object Date]") {
    tmp = /* @__PURE__ */ new Date(+x2);
  } else if (str === "[object RegExp]") {
    tmp = new RegExp(x2.source, x2.flags);
  } else if (str === "[object DataView]") {
    tmp = new x2.constructor(klona(x2.buffer));
  } else if (str === "[object ArrayBuffer]") {
    tmp = x2.slice(0);
  } else if (str.slice(-6) === "Array]") {
    tmp = new x2.constructor(x2);
  }
  if (tmp) {
    for (list = Object.getOwnPropertySymbols(x2); i2 < list.length; i2++) {
      set(tmp, list[i2], Object.getOwnPropertyDescriptor(x2, list[i2]));
    }
    for (i2 = 0, list = Object.getOwnPropertyNames(x2); i2 < list.length; i2++) {
      if (Object.hasOwnProperty.call(tmp, k2 = list[i2]) && tmp[k2] === x2[k2])
        continue;
      set(tmp, k2, Object.getOwnPropertyDescriptor(x2, k2));
    }
  }
  return tmp || x2;
}
const FormContextKey = Symbol("vee-validate-form");
const isClient = typeof window !== "undefined";
function isLocator(value) {
  return isCallable(value) && !!value.__locatorRef;
}
function isTypedSchema(value) {
  return !!value && isCallable(value.parse) && value.__type === "VVTypedSchema";
}
function isYupValidator(value) {
  return !!value && isCallable(value.validate);
}
function hasCheckedAttr(type) {
  return type === "checkbox" || type === "radio";
}
function isContainerValue(value) {
  return isObject(value) || Array.isArray(value);
}
function isEmptyContainer(value) {
  if (Array.isArray(value)) {
    return value.length === 0;
  }
  return isObject(value) && Object.keys(value).length === 0;
}
function isNotNestedPath(path) {
  return /^\[.+\]$/i.test(path);
}
function isNativeMultiSelect(el) {
  return isNativeSelect(el) && el.multiple;
}
function isNativeSelect(el) {
  return el.tagName === "SELECT";
}
function isFormSubmitEvent(evt) {
  return isEvent(evt) && evt.target && "submit" in evt.target;
}
function isEvent(evt) {
  if (!evt) {
    return false;
  }
  if (typeof Event !== "undefined" && isCallable(Event) && evt instanceof Event) {
    return true;
  }
  if (evt && evt.srcElement) {
    return true;
  }
  return false;
}
function isEqual(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    if (a2.constructor !== b2.constructor)
      return false;
    var length, i2, keys;
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length != b2.length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (!isEqual(a2[i2], b2[i2]))
          return false;
      return true;
    }
    if (a2 instanceof Map && b2 instanceof Map) {
      if (a2.size !== b2.size)
        return false;
      for (i2 of a2.entries())
        if (!b2.has(i2[0]))
          return false;
      for (i2 of a2.entries())
        if (!isEqual(i2[1], b2.get(i2[0])))
          return false;
      return true;
    }
    if (isFile(a2) && isFile(b2)) {
      if (a2.size !== b2.size)
        return false;
      if (a2.name !== b2.name)
        return false;
      if (a2.lastModified !== b2.lastModified)
        return false;
      if (a2.type !== b2.type)
        return false;
      return true;
    }
    if (a2 instanceof Set && b2 instanceof Set) {
      if (a2.size !== b2.size)
        return false;
      for (i2 of a2.entries())
        if (!b2.has(i2[0]))
          return false;
      return true;
    }
    if (ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
      length = a2.length;
      if (length != b2.length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (a2[i2] !== b2[i2])
          return false;
      return true;
    }
    if (a2.constructor === RegExp)
      return a2.source === b2.source && a2.flags === b2.flags;
    if (a2.valueOf !== Object.prototype.valueOf)
      return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString)
      return a2.toString() === b2.toString();
    keys = Object.keys(a2);
    length = keys.length;
    for (i2 = length; i2-- !== 0; ) {
      var key = keys[i2];
      if (!isEqual(a2[key], b2[key]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function isFile(a2) {
  if (!isClient) {
    return false;
  }
  return a2 instanceof File;
}
function cleanupNonNestedPath(path) {
  if (isNotNestedPath(path)) {
    return path.replace(/\[|\]/gi, "");
  }
  return path;
}
function getFromPath(object, path, fallback) {
  if (!object) {
    return fallback;
  }
  if (isNotNestedPath(path)) {
    return object[cleanupNonNestedPath(path)];
  }
  const resolvedValue = (path || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((acc, propKey) => {
    if (isContainerValue(acc) && propKey in acc) {
      return acc[propKey];
    }
    return fallback;
  }, object);
  return resolvedValue;
}
function setInPath(object, path, value) {
  if (isNotNestedPath(path)) {
    object[cleanupNonNestedPath(path)] = value;
    return;
  }
  const keys = path.split(/\.|\[(\d+)\]/).filter(Boolean);
  let acc = object;
  for (let i2 = 0; i2 < keys.length; i2++) {
    if (i2 === keys.length - 1) {
      acc[keys[i2]] = value;
      return;
    }
    if (!(keys[i2] in acc) || isNullOrUndefined(acc[keys[i2]])) {
      acc[keys[i2]] = isIndex(keys[i2 + 1]) ? [] : {};
    }
    acc = acc[keys[i2]];
  }
}
function unset(object, key) {
  if (Array.isArray(object) && isIndex(key)) {
    object.splice(Number(key), 1);
    return;
  }
  if (isObject(object)) {
    delete object[key];
  }
}
function unsetPath(object, path) {
  if (isNotNestedPath(path)) {
    delete object[cleanupNonNestedPath(path)];
    return;
  }
  const keys = path.split(/\.|\[(\d+)\]/).filter(Boolean);
  let acc = object;
  for (let i2 = 0; i2 < keys.length; i2++) {
    if (i2 === keys.length - 1) {
      unset(acc, keys[i2]);
      break;
    }
    if (!(keys[i2] in acc) || isNullOrUndefined(acc[keys[i2]])) {
      break;
    }
    acc = acc[keys[i2]];
  }
  const pathValues = keys.map((_2, idx) => {
    return getFromPath(object, keys.slice(0, idx).join("."));
  });
  for (let i2 = pathValues.length - 1; i2 >= 0; i2--) {
    if (!isEmptyContainer(pathValues[i2])) {
      continue;
    }
    if (i2 === 0) {
      unset(object, keys[0]);
      continue;
    }
    unset(pathValues[i2 - 1], keys[i2 - 1]);
  }
}
function keysOf(record) {
  return Object.keys(record);
}
function debounceAsync(inner, ms2 = 0) {
  let timer = null;
  let resolves = [];
  return function(...args) {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      const result = inner(...args);
      resolves.forEach((r2) => r2(result));
      resolves = [];
    }, ms2);
    return new Promise((resolve2) => resolves.push(resolve2));
  };
}
function withLatest(fn, onDone) {
  let latestRun;
  return async function runLatest(...args) {
    const pending = fn(...args);
    latestRun = pending;
    const result = await pending;
    if (pending !== latestRun) {
      return result;
    }
    latestRun = void 0;
    return onDone(result, args);
  };
}
function normalizeErrorItem(message) {
  return Array.isArray(message) ? message : message ? [message] : [];
}
function omit(obj, keys) {
  const target = {};
  for (const key in obj) {
    if (!keys.includes(key)) {
      target[key] = obj[key];
    }
  }
  return target;
}
function debounceNextTick(inner) {
  let lastTick = null;
  let resolves = [];
  return function(...args) {
    const thisTick = nextTick(() => {
      if (lastTick !== thisTick) {
        return;
      }
      const result = inner(...args);
      resolves.forEach((r2) => r2(result));
      resolves = [];
      lastTick = null;
    });
    lastTick = thisTick;
    return new Promise((resolve2) => resolves.push(resolve2));
  };
}
function getBoundValue(el) {
  if (hasValueBinding(el)) {
    return el._value;
  }
  return void 0;
}
function hasValueBinding(el) {
  return "_value" in el;
}
function parseInputValue(el) {
  if (el.type === "number") {
    return Number.isNaN(el.valueAsNumber) ? el.value : el.valueAsNumber;
  }
  if (el.type === "range") {
    return Number.isNaN(el.valueAsNumber) ? el.value : el.valueAsNumber;
  }
  return el.value;
}
function normalizeEventValue(value) {
  if (!isEvent(value)) {
    return value;
  }
  const input = value.target;
  if (hasCheckedAttr(input.type) && hasValueBinding(input)) {
    return getBoundValue(input);
  }
  if (input.type === "file" && input.files) {
    const files = Array.from(input.files);
    return input.multiple ? files : files[0];
  }
  if (isNativeMultiSelect(input)) {
    return Array.from(input.options).filter((opt) => opt.selected && !opt.disabled).map(getBoundValue);
  }
  if (isNativeSelect(input)) {
    const selectedOption = Array.from(input.options).find((opt) => opt.selected);
    return selectedOption ? getBoundValue(selectedOption) : input.value;
  }
  return parseInputValue(input);
}
function normalizeRules(rules) {
  const acc = {};
  Object.defineProperty(acc, "_$$isNormalized", {
    value: true,
    writable: false,
    enumerable: false,
    configurable: false
  });
  if (!rules) {
    return acc;
  }
  if (isObject(rules) && rules._$$isNormalized) {
    return rules;
  }
  if (isObject(rules)) {
    return Object.keys(rules).reduce((prev, curr) => {
      const params = normalizeParams(rules[curr]);
      if (rules[curr] !== false) {
        prev[curr] = buildParams(params);
      }
      return prev;
    }, acc);
  }
  if (typeof rules !== "string") {
    return acc;
  }
  return rules.split("|").reduce((prev, rule) => {
    const parsedRule = parseRule(rule);
    if (!parsedRule.name) {
      return prev;
    }
    prev[parsedRule.name] = buildParams(parsedRule.params);
    return prev;
  }, acc);
}
function normalizeParams(params) {
  if (params === true) {
    return [];
  }
  if (Array.isArray(params)) {
    return params;
  }
  if (isObject(params)) {
    return params;
  }
  return [params];
}
function buildParams(provided) {
  const mapValueToLocator = (value) => {
    if (typeof value === "string" && value[0] === "@") {
      return createLocator(value.slice(1));
    }
    return value;
  };
  if (Array.isArray(provided)) {
    return provided.map(mapValueToLocator);
  }
  if (provided instanceof RegExp) {
    return [provided];
  }
  return Object.keys(provided).reduce((prev, key) => {
    prev[key] = mapValueToLocator(provided[key]);
    return prev;
  }, {});
}
const parseRule = (rule) => {
  let params = [];
  const name = rule.split(":")[0];
  if (rule.includes(":")) {
    params = rule.split(":").slice(1).join(":").split(",");
  }
  return { name, params };
};
function createLocator(value) {
  const locator = (crossTable) => {
    const val = getFromPath(crossTable, value) || crossTable[value];
    return val;
  };
  locator.__locatorRef = value;
  return locator;
}
const DEFAULT_CONFIG = {
  generateMessage: ({ field }) => `${field} is not valid.`,
  bails: true,
  validateOnBlur: true,
  validateOnChange: true,
  validateOnInput: false,
  validateOnModelUpdate: true
};
let currentConfig = Object.assign({}, DEFAULT_CONFIG);
const getConfig = () => currentConfig;
async function validate(value, rules, options = {}) {
  const shouldBail = options === null || options === void 0 ? void 0 : options.bails;
  const field = {
    name: (options === null || options === void 0 ? void 0 : options.name) || "{field}",
    rules,
    label: options === null || options === void 0 ? void 0 : options.label,
    bails: shouldBail !== null && shouldBail !== void 0 ? shouldBail : true,
    formData: (options === null || options === void 0 ? void 0 : options.values) || {}
  };
  const result = await _validate(field, value);
  return Object.assign(Object.assign({}, result), { valid: !result.errors.length });
}
async function _validate(field, value) {
  const rules = field.rules;
  if (isTypedSchema(rules) || isYupValidator(rules)) {
    return validateFieldWithTypedSchema(value, Object.assign(Object.assign({}, field), { rules }));
  }
  if (isCallable(rules) || Array.isArray(rules)) {
    const ctx = {
      field: field.label || field.name,
      name: field.name,
      label: field.label,
      form: field.formData,
      value
    };
    const pipeline = Array.isArray(rules) ? rules : [rules];
    const length2 = pipeline.length;
    const errors2 = [];
    for (let i2 = 0; i2 < length2; i2++) {
      const rule = pipeline[i2];
      const result = await rule(value, ctx);
      const isValid = typeof result !== "string" && !Array.isArray(result) && result;
      if (isValid) {
        continue;
      }
      if (Array.isArray(result)) {
        errors2.push(...result);
      } else {
        const message = typeof result === "string" ? result : _generateFieldError(ctx);
        errors2.push(message);
      }
      if (field.bails) {
        return {
          errors: errors2
        };
      }
    }
    return {
      errors: errors2
    };
  }
  const normalizedContext = Object.assign(Object.assign({}, field), { rules: normalizeRules(rules) });
  const errors = [];
  const rulesKeys = Object.keys(normalizedContext.rules);
  const length = rulesKeys.length;
  for (let i2 = 0; i2 < length; i2++) {
    const rule = rulesKeys[i2];
    const result = await _test(normalizedContext, value, {
      name: rule,
      params: normalizedContext.rules[rule]
    });
    if (result.error) {
      errors.push(result.error);
      if (field.bails) {
        return {
          errors
        };
      }
    }
  }
  return {
    errors
  };
}
function isYupError(err) {
  return !!err && err.name === "ValidationError";
}
function yupToTypedSchema(yupSchema) {
  const schema = {
    __type: "VVTypedSchema",
    async parse(values2, context) {
      var _a;
      try {
        const output = await yupSchema.validate(values2, { abortEarly: false, context: (context === null || context === void 0 ? void 0 : context.formData) || {} });
        return {
          output,
          errors: []
        };
      } catch (err) {
        if (!isYupError(err)) {
          throw err;
        }
        if (!((_a = err.inner) === null || _a === void 0 ? void 0 : _a.length) && err.errors.length) {
          return { errors: [{ path: err.path, errors: err.errors }] };
        }
        const errors = err.inner.reduce((acc, curr) => {
          const path = curr.path || "";
          if (!acc[path]) {
            acc[path] = { errors: [], path };
          }
          acc[path].errors.push(...curr.errors);
          return acc;
        }, {});
        return { errors: Object.values(errors) };
      }
    }
  };
  return schema;
}
async function validateFieldWithTypedSchema(value, context) {
  const typedSchema = isTypedSchema(context.rules) ? context.rules : yupToTypedSchema(context.rules);
  const result = await typedSchema.parse(value, { formData: context.formData });
  const messages = [];
  for (const error of result.errors) {
    if (error.errors.length) {
      messages.push(...error.errors);
    }
  }
  return {
    value: result.value,
    errors: messages
  };
}
async function _test(field, value, rule) {
  const validator = resolveRule(rule.name);
  if (!validator) {
    throw new Error(`No such validator '${rule.name}' exists.`);
  }
  const params = fillTargetValues(rule.params, field.formData);
  const ctx = {
    field: field.label || field.name,
    name: field.name,
    label: field.label,
    value,
    form: field.formData,
    rule: Object.assign(Object.assign({}, rule), { params })
  };
  const result = await validator(value, params, ctx);
  if (typeof result === "string") {
    return {
      error: result
    };
  }
  return {
    error: result ? void 0 : _generateFieldError(ctx)
  };
}
function _generateFieldError(fieldCtx) {
  const message = getConfig().generateMessage;
  if (!message) {
    return "Field is invalid";
  }
  return message(fieldCtx);
}
function fillTargetValues(params, crossTable) {
  const normalize2 = (value) => {
    if (isLocator(value)) {
      return value(crossTable);
    }
    return value;
  };
  if (Array.isArray(params)) {
    return params.map(normalize2);
  }
  return Object.keys(params).reduce((acc, param) => {
    acc[param] = normalize2(params[param]);
    return acc;
  }, {});
}
async function validateTypedSchema(schema, values2) {
  const typedSchema = isTypedSchema(schema) ? schema : yupToTypedSchema(schema);
  const validationResult = await typedSchema.parse(klona(values2));
  const results = {};
  const errors = {};
  for (const error of validationResult.errors) {
    const messages = error.errors;
    const path = (error.path || "").replace(/\["(\d+)"\]/g, (_2, m2) => {
      return `[${m2}]`;
    });
    results[path] = { valid: !messages.length, errors: messages };
    if (messages.length) {
      errors[path] = messages[0];
    }
  }
  return {
    valid: !validationResult.errors.length,
    results,
    errors,
    values: validationResult.value,
    source: "schema"
  };
}
async function validateObjectSchema(schema, values2, opts) {
  const paths = keysOf(schema);
  const validations = paths.map(async (path) => {
    var _a, _b, _c;
    const strings = (_a = opts === null || opts === void 0 ? void 0 : opts.names) === null || _a === void 0 ? void 0 : _a[path];
    const fieldResult = await validate(getFromPath(values2, path), schema[path], {
      name: (strings === null || strings === void 0 ? void 0 : strings.name) || path,
      label: strings === null || strings === void 0 ? void 0 : strings.label,
      values: values2,
      bails: (_c = (_b = opts === null || opts === void 0 ? void 0 : opts.bailsMap) === null || _b === void 0 ? void 0 : _b[path]) !== null && _c !== void 0 ? _c : true
    });
    return Object.assign(Object.assign({}, fieldResult), { path });
  });
  let isAllValid = true;
  const validationResults = await Promise.all(validations);
  const results = {};
  const errors = {};
  for (const result of validationResults) {
    results[result.path] = {
      valid: result.valid,
      errors: result.errors
    };
    if (!result.valid) {
      isAllValid = false;
      errors[result.path] = result.errors[0];
    }
  }
  return {
    valid: isAllValid,
    results,
    errors,
    source: "schema"
  };
}
let FORM_COUNTER = 0;
const PRIVATE_PATH_STATE_KEYS = ["bails", "fieldsCount", "id", "multiple", "type", "validate"];
function resolveInitialValues(opts) {
  const givenInitial = (opts === null || opts === void 0 ? void 0 : opts.initialValues) || {};
  const providedValues = Object.assign({}, toValue$2(givenInitial));
  const schema = unref(opts === null || opts === void 0 ? void 0 : opts.validationSchema);
  if (schema && isTypedSchema(schema) && isCallable(schema.cast)) {
    return klona(schema.cast(providedValues) || {});
  }
  return klona(providedValues);
}
function useForm(opts) {
  var _a;
  const formId = FORM_COUNTER++;
  let FIELD_ID_COUNTER = 0;
  const isSubmitting = ref(false);
  const isValidating = ref(false);
  const submitCount = ref(0);
  const fieldArrays = [];
  const formValues = reactive(resolveInitialValues(opts));
  const pathStates = ref([]);
  const extraErrorsBag = ref({});
  const pathStateLookup = ref({});
  const rebuildPathLookup = debounceNextTick(() => {
    pathStateLookup.value = pathStates.value.reduce((names, state) => {
      names[normalizeFormPath(toValue$2(state.path))] = state;
      return names;
    }, {});
  });
  function setFieldError(field, message) {
    const state = findPathState(field);
    if (!state) {
      if (typeof field === "string") {
        extraErrorsBag.value[normalizeFormPath(field)] = normalizeErrorItem(message);
      }
      return;
    }
    if (typeof field === "string") {
      const normalizedPath = normalizeFormPath(field);
      if (extraErrorsBag.value[normalizedPath]) {
        delete extraErrorsBag.value[normalizedPath];
      }
    }
    state.errors = normalizeErrorItem(message);
    state.valid = !state.errors.length;
  }
  function setErrors(paths) {
    keysOf(paths).forEach((path) => {
      setFieldError(path, paths[path]);
    });
  }
  if (opts === null || opts === void 0 ? void 0 : opts.initialErrors) {
    setErrors(opts.initialErrors);
  }
  const errorBag = computed(() => {
    const pathErrors = pathStates.value.reduce((acc, state) => {
      if (state.errors.length) {
        acc[state.path] = state.errors;
      }
      return acc;
    }, {});
    return Object.assign(Object.assign({}, extraErrorsBag.value), pathErrors);
  });
  const errors = computed(() => {
    return keysOf(errorBag.value).reduce((acc, key) => {
      const errors2 = errorBag.value[key];
      if (errors2 === null || errors2 === void 0 ? void 0 : errors2.length) {
        acc[key] = errors2[0];
      }
      return acc;
    }, {});
  });
  const fieldNames = computed(() => {
    return pathStates.value.reduce((names, state) => {
      names[state.path] = { name: state.path || "", label: state.label || "" };
      return names;
    }, {});
  });
  const fieldBailsMap = computed(() => {
    return pathStates.value.reduce((map, state) => {
      var _a2;
      map[state.path] = (_a2 = state.bails) !== null && _a2 !== void 0 ? _a2 : true;
      return map;
    }, {});
  });
  const initialErrors = Object.assign({}, (opts === null || opts === void 0 ? void 0 : opts.initialErrors) || {});
  const keepValuesOnUnmount = (_a = opts === null || opts === void 0 ? void 0 : opts.keepValuesOnUnmount) !== null && _a !== void 0 ? _a : false;
  const { initialValues, originalInitialValues, setInitialValues } = useFormInitialValues(pathStates, formValues, opts);
  const meta = useFormMeta(pathStates, formValues, originalInitialValues, errors);
  const controlledValues = computed(() => {
    return pathStates.value.reduce((acc, state) => {
      const value = getFromPath(formValues, state.path);
      setInPath(acc, state.path, value);
      return acc;
    }, {});
  });
  const schema = opts === null || opts === void 0 ? void 0 : opts.validationSchema;
  function createPathState(path, config) {
    var _a2, _b;
    const initialValue = computed(() => getFromPath(initialValues.value, toValue$2(path)));
    const pathStateExists = pathStateLookup.value[toValue$2(path)];
    const isCheckboxOrRadio = (config === null || config === void 0 ? void 0 : config.type) === "checkbox" || (config === null || config === void 0 ? void 0 : config.type) === "radio";
    if (pathStateExists && isCheckboxOrRadio) {
      pathStateExists.multiple = true;
      const id22 = FIELD_ID_COUNTER++;
      if (Array.isArray(pathStateExists.id)) {
        pathStateExists.id.push(id22);
      } else {
        pathStateExists.id = [pathStateExists.id, id22];
      }
      pathStateExists.fieldsCount++;
      pathStateExists.__flags.pendingUnmount[id22] = false;
      return pathStateExists;
    }
    const currentValue = computed(() => getFromPath(formValues, toValue$2(path)));
    const pathValue = toValue$2(path);
    const unsetBatchIndex = UNSET_BATCH.findIndex((_path) => _path === pathValue);
    if (unsetBatchIndex !== -1) {
      UNSET_BATCH.splice(unsetBatchIndex, 1);
    }
    const isRequired = computed(() => {
      var _a3, _b2, _c, _d;
      const schemaValue = toValue$2(schema);
      if (isTypedSchema(schemaValue)) {
        return (_b2 = (_a3 = schemaValue.describe) === null || _a3 === void 0 ? void 0 : _a3.call(schemaValue, toValue$2(path)).required) !== null && _b2 !== void 0 ? _b2 : false;
      }
      const configSchemaValue = toValue$2(config === null || config === void 0 ? void 0 : config.schema);
      if (isTypedSchema(configSchemaValue)) {
        return (_d = (_c = configSchemaValue.describe) === null || _c === void 0 ? void 0 : _c.call(configSchemaValue).required) !== null && _d !== void 0 ? _d : false;
      }
      return false;
    });
    const id2 = FIELD_ID_COUNTER++;
    const state = reactive({
      id: id2,
      path,
      touched: false,
      pending: false,
      valid: true,
      validated: !!((_a2 = initialErrors[pathValue]) === null || _a2 === void 0 ? void 0 : _a2.length),
      required: isRequired,
      initialValue,
      errors: shallowRef([]),
      bails: (_b = config === null || config === void 0 ? void 0 : config.bails) !== null && _b !== void 0 ? _b : false,
      label: config === null || config === void 0 ? void 0 : config.label,
      type: (config === null || config === void 0 ? void 0 : config.type) || "default",
      value: currentValue,
      multiple: false,
      __flags: {
        pendingUnmount: { [id2]: false },
        pendingReset: false
      },
      fieldsCount: 1,
      validate: config === null || config === void 0 ? void 0 : config.validate,
      dirty: computed(() => {
        return !isEqual(unref(currentValue), unref(initialValue));
      })
    });
    pathStates.value.push(state);
    pathStateLookup.value[pathValue] = state;
    rebuildPathLookup();
    if (errors.value[pathValue] && !initialErrors[pathValue]) {
      nextTick(() => {
        validateField(pathValue, { mode: "silent" });
      });
    }
    if (isRef(path)) {
      watch(path, (newPath) => {
        rebuildPathLookup();
        const nextValue = klona(currentValue.value);
        pathStateLookup.value[newPath] = state;
        nextTick(() => {
          setInPath(formValues, newPath, nextValue);
        });
      });
    }
    return state;
  }
  const debouncedSilentValidation = debounceAsync(_validateSchema, 5);
  const debouncedValidation = debounceAsync(_validateSchema, 5);
  const validateSchema = withLatest(async (mode) => {
    return await (mode === "silent" ? debouncedSilentValidation() : debouncedValidation());
  }, (formResult, [mode]) => {
    const currentErrorsPaths = keysOf(formCtx.errorBag.value);
    const paths = [
      .../* @__PURE__ */ new Set([...keysOf(formResult.results), ...pathStates.value.map((p2) => p2.path), ...currentErrorsPaths])
    ].sort();
    const results = paths.reduce((validation, _path) => {
      var _a2;
      const expectedPath = _path;
      const pathState = findPathState(expectedPath) || findHoistedPath(expectedPath);
      const messages = ((_a2 = formResult.results[expectedPath]) === null || _a2 === void 0 ? void 0 : _a2.errors) || [];
      const path = toValue$2(pathState === null || pathState === void 0 ? void 0 : pathState.path) || expectedPath;
      const fieldResult = mergeValidationResults({ errors: messages, valid: !messages.length }, validation.results[path]);
      validation.results[path] = fieldResult;
      if (!fieldResult.valid) {
        validation.errors[path] = fieldResult.errors[0];
      }
      if (pathState && extraErrorsBag.value[path]) {
        delete extraErrorsBag.value[path];
      }
      if (!pathState) {
        setFieldError(path, messages);
        return validation;
      }
      pathState.valid = fieldResult.valid;
      if (mode === "silent") {
        return validation;
      }
      if (mode === "validated-only" && !pathState.validated) {
        return validation;
      }
      setFieldError(pathState, fieldResult.errors);
      return validation;
    }, {
      valid: formResult.valid,
      results: {},
      errors: {},
      source: formResult.source
    });
    if (formResult.values) {
      results.values = formResult.values;
      results.source = formResult.source;
    }
    keysOf(results.results).forEach((path) => {
      var _a2;
      const pathState = findPathState(path);
      if (!pathState) {
        return;
      }
      if (mode === "silent") {
        return;
      }
      if (mode === "validated-only" && !pathState.validated) {
        return;
      }
      setFieldError(pathState, (_a2 = results.results[path]) === null || _a2 === void 0 ? void 0 : _a2.errors);
    });
    return results;
  });
  function mutateAllPathState(mutation) {
    pathStates.value.forEach(mutation);
  }
  function findPathState(path) {
    const normalizedPath = typeof path === "string" ? normalizeFormPath(path) : path;
    const pathState = typeof normalizedPath === "string" ? pathStateLookup.value[normalizedPath] : normalizedPath;
    return pathState;
  }
  function findHoistedPath(path) {
    const candidates = pathStates.value.filter((state) => path.startsWith(state.path));
    return candidates.reduce((bestCandidate, candidate) => {
      if (!bestCandidate) {
        return candidate;
      }
      return candidate.path.length > bestCandidate.path.length ? candidate : bestCandidate;
    }, void 0);
  }
  let UNSET_BATCH = [];
  let PENDING_UNSET;
  function unsetPathValue(path) {
    UNSET_BATCH.push(path);
    if (!PENDING_UNSET) {
      PENDING_UNSET = nextTick(() => {
        const sortedPaths = [...UNSET_BATCH].sort().reverse();
        sortedPaths.forEach((p2) => {
          unsetPath(formValues, p2);
        });
        UNSET_BATCH = [];
        PENDING_UNSET = null;
      });
    }
    return PENDING_UNSET;
  }
  function makeSubmissionFactory(onlyControlled) {
    return function submitHandlerFactory(fn, onValidationError) {
      return function submissionHandler(e2) {
        if (e2 instanceof Event) {
          e2.preventDefault();
          e2.stopPropagation();
        }
        mutateAllPathState((s) => s.touched = true);
        isSubmitting.value = true;
        submitCount.value++;
        return validate2().then((result) => {
          const values2 = klona(formValues);
          if (result.valid && typeof fn === "function") {
            const controlled = klona(controlledValues.value);
            let submittedValues = onlyControlled ? controlled : values2;
            if (result.values) {
              submittedValues = result.source === "schema" ? result.values : Object.assign({}, submittedValues, result.values);
            }
            return fn(submittedValues, {
              evt: e2,
              controlledValues: controlled,
              setErrors,
              setFieldError,
              setTouched,
              setFieldTouched,
              setValues,
              setFieldValue,
              resetForm,
              resetField
            });
          }
          if (!result.valid && typeof onValidationError === "function") {
            onValidationError({
              values: values2,
              evt: e2,
              errors: result.errors,
              results: result.results
            });
          }
        }).then((returnVal) => {
          isSubmitting.value = false;
          return returnVal;
        }, (err) => {
          isSubmitting.value = false;
          throw err;
        });
      };
    };
  }
  const handleSubmitImpl = makeSubmissionFactory(false);
  const handleSubmit = handleSubmitImpl;
  handleSubmit.withControlled = makeSubmissionFactory(true);
  function removePathState(path, id2) {
    const idx = pathStates.value.findIndex((s) => {
      return s.path === path && (Array.isArray(s.id) ? s.id.includes(id2) : s.id === id2);
    });
    const pathState = pathStates.value[idx];
    if (idx === -1 || !pathState) {
      return;
    }
    nextTick(() => {
      validateField(path, { mode: "silent", warn: false });
    });
    if (pathState.multiple && pathState.fieldsCount) {
      pathState.fieldsCount--;
    }
    if (Array.isArray(pathState.id)) {
      const idIndex = pathState.id.indexOf(id2);
      if (idIndex >= 0) {
        pathState.id.splice(idIndex, 1);
      }
      delete pathState.__flags.pendingUnmount[id2];
    }
    if (!pathState.multiple || pathState.fieldsCount <= 0) {
      pathStates.value.splice(idx, 1);
      unsetInitialValue(path);
      rebuildPathLookup();
      delete pathStateLookup.value[path];
    }
  }
  function destroyPath(path) {
    keysOf(pathStateLookup.value).forEach((key) => {
      if (key.startsWith(path)) {
        delete pathStateLookup.value[key];
      }
    });
    pathStates.value = pathStates.value.filter((s) => !s.path.startsWith(path));
    nextTick(() => {
      rebuildPathLookup();
    });
  }
  const formCtx = {
    formId,
    values: formValues,
    controlledValues,
    errorBag,
    errors,
    schema,
    submitCount,
    meta,
    isSubmitting,
    isValidating,
    fieldArrays,
    keepValuesOnUnmount,
    validateSchema: unref(schema) ? validateSchema : void 0,
    validate: validate2,
    setFieldError,
    validateField,
    setFieldValue,
    setValues,
    setErrors,
    setFieldTouched,
    setTouched,
    resetForm,
    resetField,
    handleSubmit,
    useFieldModel,
    defineInputBinds,
    defineComponentBinds,
    defineField,
    stageInitialValue,
    unsetInitialValue,
    setFieldInitialValue,
    createPathState,
    getPathState: findPathState,
    unsetPathValue,
    removePathState,
    initialValues,
    getAllPathStates: () => pathStates.value,
    destroyPath,
    isFieldTouched,
    isFieldDirty,
    isFieldValid
  };
  function setFieldValue(field, value, shouldValidate = true) {
    const clonedValue = klona(value);
    const path = typeof field === "string" ? field : field.path;
    const pathState = findPathState(path);
    if (!pathState) {
      createPathState(path);
    }
    setInPath(formValues, path, clonedValue);
    if (shouldValidate) {
      validateField(path);
    }
  }
  function forceSetValues(fields, shouldValidate = true) {
    keysOf(formValues).forEach((key) => {
      delete formValues[key];
    });
    keysOf(fields).forEach((path) => {
      setFieldValue(path, fields[path], false);
    });
    if (shouldValidate) {
      validate2();
    }
  }
  function setValues(fields, shouldValidate = true) {
    merge(formValues, fields);
    fieldArrays.forEach((f2) => f2 && f2.reset());
    if (shouldValidate) {
      validate2();
    }
  }
  function createModel(path, shouldValidate) {
    const pathState = findPathState(toValue$2(path)) || createPathState(path);
    return computed({
      get() {
        return pathState.value;
      },
      set(value) {
        var _a2;
        const pathValue = toValue$2(path);
        setFieldValue(pathValue, value, (_a2 = toValue$2(shouldValidate)) !== null && _a2 !== void 0 ? _a2 : false);
      }
    });
  }
  function setFieldTouched(field, isTouched) {
    const pathState = findPathState(field);
    if (pathState) {
      pathState.touched = isTouched;
    }
  }
  function isFieldTouched(field) {
    const pathState = findPathState(field);
    if (pathState) {
      return pathState.touched;
    }
    return pathStates.value.filter((s) => s.path.startsWith(field)).some((s) => s.touched);
  }
  function isFieldDirty(field) {
    const pathState = findPathState(field);
    if (pathState) {
      return pathState.dirty;
    }
    return pathStates.value.filter((s) => s.path.startsWith(field)).some((s) => s.dirty);
  }
  function isFieldValid(field) {
    const pathState = findPathState(field);
    if (pathState) {
      return pathState.valid;
    }
    return pathStates.value.filter((s) => s.path.startsWith(field)).every((s) => s.valid);
  }
  function setTouched(fields) {
    if (typeof fields === "boolean") {
      mutateAllPathState((state) => {
        state.touched = fields;
      });
      return;
    }
    keysOf(fields).forEach((field) => {
      setFieldTouched(field, !!fields[field]);
    });
  }
  function resetField(field, state) {
    var _a2;
    const newValue = state && "value" in state ? state.value : getFromPath(initialValues.value, field);
    const pathState = findPathState(field);
    if (pathState) {
      pathState.__flags.pendingReset = true;
    }
    setFieldInitialValue(field, klona(newValue), true);
    setFieldValue(field, newValue, false);
    setFieldTouched(field, (_a2 = state === null || state === void 0 ? void 0 : state.touched) !== null && _a2 !== void 0 ? _a2 : false);
    setFieldError(field, (state === null || state === void 0 ? void 0 : state.errors) || []);
    nextTick(() => {
      if (pathState) {
        pathState.__flags.pendingReset = false;
      }
    });
  }
  function resetForm(resetState, opts2) {
    let newValues = klona((resetState === null || resetState === void 0 ? void 0 : resetState.values) ? resetState.values : originalInitialValues.value);
    newValues = (opts2 === null || opts2 === void 0 ? void 0 : opts2.force) ? newValues : merge(originalInitialValues.value, newValues);
    newValues = isTypedSchema(schema) && isCallable(schema.cast) ? schema.cast(newValues) : newValues;
    setInitialValues(newValues, { force: opts2 === null || opts2 === void 0 ? void 0 : opts2.force });
    mutateAllPathState((state) => {
      var _a2;
      state.__flags.pendingReset = true;
      state.validated = false;
      state.touched = ((_a2 = resetState === null || resetState === void 0 ? void 0 : resetState.touched) === null || _a2 === void 0 ? void 0 : _a2[state.path]) || false;
      setFieldValue(state.path, getFromPath(newValues, state.path), false);
      setFieldError(state.path, void 0);
    });
    (opts2 === null || opts2 === void 0 ? void 0 : opts2.force) ? forceSetValues(newValues, false) : setValues(newValues, false);
    setErrors((resetState === null || resetState === void 0 ? void 0 : resetState.errors) || {});
    submitCount.value = (resetState === null || resetState === void 0 ? void 0 : resetState.submitCount) || 0;
    nextTick(() => {
      validate2({ mode: "silent" });
      mutateAllPathState((state) => {
        state.__flags.pendingReset = false;
      });
    });
  }
  async function validate2(opts2) {
    const mode = (opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) || "force";
    if (mode === "force") {
      mutateAllPathState((f2) => f2.validated = true);
    }
    if (formCtx.validateSchema) {
      return formCtx.validateSchema(mode);
    }
    isValidating.value = true;
    const validations = await Promise.all(pathStates.value.map((state) => {
      if (!state.validate) {
        return Promise.resolve({
          key: state.path,
          valid: true,
          errors: [],
          value: void 0
        });
      }
      return state.validate(opts2).then((result) => {
        return {
          key: state.path,
          valid: result.valid,
          errors: result.errors,
          value: result.value
        };
      });
    }));
    isValidating.value = false;
    const results = {};
    const errors2 = {};
    const values2 = {};
    for (const validation of validations) {
      results[validation.key] = {
        valid: validation.valid,
        errors: validation.errors
      };
      if (validation.value) {
        setInPath(values2, validation.key, validation.value);
      }
      if (validation.errors.length) {
        errors2[validation.key] = validation.errors[0];
      }
    }
    return {
      valid: validations.every((r2) => r2.valid),
      results,
      errors: errors2,
      values: values2,
      source: "fields"
    };
  }
  async function validateField(path, opts2) {
    var _a2;
    const state = findPathState(path);
    if (state && (opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) !== "silent") {
      state.validated = true;
    }
    if (schema) {
      const { results } = await validateSchema((opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) || "validated-only");
      return results[path] || { errors: [], valid: true };
    }
    if (state === null || state === void 0 ? void 0 : state.validate) {
      return state.validate(opts2);
    }
    !state && ((_a2 = opts2 === null || opts2 === void 0 ? void 0 : opts2.warn) !== null && _a2 !== void 0 ? _a2 : true);
    return Promise.resolve({ errors: [], valid: true });
  }
  function unsetInitialValue(path) {
    unsetPath(initialValues.value, path);
  }
  function stageInitialValue(path, value, updateOriginal = false) {
    setFieldInitialValue(path, value);
    setInPath(formValues, path, value);
    if (updateOriginal && !(opts === null || opts === void 0 ? void 0 : opts.initialValues)) {
      setInPath(originalInitialValues.value, path, klona(value));
    }
  }
  function setFieldInitialValue(path, value, updateOriginal = false) {
    setInPath(initialValues.value, path, klona(value));
    if (updateOriginal) {
      setInPath(originalInitialValues.value, path, klona(value));
    }
  }
  async function _validateSchema() {
    const schemaValue = unref(schema);
    if (!schemaValue) {
      return { valid: true, results: {}, errors: {}, source: "none" };
    }
    isValidating.value = true;
    const formResult = isYupValidator(schemaValue) || isTypedSchema(schemaValue) ? await validateTypedSchema(schemaValue, formValues) : await validateObjectSchema(schemaValue, formValues, {
      names: fieldNames.value,
      bailsMap: fieldBailsMap.value
    });
    isValidating.value = false;
    return formResult;
  }
  const submitForm = handleSubmit((_2, { evt }) => {
    if (isFormSubmitEvent(evt)) {
      evt.target.submit();
    }
  });
  onMounted(() => {
    if (opts === null || opts === void 0 ? void 0 : opts.initialErrors) {
      setErrors(opts.initialErrors);
    }
    if (opts === null || opts === void 0 ? void 0 : opts.initialTouched) {
      setTouched(opts.initialTouched);
    }
    if (opts === null || opts === void 0 ? void 0 : opts.validateOnMount) {
      validate2();
      return;
    }
    if (formCtx.validateSchema) {
      formCtx.validateSchema("silent");
    }
  });
  if (isRef(schema)) {
    watch(schema, () => {
      var _a2;
      (_a2 = formCtx.validateSchema) === null || _a2 === void 0 ? void 0 : _a2.call(formCtx, "validated-only");
    });
  }
  provide(FormContextKey, formCtx);
  function defineField(path, config) {
    const label = isCallable(config) ? void 0 : config === null || config === void 0 ? void 0 : config.label;
    const pathState = findPathState(toValue$2(path)) || createPathState(path, { label });
    const evalConfig = () => isCallable(config) ? config(omit(pathState, PRIVATE_PATH_STATE_KEYS)) : config || {};
    function onBlur() {
      var _a2;
      pathState.touched = true;
      const validateOnBlur = (_a2 = evalConfig().validateOnBlur) !== null && _a2 !== void 0 ? _a2 : getConfig().validateOnBlur;
      if (validateOnBlur) {
        validateField(pathState.path);
      }
    }
    function onInput() {
      var _a2;
      const validateOnInput = (_a2 = evalConfig().validateOnInput) !== null && _a2 !== void 0 ? _a2 : getConfig().validateOnInput;
      if (validateOnInput) {
        nextTick(() => {
          validateField(pathState.path);
        });
      }
    }
    function onChange() {
      var _a2;
      const validateOnChange = (_a2 = evalConfig().validateOnChange) !== null && _a2 !== void 0 ? _a2 : getConfig().validateOnChange;
      if (validateOnChange) {
        nextTick(() => {
          validateField(pathState.path);
        });
      }
    }
    const props = computed(() => {
      const base = {
        onChange,
        onInput,
        onBlur
      };
      if (isCallable(config)) {
        return Object.assign(Object.assign({}, base), config(omit(pathState, PRIVATE_PATH_STATE_KEYS)).props || {});
      }
      if (config === null || config === void 0 ? void 0 : config.props) {
        return Object.assign(Object.assign({}, base), config.props(omit(pathState, PRIVATE_PATH_STATE_KEYS)));
      }
      return base;
    });
    const model = createModel(path, () => {
      var _a2, _b, _c;
      return (_c = (_a2 = evalConfig().validateOnModelUpdate) !== null && _a2 !== void 0 ? _a2 : (_b = getConfig()) === null || _b === void 0 ? void 0 : _b.validateOnModelUpdate) !== null && _c !== void 0 ? _c : true;
    });
    return [model, props];
  }
  function useFieldModel(pathOrPaths) {
    if (!Array.isArray(pathOrPaths)) {
      return createModel(pathOrPaths);
    }
    return pathOrPaths.map((p2) => createModel(p2, true));
  }
  function defineInputBinds(path, config) {
    const [model, props] = defineField(path, config);
    function onBlur() {
      props.value.onBlur();
    }
    function onInput(e2) {
      const value = normalizeEventValue(e2);
      setFieldValue(toValue$2(path), value, false);
      props.value.onInput();
    }
    function onChange(e2) {
      const value = normalizeEventValue(e2);
      setFieldValue(toValue$2(path), value, false);
      props.value.onChange();
    }
    return computed(() => {
      return Object.assign(Object.assign({}, props.value), {
        onBlur,
        onInput,
        onChange,
        value: model.value
      });
    });
  }
  function defineComponentBinds(path, config) {
    const [model, props] = defineField(path, config);
    const pathState = findPathState(toValue$2(path));
    function onUpdateModelValue(value) {
      model.value = value;
    }
    return computed(() => {
      const conf = isCallable(config) ? config(omit(pathState, PRIVATE_PATH_STATE_KEYS)) : config || {};
      return Object.assign({ [conf.model || "modelValue"]: model.value, [`onUpdate:${conf.model || "modelValue"}`]: onUpdateModelValue }, props.value);
    });
  }
  return Object.assign(Object.assign({}, formCtx), { values: readonly(formValues), handleReset: () => resetForm(), submitForm });
}
function useFormMeta(pathsState, currentValues, initialValues, errors) {
  const MERGE_STRATEGIES = {
    touched: "some",
    pending: "some",
    valid: "every"
  };
  const isDirty = computed(() => {
    return !isEqual(currentValues, unref(initialValues));
  });
  function calculateFlags() {
    const states = pathsState.value;
    return keysOf(MERGE_STRATEGIES).reduce((acc, flag) => {
      const mergeMethod = MERGE_STRATEGIES[flag];
      acc[flag] = states[mergeMethod]((s) => s[flag]);
      return acc;
    }, {});
  }
  const flags = reactive(calculateFlags());
  watchEffect(() => {
    const value = calculateFlags();
    flags.touched = value.touched;
    flags.valid = value.valid;
    flags.pending = value.pending;
  });
  return computed(() => {
    return Object.assign(Object.assign({ initialValues: unref(initialValues) }, flags), { valid: flags.valid && !keysOf(errors.value).length, dirty: isDirty.value });
  });
}
function useFormInitialValues(pathsState, formValues, opts) {
  const values2 = resolveInitialValues(opts);
  const initialValues = ref(values2);
  const originalInitialValues = ref(klona(values2));
  function setInitialValues(values22, opts2) {
    if (opts2 === null || opts2 === void 0 ? void 0 : opts2.force) {
      initialValues.value = klona(values22);
      originalInitialValues.value = klona(values22);
    } else {
      initialValues.value = merge(klona(initialValues.value) || {}, klona(values22));
      originalInitialValues.value = merge(klona(originalInitialValues.value) || {}, klona(values22));
    }
    if (!(opts2 === null || opts2 === void 0 ? void 0 : opts2.updateFields)) {
      return;
    }
    pathsState.value.forEach((state) => {
      const wasTouched = state.touched;
      if (wasTouched) {
        return;
      }
      const newValue = getFromPath(initialValues.value, state.path);
      setInPath(formValues, state.path, klona(newValue));
    });
  }
  return {
    initialValues,
    originalInitialValues,
    setInitialValues
  };
}
function mergeValidationResults(a2, b2) {
  if (!b2) {
    return a2;
  }
  return {
    valid: a2.valid && b2.valid,
    errors: [...a2.errors, ...b2.errors]
  };
}
const _hoisted_1$B = { class: "flex flex-row justify-between items-center mb-5" };
const _hoisted_2$v = { class: "font-bold text-lg" };
const _hoisted_3$p = /* @__PURE__ */ createBaseVNode("kbd", { class: "kbd cursor-pointer" }, "Esc", -1);
const _hoisted_4$l = [
  _hoisted_3$p
];
const _hoisted_5$i = { class: "flex flex-row gap-6" };
const _hoisted_6$h = { class: "flex flex-col items-center" };
const _hoisted_7$d = { class: "h-[120px] w-[100px] mb-2" };
const _hoisted_8$c = ["src", "alt"];
const _hoisted_9$b = {
  type: "button",
  value: "Input",
  class: "btn btn-sm btn-neutral"
};
const _hoisted_10$a = { class: "flex-1" };
const _hoisted_11$a = ["placeholder"];
const _hoisted_12$9 = {
  key: 0,
  class: "label"
};
const _hoisted_13$6 = { class: "label-text text-error" };
const _hoisted_14$6 = { class: "mt-6" };
const _hoisted_15$6 = ["placeholder"];
const _hoisted_16$6 = {
  key: 0,
  class: "label"
};
const _hoisted_17$6 = { class: "label-text text-error" };
const _hoisted_18$6 = { class: "modal-action" };
const _hoisted_19$6 = {
  class: "btn btn-success ml-4",
  type: "submit"
};
const _sfc_main$H = /* @__PURE__ */ defineComponent({
  __name: "Edit",
  props: {
    book: {}
  },
  setup(__props) {
    const props = __props;
    const { dialogRef, openDialog, closeDialog } = useDialog();
    const { defineField, handleSubmit, errors: editeError } = useForm({
      validationSchema: {
        name: (value) => value ? true : t$2("book.needBookName"),
        author: (value) => value ? true : t$2("book.needAuhor")
      }
    });
    const [name, nameProps] = defineField("name");
    const [author, authorProps] = defineField("author");
    const initEdite = async () => {
      name.value = props.book.name;
      author.value = props.book.author;
      openDialog();
      await nextTick();
      openDialog();
    };
    const inputRef = ref(null);
    const cover = ref(props.book.cover);
    async function uploadCover(event) {
      try {
        const files = event.target.files;
        if (files === null)
          return;
        const res = await fileToUint8Array(files[0]);
        set$1(cover, res);
      } catch (err) {
        toastError(`book.uploadCoverFial${err}`);
      } finally {
        if (inputRef.value) {
          inputRef.value.value = "";
        }
      }
    }
    const submitEdite = handleSubmit((values2) => {
      BookAction.update(props.book.id, { ...values2, cover: get(cover) });
      closeDialog();
    });
    initEdite();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("dialog", {
        class: "modal",
        ref_key: "dialogRef",
        ref: dialogRef
      }, [
        withDirectives((openBlock(), createElementBlock("div", {
          class: "modal-box max-w-5xl",
          onContextmenu: _cache[5] || (_cache[5] = withModifiers(() => {
          }, ["prevent"]))
        }, [
          createBaseVNode("div", _hoisted_1$B, [
            createBaseVNode("h3", _hoisted_2$v, toDisplayString$1(unref(t$2)("common.edit")), 1),
            createBaseVNode("div", {
              onClick: _cache[0] || (_cache[0] = //@ts-ignore
              (...args) => unref(closeDialog) && unref(closeDialog)(...args))
            }, _hoisted_4$l)
          ]),
          createBaseVNode("form", {
            onSubmit: _cache[4] || (_cache[4] = //@ts-ignore
            (...args) => unref(submitEdite) && unref(submitEdite)(...args))
          }, [
            createBaseVNode("div", _hoisted_5$i, [
              createBaseVNode("div", _hoisted_6$h, [
                createBaseVNode("div", _hoisted_7$d, [
                  createBaseVNode("img", {
                    src: unref(convertUint8ArrayToURL)(cover.value),
                    class: "w-full h-full rounded object-cover",
                    alt: unref(t$2)("book.cover")
                  }, null, 8, _hoisted_8$c)
                ]),
                createBaseVNode("label", null, [
                  createBaseVNode("a", _hoisted_9$b, toDisplayString$1(unref(t$2)("book.uploadCover")), 1),
                  createBaseVNode("input", {
                    type: "file",
                    ref_key: "inputRef",
                    ref: inputRef,
                    accept: "image/*",
                    class: "hidden",
                    onChange: uploadCover
                  }, null, 544)
                ])
              ]),
              createBaseVNode("div", _hoisted_10$a, [
                createBaseVNode("div", null, [
                  createBaseVNode("label", {
                    class: normalizeClass(["input input-bordered flex items-center gap-2", { "input-error": unref(editeError).name }]),
                    for: "name"
                  }, [
                    createTextVNode(toDisplayString$1(unref(t$2)("book.name")) + " ", 1),
                    withDirectives(createBaseVNode("input", mergeProps({
                      type: "text",
                      class: "grow",
                      name: "name",
                      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(name) ? name.value = $event : null)
                    }, unref(nameProps), {
                      placeholder: unref(t$2)("book.needBookName")
                    }), null, 16, _hoisted_11$a), [
                      [vModelText, unref(name)]
                    ])
                  ], 2),
                  unref(editeError).name ? (openBlock(), createElementBlock("div", _hoisted_12$9, [
                    createBaseVNode("span", _hoisted_13$6, toDisplayString$1(unref(editeError).name), 1)
                  ])) : createCommentVNode("", true)
                ]),
                createBaseVNode("div", _hoisted_14$6, [
                  createBaseVNode("label", {
                    class: normalizeClass(["input input-bordered flex items-center gap-2", { "input-error": unref(editeError).author }])
                  }, [
                    createTextVNode(toDisplayString$1(unref(t$2)("book.author")) + " ", 1),
                    withDirectives(createBaseVNode("input", mergeProps({
                      type: "text",
                      class: "grow",
                      name: "author",
                      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => isRef(author) ? author.value = $event : null)
                    }, unref(authorProps), {
                      placeholder: unref(t$2)("book.needAuhor")
                    }), null, 16, _hoisted_15$6), [
                      [vModelText, unref(author)]
                    ])
                  ], 2),
                  unref(editeError).author ? (openBlock(), createElementBlock("div", _hoisted_16$6, [
                    createBaseVNode("span", _hoisted_17$6, toDisplayString$1(unref(editeError).author), 1)
                  ])) : createCommentVNode("", true)
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_18$6, [
              createBaseVNode("button", {
                class: "btn btn-outline",
                onClick: _cache[3] || (_cache[3] = //@ts-ignore
                (...args) => unref(closeDialog) && unref(closeDialog)(...args))
              }, toDisplayString$1(unref(t$2)("common.cancel")), 1),
              createBaseVNode("button", _hoisted_19$6, toDisplayString$1(unref(t$2)("common.sure")), 1)
            ])
          ], 32)
        ], 32)), [
          [unref(vOnClickOutside), unref(closeDialog)]
        ])
      ], 512);
    };
  }
});
const editDialog = (book2) => createDialog(_sfc_main$H, { book: book2 });
const _hoisted_1$A = { class: "modal-box" };
const _hoisted_2$u = { class: "flex flex-row justify-between items-center" };
const _hoisted_3$o = { class: "font-bold text-lg" };
const _hoisted_4$k = /* @__PURE__ */ createBaseVNode("kbd", { class: "kbd cursor-pointer" }, "Esc", -1);
const _hoisted_5$h = [
  _hoisted_4$k
];
const _hoisted_6$g = { class: "py-4" };
const _hoisted_7$c = {
  key: 0,
  class: "text-warning"
};
const _hoisted_8$b = {
  key: 1,
  class: "text-warning"
};
const _hoisted_9$a = { class: "modal-action" };
const _sfc_main$G = /* @__PURE__ */ defineComponent({
  __name: "Remove",
  props: {
    book: {},
    isRecycleBin: { type: Boolean },
    isForce: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    const { dialogRef, openDialog, closeDialog } = useDialog();
    function removeOneBook() {
      const id2 = props.book.id;
      if (!id2)
        return;
      let isForce = props.isForce;
      if (!isForce) {
        isForce = !settingStore.value.isOpenRecycleBin;
      }
      BookAction.removeOne(id2, isForce);
      closeDialog();
    }
    const initEdite = async () => {
      openDialog();
      await nextTick();
      openDialog();
    };
    initEdite();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("dialog", {
        class: "modal",
        ref_key: "dialogRef",
        ref: dialogRef
      }, [
        withDirectives((openBlock(), createElementBlock("div", _hoisted_1$A, [
          createBaseVNode("div", _hoisted_2$u, [
            createBaseVNode("h3", _hoisted_3$o, toDisplayString$1(unref(t$2)("book.removeBook")), 1),
            createBaseVNode("div", {
              onClick: _cache[0] || (_cache[0] = //@ts-ignore
              (...args) => unref(closeDialog) && unref(closeDialog)(...args))
            }, _hoisted_5$h)
          ]),
          createBaseVNode("p", _hoisted_6$g, toDisplayString$1(_ctx.book.name), 1),
          unref(settingStore).isOpenRecycleBin && !_ctx.isRecycleBin ? (openBlock(), createElementBlock("p", _hoisted_7$c, toDisplayString$1(unref(t$2)("book.moveToRecycleBin")), 1)) : (openBlock(), createElementBlock("p", _hoisted_8$b, toDisplayString$1(unref(t$2)("book.forceRemove")), 1)),
          createBaseVNode("div", _hoisted_9$a, [
            createBaseVNode("button", {
              class: "btn btn-outline",
              onClick: _cache[1] || (_cache[1] = //@ts-ignore
              (...args) => unref(closeDialog) && unref(closeDialog)(...args))
            }, ""),
            createBaseVNode("button", {
              class: "btn btn-outline btn-error ml-4",
              onClick: removeOneBook
            }, toDisplayString$1(unref(t$2)("common.sure")), 1)
          ])
        ])), [
          [unref(vOnClickOutside), unref(closeDialog)]
        ])
      ], 512);
    };
  }
});
const removeDialog = (book2, isRecycleBin, isForce) => createDialog(_sfc_main$G, { book: book2, isRecycleBin, isForce });
const _hoisted_1$z = ["checked"];
const _hoisted_2$t = ["data-index", "checked", "disabled"];
const _hoisted_3$n = ["data-index", "checked", "disabled"];
const _sfc_main$F = /* @__PURE__ */ defineComponent({
  __name: "ScoreInput",
  props: {
    value: {},
    readonly: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    const score = computed(() => {
      const val = props.value;
      if (isUndefined(val))
        return 0;
      if (val == -1)
        return 0;
      return val;
    });
    const checkedScore = (index, isHalf, val) => {
      if (isUndefined(val))
        return false;
      if (val == -1)
        return false;
      if (val === 0)
        return false;
      if (isHalf) {
        if (val > index - 1 && val <= index - 0.5) {
          return true;
        } else {
          return false;
        }
      } else {
        if (val > index - 0.5 && val <= index) {
          return true;
        } else {
          return false;
        }
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("input", {
          type: "radio",
          name: "rating-10",
          class: "rating-hidden",
          checked: score.value === 0
        }, null, 8, _hoisted_1$z),
        (openBlock(), createElementBlock(Fragment, null, renderList(10, (item) => {
          return openBlock(), createElementBlock(Fragment, { key: item }, [
            createBaseVNode("input", {
              type: "radio",
              "data-index": item,
              name: "rating-10",
              class: "bg-orange-400 mask mask-star-2 mask-half-1",
              checked: checkedScore(item, true, score.value),
              disabled: _ctx.readonly
            }, null, 8, _hoisted_2$t),
            createBaseVNode("input", {
              type: "radio",
              "data-index": item,
              name: "rating-10",
              class: "bg-orange-500 mask mask-star-2 mask-half-2",
              checked: checkedScore(item, false, score.value),
              disabled: _ctx.readonly
            }, null, 8, _hoisted_3$n)
          ], 64);
        }), 64))
      ], 64);
    };
  }
});
const _hoisted_1$y = { class: "modal-box max-w-fit" };
const _hoisted_2$s = { class: "flex flex-row justify-between items-center mb-5" };
const _hoisted_3$m = { class: "font-bold text-lg" };
const _hoisted_4$j = /* @__PURE__ */ createBaseVNode("kbd", { class: "kbd cursor-pointer" }, "Esc", -1);
const _hoisted_5$g = [
  _hoisted_4$j
];
const _hoisted_6$f = { class: "flex flex-col gap-4" };
const _hoisted_7$b = { class: "h-12 px-4 rounded-lg bg-base-200 flex flex-row gap-2 items-center" };
const _hoisted_8$a = ["placeholder"];
const _hoisted_9$9 = {
  key: 0,
  class: "label"
};
const _hoisted_10$9 = { class: "label-text text-error" };
const _hoisted_11$9 = { class: "modal-action" };
const _hoisted_12$8 = {
  class: "btn btn-success ml-4",
  type: "submit"
};
const _sfc_main$E = /* @__PURE__ */ defineComponent({
  __name: "Score",
  props: {
    book: {}
  },
  setup(__props) {
    const props = __props;
    const { dialogRef, openDialog, closeDialog } = useDialog();
    const { defineField, handleSubmit, errors } = useForm({
      validationSchema: {
        score: (value) => value || value === 0 ? true : t$2("book.needScore")
      }
    });
    const [score, scoreProps] = defineField("score");
    const initScore = async () => {
      const val = props.book.score;
      score.value = isUndefined(val) || val === -1 ? 0 : val;
      openDialog();
      await nextTick();
      openDialog();
    };
    const submitScore = handleSubmit((value) => {
      value.score = +value.score.toFixed(1);
      BookAction.update(props.book.id, value);
      closeDialog();
    });
    const chooseScore = (event) => {
      const target = event.target;
      if (target.tagName === "INPUT") {
        const index = target.getAttribute("data-index");
        if (index === null)
          return;
        const isHalf = target.classList.contains("mask-half-1");
        score.value = +index - (isHalf ? 0.5 : 0);
      }
    };
    initScore();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("dialog", {
        class: "modal",
        ref_key: "dialogRef",
        ref: dialogRef
      }, [
        withDirectives((openBlock(), createElementBlock("div", _hoisted_1$y, [
          createBaseVNode("div", _hoisted_2$s, [
            createBaseVNode("h3", _hoisted_3$m, toDisplayString$1(unref(t$2)("book.score")), 1),
            createBaseVNode("div", {
              onClick: _cache[0] || (_cache[0] = //@ts-ignore
              (...args) => unref(closeDialog) && unref(closeDialog)(...args))
            }, _hoisted_5$g)
          ]),
          createBaseVNode("form", {
            onSubmit: _cache[3] || (_cache[3] = //@ts-ignore
            (...args) => unref(submitScore) && unref(submitScore)(...args))
          }, [
            createBaseVNode("div", _hoisted_6$f, [
              createBaseVNode("div", _hoisted_7$b, [
                createBaseVNode("span", null, toDisplayString$1(unref(t$2)("book.name")), 1),
                createBaseVNode("div", null, toDisplayString$1(_ctx.book.name), 1)
              ]),
              createBaseVNode("div", null, [
                createBaseVNode("label", {
                  class: normalizeClass(["input input-bordered flex items-center gap-2", { "input-error": unref(errors).score }]),
                  for: "name"
                }, [
                  createTextVNode(toDisplayString$1(unref(t$2)("book.score")) + " ", 1),
                  withDirectives(createBaseVNode("input", mergeProps({
                    type: "number",
                    max: "10",
                    min: "0",
                    step: "0.1",
                    class: "grow",
                    name: "score",
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(score) ? score.value = $event : null)
                  }, unref(scoreProps), {
                    placeholder: unref(t$2)("book.needScore")
                  }), null, 16, _hoisted_8$a), [
                    [vModelText, unref(score)]
                  ])
                ], 2),
                unref(errors).score ? (openBlock(), createElementBlock("div", _hoisted_9$9, [
                  createBaseVNode("span", _hoisted_10$9, toDisplayString$1(unref(errors).score), 1)
                ])) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", {
                class: "rating rating-md rating-half",
                onClick: chooseScore
              }, [
                createVNode(_sfc_main$F, {
                  value: unref(score),
                  readonly: false
                }, null, 8, ["value"])
              ])
            ]),
            createBaseVNode("div", _hoisted_11$9, [
              createBaseVNode("button", {
                class: "btn btn-outline",
                onClick: _cache[2] || (_cache[2] = //@ts-ignore
                (...args) => unref(closeDialog) && unref(closeDialog)(...args))
              }, toDisplayString$1(unref(t$2)("common.cancel")), 1),
              createBaseVNode("button", _hoisted_12$8, toDisplayString$1(unref(t$2)("common.sure")), 1)
            ])
          ], 32)
        ])), [
          [unref(vOnClickOutside), unref(closeDialog)]
        ])
      ], 512);
    };
  }
});
const scroreDialog = (book2) => createDialog(_sfc_main$E, { book: book2 });
const _withScopeId$2 = (n2) => (pushScopeId("data-v-2bcc3d2a"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$x = ["data-index"];
const _hoisted_2$r = {
  key: 0,
  class: "relative w-full"
};
const _hoisted_3$l = { class: "flex w-full justify-start pb-[1.125rem] px-5 gap-10 class" };
const _hoisted_4$i = ["onClick", "onContextmenu"];
const _hoisted_5$f = ["src", "alt"];
const _hoisted_6$e = { class: "line-clamp-2 mx-1 mb-1 text-sm" };
const _hoisted_7$a = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "shelf-shadows shadow-2xl" }, null, -1));
const _hoisted_8$9 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "shelf bg-base-100" }, null, -1));
const _hoisted_9$8 = {
  key: 1,
  class: "flex w-full justify-start gap-8"
};
const _hoisted_10$8 = ["onClick", "onContextmenu"];
const _hoisted_11$8 = { style: { width: `${84}px`, height: `${121}px` } };
const _hoisted_12$7 = ["src", "alt"];
const _hoisted_13$5 = { class: "flex flex-1 flex-col gap-2" };
const _hoisted_14$5 = { class: "line-clamp-2" };
const _hoisted_15$5 = {
  key: 2,
  class: "flex w-full flex-col"
};
const _hoisted_16$5 = ["onMouseenter", "onClick", "onContextmenu"];
const _hoisted_17$5 = { style: { width: `${84}px`, height: `${121}px` } };
const _hoisted_18$5 = ["src", "alt"];
const _hoisted_19$5 = { class: "flexflex-col flex-1 py-2" };
const _hoisted_20$5 = { class: "line-clamp-1" };
const _hoisted_21$5 = { class: "text-error" };
const _hoisted_22$5 = { key: 0 };
const _hoisted_23$5 = { key: 1 };
const _hoisted_24$5 = { class: "text-error" };
const _hoisted_25$4 = {
  key: 1,
  class: "hero min-h-screen bg-base-200"
};
const _hoisted_26$4 = { class: "hero-content text-center" };
const _hoisted_27$4 = {
  key: 0,
  class: "max-w-md"
};
const _hoisted_28$4 = { class: "text-5xl font-bold" };
const _hoisted_29$3 = { class: "py-6" };
const _hoisted_30$3 = {
  key: 1,
  class: "max-w-md"
};
const _hoisted_31$2 = { class: "text-5xl font-bold" };
const _hoisted_32$2 = { class: "py-6" };
const bookshelfWidht$1 = 120;
const bookshelfHeight$1 = 137;
const bookCardWidth = 282;
const _sfc_main$D = /* @__PURE__ */ defineComponent({
  __name: "BookList",
  props: {
    data: { default: () => [] },
    isRecycleBin: { type: Boolean, default: false }
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const textOpacity = { "--tw-text-opacity": 0.6 };
    const { indexBgOpacity, hoverAction } = useBgOpacity();
    const bookMode2 = (value) => value === settingStore.value.bookself;
    const store2 = useContentCantianerStore();
    const parentRef = ref(null);
    const parentOffsetRef = ref(0);
    onMounted(() => {
      parentOffsetRef.value = parentRef.value?.offsetTop ?? 0;
    });
    const list = computed(() => {
      const width = bookMode2(BookshelftMode.bookshelf) ? bookshelfWidht$1 : bookMode2(BookshelftMode.card) ? bookCardWidth : 0;
      const count = parseInt((store2.width / (width + remToPx(2.5))).toString());
      return bookMode2(BookshelftMode.list) ? toRaw(props.data) : chuankArray(toRaw(props.data) || [], count);
    });
    const rowVirtualizerOptions = computed(() => {
      return {
        count: list.value.length,
        estimateSize: () => 350,
        overscan: 5,
        getScrollElement: () => parentRef.value
      };
    });
    const rowVirtualizer = useVirtualizer(rowVirtualizerOptions);
    const virtualRows = computed(() => rowVirtualizer.value.getVirtualItems());
    const totalSize = computed(() => rowVirtualizer.value.getTotalSize());
    const measureElement2 = (el) => {
      if (!el) {
        return;
      }
      setTimeout(() => {
        rowVirtualizer.value.measureElement(el);
      });
      return void 0;
    };
    const uploadRef = ref(null);
    function uploadAction() {
      uploadRef.value?.open();
    }
    const { rightEvent, closeRight, rightInfo, selectData } = useRightClick();
    const dialogAction = (cb) => {
      if (!selectData.value)
        return;
      cb(selectData.value);
      closeRight();
    };
    const onEdite = () => dialogAction(editDialog);
    const onDetail = () => dialogAction(detailDialog);
    const onScore = () => dialogAction(scroreDialog);
    function onRemove(isForce) {
      const id2 = selectData.value?.id;
      if (!id2)
        return;
      removeDialog(selectData.value, props.isRecycleBin, isForce);
      closeRight();
    }
    function restoreOneBook() {
      const id2 = selectData.value?.id;
      if (!id2)
        return;
      BookAction.restoreOne(id2);
      closeRight();
    }
    function onLove() {
      const data2 = selectData.value;
      if (data2) {
        const isLove = !data2.isLove;
        BookAction.update(data2.id, { isLove });
        isLove ? toastSuccess(t$2("common.addSuccess")) : toastSuccess(t$2("common.removeSuccess"));
        closeRight();
      }
    }
    const onBookshelf = () => dialogAction(bookshelfDialog);
    return (_ctx, _cache) => {
      return _ctx.data.length ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref_key: "parentRef",
        ref: parentRef,
        id: "book-list-dialog",
        class: "p-6 flex h-full overflow-auto"
      }, [
        createBaseVNode("div", {
          class: "relative w-full",
          style: normalizeStyle({
            height: `${totalSize.value}px`
          })
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(virtualRows.value, (virtualRow) => {
            return openBlock(), createElementBlock("div", {
              key: virtualRow.key,
              ref_for: true,
              ref: measureElement2,
              "data-index": virtualRow.index,
              class: normalizeClass(["absolute top-0 left-0 w-full", [bookMode2(unref(BookshelftMode).list) ? "pb-4" : bookMode2(unref(BookshelftMode).bookshelf) ? "pb-10" : "pb-5"]]),
              style: normalizeStyle({
                transform: `translateY(${virtualRow.start - unref(rowVirtualizer).options.scrollMargin}px)`
              })
            }, [
              bookMode2(unref(BookshelftMode).bookshelf) ? (openBlock(), createElementBlock("div", _hoisted_2$r, [
                createBaseVNode("div", _hoisted_3$l, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(list.value[virtualRow.index], (item) => {
                    return openBlock(), createElementBlock("div", {
                      class: "card bg-base-100 rounded shadow cursor-pointer gap-2 bookshelf transition ease-in-out",
                      onClick: ($event) => emit2("click", item),
                      style: normalizeStyle({ width: `${bookshelfWidht$1}px`, height: `${bookshelfHeight$1 + unref(remToPx)(3.5)}px` }),
                      onContextmenu: ($event) => unref(rightEvent)($event, item)
                    }, [
                      createBaseVNode("div", {
                        style: normalizeStyle({ width: `${bookshelfWidht$1}px`, height: `${bookshelfHeight$1}px` }),
                        class: "rounded"
                      }, [
                        createBaseVNode("img", {
                          src: unref(convertUint8ArrayToURL)(item.cover),
                          class: "w-full rounded h-full object-cover",
                          alt: unref(t$2)("book.cover")
                        }, null, 8, _hoisted_5$f)
                      ], 4),
                      createBaseVNode("div", _hoisted_6$e, toDisplayString$1(item.name), 1)
                    ], 44, _hoisted_4$i);
                  }), 256))
                ]),
                _hoisted_7$a,
                _hoisted_8$9
              ])) : bookMode2(unref(BookshelftMode).card) ? (openBlock(), createElementBlock("div", _hoisted_9$8, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(list.value[virtualRow.index], (item) => {
                  return openBlock(), createElementBlock("div", {
                    class: "card flex-row items-center gap-4 p-4 bg-base-100 shadow-md cursor-pointer transition ease-in-out duration-150 hover:scale-110",
                    onClick: ($event) => emit2("click", item),
                    onContextmenu: ($event) => unref(rightEvent)($event, item),
                    style: normalizeStyle({ width: `${bookCardWidth}px` })
                  }, [
                    createBaseVNode("figure", _hoisted_11$8, [
                      createBaseVNode("img", {
                        src: unref(convertUint8ArrayToURL)(item.cover),
                        class: "w-full rounded h-full object-cover",
                        alt: unref(t$2)("book.cover")
                      }, null, 8, _hoisted_12$7)
                    ]),
                    createBaseVNode("div", _hoisted_13$5, [
                      createBaseVNode("p", _hoisted_14$5, toDisplayString$1(item.name), 1),
                      createBaseVNode("p", {
                        class: "line-clamp-2 label-text",
                        style: textOpacity
                      }, toDisplayString$1(item.author), 1)
                    ])
                  ], 44, _hoisted_10$8);
                }), 256))
              ])) : (openBlock(), createElementBlock("div", _hoisted_15$5, [
                createBaseVNode("div", {
                  class: "card flex flex-row bg-base-100 p-2 gap-4 cursor-pointer shadow hover:bg-primary hover:text-primary-content",
                  style: normalizeStyle({ "--tw-bg-opacity": unref(indexBgOpacity)(virtualRow.index) }),
                  onMouseenter: ($event) => unref(hoverAction)(0.3, virtualRow.index),
                  onMouseleave: _cache[0] || (_cache[0] = ($event) => unref(hoverAction)(1, -1)),
                  onClick: ($event) => emit2("click", list.value[virtualRow.index]),
                  onContextmenu: ($event) => unref(rightEvent)($event, list.value[virtualRow.index])
                }, [
                  createBaseVNode("figure", _hoisted_17$5, [
                    createBaseVNode("img", {
                      src: unref(convertUint8ArrayToURL)(list.value[virtualRow.index].cover),
                      class: "w-full rounded h-full object-cover",
                      alt: unref(t$2)("book.cover")
                    }, null, 8, _hoisted_18$5)
                  ]),
                  createBaseVNode("div", _hoisted_19$5, [
                    createBaseVNode("p", _hoisted_20$5, toDisplayString$1(list.value[virtualRow.index].name), 1),
                    createBaseVNode("p", {
                      class: "line-clamp-1 label-text",
                      style: textOpacity
                    }, toDisplayString$1(list.value[virtualRow.index].author), 1)
                  ])
                ], 44, _hoisted_16$5)
              ]))
            ], 14, _hoisted_1$x);
          }), 128))
        ], 4),
        unref(rightInfo).show ? withDirectives((openBlock(), createElementBlock("ul", {
          key: 0,
          class: "fixed menu bg-base-100 border border-accent rounded-md shadow-2xl gap-1 min-w-40 z-[99]",
          style: normalizeStyle({ top: unref(rightInfo).top, left: unref(rightInfo).left })
        }, [
          _ctx.isRecycleBin ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("li", {
              onClick: _cache[1] || (_cache[1] = ($event) => restoreOneBook())
            }, [
              createBaseVNode("a", null, [
                createVNode(unref(UndoDot), { class: "h-5 w-5" }),
                createTextVNode(toDisplayString$1(_ctx.$t("common.restore")), 1)
              ])
            ]),
            createBaseVNode("li", {
              onClick: _cache[2] || (_cache[2] = ($event) => onRemove(true))
            }, [
              createBaseVNode("a", _hoisted_21$5, [
                createVNode(unref(Trash2), { class: "h-5 w-5" }),
                createTextVNode(toDisplayString$1(_ctx.$t("common.forceRemove")), 1)
              ])
            ])
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createBaseVNode("li", {
              onClick: _cache[3] || (_cache[3] = ($event) => onLove())
            }, [
              unref(selectData)?.isLove ? (openBlock(), createElementBlock("a", _hoisted_22$5, [
                createVNode(unref(HeartOff), { class: "h-5 w-5" }),
                createTextVNode(toDisplayString$1(_ctx.$t("common.removeLove")), 1)
              ])) : (openBlock(), createElementBlock("a", _hoisted_23$5, [
                createVNode(unref(Heart), { class: "h-5 w-5" }),
                createTextVNode(toDisplayString$1(_ctx.$t("common.addLove")), 1)
              ]))
            ]),
            createBaseVNode("li", {
              onClick: _cache[4] || (_cache[4] = ($event) => onBookshelf())
            }, [
              createBaseVNode("a", null, [
                createVNode(unref(SquareLibrary), { class: "h-5 w-5" }),
                createTextVNode(toDisplayString$1(_ctx.$t("common.addBookshelf")), 1)
              ])
            ]),
            createBaseVNode("li", {
              onClick: _cache[5] || (_cache[5] = ($event) => onRemove(false))
            }, [
              createBaseVNode("a", _hoisted_24$5, [
                createVNode(unref(Trash2), { class: "h-5 w-5" }),
                createTextVNode(toDisplayString$1(_ctx.$t("common.remove")), 1)
              ])
            ]),
            createBaseVNode("li", {
              onClick: _cache[6] || (_cache[6] = ($event) => onEdite())
            }, [
              createBaseVNode("a", null, [
                createVNode(unref(PencilLine), { class: "h-5 w-5" }),
                createTextVNode(toDisplayString$1(_ctx.$t("common.edit")), 1)
              ])
            ]),
            createBaseVNode("li", {
              onClick: _cache[7] || (_cache[7] = ($event) => onScore())
            }, [
              createBaseVNode("a", null, [
                createVNode(unref(Star), { class: "h-5 w-5" }),
                createTextVNode(toDisplayString$1(_ctx.$t("common.score")), 1)
              ])
            ]),
            createBaseVNode("li", {
              onClick: _cache[8] || (_cache[8] = ($event) => onDetail())
            }, [
              createBaseVNode("a", null, [
                createVNode(unref(BellElectric), { class: "h-5 w-5" }),
                createTextVNode(toDisplayString$1(_ctx.$t("common.detail")), 1)
              ])
            ])
          ], 64))
        ], 4)), [
          [unref(vOnClickOutside), unref(closeRight)]
        ]) : createCommentVNode("", true)
      ], 512)) : (openBlock(), createElementBlock("div", _hoisted_25$4, [
        createBaseVNode("div", _hoisted_26$4, [
          _ctx.isRecycleBin ? (openBlock(), createElementBlock("div", _hoisted_27$4, [
            createBaseVNode("h1", _hoisted_28$4, toDisplayString$1(unref(t$2)("common.empty")), 1),
            createBaseVNode("p", _hoisted_29$3, toDisplayString$1(_ctx.$t("book.recycleNoRecord")), 1)
          ])) : (openBlock(), createElementBlock("div", _hoisted_30$3, [
            createBaseVNode("h1", _hoisted_31$2, toDisplayString$1(_ctx.$t("book.empty")), 1),
            createBaseVNode("p", _hoisted_32$2, toDisplayString$1(_ctx.$t("book.uploadBookTip")), 1),
            createBaseVNode("button", {
              class: "btn btn-accent",
              onClick: _cache[9] || (_cache[9] = ($event) => uploadAction())
            }, [
              createVNode(unref(Plus)),
              createTextVNode(toDisplayString$1(unref(t$2)("file.upload")), 1)
            ]),
            createVNode(unref(_sfc_main$m), {
              ref_key: "uploadRef",
              ref: uploadRef
            }, null, 512)
          ]))
        ])
      ]));
    };
  }
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const BookListView = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["__scopeId", "data-v-2bcc3d2a"]]);
const _hoisted_1$w = { class: "form-control" };
const _hoisted_2$q = { class: "cursor-pointer label" };
const _hoisted_3$k = { class: "font-bold text-xl" };
const _sfc_main$C = /* @__PURE__ */ defineComponent({
  __name: "CheckBox",
  props: /* @__PURE__ */ mergeModels({
    title: {},
    desc: {}
  }, {
    "modelValue": {},
    "modelModifiers": {}
  }),
  emits: ["update:modelValue"],
  setup(__props) {
    const model = useModel(__props, "modelValue");
    const textOpacity = { "--tw-text-opacity": 0.6 };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$w, [
        createBaseVNode("label", _hoisted_2$q, [
          createBaseVNode("div", null, [
            createBaseVNode("h3", _hoisted_3$k, toDisplayString$1(_ctx.title), 1),
            createBaseVNode("p", {
              class: "label-text font-normal mt-1",
              style: textOpacity
            }, toDisplayString$1(_ctx.desc), 1)
          ]),
          withDirectives(createBaseVNode("input", {
            type: "checkbox",
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => model.value = $event),
            class: "checkbox checkbox-info"
          }, null, 512), [
            [vModelCheckbox, model.value]
          ])
        ])
      ]);
    };
  }
});
const _hoisted_1$v = ["id"];
const _hoisted_2$p = /* @__PURE__ */ createBaseVNode("div", { class: "drawer-content" }, null, -1);
const _hoisted_3$j = { class: "drawer-side" };
const _hoisted_4$h = ["for"];
const _sfc_main$B = /* @__PURE__ */ defineComponent({
  __name: "Drawer",
  props: {
    id: {},
    isRight: { type: Boolean }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["drawer z-20", { "drawer-end": _ctx.isRight }])
      }, [
        createBaseVNode("input", {
          "aria-label": "Drawer handler",
          id: _ctx.id,
          class: "drawer-toggle",
          type: "checkbox"
        }, null, 8, _hoisted_1$v),
        _hoisted_2$p,
        createBaseVNode("div", _hoisted_3$j, [
          createBaseVNode("label", {
            class: "drawer-overlay",
            for: _ctx.id,
            "aria-label": "close sidebar"
          }, null, 8, _hoisted_4$h),
          renderSlot(_ctx.$slots, "default")
        ])
      ], 2);
    };
  }
});
const _sfc_main$A = /* @__PURE__ */ defineComponent({
  __name: "Dropdown",
  props: {
    detailsClass: { default: "" },
    summaryClass: { default: "" }
  },
  setup(__props) {
    const detailsRef = ref(null);
    const onCloce = () => {
      if (detailsRef.value && detailsRef.value.open) {
        detailsRef.value.open = false;
      }
    };
    onClickOutside$1(detailsRef, onCloce);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("details", {
        class: normalizeClass(["dropdown", _ctx.detailsClass]),
        ref_key: "detailsRef",
        ref: detailsRef
      }, [
        createBaseVNode("summary", {
          class: normalizeClass(_ctx.summaryClass)
        }, [
          renderSlot(_ctx.$slots, "summary")
        ], 2),
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
});
const _hoisted_1$u = { class: "hero min-h-screen bg-base-100" };
const _hoisted_2$o = { class: "hero-content text-center" };
const _hoisted_3$i = { class: "max-w-md flex items-center flex-col" };
const _hoisted_4$g = /* @__PURE__ */ createStaticVNode('<svg class="emoji-404" enable-background="new 0 0 226 249.135" height="249.135" id="Layer_1" overflow="visible" version="1.1" viewBox="0 0 226 249.135" width="226" xml:space="preserve" data-v-8e9d18b8><circle cx="113" cy="113" fill="#FFE585" r="109" data-v-8e9d18b8></circle><line enable-background="new    " fill="none" opacity="0.29" stroke="#6E6E96" stroke-linecap="round" stroke-linejoin="round" stroke-width="8" x1="88.866" x2="136.866" y1="245.135" y2="245.135" data-v-8e9d18b8></line><line enable-background="new    " fill="none" opacity="0.17" stroke="#6E6E96" stroke-linecap="round" stroke-linejoin="round" stroke-width="8" x1="154.732" x2="168.732" y1="245.135" y2="245.135" data-v-8e9d18b8></line><line enable-background="new    " fill="none" opacity="0.17" stroke="#6E6E96" stroke-linecap="round" stroke-linejoin="round" stroke-width="8" x1="69.732" x2="58.732" y1="245.135" y2="245.135" data-v-8e9d18b8></line><circle cx="68.732" cy="93" fill="#6E6E96" r="9" data-v-8e9d18b8></circle><path d="M115.568,5.947c-1.026,0-2.049,0.017-3.069,0.045  c54.425,1.551,98.069,46.155,98.069,100.955c0,55.781-45.219,101-101,101c-55.781,0-101-45.219-101-101  c0-8.786,1.124-17.309,3.232-25.436c-3.393,10.536-5.232,21.771-5.232,33.436c0,60.199,48.801,109,109,109s109-48.801,109-109  S175.768,5.947,115.568,5.947z" enable-background="new    " fill="#FF9900" opacity="0.24" data-v-8e9d18b8></path><circle cx="156.398" cy="93" fill="#6E6E96" r="9" data-v-8e9d18b8></circle><ellipse cx="67.732" cy="140.894" enable-background="new    " fill="#FF0000" opacity="0.18" rx="17.372" ry="8.106" data-v-8e9d18b8></ellipse><ellipse cx="154.88" cy="140.894" enable-background="new    " fill="#FF0000" opacity="0.18" rx="17.371" ry="8.106" data-v-8e9d18b8></ellipse><path d="M13,118.5C13,61.338,59.338,15,116.5,15c55.922,0,101.477,44.353,103.427,99.797  c0.044-1.261,0.073-2.525,0.073-3.797C220,50.802,171.199,2,111,2S2,50.802,2,111c0,50.111,33.818,92.318,79.876,105.06  C41.743,201.814,13,163.518,13,118.5z" fill="#FFEFB5" data-v-8e9d18b8></path><circle cx="113" cy="113" fill="none" r="109" stroke="#6E6E96" stroke-width="8" data-v-8e9d18b8></circle></svg>', 1);
const _hoisted_5$e = { class: "text-5xl font-bold pt-8" };
const _hoisted_6$d = { class: "py-6" };
const _hoisted_7$9 = { class: "btn btn-primary" };
const _sfc_main$z = /* @__PURE__ */ defineComponent({
  __name: "404",
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_RouterLink = resolveComponent("RouterLink");
      return openBlock(), createElementBlock("div", _hoisted_1$u, [
        createBaseVNode("div", _hoisted_2$o, [
          createBaseVNode("div", _hoisted_3$i, [
            _hoisted_4$g,
            createBaseVNode("h1", _hoisted_5$e, "404 " + toDisplayString$1(_ctx.$t("unfound.title")), 1),
            createBaseVNode("p", _hoisted_6$d, toDisplayString$1(_ctx.$t("unfound.desc")), 1),
            createBaseVNode("button", _hoisted_7$9, [
              createVNode(_component_RouterLink, {
                to: unref(RouterName).Home
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(_ctx.$t("unfound.tip")), 1)
                ]),
                _: 1
              }, 8, ["to"])
            ])
          ])
        ])
      ]);
    };
  }
});
const ErrorView = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["__scopeId", "data-v-8e9d18b8"]]);
const _hoisted_1$t = ["onClick"];
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "List",
  props: {
    modelValue: {},
    list: { default: () => [] },
    isCloce: { type: Boolean, default: true },
    class: { default: "" }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    function onClick(value) {
      const data2 = props.modelValue.id ? value : value.id;
      emit2("update:modelValue", data2);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("ul", {
        class: normalizeClass(["p-2 mt-2 z-[10] max-h-60 md:max-h-72 lg:max-h-96 w-full overflow-auto border border-accent rounded-md menu flex-nowrap bg-base-100 shadow-2xl gap-1 scrollbar-thin", _ctx.class])
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (item) => {
          return openBlock(), createElementBlock("li", {
            key: item.value,
            onClick: ($event) => onClick(item),
            class: "text-base-content"
          }, [
            _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", {
              key: 0,
              data: item
            }) : (openBlock(), createElementBlock("a", {
              key: 1,
              class: normalizeClass({ "active": (_ctx.modelValue?.id || _ctx.modelValue) === item.id })
            }, toDisplayString$1(item.value), 3))
          ], 8, _hoisted_1$t);
        }), 128))
      ], 2);
    };
  }
});
const _sfc_main$x = {};
const _hoisted_1$s = { class: "hero h-full bg-base-100" };
const _hoisted_2$n = /* @__PURE__ */ createBaseVNode("span", { class: "loading loading-ring loading-xs" }, null, -1);
const _hoisted_3$h = /* @__PURE__ */ createBaseVNode("span", { class: "loading loading-ring loading-sm" }, null, -1);
const _hoisted_4$f = /* @__PURE__ */ createBaseVNode("span", { class: "loading loading-ring loading-md" }, null, -1);
const _hoisted_5$d = /* @__PURE__ */ createBaseVNode("span", { class: "loading loading-ring loading-lg" }, null, -1);
const _hoisted_6$c = [
  _hoisted_2$n,
  _hoisted_3$h,
  _hoisted_4$f,
  _hoisted_5$d
];
function _sfc_render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("div", _hoisted_1$s, _hoisted_6$c);
}
const RingLoadingView = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$1]]);
const _sfc_main$w = {};
const _hoisted_1$r = { class: "flex w-full flex-col gap-4" };
const _hoisted_2$m = /* @__PURE__ */ createStaticVNode('<div class="flex items-center gap-4"><div class="skeleton h-16 w-16 shrink-0 rounded-full"></div><div class="flex flex-col gap-4 w-full"><div class="skeleton h-4 w-1/2"></div><div class="skeleton h-4 w-full"></div></div></div><div class="flex items-center gap-4"><div class="skeleton h-16 w-16 shrink-0 rounded-full"></div><div class="flex flex-col gap-4 w-full"><div class="skeleton h-4 w-1/2"></div><div class="skeleton h-4 w-full"></div></div></div><div class="skeleton h-32 w-full"></div>', 3);
const _hoisted_5$c = [
  _hoisted_2$m
];
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", _hoisted_1$r, _hoisted_5$c);
}
const SkeletonView = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render]]);
const _hoisted_1$q = { class: "card rounded-md shadow-md bg-base-100 cursor-pointer text-sm w-96 prose" };
const _hoisted_2$l = { class: "card-body" };
const _hoisted_3$g = { class: "flex flex-row item-center justify-between" };
const _hoisted_4$e = { class: "dropdown dropdown-end" };
const _hoisted_5$b = { class: "btn btn-ghost btn-sm" };
const _hoisted_6$b = {
  tabindex: "0",
  class: "dropdown-content z-[1] menu p-2 shadow-2xl border border-primary bg-base-100 rounded-md w-48"
};
const _hoisted_7$8 = { class: "text-error no-underline" };
const _hoisted_8$8 = { class: "no-underline" };
const _hoisted_9$7 = { class: "my-[0.6em] line-clamp-3" };
const _hoisted_10$7 = { class: "my-[0.6em] line-clamp-3" };
const _hoisted_11$7 = { class: "my-[0.6em] line-clamp-3" };
const _hoisted_12$6 = { class: "my-[0.6em] line-clamp-3" };
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  __name: "Card",
  props: {
    data: {}
  },
  emits: ["delete", "detail", "jump"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const getColorName = (val) => NoteAction.getDomSource(val)[0]?.className || "";
    const className = ref(settingStore.value.isNoteShowClass ? getColorName(props.data.domSource) : "");
    const noteText = computed(() => NoteAction.getNoteText(props.data.notes).reduce((acc, cur) => acc += cur.value, ""));
    const onMouseEnter = () => className.value = getColorName(props.data.domSource);
    const onMouseLeave = () => className.value = "";
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$q, [
        createBaseVNode("div", _hoisted_2$l, [
          createBaseVNode("div", _hoisted_3$g, [
            createBaseVNode("div", null, toDisplayString$1(unref(dayjs)(_ctx.data.updateTime).format("L LT")), 1),
            createBaseVNode("div", _hoisted_4$e, [
              createBaseVNode("button", _hoisted_5$b, [
                createVNode(unref(Ellipsis), { class: "w-5 h-5" })
              ]),
              createBaseVNode("ul", _hoisted_6$b, [
                createBaseVNode("li", {
                  onClick: _cache[0] || (_cache[0] = ($event) => emit2("delete", _ctx.data))
                }, [
                  createBaseVNode("a", _hoisted_7$8, [
                    createVNode(unref(Trash2), { class: "h-5 w-5" }),
                    createTextVNode(toDisplayString$1(unref(t$2)("common.remove")), 1)
                  ])
                ]),
                createBaseVNode("li", {
                  onClick: _cache[1] || (_cache[1] = ($event) => emit2("detail", _ctx.data))
                }, [
                  createBaseVNode("a", _hoisted_8$8, [
                    createVNode(unref(BellElectric), { class: "h-5 w-5" }),
                    createTextVNode(toDisplayString$1(unref(t$2)("common.detail")), 1)
                  ])
                ])
              ])
            ])
          ]),
          unref(settingStore).isNoteShowClass ? (openBlock(), createElementBlock("div", {
            key: 0,
            onClick: _cache[2] || (_cache[2] = ($event) => emit2("jump", _ctx.data))
          }, [
            createBaseVNode("blockquote", {
              class: normalizeClass(["my-[1em]", className.value])
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(NoteAction).getDomSource(_ctx.data?.domSource), (item) => {
                return openBlock(), createElementBlock("p", _hoisted_9$7, toDisplayString$1(item.text), 1);
              }), 256))
            ], 2),
            createBaseVNode("p", _hoisted_10$7, toDisplayString$1(noteText.value), 1)
          ])) : (openBlock(), createElementBlock("div", {
            key: 1,
            onClick: _cache[3] || (_cache[3] = ($event) => emit2("jump", _ctx.data))
          }, [
            createBaseVNode("blockquote", {
              class: normalizeClass(["my-[1em]", className.value]),
              onMouseenter: onMouseEnter,
              onMouseleave: onMouseLeave
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(NoteAction).getDomSource(_ctx.data?.domSource), (item) => {
                return openBlock(), createElementBlock("p", _hoisted_11$7, toDisplayString$1(item.text), 1);
              }), 256))
            ], 34),
            createBaseVNode("p", _hoisted_12$6, toDisplayString$1(noteText.value), 1)
          ]))
        ])
      ]);
    };
  }
});
const _hoisted_1$p = { class: "bg-base-200 p-3 rounded-md grid grid-cols-1 divide-y" };
const _hoisted_2$k = { class: "flex flex-row justify-between items-center mt-3" };
const _hoisted_3$f = { class: "stat-desc" };
const _hoisted_4$d = { key: 0 };
const _hoisted_5$a = ["onClick"];
const _hoisted_6$a = { class: "my-2" };
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "Note",
  props: {
    data: { default: () => [] },
    showRemove: { type: Boolean, default: true }
  },
  emits: ["remove"],
  setup(__props, { emit: __emit }) {
    const emit2 = __emit;
    const removeNote = (index) => {
      emit2("remove", index);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$p, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.data, (item, index) => {
          return openBlock(), createElementBlock("div", null, [
            createBaseVNode("div", _hoisted_2$k, [
              createBaseVNode("div", _hoisted_3$f, toDisplayString$1(unref(dayjs)(item.time).format("L LT")), 1),
              _ctx.showRemove ? (openBlock(), createElementBlock("div", _hoisted_4$d, [
                createBaseVNode("button", {
                  class: "btn btn-outline btn-error btn-xs",
                  onClick: ($event) => removeNote(index)
                }, toDisplayString$1(_ctx.$t("common.remove")), 9, _hoisted_5$a)
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("p", _hoisted_6$a, toDisplayString$1(item.value), 1)
          ]);
        }), 256))
      ]);
    };
  }
});
const _hoisted_1$o = ["data-index"];
const _hoisted_2$j = { class: "modal-box" };
const _hoisted_3$e = { class: "flex flex-row justify-between items-center" };
const _hoisted_4$c = { class: "font-bold text-lg" };
const _hoisted_5$9 = /* @__PURE__ */ createBaseVNode("kbd", { class: "kbd cursor-pointer" }, "Esc", -1);
const _hoisted_6$9 = [
  _hoisted_5$9
];
const _hoisted_7$7 = { key: 0 };
const _hoisted_8$7 = { class: "prose" };
const _hoisted_9$6 = { class: "my-[1em]" };
const _hoisted_10$6 = { class: "my-[0.6em]" };
const _hoisted_11$6 = { class: "text-warning mt-4" };
const _hoisted_12$5 = { class: "modal-action" };
const _hoisted_13$4 = { class: "modal-box" };
const _hoisted_14$4 = { class: "flex flex-row justify-between items-center" };
const _hoisted_15$4 = { class: "font-bold text-lg" };
const _hoisted_16$4 = /* @__PURE__ */ createBaseVNode("kbd", { class: "kbd cursor-pointer" }, "Esc", -1);
const _hoisted_17$4 = [
  _hoisted_16$4
];
const _hoisted_18$4 = { key: 0 };
const _hoisted_19$4 = { class: "prose" };
const _hoisted_20$4 = { class: "my-[1em]" };
const _hoisted_21$4 = { class: "my-[0.6em]" };
const _hoisted_22$4 = { class: "modal-action" };
const _hoisted_23$4 = {
  key: 1,
  class: "hero min-h-screen bg-base-200"
};
const _hoisted_24$4 = { class: "hero-content text-center" };
const _hoisted_25$3 = { class: "max-w-md" };
const _hoisted_26$3 = { class: "text-5xl font-bold" };
const _hoisted_27$3 = { class: "py-6" };
const _hoisted_28$3 = { class: "btn btn-secondary" };
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "NoteList",
  props: {
    data: { default: () => [] }
  },
  setup(__props) {
    const props = __props;
    const noteList = ref([]);
    const store2 = useContentCantianerStore();
    const parentRef = ref(null);
    const list = computed(() => {
      const count = parseInt((store2.width / remToPx(24 + 1)).toString());
      return chuankArray(toRaw(props.data) || [], count);
    });
    const rowVirtualizerOptions = computed(() => {
      return {
        count: list.value.length,
        estimateSize: () => 350,
        overscan: 5,
        getScrollElement: () => parentRef.value
      };
    });
    const rowVirtualizer = useVirtualizer(rowVirtualizerOptions);
    const virtualRows = computed(() => rowVirtualizer.value.getVirtualItems());
    const totalSize = computed(() => rowVirtualizer.value.getTotalSize());
    const measureElement2 = (el) => {
      if (!el) {
        return;
      }
      setTimeout(() => {
        rowVirtualizer.value.measureElement(el);
      });
      return void 0;
    };
    let selectData = null;
    const { dialogRef: removeDialogRef, openDialog: openRemoveDialog, closeDialog: closeRemoveDialog } = useDialog();
    const removeBefore = (value) => {
      selectData = value;
      openRemoveDialog();
    };
    const removeAction = async () => {
      await NoteAction.removeOne(selectData.id);
      closeRemoveDialog();
      toastSuccess(t$2("note.removeSuccess"));
    };
    const { dialogRef: detailDialogRef, openDialog: openDetailDialog, closeDialog: closeDetailDialog } = useDialog();
    const onDetail = (value) => {
      selectData = value;
      openDetailDialog();
      set$1(noteList, NoteAction.getNoteText(value.notes));
    };
    const removeNote = async (index) => {
      noteList.value.splice(index, 1);
      await NoteAction.update(selectData.id, { notes: JSON.stringify(noteList.value) });
      toastSuccess(t$2("note.removeSuccess"));
    };
    const jump = (value) => {
      localStorage.setItem("__note__", JSON.stringify(value));
      bookJump(value.eBookId);
    };
    return (_ctx, _cache) => {
      const _component_RouterLink = resolveComponent("RouterLink");
      return _ctx.data.length ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref_key: "parentRef",
        ref: parentRef,
        class: "p-6 h-full overflow-auto"
      }, [
        createBaseVNode("div", {
          class: "relative w-full",
          style: normalizeStyle({ height: `${totalSize.value}px` })
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(virtualRows.value, (virtualRow) => {
            return openBlock(), createElementBlock("div", {
              key: virtualRow.key,
              ref_for: true,
              ref: measureElement2,
              "data-index": virtualRow.index,
              class: "flex gap-4 absolute top-0 left-0 w-full pb-5",
              style: normalizeStyle({ transform: `translateY(${virtualRow.start - unref(rowVirtualizer).options.scrollMargin}px)` })
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(list.value[virtualRow.index], (item) => {
                return openBlock(), createBlock(_sfc_main$v, {
                  data: item,
                  onDelete: removeBefore,
                  onDetail,
                  onJump: jump
                }, null, 8, ["data"]);
              }), 256))
            ], 12, _hoisted_1$o);
          }), 128))
        ], 4),
        createBaseVNode("dialog", {
          class: "modal",
          ref_key: "removeDialogRef",
          ref: removeDialogRef
        }, [
          withDirectives((openBlock(), createElementBlock("div", _hoisted_2$j, [
            createBaseVNode("div", _hoisted_3$e, [
              createBaseVNode("h3", _hoisted_4$c, toDisplayString$1(unref(t$2)("note.sureRemove")), 1),
              createBaseVNode("div", {
                onClick: _cache[0] || (_cache[0] = //@ts-ignore
                (...args) => unref(closeRemoveDialog) && unref(closeRemoveDialog)(...args))
              }, _hoisted_6$9)
            ]),
            unref(selectData)?.createTime ? (openBlock(), createElementBlock("div", _hoisted_7$7, toDisplayString$1(unref(dayjs)(unref(selectData)?.createTime).format("L LT")), 1)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_8$7, [
              createBaseVNode("blockquote", _hoisted_9$6, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(NoteAction).getDomSource(unref(selectData)?.domSource), (item) => {
                  return openBlock(), createElementBlock("p", _hoisted_10$6, toDisplayString$1(item.text), 1);
                }), 256))
              ])
            ]),
            noteList.value.length ? (openBlock(), createBlock(_sfc_main$u, {
              key: 1,
              data: noteList.value,
              onRemove: removeNote
            }, null, 8, ["data"])) : createCommentVNode("", true),
            createBaseVNode("p", _hoisted_11$6, toDisplayString$1(unref(t$2)("note.forceRemove")), 1),
            createBaseVNode("div", _hoisted_12$5, [
              createBaseVNode("button", {
                class: "btn btn-outline",
                onClick: _cache[1] || (_cache[1] = //@ts-ignore
                (...args) => unref(closeRemoveDialog) && unref(closeRemoveDialog)(...args))
              }, toDisplayString$1(unref(t$2)("common.remove")), 1),
              createBaseVNode("button", {
                class: "btn btn-outline btn-error ml-4",
                onClick: removeAction
              }, toDisplayString$1(unref(t$2)("common.sure")), 1)
            ])
          ])), [
            [unref(vOnClickOutside), unref(closeRemoveDialog)]
          ])
        ], 512),
        createBaseVNode("dialog", {
          class: "modal",
          ref_key: "detailDialogRef",
          ref: detailDialogRef
        }, [
          withDirectives((openBlock(), createElementBlock("div", _hoisted_13$4, [
            createBaseVNode("div", _hoisted_14$4, [
              createBaseVNode("h3", _hoisted_15$4, toDisplayString$1(unref(t$2)("note.noteDetail")), 1),
              createBaseVNode("div", {
                onClick: _cache[2] || (_cache[2] = //@ts-ignore
                (...args) => unref(closeDetailDialog) && unref(closeDetailDialog)(...args))
              }, _hoisted_17$4)
            ]),
            unref(selectData)?.createTime ? (openBlock(), createElementBlock("div", _hoisted_18$4, toDisplayString$1(unref(dayjs)(unref(selectData)?.createTime).format("L LT")), 1)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_19$4, [
              createBaseVNode("blockquote", _hoisted_20$4, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(NoteAction).getDomSource(unref(selectData)?.domSource), (item) => {
                  return openBlock(), createElementBlock("p", _hoisted_21$4, toDisplayString$1(item.text), 1);
                }), 256))
              ])
            ]),
            noteList.value.length ? (openBlock(), createBlock(_sfc_main$u, {
              key: 1,
              data: noteList.value,
              "show-remove": false
            }, null, 8, ["data"])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_22$4, [
              createBaseVNode("button", {
                class: "btn btn-outline",
                onClick: _cache[3] || (_cache[3] = //@ts-ignore
                (...args) => unref(closeDetailDialog) && unref(closeDetailDialog)(...args))
              }, "")
            ])
          ])), [
            [unref(vOnClickOutside), unref(closeDetailDialog)]
          ])
        ], 512)
      ], 512)) : (openBlock(), createElementBlock("div", _hoisted_23$4, [
        createBaseVNode("div", _hoisted_24$4, [
          createBaseVNode("div", _hoisted_25$3, [
            createBaseVNode("h1", _hoisted_26$3, toDisplayString$1(unref(t$2)("note.empty")), 1),
            createBaseVNode("p", _hoisted_27$3, toDisplayString$1(unref(t$2)("note.emptyNoteListTip")), 1),
            createVNode(_component_RouterLink, {
              to: unref(RouterName).Book
            }, {
              default: withCtx(() => [
                createBaseVNode("button", _hoisted_28$3, [
                  createVNode(unref(Flag)),
                  createTextVNode(toDisplayString$1(unref(t$2)("book.jumpToBookList")), 1)
                ])
              ]),
              _: 1
            }, 8, ["to"])
          ])
        ])
      ]));
    };
  }
});
const _hoisted_1$n = { class: "p-2 mt-2 dropdown-content z-[10] max-h-60 md:max-h-72 lg:max-h-96 w-full overflow-auto border border-accent rounded-md menu flex-nowrap bg-base-100 shadow-2xl gap-1 scrollbar-thin" };
const _hoisted_2$i = ["onClick"];
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "Select",
  props: {
    modelValue: {},
    list: { default: () => [] },
    isCloce: { type: Boolean, default: true },
    className: { default: "" }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const detailsRef = ref(null);
    const summaryRef = ref(null);
    const position = ref("");
    onMounted(() => {
      position.value = isInClientRectTop(summaryRef.value) ? "dropdown-top" : "dropdown-bottom";
    });
    const onCloce = () => {
      if (detailsRef.value && detailsRef.value.open) {
        detailsRef.value.open = false;
      }
    };
    onClickOutside$1(detailsRef, onCloce);
    function onClick(value) {
      const data2 = props.modelValue.id ? value : value.id;
      emit2("update:modelValue", data2);
      if (props.isCloce)
        onCloce();
    }
    function getModelValue(modelValue) {
      if (!modelValue)
        return "";
      if (modelValue.id) {
        return modelValue.value;
      } else {
        return props.list.find((item) => item.id === modelValue)?.value;
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("details", {
        class: normalizeClass(["dropdown", position.value]),
        ref_key: "detailsRef",
        ref: detailsRef
      }, [
        createBaseVNode("summary", {
          ref_key: "summaryRef",
          ref: summaryRef,
          class: normalizeClass(["cursor-pointer select select-bordered items-center w-full", _ctx.className])
        }, toDisplayString$1(getModelValue(_ctx.modelValue)), 3),
        createBaseVNode("ul", _hoisted_1$n, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (item) => {
            return openBlock(), createElementBlock("li", {
              key: item.value,
              onClick: ($event) => onClick(item),
              class: "text-base-content"
            }, [
              _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", {
                key: 0,
                data: item
              }) : (openBlock(), createElementBlock("a", {
                key: 1,
                class: normalizeClass({ "active": (_ctx.modelValue?.id || _ctx.modelValue) === item.id })
              }, toDisplayString$1(item.value), 3))
            ], 8, _hoisted_2$i);
          }), 128))
        ])
      ], 2);
    };
  }
});
const _hoisted_1$m = { class: "form-control w-full max-w-xs" };
const _hoisted_2$h = { class: "label" };
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "SelectView",
  props: /* @__PURE__ */ mergeModels({
    label: {},
    list: {}
  }, {
    "modelValue": {},
    "modelModifiers": {}
  }),
  emits: ["update:modelValue"],
  setup(__props) {
    const model = useModel(__props, "modelValue");
    const textOpacity = { "--tw-text-opacity": 0.6 };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("label", _hoisted_1$m, [
        createBaseVNode("div", _hoisted_2$h, [
          createBaseVNode("span", {
            class: "label-text",
            style: textOpacity
          }, toDisplayString$1(_ctx.label), 1)
        ]),
        createVNode(_sfc_main$s, {
          modelValue: model.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => model.value = $event),
          list: _ctx.list
        }, null, 8, ["modelValue", "list"])
      ]);
    };
  }
});
const _hoisted_1$l = { class: "badge badge-info gap-2" };
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "TagList",
  props: {
    tag: { default: () => [] },
    show: { type: Boolean, default: true }
  },
  emits: ["remove"],
  setup(__props, { emit: __emit }) {
    const emit2 = __emit;
    return (_ctx, _cache) => {
      return openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.tag, (item, index) => {
        return openBlock(), createElementBlock("div", _hoisted_1$l, [
          createTextVNode(toDisplayString$1(item.tagName) + " ", 1),
          _ctx.show ? (openBlock(), createBlock(unref(X), {
            key: 0,
            class: "w-4 h-4 cursor-pointer",
            onClick: ($event) => emit2("remove", index)
          }, null, 8, ["onClick"])) : createCommentVNode("", true)
        ]);
      }), 256);
    };
  }
});
class TagAction {
  static async add(tagName) {
    try {
      const time = {
        id: v4(),
        tagName,
        createTime: now(),
        updateTime: now(),
        isDelete: null
      };
      await db.tag.put(time);
      return await this.findOne(time.id);
    } catch (error) {
      toastError("" + error);
      return Promise.reject(error);
    }
  }
  static observable(isDelete = false) {
    try {
      return useObservable(
        liveQuery(
          async () => (await db.tag.toArray()).filter((item) => isDelete ? item.isDelete : !item.isDelete)
        )
      );
    } catch (error) {
      toastError("" + error);
      return [];
    }
  }
  static observableByIds(ids) {
    const id2 = new Set(ids.split(","));
    try {
      return useObservable(
        liveQuery(async () => (await db.tag.toArray()).filter((item) => id2.has(item.id)))
      );
    } catch (error) {
      toastError("" + error);
      return [];
    }
  }
  static findByIds(ids) {
    const id2 = ids.split(",");
    return db.tag.where("id").anyOf(id2).toArray();
  }
  static findOne(id2) {
    return db.tag.where("id").equals(id2).first();
  }
  static toJSON(tag2) {
    const result = tag2.map((item) => ({ id: item.id, tagName: item.tagName }));
    return JSON.stringify(result);
  }
  static toTag(val) {
    try {
      return JSON.parse(val);
    } catch (error) {
      return [];
    }
  }
}
const _hoisted_1$k = ["onClick"];
const _hoisted_2$g = ["placeholder"];
const _hoisted_3$d = ["onClick"];
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "TagInput",
  props: {
    modelValue: { default: () => [] }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const container = ref(null);
    const listContianer = ref(null);
    const list = ref(props.modelValue);
    const tagValue = ref("");
    const allTag = TagAction.observable();
    watchEffect(() => {
      set$1(list, props.modelValue);
    });
    const placeholderOption = computed(() => {
      const val = get(tagValue);
      if (!val)
        return [];
      const all = get(allTag) || [];
      return all.filter((item) => item.tagName.includes(val)).filter((item) => !list.value.find((sub) => sub.id === item.id));
    });
    const isTop = computed(() => {
      const dom = get(container);
      if (!dom)
        return false;
      return isInClientRectTop(dom);
    });
    const activePlaceholder = ref(-1);
    const onRemove = (index) => {
      list.value.splice(index, 1);
    };
    const reset = () => {
      set$1(tagValue, "");
      set$1(activePlaceholder, -1);
    };
    const addAction = (val) => {
      const isExist = list.value.find((item) => item.id === val.id);
      if (!isExist) {
        list.value.push(val);
        emit2("update:modelValue", list.value);
      }
      reset();
    };
    const onAdd = useThrottleFn(async () => {
      const index = get(activePlaceholder);
      if (index !== -1) {
        addAction(get(placeholderOption)[index]);
        return;
      }
      const val = get(tagValue).trim();
      if (val) {
        const all = get(allTag);
        const isExist = all.find((item) => item.tagName === val);
        if (!isExist) {
          const res = await TagAction.add(val);
          if (res) {
            addAction(get(res));
          }
        } else {
          addAction(get(isExist));
        }
      }
    }, 150);
    const onPlaceholder = (val) => addAction(val);
    const activeToView = () => {
      const node = get(listContianer);
      if (!node)
        return;
      const { scrollHeight, clientHeight } = node;
      if (scrollHeight <= clientHeight)
        return;
      const target = node.children[get(activePlaceholder)]?.firstElementChild;
      if (!target)
        return;
      e$1(target, { behavior: "smooth", scrollMode: "if-needed" });
    };
    const onDown = () => {
      const index = get(activePlaceholder);
      const len = get(placeholderOption).length;
      if (index < len - 1) {
        set$1(activePlaceholder, index + 1);
        activeToView();
      }
    };
    const onUp = () => {
      const index = get(activePlaceholder);
      if (index <= 0) {
        set$1(activePlaceholder, 0);
      } else {
        set$1(activePlaceholder, index - 1);
      }
      activeToView();
    };
    const onTab = () => {
      const index = get(activePlaceholder);
      if (index !== -1) {
        addAction(get(placeholderOption)[index]);
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        isTop.value && placeholderOption.value.length ? (openBlock(), createElementBlock("ul", {
          key: 0,
          ref_key: "listContianer",
          ref: listContianer,
          class: "p-2 mt-2 z-[10] max-h-60 md:max-h-72 lg:max-h-96 w-full overflow-auto border border-accent rounded-md menu flex-nowrap bg-base-100 shadow-2xl gap-1 scrollbar-thin"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(placeholderOption.value, (item, index) => {
            return openBlock(), createElementBlock("li", {
              key: item.id,
              onClick: ($event) => onPlaceholder(item),
              class: "text-base-content"
            }, [
              createBaseVNode("a", {
                class: normalizeClass({ active: activePlaceholder.value === index })
              }, toDisplayString$1(item.tagName), 3)
            ], 8, _hoisted_1$k);
          }), 128))
        ], 512)) : createCommentVNode("", true),
        createBaseVNode("label", {
          class: "input input-bordered flex items-center gap-2 flex-wrap min-h-12 h-auto py-2",
          ref_key: "container",
          ref: container
        }, [
          createVNode(_sfc_main$q, {
            tag: list.value,
            onRemove
          }, null, 8, ["tag"]),
          withDirectives(createBaseVNode("input", {
            type: "text",
            class: "grow",
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => tagValue.value = $event),
            placeholder: unref(t$2)("tag.needTag"),
            onKeydown: [
              _cache[1] || (_cache[1] = withKeys(($event) => unref(onAdd)(), ["enter"])),
              _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => onDown(), ["prevent"]), ["down"])),
              _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => onUp(), ["prevent"]), ["up"])),
              _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => onTab(), ["prevent"]), ["tab"]))
            ]
          }, null, 40, _hoisted_2$g), [
            [vModelText, tagValue.value]
          ])
        ], 512),
        !isTop.value && placeholderOption.value.length ? (openBlock(), createElementBlock("ul", {
          key: 1,
          ref_key: "listContianer",
          ref: listContianer,
          class: "p-2 mt-2 z-[10] max-h-60 md:max-h-72 lg:max-h-96 w-full overflow-auto border border-accent rounded-md menu flex-nowrap bg-base-100 shadow-2xl gap-1 scrollbar-thin"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(placeholderOption.value, (item, index) => {
            return openBlock(), createElementBlock("li", {
              key: item.id,
              onClick: ($event) => onPlaceholder(item),
              class: "text-base-content"
            }, [
              createBaseVNode("a", {
                class: normalizeClass({ active: activePlaceholder.value === index })
              }, toDisplayString$1(item.tagName), 3)
            ], 8, _hoisted_3$d);
          }), 128))
        ], 512)) : createCommentVNode("", true)
      ], 64);
    };
  }
});
const _hoisted_1$j = ["onClick"];
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "ExpandTree",
  props: {
    data: { default: () => [] },
    deps: { default: 0 },
    active: { default: 0 }
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const emit2 = __emit;
    const handleClick = (e2) => {
      emit2("click", e2);
    };
    const isActive = (item, active) => active >= item.page && active < item.nextPage;
    return (_ctx, _cache) => {
      const _component_ExpandTreeView = resolveComponent("ExpandTreeView");
      return openBlock(), createElementBlock("ul", {
        class: normalizeClass({ "menu": _ctx.deps === 0 })
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.data, (item) => {
          return openBlock(), createElementBlock("li", {
            key: item.herf,
            onClick: withModifiers(($event) => handleClick(item), ["stop"])
          }, [
            createBaseVNode("a", {
              class: normalizeClass(["whitespace-normal", { active: isActive(item, _ctx.active) }])
            }, toDisplayString$1(item.label), 3),
            item.subitems && item.subitems.length > 0 ? (openBlock(), createBlock(_component_ExpandTreeView, {
              key: 0,
              data: item.subitems,
              active: _ctx.active,
              deps: _ctx.deps + 1,
              onClick: handleClick
            }, null, 8, ["data", "active", "deps"])) : createCommentVNode("", true)
          ], 8, _hoisted_1$j);
        }), 128))
      ], 2);
    };
  }
});
const _hoisted_1$i = { key: 0 };
const _hoisted_2$f = { class: "whitespace-normal" };
const _hoisted_3$c = {
  key: 1,
  class: "whitespace-normal"
};
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "FoldTree",
  props: {
    data: { default: () => [] },
    deps: { default: 0 }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_Doc = resolveComponent("Doc");
      return openBlock(), createElementBlock("ul", {
        class: normalizeClass({ "menu": _ctx.deps === 0 })
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.data, (item) => {
          return openBlock(), createElementBlock("li", {
            key: item.herf
          }, [
            item.subitems && item.subitems.length > 0 ? (openBlock(), createElementBlock("details", _hoisted_1$i, [
              createBaseVNode("summary", _hoisted_2$f, toDisplayString$1(item.label), 1),
              createVNode(_component_Doc, {
                data: item.subitems,
                deps: _ctx.deps + 1
              }, null, 8, ["data", "deps"])
            ])) : (openBlock(), createElementBlock("a", _hoisted_3$c, toDisplayString$1(item.label), 1))
          ]);
        }), 128))
      ], 2);
    };
  }
});
const makeComicBook = ({ entries, loadBlob, getSize }, file2) => {
  const cache2 = /* @__PURE__ */ new Map();
  const urls = /* @__PURE__ */ new Map();
  const load = async (name) => {
    if (cache2.has(name))
      return cache2.get(name);
    const src = URL.createObjectURL(await loadBlob(name));
    const page = URL.createObjectURL(new Blob([`<img src="${src}">`], { type: "text/html" }));
    urls.set(name, [src, page]);
    cache2.set(name, page);
    return page;
  };
  const unload = (name) => {
    urls.get(name)?.forEach?.((url) => URL.revokeObjectURL(url));
    urls.delete(name);
    cache2.delete(name);
  };
  const exts = [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".svg", ".jxl", ".avif"];
  const files = entries.map((entry) => entry.filename).filter((name) => exts.some((ext) => name.endsWith(ext))).sort();
  if (!files.length)
    throw new Error("No supported image files in archive");
  const book2 = {};
  book2.getCover = () => loadBlob(files[0]);
  book2.metadata = { title: file2.name };
  book2.sections = files.map((name) => ({
    id: name,
    load: () => load(name),
    unload: () => unload(name),
    size: getSize(name)
  }));
  book2.toc = files.map((name) => ({ label: name, href: name }));
  book2.rendition = { layout: "pre-paginated" };
  book2.resolveHref = (href) => ({ index: book2.sections.findIndex((s) => s.id === href) });
  book2.splitTOCHref = (href) => [href, null];
  book2.getTOCFragment = (doc2) => doc2.documentElement;
  book2.destroy = () => {
    for (const arr of urls.values())
      for (const url of arr)
        URL.revokeObjectURL(url);
  };
  return book2;
};
const findIndices = (arr, f2) => arr.map((x2, i2, a2) => f2(x2, i2, a2) ? i2 : null).filter((x2) => x2 != null);
const splitAt = (arr, is) => [-1, ...is, arr.length].reduce(
  ({ xs, a: a2 }, b2) => ({ xs: xs?.concat([arr.slice(a2 + 1, b2)]) ?? [], a: b2 }),
  {}
).xs;
const concatArrays = (a2, b2) => a2.slice(0, -1).concat([a2[a2.length - 1].concat(b2[0])]).concat(b2.slice(1));
const isNumber = /\d/;
const isCFI = /^epubcfi\((.*)\)$/;
const escapeCFI = (str) => str.replace(/[\^[\](),;=]/g, "^$&");
const wrap = (x2) => isCFI.test(x2) ? x2 : `epubcfi(${x2})`;
const unwrap = (x2) => x2.match(isCFI)?.[1] ?? x2;
const tokenizer = (str) => {
  const tokens = [];
  let state, escape2, value = "";
  const push = (x2) => (tokens.push(x2), state = null, value = "");
  const cat = (x2) => (value += x2, escape2 = false);
  for (const char of Array.from(str.trim()).concat("")) {
    if (char === "^" && !escape2) {
      escape2 = true;
      continue;
    }
    if (state === "!")
      push(["!"]);
    else if (state === ",")
      push([","]);
    else if (state === "/" || state === ":") {
      if (isNumber.test(char)) {
        cat(char);
        continue;
      } else
        push([state, parseInt(value)]);
    } else if (state === "~") {
      if (isNumber.test(char) || char === ".") {
        cat(char);
        continue;
      } else
        push(["~", parseFloat(value)]);
    } else if (state === "@") {
      if (char === ":") {
        push(["@", parseFloat(value)]);
        state = "@";
        continue;
      }
      if (isNumber.test(char) || char === ".") {
        cat(char);
        continue;
      } else
        push(["@", parseFloat(value)]);
    } else if (state === "[") {
      if (char === ";" && !escape2) {
        push(["[", value]);
        state = ";";
      } else if (char === "," && !escape2) {
        push(["[", value]);
        state = "[";
      } else if (char === "]" && !escape2)
        push(["[", value]);
      else
        cat(char);
      continue;
    } else if (state?.startsWith(";")) {
      if (char === "=" && !escape2) {
        state = `;${value}`;
        value = "";
      } else if (char === ";" && !escape2) {
        push([state, value]);
        state = ";";
      } else if (char === "]" && !escape2)
        push([state, value]);
      else
        cat(char);
      continue;
    }
    if (char === "/" || char === ":" || char === "~" || char === "@" || char === "[" || char === "!" || char === ",")
      state = char;
  }
  return tokens;
};
const findTokens = (tokens, x2) => findIndices(tokens, ([t2]) => t2 === x2);
const parser = (tokens) => {
  const parts = [];
  let state;
  for (const [type, val] of tokens) {
    if (type === "/")
      parts.push({ index: val });
    else {
      const last2 = parts[parts.length - 1];
      if (type === ":")
        last2.offset = val;
      else if (type === "~")
        last2.temporal = val;
      else if (type === "@")
        last2.spatial = (last2.spatial ?? []).concat(val);
      else if (type === ";s")
        last2.side = val;
      else if (type === "[") {
        if (state === "/" && val)
          last2.id = val;
        else {
          last2.text = (last2.text ?? []).concat(val);
          continue;
        }
      }
    }
    state = type;
  }
  return parts;
};
const parserIndir = (tokens) => splitAt(tokens, findTokens(tokens, "!")).map(parser);
const parse = (cfi) => {
  const tokens = tokenizer(unwrap(cfi));
  const commas = findTokens(tokens, ",");
  if (!commas.length)
    return parserIndir(tokens);
  const [parent, start, end] = splitAt(tokens, commas).map(parserIndir);
  return { parent, start, end };
};
const partToString = ({ index, id: id2, offset, temporal, spatial, text, side }) => {
  const param = side ? `;s=${side}` : "";
  return `/${index}` + (id2 ? `[${escapeCFI(id2)}${param}]` : "") + // "CFI expressions [..] SHOULD include an explicit character offset"
  (offset != null && index % 2 ? `:${offset}` : "") + (temporal ? `~${temporal}` : "") + (spatial ? `@${spatial.join(":")}` : "") + (text || !id2 && side ? "[" + (text?.map(escapeCFI)?.join(",") ?? "") + param + "]" : "");
};
const toInnerString = (parsed) => parsed.parent ? [parsed.parent, parsed.start, parsed.end].map(toInnerString).join(",") : parsed.map((parts) => parts.map(partToString).join("")).join("!");
const toString = (parsed) => wrap(toInnerString(parsed));
const collapse = (x2, toEnd) => typeof x2 === "string" ? toString(collapse(parse(x2), toEnd)) : x2.parent ? concatArrays(x2.parent, x2[toEnd ? "end" : "start"]) : x2;
const isTextNode$1 = ({ nodeType }) => nodeType === 3 || nodeType === 4;
const isElementNode = ({ nodeType }) => nodeType === 1;
const getChildNodes = (node, filter) => {
  const nodes = Array.from(node.childNodes).filter((node2) => isTextNode$1(node2) || isElementNode(node2));
  return filter ? nodes.map((node2) => {
    const accept = filter(node2);
    if (accept === NodeFilter.FILTER_REJECT)
      return null;
    else if (accept === NodeFilter.FILTER_SKIP)
      return getChildNodes(node2, filter);
    else
      return node2;
  }).flat().filter((x2) => x2) : nodes;
};
const indexChildNodes = (node, filter) => {
  const nodes = getChildNodes(node, filter).reduce((arr, node2) => {
    let last2 = arr[arr.length - 1];
    if (!last2)
      arr.push(node2);
    else if (isTextNode$1(node2)) {
      if (Array.isArray(last2))
        last2.push(node2);
      else if (isTextNode$1(last2))
        arr[arr.length - 1] = [last2, node2];
      else
        arr.push(node2);
    } else {
      if (isElementNode(last2))
        arr.push(null, node2);
      else
        arr.push(node2);
    }
    return arr;
  }, []);
  if (isElementNode(nodes[0]))
    nodes.unshift("first");
  if (isElementNode(nodes[nodes.length - 1]))
    nodes.push("last");
  nodes.unshift("before");
  nodes.push("after");
  return nodes;
};
const partsToNode = (node, parts, filter) => {
  const { id: id2 } = parts[parts.length - 1];
  if (id2) {
    const el = node.ownerDocument.getElementById(id2);
    if (el)
      return { node: el, offset: 0 };
  }
  for (const { index } of parts) {
    const newNode = node ? indexChildNodes(node, filter)[index] : null;
    if (newNode === "first")
      return { node: node.firstChild ?? node };
    if (newNode === "last")
      return { node: node.lastChild ?? node };
    if (newNode === "before")
      return { node, before: true };
    if (newNode === "after")
      return { node, after: true };
    node = newNode;
  }
  const { offset } = parts[parts.length - 1];
  if (!Array.isArray(node))
    return { node, offset };
  let sum = 0;
  for (const n2 of node) {
    const { length } = n2.nodeValue;
    if (sum + length >= offset)
      return { node: n2, offset: offset - sum };
    sum += length;
  }
};
const nodeToParts = (node, offset, filter) => {
  const { parentNode, id: id2 } = node;
  const indexed = indexChildNodes(parentNode, filter);
  const index = indexed.findIndex(
    (x2) => Array.isArray(x2) ? x2.some((x3) => x3 === node) : x2 === node
  );
  const chunk = indexed[index];
  if (Array.isArray(chunk)) {
    let sum = 0;
    for (const x2 of chunk) {
      if (x2 === node) {
        sum += offset;
        break;
      } else
        sum += x2.nodeValue.length;
    }
    offset = sum;
  }
  const part = { id: id2, index, offset };
  return (parentNode !== node.ownerDocument.documentElement ? nodeToParts(parentNode, null, filter).concat(part) : [part]).filter((x2) => x2.index !== -1);
};
const toRange = (doc2, parts, filter) => {
  const startParts = collapse(parts);
  const endParts = collapse(parts, true);
  const root = doc2.documentElement;
  const start = partsToNode(root, startParts[0], filter);
  const end = partsToNode(root, endParts[0], filter);
  const range = doc2.createRange();
  if (start.before)
    range.setStartBefore(start.node);
  else if (start.after)
    range.setStartAfter(start.node);
  else
    range.setStart(start.node, start.offset);
  if (end.before)
    range.setEndBefore(end.node);
  else if (end.after)
    range.setEndAfter(end.node);
  else
    range.setEnd(end.node, end.offset);
  return range;
};
const fromElements = (elements) => {
  const results = [];
  const { parentNode } = elements[0];
  const parts = nodeToParts(parentNode);
  for (const [index, node] of indexChildNodes(parentNode).entries()) {
    const el = elements[results.length];
    if (node === el)
      results.push(toString([parts.concat({ id: el.id, index })]));
  }
  return results;
};
const toElement = (doc2, parts) => partsToNode(doc2.documentElement, collapse(parts)).node;
const fake = {
  fromIndex: (index) => wrap(`/6/${(index + 1) * 2}`),
  toIndex: (parts) => parts?.at(-1).index / 2 - 1
};
const NS$1 = {
  CONTAINER: "urn:oasis:names:tc:opendocument:xmlns:container",
  XHTML: "http://www.w3.org/1999/xhtml",
  OPF: "http://www.idpf.org/2007/opf",
  EPUB: "http://www.idpf.org/2007/ops",
  DC: "http://purl.org/dc/elements/1.1/",
  DCTERMS: "http://purl.org/dc/terms/",
  ENC: "http://www.w3.org/2001/04/xmlenc#",
  NCX: "http://www.daisy.org/z3986/2005/ncx/",
  XLINK: "http://www.w3.org/1999/xlink",
  SMIL: "http://www.w3.org/ns/SMIL"
};
const MIME$2 = {
  XML: "application/xml",
  NCX: "application/x-dtbncx+xml",
  XHTML: "application/xhtml+xml",
  HTML: "text/html",
  CSS: "text/css",
  SVG: "image/svg+xml",
  JS: /\/(x-)?(javascript|ecmascript)/
};
const camel = (x2) => x2.toLowerCase().replace(/[-:](.)/g, (_2, g2) => g2.toUpperCase());
const normalizeWhitespace$1 = (str) => str ? str.replace(/[\t\n\f\r ]+/g, " ").replace(/^[\t\n\f\r ]+/, "").replace(/[\t\n\f\r ]+$/, "") : "";
const filterAttribute = (attr, value, isList) => isList ? (el) => el.getAttribute(attr)?.split(/\s/)?.includes(value) : typeof value === "function" ? (el) => value(el.getAttribute(attr)) : (el) => el.getAttribute(attr) === value;
const getAttributes = (...xs) => (el) => el ? Object.fromEntries(xs.map((x2) => [camel(x2), el.getAttribute(x2)])) : null;
const getElementText$1 = (el) => normalizeWhitespace$1(el?.textContent);
const childGetter = (doc2, ns) => {
  const useNS = doc2.lookupNamespaceURI(null) === ns || doc2.lookupPrefix(ns);
  const f2 = useNS ? (el, name) => (el2) => el2.namespaceURI === ns && el2.localName === name : (el, name) => (el2) => el2.localName === name;
  return {
    $: (el, name) => [...el.children].find(f2(el, name)),
    $$: (el, name) => [...el.children].filter(f2(el, name)),
    $$$: useNS ? (el, name) => [...el.getElementsByTagNameNS(ns, name)] : (el, name) => [...el.getElementsByTagName(name)]
  };
};
const resolveURL = (url, relativeTo) => {
  try {
    if (relativeTo.includes(":"))
      return new URL(url, relativeTo);
    const root = "https://invalid.invalid/";
    const obj = new URL(url, root + relativeTo);
    obj.search = "";
    return decodeURI(obj.href.replace(root, ""));
  } catch (e2) {
    console.warn(e2);
    return url;
  }
};
const isExternal$1 = (uri) => /^(?!blob)\w+:/i.test(uri);
const pathRelative = (from2, to) => {
  if (!from2)
    return to;
  const as = from2.replace(/\/$/, "").split("/");
  const bs = to.replace(/\/$/, "").split("/");
  const i2 = (as.length > bs.length ? as : bs).findIndex((_2, i3) => as[i3] !== bs[i3]);
  return i2 < 0 ? "" : Array(as.length - i2).fill("..").concat(bs.slice(i2)).join("/");
};
const pathDirname = (str) => str.slice(0, str.lastIndexOf("/") + 1);
const replaceSeries$1 = async (str, regex, f2) => {
  const matches = [];
  str.replace(regex, (...args) => (matches.push(args), null));
  const results = [];
  for (const args of matches)
    results.push(await f2(...args));
  return str.replace(regex, () => results.shift());
};
const regexEscape = (str) => str.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
const LANGS = { attrs: ["dir", "xml:lang"] };
const ALTS = { name: "alternate-script", many: true, ...LANGS, props: ["file-as"] };
const CONTRIB = {
  many: true,
  ...LANGS,
  props: [{ name: "role", many: true, attrs: ["scheme"] }, "file-as", ALTS],
  setLegacyAttrs: (obj, el) => {
    if (!obj.role?.length) {
      const value = el.getAttributeNS(NS$1.OPF, "role");
      if (value)
        obj.role = [{ value }];
    }
    obj.fileAs ??= el.getAttributeNS(NS$1.OPF, "file-as");
  }
};
const METADATA = [
  {
    name: "title",
    many: true,
    ...LANGS,
    props: ["title-type", "display-seq", "file-as", ALTS]
  },
  {
    name: "identifier",
    many: true,
    props: [{ name: "identifier-type", attrs: ["scheme"] }],
    setLegacyAttrs: (obj, el) => {
      if (!obj.identifierType) {
        const value = el.getAttributeNS(NS$1.OPF, "scheme");
        if (value)
          obj.identifierType = { value };
      }
    }
  },
  { name: "language", many: true },
  { name: "creator", ...CONTRIB },
  { name: "contributor", ...CONTRIB },
  { name: "publisher", ...LANGS, props: ["file-as", ALTS] },
  { name: "description", ...LANGS, props: [ALTS] },
  { name: "rights", ...LANGS, props: [ALTS] },
  { name: "date" },
  { name: "dcterms:modified", type: "meta" },
  {
    name: "subject",
    many: true,
    ...LANGS,
    props: ["term", "authority", ALTS],
    setLegacyAttrs: (obj, el) => {
      obj.term ??= el.getAttributeNS(NS$1.OPF, "term");
      obj.authority ??= el.getAttributeNS(NS$1.OPF, "authority");
    }
  },
  { name: "source", many: true },
  {
    name: "belongs-to-collection",
    type: "meta",
    many: true,
    ...LANGS,
    props: [
      "collection-type",
      "group-position",
      "dcterms:identifier",
      "file-as",
      ALTS,
      { name: "belongs-to-collection", recursive: true }
    ]
  }
];
const getMetadata = (opf) => {
  const { $: $2, $$: $$2 } = childGetter(opf, NS$1.OPF);
  const $metadata = $2(opf.documentElement, "metadata");
  const els = Array.from($metadata.children);
  const getValue2 = (obj, el) => {
    if (!el)
      return null;
    const { props = [], attrs = [] } = obj;
    const value = getElementText$1(el);
    if (!props.length && !attrs.length)
      return value;
    const id2 = el.getAttribute("id");
    const refines = id2 ? els.filter(filterAttribute("refines", "#" + id2)) : [];
    const result = Object.fromEntries(
      [["value", value]].concat(
        props.map((prop) => {
          const { many, recursive } = prop;
          const name = typeof prop === "string" ? prop : prop.name;
          const filter = filterAttribute("property", name);
          const subobj = recursive ? obj : prop;
          return [
            camel(name),
            many ? refines.filter(filter).map((el2) => getValue2(subobj, el2)) : getValue2(subobj, refines.find(filter))
          ];
        })
      ).concat(attrs.map((attr) => [camel(attr), el.getAttribute(attr)]))
    );
    obj.setLegacyAttrs?.(result, el);
    return result;
  };
  const arr = els.filter(filterAttribute("refines", null));
  const metadata = Object.fromEntries(
    METADATA.map((obj) => {
      const { type, name, many } = obj;
      const filter = type === "meta" ? (el) => el.namespaceURI === NS$1.OPF && el.getAttribute("property") === name : (el) => el.namespaceURI === NS$1.DC && el.localName === name;
      return [
        camel(name),
        many ? arr.filter(filter).map((el) => getValue2(obj, el)) : getValue2(obj, arr.find(filter))
      ];
    })
  );
  const $$meta = $$2($metadata, "meta");
  const getMetasByPrefix = (prefix) => $$meta.filter(filterAttribute("property", (x2) => x2?.startsWith(prefix))).map((el) => [el.getAttribute("property").replace(prefix, ""), el]);
  const rendition = Object.fromEntries(
    getMetasByPrefix("rendition:").map(([k2, el]) => [k2, getElementText$1(el)])
  );
  const media = { narrator: [], duration: {} };
  for (const [k2, el] of getMetasByPrefix("media:")) {
    const v2 = getElementText$1(el);
    if (k2 === "duration")
      media.duration[el.getAttribute("refines")?.split("#")?.[1] ?? ""] = parseClock(v2);
    else if (k2 === "active-class")
      media.activeClass = v2;
    else if (k2 === "narrator")
      media.narrator.push(v2);
    else if (k2 === "playback-active-class")
      media.playbackActiveClass = v2;
  }
  return { metadata, rendition, media };
};
const parseNav = (doc2, resolve2 = (f2) => f2) => {
  const { $: $2, $$: $$2, $$$ } = childGetter(doc2, NS$1.XHTML);
  const resolveHref = (href) => href ? decodeURI(resolve2(href)) : null;
  const parseLI = (getType2) => ($li) => {
    const $a = $2($li, "a") ?? $2($li, "span");
    const $ol = $2($li, "ol");
    const href = resolveHref($a?.getAttribute("href"));
    const label = getElementText$1($a) || $a?.getAttribute("title");
    const result = { label, href, subitems: parseOL($ol) };
    if (getType2)
      result.type = $a?.getAttributeNS(NS$1.EPUB, "type")?.split(/\s/);
    return result;
  };
  const parseOL = ($ol, getType2) => $ol ? $$2($ol, "li").map(parseLI(getType2)) : null;
  const parseNav2 = ($nav, getType2) => parseOL($2($nav, "ol"), getType2);
  const $$nav = $$$(doc2, "nav");
  let toc = null, pageList = null, landmarks = null, others = [];
  for (const $nav of $$nav) {
    const type = $nav.getAttributeNS(NS$1.EPUB, "type")?.split(/\s/) ?? [];
    if (type.includes("toc"))
      toc ??= parseNav2($nav);
    else if (type.includes("page-list"))
      pageList ??= parseNav2($nav);
    else if (type.includes("landmarks"))
      landmarks ??= parseNav2($nav, true);
    else
      others.push({
        label: getElementText$1($nav.firstElementChild),
        type,
        list: parseNav2($nav)
      });
  }
  return { toc, pageList, landmarks, others };
};
const parseNCX = (doc2, resolve2 = (f2) => f2) => {
  const { $: $2, $$: $$2 } = childGetter(doc2, NS$1.NCX);
  const resolveHref = (href) => href ? decodeURI(resolve2(href)) : null;
  const parseItem = (el) => {
    const $label = $2(el, "navLabel");
    const $content = $2(el, "content");
    const label = getElementText$1($label);
    const href = resolveHref($content.getAttribute("src"));
    if (el.localName === "navPoint") {
      const els = $$2(el, "navPoint");
      return { label, href, subitems: els.length ? els.map(parseItem) : null };
    }
    return { label, href };
  };
  const parseList = (el, itemName) => $$2(el, itemName).map(parseItem);
  const getSingle = (container, itemName) => {
    const $container = $2(doc2.documentElement, container);
    return $container ? parseList($container, itemName) : null;
  };
  return {
    toc: getSingle("navMap", "navPoint"),
    pageList: getSingle("pageList", "pageTarget"),
    others: $$2(doc2.documentElement, "navList").map((el) => ({
      label: getElementText$1($2(el, "navLabel")),
      list: parseList(el, "navTarget")
    }))
  };
};
const parseClock = (str) => {
  if (!str)
    return;
  const parts = str.split(":").map((x3) => parseFloat(x3));
  if (parts.length === 3) {
    const [h2, m2, s] = parts;
    return h2 * 60 * 60 + m2 * 60 + s;
  }
  if (parts.length === 2) {
    const [m2, s] = parts;
    return m2 * 60 + s;
  }
  const [x2, unit] = str.split(/(?=[^\d.])/);
  const n2 = parseFloat(x2);
  const f2 = unit === "h" ? 60 * 60 : unit === "min" ? 60 : unit === "ms" ? 1e-3 : 1;
  return n2 * f2;
};
class MediaOverlay extends EventTarget {
  #entries;
  #lastMediaOverlayItem;
  #sectionIndex;
  #audioIndex;
  #itemIndex;
  #audio;
  #volume = 1;
  #rate = 1;
  constructor(book2, loadXML) {
    super();
    this.book = book2;
    this.loadXML = loadXML;
  }
  async #loadSMIL(item) {
    if (this.#lastMediaOverlayItem === item)
      return;
    const doc2 = await this.loadXML(item.href);
    const resolve2 = (href) => href ? resolveURL(href, item.href) : null;
    const { $: $2, $$$ } = childGetter(doc2, NS$1.SMIL);
    this.#audioIndex = -1;
    this.#itemIndex = -1;
    this.#entries = $$$(doc2, "par").reduce((arr, $par) => {
      const text = resolve2($2($par, "text")?.getAttribute("src"));
      const $audio = $2($par, "audio");
      if (!text || !$audio)
        return arr;
      const src = resolve2($audio.getAttribute("src"));
      const begin = parseClock($audio.getAttribute("clipBegin"));
      const end = parseClock($audio.getAttribute("clipEnd"));
      const last2 = arr.at(-1);
      if (last2?.src === src)
        last2.items.push({ text, begin, end });
      else
        arr.push({ src, items: [{ text, begin, end }] });
      return arr;
    }, []);
    this.#lastMediaOverlayItem = item;
  }
  get #activeAudio() {
    return this.#entries[this.#audioIndex];
  }
  get #activeItem() {
    return this.#activeAudio?.items?.[this.#itemIndex];
  }
  #error(e2) {
    console.error(e2);
    this.dispatchEvent(new CustomEvent("error", { detail: e2 }));
  }
  #highlight() {
    this.dispatchEvent(new CustomEvent("highlight", { detail: this.#activeItem }));
  }
  #unhighlight() {
    this.dispatchEvent(new CustomEvent("unhighlight", { detail: this.#activeItem }));
  }
  async #play(audioIndex, itemIndex) {
    if (this.#audio) {
      this.#audio.pause();
      URL.revokeObjectURL(this.#audio.src);
      this.#audio = null;
    }
    this.#audioIndex = audioIndex;
    this.#itemIndex = itemIndex;
    const src = this.#activeAudio?.src;
    if (!src || !this.#activeItem)
      return this.start(this.#sectionIndex + 1);
    const url = URL.createObjectURL(await this.book.loadBlob(src));
    const audio = new Audio(url);
    this.#audio = audio;
    audio.addEventListener("timeupdate", () => {
      if (audio.paused)
        return;
      const t2 = audio.currentTime;
      const { items } = this.#activeAudio;
      if (t2 > this.#activeItem?.end) {
        this.#unhighlight();
        if (this.#itemIndex === items.length - 1) {
          this.#play(this.#audioIndex + 1, 0).catch((e2) => this.#error(e2));
          return;
        }
      }
      const oldIndex = this.#itemIndex;
      while (items[this.#itemIndex + 1]?.begin <= t2)
        this.#itemIndex++;
      if (this.#itemIndex !== oldIndex)
        this.#highlight();
    });
    audio.addEventListener("error", () => this.#error(new Error(`Failed to load ${src}`)));
    audio.addEventListener("playing", () => this.#highlight());
    audio.addEventListener("pause", () => this.#unhighlight());
    audio.addEventListener("ended", () => {
      this.#unhighlight();
      URL.revokeObjectURL(url);
      this.#audio = null;
      this.#play(audioIndex + 1, 0).catch((e2) => this.#error(e2));
    });
    audio.addEventListener("canplaythrough", () => {
      audio.currentTime = this.#activeItem.begin ?? 0;
      audio.volume = this.#volume;
      audio.playbackRate = this.#rate;
      audio.play().catch((e2) => this.#error(e2));
    });
  }
  async start(sectionIndex, filter = () => true) {
    this.#audio?.pause();
    const section = this.book.sections[sectionIndex];
    const href = section?.id;
    if (!href)
      return;
    const { mediaOverlay } = section;
    if (!mediaOverlay)
      return this.start(sectionIndex + 1);
    this.#sectionIndex = sectionIndex;
    await this.#loadSMIL(mediaOverlay);
    for (let i2 = 0; i2 < this.#entries.length; i2++) {
      const { items } = this.#entries[i2];
      for (let j = 0; j < items.length; j++) {
        if (items[j].text.split("#")[0] === href && filter(items[j], j, items))
          return this.#play(i2, j).catch((e2) => this.#error(e2));
      }
    }
  }
  pause() {
    this.#audio?.pause();
  }
  resume() {
    this.#audio?.play().catch((e2) => this.#error(e2));
  }
  prev() {
    if (this.#itemIndex > 0)
      this.#play(this.#audioIndex, this.#itemIndex - 1);
    else if (this.#audioIndex > 0)
      this.#play(this.#audioIndex - 1, this.#entries[this.#audioIndex - 1].items.length - 1);
    else if (this.#sectionIndex > 0)
      this.start(this.#sectionIndex - 1, (_2, i2, items) => i2 === items.length - 1);
  }
  next() {
    this.#play(this.#audioIndex, this.#itemIndex + 1);
  }
  setVolume(volume) {
    this.#volume = volume;
    if (this.#audio)
      this.#audio.volume = volume;
  }
  setRate(rate) {
    this.#rate = rate;
    if (this.#audio)
      this.#audio.playbackRate = rate;
  }
}
const isUUID = /([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})/;
const getUUID = (opf) => {
  for (const el of opf.getElementsByTagNameNS(NS$1.DC, "identifier")) {
    const [id2] = getElementText$1(el).split(":").slice(-1);
    if (isUUID.test(id2))
      return id2;
  }
  return "";
};
const getIdentifier = (opf) => getElementText$1(
  opf.getElementById(opf.documentElement.getAttribute("unique-identifier")) ?? opf.getElementsByTagNameNS(NS$1.DC, "identifier")[0]
);
const deobfuscate = async (key, length, blob) => {
  const array = new Uint8Array(await blob.slice(0, length).arrayBuffer());
  length = Math.min(length, array.length);
  for (var i2 = 0; i2 < length; i2++)
    array[i2] = array[i2] ^ key[i2 % key.length];
  return new Blob([array, blob.slice(length)], { type: blob.type });
};
const WebCryptoSHA1 = async (str) => {
  const data2 = new TextEncoder().encode(str);
  const buffer = await globalThis.crypto.subtle.digest("SHA-1", data2);
  return new Uint8Array(buffer);
};
const deobfuscators = (sha1 = WebCryptoSHA1) => ({
  "http://www.idpf.org/2008/embedding": {
    key: (opf) => sha1(
      getIdentifier(opf).replaceAll(/[\u0020\u0009\u000d\u000a]/g, "")
    ),
    decode: (key, blob) => deobfuscate(key, 1040, blob)
  },
  "http://ns.adobe.com/pdf/enc#RC": {
    key: (opf) => {
      const uuid = getUUID(opf).replaceAll("-", "");
      return Uint8Array.from({ length: 16 }, (_2, i2) => parseInt(uuid.slice(i2 * 2, i2 * 2 + 2), 16));
    },
    decode: (key, blob) => deobfuscate(key, 1024, blob)
  }
});
class Encryption {
  #uris = /* @__PURE__ */ new Map();
  #decoders = /* @__PURE__ */ new Map();
  #algorithms;
  constructor(algorithms) {
    this.#algorithms = algorithms;
  }
  async init(encryption, opf) {
    if (!encryption)
      return;
    const data2 = Array.from(encryption.getElementsByTagNameNS(NS$1.ENC, "EncryptedData"), (el) => ({
      algorithm: el.getElementsByTagNameNS(NS$1.ENC, "EncryptionMethod")[0]?.getAttribute("Algorithm"),
      uri: el.getElementsByTagNameNS(NS$1.ENC, "CipherReference")[0]?.getAttribute("URI")
    }));
    for (const { algorithm, uri } of data2) {
      if (!this.#decoders.has(algorithm)) {
        const algo = this.#algorithms[algorithm];
        if (!algo) {
          console.warn("Unknown encryption algorithm");
          continue;
        }
        const key = await algo.key(opf);
        this.#decoders.set(algorithm, (blob) => algo.decode(key, blob));
      }
      this.#uris.set(uri, algorithm);
    }
  }
  getDecoder(uri) {
    return this.#decoders.get(this.#uris.get(uri)) ?? ((x2) => x2);
  }
}
class Resources {
  constructor({ opf, resolveHref }) {
    this.opf = opf;
    const { $: $2, $$: $$2, $$$ } = childGetter(opf, NS$1.OPF);
    const $manifest = $2(opf.documentElement, "manifest");
    const $spine = $2(opf.documentElement, "spine");
    const $$itemref = $$2($spine, "itemref");
    this.manifest = $$2($manifest, "item").map(getAttributes("href", "id", "media-type", "properties", "media-overlay")).map((item) => {
      item.href = resolveHref(item.href);
      item.properties = item.properties?.split(/\s/);
      return item;
    });
    this.spine = $$itemref.map(getAttributes("idref", "id", "linear", "properties")).map((item) => (item.properties = item.properties?.split(/\s/), item));
    this.pageProgressionDirection = $spine.getAttribute("page-progression-direction");
    this.navPath = this.getItemByProperty("nav")?.href;
    this.ncxPath = (this.getItemByID($spine.getAttribute("toc")) ?? this.manifest.find((item) => item.mediaType === MIME$2.NCX))?.href;
    const $guide = $2(opf.documentElement, "guide");
    if ($guide)
      this.guide = $$2($guide, "reference").map(getAttributes("type", "title", "href")).map(({ type, title, href }) => ({
        label: title,
        type: type.split(/\s/),
        href: resolveHref(href)
      }));
    this.cover = this.getItemByProperty("cover-image") ?? // EPUB 2 compat
    this.getItemByID(
      $$$(opf, "meta").find(filterAttribute("name", "cover"))?.getAttribute("content")
    ) ?? this.getItemByHref(this.guide?.find((ref2) => ref2.type.includes("cover"))?.href);
    this.cfis = fromElements($$itemref);
  }
  getItemByID(id2) {
    return this.manifest.find((item) => item.id === id2);
  }
  getItemByHref(href) {
    return this.manifest.find((item) => item.href === href);
  }
  getItemByProperty(prop) {
    return this.manifest.find((item) => item.properties?.includes(prop));
  }
  resolveCFI(cfi) {
    const parts = parse(cfi);
    const top = (parts.parent ?? parts).shift();
    let $itemref = toElement(this.opf, top);
    if ($itemref && $itemref.nodeName !== "idref") {
      top.at(-1).id = null;
      $itemref = toElement(this.opf, top);
    }
    const idref = $itemref?.getAttribute("idref");
    const index = this.spine.findIndex((item) => item.idref === idref);
    const anchor = (doc2) => toRange(doc2, parts);
    return { index, anchor };
  }
}
class Loader {
  #cache = /* @__PURE__ */ new Map();
  #children = /* @__PURE__ */ new Map();
  #refCount = /* @__PURE__ */ new Map();
  allowScript = false;
  constructor({ loadText, loadBlob, resources }) {
    this.loadText = loadText;
    this.loadBlob = loadBlob;
    this.manifest = resources.manifest;
    this.assets = resources.manifest;
  }
  createURL(href, data2, type, parent) {
    if (!data2)
      return "";
    const url = URL.createObjectURL(new Blob([data2], { type }));
    this.#cache.set(href, url);
    this.#refCount.set(href, 1);
    if (parent) {
      const childList = this.#children.get(parent);
      if (childList)
        childList.push(href);
      else
        this.#children.set(parent, [href]);
    }
    return url;
  }
  ref(href, parent) {
    const childList = this.#children.get(parent);
    if (!childList?.includes(href)) {
      this.#refCount.set(href, this.#refCount.get(href) + 1);
      if (childList)
        childList.push(href);
      else
        this.#children.set(parent, [href]);
    }
    return this.#cache.get(href);
  }
  unref(href) {
    if (!this.#refCount.has(href))
      return;
    const count = this.#refCount.get(href) - 1;
    if (count < 1) {
      URL.revokeObjectURL(this.#cache.get(href));
      this.#cache.delete(href);
      this.#refCount.delete(href);
      const childList = this.#children.get(href);
      if (childList)
        while (childList.length)
          this.unref(childList.pop());
      this.#children.delete(href);
    } else
      this.#refCount.set(href, count);
  }
  // load manifest item, recursively loading all resources as needed
  async loadItem(item, parents = []) {
    if (!item)
      return null;
    const { href, mediaType } = item;
    const isScript = MIME$2.JS.test(item.mediaType);
    if (isScript && !this.allowScript)
      return null;
    const parent = parents.at(-1);
    if (this.#cache.has(href))
      return this.ref(href, parent);
    const shouldReplace = (isScript || [MIME$2.XHTML, MIME$2.HTML, MIME$2.CSS, MIME$2.SVG].includes(mediaType)) && // prevent circular references
    parents.every((p2) => p2 !== href);
    if (shouldReplace)
      return this.loadReplaced(item, parents);
    return this.createURL(href, await this.loadBlob(href), mediaType, parent);
  }
  async loadHref(href, base, parents = []) {
    if (isExternal$1(href))
      return href;
    const path = resolveURL(href, base);
    const item = this.manifest.find((item2) => item2.href === path);
    if (!item)
      return href;
    return this.loadItem(item, parents.concat(base));
  }
  async loadReplaced(item, parents = []) {
    const { href, mediaType } = item;
    const parent = parents.at(-1);
    const str = await this.loadText(href);
    if (!str)
      return null;
    if ([MIME$2.XHTML, MIME$2.HTML, MIME$2.SVG].includes(mediaType)) {
      let doc2 = new DOMParser().parseFromString(str, mediaType);
      if (mediaType === MIME$2.XHTML && doc2.querySelector("parsererror")) {
        console.warn(doc2.querySelector("parsererror").innerText);
        item.mediaType = MIME$2.HTML;
        doc2 = new DOMParser().parseFromString(str, item.mediaType);
      }
      if ([MIME$2.XHTML, MIME$2.SVG].includes(item.mediaType)) {
        let child = doc2.firstChild;
        while (child instanceof ProcessingInstruction) {
          if (child.data) {
            const replacedData = await replaceSeries$1(
              child.data,
              /(?:^|\s*)(href\s*=\s*['"])([^'"]*)(['"])/i,
              (_2, p1, p2, p3) => this.loadHref(p2, href, parents).then((p22) => `${p1}${p22}${p3}`)
            );
            child.replaceWith(doc2.createProcessingInstruction(child.target, replacedData));
          }
          child = child.nextSibling;
        }
      }
      const replace = async (el, attr) => el.setAttribute(attr, await this.loadHref(el.getAttribute(attr), href, parents));
      for (const el of doc2.querySelectorAll("link[href]"))
        await replace(el, "href");
      for (const el of doc2.querySelectorAll("[src]"))
        await replace(el, "src");
      for (const el of doc2.querySelectorAll("[poster]"))
        await replace(el, "poster");
      for (const el of doc2.querySelectorAll("object[data]"))
        await replace(el, "data");
      for (const el of doc2.querySelectorAll("[*|href]:not([href]"))
        el.setAttributeNS(
          NS$1.XLINK,
          "href",
          await this.loadHref(el.getAttributeNS(NS$1.XLINK, "href"), href, parents)
        );
      for (const el of doc2.querySelectorAll("style"))
        if (el.textContent)
          el.textContent = await this.replaceCSS(el.textContent, href, parents);
      for (const el of doc2.querySelectorAll("[style]"))
        el.setAttribute("style", await this.replaceCSS(el.getAttribute("style"), href, parents));
      const result2 = new XMLSerializer().serializeToString(doc2);
      return this.createURL(href, result2, item.mediaType, parent);
    }
    const result = mediaType === MIME$2.CSS ? await this.replaceCSS(str, href, parents) : await this.replaceString(str, href, parents);
    return this.createURL(href, result, mediaType, parent);
  }
  async replaceCSS(str, href, parents = []) {
    const replacedUrls = await replaceSeries$1(
      str,
      /url\(\s*["']?([^'"\n]*?)\s*["']?\s*\)/gi,
      (_2, url) => this.loadHref(url, href, parents).then((url2) => `url("${url2}")`)
    );
    const replacedImports = await replaceSeries$1(
      replacedUrls,
      /@import\s*["']([^"'\n]*?)["']/gi,
      (_2, url) => this.loadHref(url, href, parents).then((url2) => `@import "${url2}"`)
    );
    const w2 = window?.innerWidth ?? 800;
    const h2 = window?.innerHeight ?? 600;
    return replacedImports.replace(/(?<=[{\s;])-epub-/gi, "").replace(/(\d*\.?\d+)vw/gi, (_2, d) => parseFloat(d) * w2 / 100 + "px").replace(/(\d*\.?\d+)vh/gi, (_2, d) => parseFloat(d) * h2 / 100 + "px").replace(/page-break-(after|before|inside)\s*:/gi, (_2, x2) => `-webkit-column-break-${x2}:`).replace(
      /break-(after|before|inside)\s*:\s*(avoid-)?page/gi,
      (_2, x2, y2) => `break-${x2}: ${y2 ?? ""}column`
    );
  }
  // find & replace all possible relative paths for all assets without parsing
  replaceString(str, href, parents = []) {
    const assetMap = /* @__PURE__ */ new Map();
    const urls = this.assets.map((asset) => {
      if (asset.href === href)
        return;
      const relative = pathRelative(pathDirname(href), asset.href);
      const relativeEnc = encodeURI(relative);
      const rootRelative = "/" + asset.href;
      const rootRelativeEnc = encodeURI(rootRelative);
      const set2 = /* @__PURE__ */ new Set([relative, relativeEnc, rootRelative, rootRelativeEnc]);
      for (const url of set2)
        assetMap.set(url, asset);
      return Array.from(set2);
    }).flat().filter((x2) => x2);
    if (!urls.length)
      return str;
    const regex = new RegExp(urls.map(regexEscape).join("|"), "g");
    return replaceSeries$1(
      str,
      regex,
      async (match2) => this.loadItem(assetMap.get(match2.replace(/^\//, "")), parents.concat(href))
    );
  }
  unloadItem(item) {
    this.unref(item?.href);
  }
  destroy() {
    for (const url of this.#cache.values())
      URL.revokeObjectURL(url);
  }
}
const getHTMLFragment = (doc2, id2) => doc2.getElementById(id2) ?? doc2.querySelector(`[name="${CSS.escape(id2)}"]`);
const getPageSpread$1 = (properties) => {
  for (const p2 of properties) {
    if (p2 === "page-spread-left" || p2 === "rendition:page-spread-left")
      return "left";
    if (p2 === "page-spread-right" || p2 === "rendition:page-spread-right")
      return "right";
    if (p2 === "rendition:page-spread-center")
      return "center";
  }
};
class EPUB {
  parser = new DOMParser();
  #loader;
  #encryption;
  constructor({ loadText, loadBlob, getSize, sha1 }) {
    this.loadText = loadText;
    this.loadBlob = loadBlob;
    this.getSize = getSize;
    this.#encryption = new Encryption(deobfuscators(sha1));
  }
  async #loadXML(uri) {
    const str = await this.loadText(uri);
    if (!str)
      return null;
    const doc2 = this.parser.parseFromString(str, MIME$2.XML);
    if (doc2.querySelector("parsererror"))
      throw new Error(`XML parsing error: ${uri}
${doc2.querySelector("parsererror").innerText}`);
    return doc2;
  }
  async init() {
    const $container = await this.#loadXML("META-INF/container.xml");
    if (!$container)
      throw new Error("Failed to load container file");
    const opfs = Array.from(
      $container.getElementsByTagNameNS(NS$1.CONTAINER, "rootfile"),
      getAttributes("full-path", "media-type")
    ).filter((file2) => file2.mediaType === "application/oebps-package+xml");
    if (!opfs.length)
      throw new Error("No package document defined in container");
    const opfPath = opfs[0].fullPath;
    const opf = await this.#loadXML(opfPath);
    if (!opf)
      throw new Error("Failed to load package document");
    const $encryption = await this.#loadXML("META-INF/encryption.xml");
    await this.#encryption.init($encryption, opf);
    this.resources = new Resources({
      opf,
      resolveHref: (url) => resolveURL(url, opfPath)
    });
    this.#loader = new Loader({
      loadText: this.loadText,
      loadBlob: (uri) => Promise.resolve(this.loadBlob(uri)).then(this.#encryption.getDecoder(uri)),
      resources: this.resources
    });
    this.sections = this.resources.spine.map((spineItem, index) => {
      const { idref, linear, properties = [] } = spineItem;
      const item = this.resources.getItemByID(idref);
      if (!item) {
        console.warn(`Could not find item with ID "${idref}" in manifest`);
        return null;
      }
      return {
        id: item.href,
        load: () => this.#loader.loadItem(item),
        unload: () => this.#loader.unloadItem(item),
        createDocument: () => this.loadDocument(item),
        size: this.getSize(item.href),
        cfi: this.resources.cfis[index],
        linear,
        pageSpread: getPageSpread$1(properties),
        resolveHref: (href) => resolveURL(href, item.href),
        mediaOverlay: item.mediaOverlay ? this.resources.getItemByID(item.mediaOverlay) : null
      };
    }).filter((s) => s);
    const { navPath, ncxPath } = this.resources;
    if (navPath)
      try {
        const resolve2 = (url) => resolveURL(url, navPath);
        const nav = parseNav(await this.#loadXML(navPath), resolve2);
        this.toc = nav.toc;
        this.pageList = nav.pageList;
        this.landmarks = nav.landmarks;
      } catch (e2) {
        console.warn(e2);
      }
    if (!this.toc && ncxPath)
      try {
        const resolve2 = (url) => resolveURL(url, ncxPath);
        const ncx = parseNCX(await this.#loadXML(ncxPath), resolve2);
        this.toc = ncx.toc;
        this.pageList = ncx.pageList;
      } catch (e2) {
        console.warn(e2);
      }
    this.landmarks ??= this.resources.guide;
    const { metadata, rendition, media } = getMetadata(opf);
    this.rendition = rendition;
    this.media = media;
    this.dir = this.resources.pageProgressionDirection;
    this.parsedMetadata = metadata;
    const title = metadata?.title?.[0];
    this.metadata = {
      title: title?.value,
      subtitle: metadata?.title?.find((x2) => x2.titleType === "subtitle")?.value,
      sortAs: title?.fileAs,
      language: metadata?.language,
      identifier: getIdentifier(opf),
      description: metadata?.description?.value,
      publisher: metadata?.publisher?.value,
      published: metadata?.date,
      modified: metadata?.dctermsModified,
      subject: metadata?.subject?.filter(({ value, term }) => value || term)?.map(({ value, term, authority }) => ({ name: value, code: term, scheme: authority })),
      rights: metadata?.rights?.value
    };
    const relators = {
      art: "artist",
      aut: "author",
      bkp: "producer",
      clr: "colorist",
      edt: "editor",
      ill: "illustrator",
      nrt: "narrator",
      trl: "translator",
      pbl: "publisher"
    };
    const mapContributor = (defaultKey) => (obj) => {
      const keys = [
        ...new Set(
          obj.role?.map(
            ({ value: value2, scheme }) => (!scheme || scheme === "marc:relators" ? relators[value2] : null) ?? defaultKey
          )
        )
      ];
      const value = { name: obj.value, sortAs: obj.fileAs };
      return [keys?.length ? keys : [defaultKey], value];
    };
    metadata?.creator?.map(mapContributor("author"))?.concat(metadata?.contributor?.map?.(mapContributor("contributor")))?.forEach(
      ([keys, value]) => keys.forEach((key) => {
        if (this.metadata[key])
          this.metadata[key].push(value);
        else
          this.metadata[key] = [value];
      })
    );
    return this;
  }
  async loadDocument(item) {
    const str = await this.loadText(item.href);
    return this.parser.parseFromString(str, item.mediaType);
  }
  getMediaOverlay() {
    return new MediaOverlay(this, this.#loadXML.bind(this));
  }
  resolveCFI(cfi) {
    return this.resources.resolveCFI(cfi);
  }
  resolveHref(href) {
    const [path, hash] = href.split("#");
    const item = this.resources.getItemByHref(decodeURI(path));
    if (!item)
      return null;
    const index = this.resources.spine.findIndex(({ idref }) => idref === item.id);
    const anchor = hash ? (doc2) => getHTMLFragment(doc2, hash) : () => 0;
    return { index, anchor };
  }
  splitTOCHref(href) {
    return href?.split("#") ?? [];
  }
  getTOCFragment(doc2, id2) {
    return doc2.getElementById(id2) ?? doc2.querySelector(`[name="${CSS.escape(id2)}"]`);
  }
  isExternal(uri) {
    return isExternal$1(uri);
  }
  async getCover() {
    const cover = this.resources?.cover;
    return cover?.href ? new Blob([await this.loadBlob(cover.href)], { type: cover.mediaType }) : null;
  }
  async getCalibreBookmarks() {
    const txt = await this.loadText("META-INF/calibre_bookmarks.txt");
    const magic = "encoding=json+base64:";
    if (txt?.startsWith(magic)) {
      const json = atob(txt.slice(magic.length));
      return JSON.parse(json);
    }
  }
  destroy() {
    this.#loader?.destroy();
  }
}
const normalizeWhitespace = (str) => str ? str.replace(/[\t\n\f\r ]+/g, " ").replace(/^[\t\n\f\r ]+/, "").replace(/[\t\n\f\r ]+$/, "") : "";
const getElementText = (el) => normalizeWhitespace(el?.textContent);
const NS = {
  XLINK: "http://www.w3.org/1999/xlink",
  EPUB: "http://www.idpf.org/2007/ops"
};
const MIME$1 = {
  XML: "application/xml",
  XHTML: "application/xhtml+xml"
};
const STYLE = {
  strong: ["strong", "self"],
  emphasis: ["em", "self"],
  style: ["span", "self"],
  a: "anchor",
  strikethrough: ["s", "self"],
  sub: ["sub", "self"],
  sup: ["sup", "self"],
  code: ["code", "self"],
  image: "image"
};
const TABLE = {
  tr: ["tr", ["align"]],
  th: ["th", ["colspan", "rowspan", "align", "valign"]],
  td: ["td", ["colspan", "rowspan", "align", "valign"]]
};
const POEM = {
  epigraph: ["blockquote"],
  subtitle: ["h2", STYLE],
  "text-author": ["p", STYLE],
  date: ["p", STYLE],
  stanza: "stanza"
};
const SECTION = {
  title: [
    "header",
    {
      p: ["h1", STYLE],
      "empty-line": ["br"]
    }
  ],
  epigraph: ["blockquote", "self"],
  image: "image",
  annotation: ["aside"],
  section: ["section", "self"],
  p: ["p", STYLE],
  poem: ["blockquote", POEM],
  subtitle: ["h2", STYLE],
  cite: ["blockquote", "self"],
  "empty-line": ["br"],
  table: ["table", TABLE],
  "text-author": ["p", STYLE]
};
POEM["epigraph"].push(SECTION);
const BODY = {
  image: "image",
  title: [
    "section",
    {
      p: ["h1", STYLE],
      "empty-line": ["br"]
    }
  ],
  epigraph: ["section", SECTION],
  section: ["section", SECTION]
};
const getImageSrc = (el) => {
  const href = el.getAttributeNS(NS.XLINK, "href");
  const [, id2] = href.split("#");
  const bin = el.getRootNode().getElementById(id2);
  return bin ? `data:${bin.getAttribute("content-type")};base64,${bin.textContent}` : href;
};
class FB2Converter {
  constructor(fb2) {
    this.fb2 = fb2;
    this.doc = document.implementation.createDocument(NS.XHTML, "html");
  }
  image(node) {
    const el = this.doc.createElement("img");
    el.alt = node.getAttribute("alt");
    el.title = node.getAttribute("title");
    el.setAttribute("src", getImageSrc(node));
    return el;
  }
  anchor(node) {
    const el = this.convert(node, { a: ["a", STYLE] });
    el.setAttribute("href", node.getAttributeNS(NS.XLINK, "href"));
    if (node.getAttribute("type") === "note")
      el.setAttributeNS(NS.EPUB, "epub:type", "noteref");
    return el;
  }
  stanza(node) {
    const el = this.convert(node, {
      stanza: [
        "p",
        {
          title: [
            "header",
            {
              p: ["strong", STYLE],
              "empty-line": ["br"]
            }
          ],
          subtitle: ["p", STYLE]
        }
      ]
    });
    for (const child of node.children)
      if (child.nodeName === "v") {
        el.append(this.doc.createTextNode(child.textContent));
        el.append(this.doc.createElement("br"));
      }
    return el;
  }
  convert(node, def2) {
    if (node.nodeType === 3)
      return this.doc.createTextNode(node.textContent);
    if (node.nodeType === 4)
      return this.doc.createCDATASection(node.textContent);
    if (node.nodeType === 8)
      return this.doc.createComment(node.textContent);
    const d = def2?.[node.nodeName];
    if (!d)
      return null;
    if (typeof d === "string")
      return this[d](node);
    const [name, opts] = d;
    const el = this.doc.createElement(name);
    if (node.id)
      el.id = node.id;
    el.classList.add(node.nodeName);
    if (Array.isArray(opts))
      for (const attr of opts)
        el.setAttribute(attr, node.getAttribute(attr));
    const childDef = opts === "self" ? def2 : Array.isArray(opts) ? null : opts;
    let child = node.firstChild;
    while (child) {
      const childEl = this.convert(child, childDef);
      if (childEl)
        el.append(childEl);
      child = child.nextSibling;
    }
    return el;
  }
}
const parseXML = async (blob) => {
  const buffer = await blob.arrayBuffer();
  const str = new TextDecoder("utf-8").decode(buffer);
  const parser2 = new DOMParser();
  const doc2 = parser2.parseFromString(str, MIME$1.XML);
  const encoding = doc2.xmlEncoding || // `Document.xmlEncoding` is deprecated, and already removed in Firefox
  // so parse the XML declaration manually
  str.match(/^<\?xml\s+version\s*=\s*["']1.\d+"\s+encoding\s*=\s*["']([A-Za-z0-9._-]*)["']/)?.[1];
  if (encoding && encoding.toLowerCase() !== "utf-8") {
    const str2 = new TextDecoder(encoding).decode(buffer);
    return parser2.parseFromString(str2, MIME$1.XML);
  }
  return doc2;
};
const style = URL.createObjectURL(
  new Blob(
    [
      `
@namespace epub "http://www.idpf.org/2007/ops";
body > img, section > img {
    display: block;
    margin: auto;
}
.title h1 {
    text-align: center;
}
body > section > .title, body.notesBodyType > .title {
    margin: 3em 0;
}
body.notesBodyType > section .title h1 {
    text-align: start;
}
body.notesBodyType > section .title {
    margin: 1em 0;
}
p {
    text-indent: 1em;
    margin: 0;
}
:not(p) + p, p:first-child {
    text-indent: 0;
}
.poem p {
    text-indent: 0;
    margin: 1em 0;
}
.text-author, .date {
    text-align: end;
}
.text-author:before {
    content: "";
}
table {
    border-collapse: collapse;
}
td, th {
    padding: .25em;
}
a[epub|type~="noteref"] {
    font-size: .75em;
    vertical-align: super;
}
body:not(.notesBodyType) > .title, body:not(.notesBodyType) > .epigraph {
    margin: 3em 0;
}
`
    ],
    { type: "text/css" }
  )
);
const template = (html) => `<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head><link href="${style}" rel="stylesheet" type="text/css"/></head>
    <body>${html}</body>
</html>`;
const dataID = "data-foliate-id";
const makeFB2 = async (blob) => {
  const book2 = {};
  const doc2 = await parseXML(blob);
  const converter = new FB2Converter(doc2);
  const $2 = (x2) => doc2.querySelector(x2);
  const $$2 = (x2) => [...doc2.querySelectorAll(x2)];
  const getPerson = (el) => {
    const nick = getElementText(el.querySelector("nickname"));
    if (nick)
      return nick;
    const first = getElementText(el.querySelector("first-name"));
    const middle = getElementText(el.querySelector("middle-name"));
    const last2 = getElementText(el.querySelector("last-name"));
    const name = [first, middle, last2].filter((x2) => x2).join(" ");
    const sortAs = last2 ? [last2, [first, middle].filter((x2) => x2).join(" ")].join(", ") : null;
    return { name, sortAs };
  };
  const getDate = (el) => el?.getAttribute("value") ?? getElementText(el);
  const annotation = $2("title-info annotation");
  book2.metadata = {
    title: getElementText($2("title-info book-title")),
    identifier: getElementText($2("document-info id")),
    language: getElementText($2("title-info lang")),
    author: $$2("title-info author").map(getPerson),
    translator: $$2("title-info translator").map(getPerson),
    producer: $$2("document-info author").map(getPerson).concat($$2("document-info program-used").map(getElementText)),
    publisher: getElementText($2("publish-info publisher")),
    published: getDate($2("title-info date")),
    modified: getDate($2("document-info date")),
    description: annotation ? converter.convert(annotation, { annotation: ["div", SECTION] }).innerHTML : null,
    subject: $$2("title-info genre").map(getElementText)
  };
  if ($2("coverpage image")) {
    const src = getImageSrc($2("coverpage image"));
    book2.getCover = () => fetch(src).then((res) => res.blob());
  } else
    book2.getCover = () => null;
  const bodyData = Array.from(doc2.querySelectorAll("body"), (body) => {
    const converted = converter.convert(body, { body: ["body", BODY] });
    return [
      Array.from(converted.children, (el) => {
        const ids = [el, ...el.querySelectorAll("[id]")].map((el2) => el2.id);
        return { el, ids };
      }),
      converted
    ];
  });
  const urls = [];
  const sectionData = bodyData[0][0].map(({ el, ids }) => {
    const titles = Array.from(el.querySelectorAll(":scope > section > .title"), (el2, index) => {
      el2.setAttribute(dataID, index);
      return { title: getElementText(el2), index };
    });
    return { ids, titles, el };
  }).concat(
    bodyData.slice(1).map(([sections, body]) => {
      const ids = sections.map((s) => s.ids).flat();
      body.classList.add("notesBodyType");
      return { ids, el: body, linear: "no" };
    })
  ).map(({ ids, titles, el, linear }) => {
    const str = template(el.outerHTML);
    const blob2 = new Blob([str], { type: MIME$1.XHTML });
    const url = URL.createObjectURL(blob2);
    urls.push(url);
    const title = normalizeWhitespace(
      el.querySelector(".title, .subtitle, p")?.textContent ?? (el.classList.contains("title") ? el.textContent : "")
    );
    return {
      ids,
      title,
      titles,
      load: () => url,
      createDocument: () => new DOMParser().parseFromString(str, MIME$1.XHTML),
      // doo't count image data as it'd skew the size too much
      size: blob2.size - Array.from(
        el.querySelectorAll("[src]"),
        (el2) => el2.getAttribute("src")?.length ?? 0
      ).reduce((a2, b2) => a2 + b2, 0),
      linear
    };
  });
  const idMap = /* @__PURE__ */ new Map();
  book2.sections = sectionData.map((section, index) => {
    const { ids, load, createDocument, size: size2, linear } = section;
    for (const id2 of ids)
      if (id2)
        idMap.set(id2, index);
    return { id: index, load, createDocument, size: size2, linear };
  });
  book2.toc = sectionData.map(({ title, titles }, index) => {
    const id2 = index.toString();
    return {
      label: title,
      href: id2,
      subitems: titles?.length ? titles.map(({ title: title2, index: index2 }) => ({
        label: title2,
        href: `${id2}#${index2}`
      })) : null
    };
  }).filter((item) => item);
  book2.resolveHref = (href) => {
    const [a2, b2] = href.split("#");
    return a2 ? (
      // the link is from the TOC
      { index: Number(a2), anchor: (doc3) => doc3.querySelector(`[${dataID}="${b2}"]`) }
    ) : (
      // link from within the page
      { index: idMap.get(b2), anchor: (doc3) => doc3.getElementById(b2) }
    );
  };
  book2.splitTOCHref = (href) => href?.split("#")?.map((x2) => Number(x2)) ?? [];
  book2.getTOCFragment = (doc3, id2) => doc3.querySelector(`[${dataID}="${id2}"]`);
  book2.destroy = () => {
    for (const url of urls)
      URL.revokeObjectURL(url);
  };
  return book2;
};
const unescapeHTML = (str) => {
  if (!str)
    return "";
  const textarea = document.createElement("textarea");
  textarea.innerHTML = str;
  return textarea.value;
};
const MIME = {
  XML: "application/xml",
  XHTML: "application/xhtml+xml",
  HTML: "text/html",
  CSS: "text/css",
  SVG: "image/svg+xml"
};
const PDB_HEADER = {
  name: [0, 32, "string"],
  type: [60, 4, "string"],
  creator: [64, 4, "string"],
  numRecords: [76, 2, "uint"]
};
const PALMDOC_HEADER = {
  compression: [0, 2, "uint"],
  numTextRecords: [8, 2, "uint"],
  recordSize: [10, 2, "uint"],
  encryption: [12, 2, "uint"]
};
const MOBI_HEADER = {
  magic: [16, 4, "string"],
  length: [20, 4, "uint"],
  type: [24, 4, "uint"],
  encoding: [28, 4, "uint"],
  uid: [32, 4, "uint"],
  version: [36, 4, "uint"],
  titleOffset: [84, 4, "uint"],
  titleLength: [88, 4, "uint"],
  localeRegion: [94, 1, "uint"],
  localeLanguage: [95, 1, "uint"],
  resourceStart: [108, 4, "uint"],
  huffcdic: [112, 4, "uint"],
  numHuffcdic: [116, 4, "uint"],
  exthFlag: [128, 4, "uint"],
  trailingFlags: [240, 4, "uint"],
  indx: [244, 4, "uint"]
};
const KF8_HEADER = {
  resourceStart: [108, 4, "uint"],
  fdst: [192, 4, "uint"],
  numFdst: [196, 4, "uint"],
  frag: [248, 4, "uint"],
  skel: [252, 4, "uint"],
  guide: [260, 4, "uint"]
};
const EXTH_HEADER = {
  magic: [0, 4, "string"],
  length: [4, 4, "uint"],
  count: [8, 4, "uint"]
};
const INDX_HEADER = {
  magic: [0, 4, "string"],
  length: [4, 4, "uint"],
  type: [8, 4, "uint"],
  idxt: [20, 4, "uint"],
  numRecords: [24, 4, "uint"],
  encoding: [28, 4, "uint"],
  language: [32, 4, "uint"],
  total: [36, 4, "uint"],
  ordt: [40, 4, "uint"],
  ligt: [44, 4, "uint"],
  numLigt: [48, 4, "uint"],
  numCncx: [52, 4, "uint"]
};
const TAGX_HEADER = {
  magic: [0, 4, "string"],
  length: [4, 4, "uint"],
  numControlBytes: [8, 4, "uint"]
};
const HUFF_HEADER = {
  magic: [0, 4, "string"],
  offset1: [8, 4, "uint"],
  offset2: [12, 4, "uint"]
};
const CDIC_HEADER = {
  magic: [0, 4, "string"],
  length: [4, 4, "uint"],
  numEntries: [8, 4, "uint"],
  codeLength: [12, 4, "uint"]
};
const FDST_HEADER = {
  magic: [0, 4, "string"],
  numEntries: [8, 4, "uint"]
};
const FONT_HEADER = {
  flags: [8, 4, "uint"],
  dataStart: [12, 4, "uint"],
  keyLength: [16, 4, "uint"],
  keyStart: [20, 4, "uint"]
};
const MOBI_ENCODING = {
  1252: "windows-1252",
  65001: "utf-8"
};
const EXTH_RECORD_TYPE = {
  100: ["creator", "string", true],
  101: ["publisher"],
  103: ["description"],
  104: ["isbn"],
  105: ["subject", "string", true],
  106: ["date"],
  108: ["contributor", "string", true],
  109: ["rights"],
  110: ["subjectCode", "string", true],
  112: ["source", "string", true],
  113: ["asin"],
  121: ["boundary", "uint"],
  122: ["fixedLayout"],
  125: ["numResources", "uint"],
  126: ["originalResolution"],
  127: ["zeroGutter"],
  128: ["zeroMargin"],
  129: ["coverURI"],
  132: ["regionMagnification"],
  201: ["coverOffset", "uint"],
  202: ["thumbnailOffset", "uint"],
  503: ["title"],
  524: ["language", "string", true],
  527: ["pageProgressionDirection"]
};
const MOBI_LANG = {
  1: [
    "ar",
    "ar-SA",
    "ar-IQ",
    "ar-EG",
    "ar-LY",
    "ar-DZ",
    "ar-MA",
    "ar-TN",
    "ar-OM",
    "ar-YE",
    "ar-SY",
    "ar-JO",
    "ar-LB",
    "ar-KW",
    "ar-AE",
    "ar-BH",
    "ar-QA"
  ],
  2: ["bg"],
  3: ["ca"],
  4: ["zh", "zh-TW", "zh-CN", "zh-HK", "zh-SG"],
  5: ["cs"],
  6: ["da"],
  7: ["de", "de-DE", "de-CH", "de-AT", "de-LU", "de-LI"],
  8: ["el"],
  9: [
    "en",
    "en-US",
    "en-GB",
    "en-AU",
    "en-CA",
    "en-NZ",
    "en-IE",
    "en-ZA",
    "en-JM",
    null,
    "en-BZ",
    "en-TT",
    "en-ZW",
    "en-PH"
  ],
  10: [
    "es",
    "es-ES",
    "es-MX",
    null,
    "es-GT",
    "es-CR",
    "es-PA",
    "es-DO",
    "es-VE",
    "es-CO",
    "es-PE",
    "es-AR",
    "es-EC",
    "es-CL",
    "es-UY",
    "es-PY",
    "es-BO",
    "es-SV",
    "es-HN",
    "es-NI",
    "es-PR"
  ],
  11: ["fi"],
  12: ["fr", "fr-FR", "fr-BE", "fr-CA", "fr-CH", "fr-LU", "fr-MC"],
  13: ["he"],
  14: ["hu"],
  15: ["is"],
  16: ["it", "it-IT", "it-CH"],
  17: ["ja"],
  18: ["ko"],
  19: ["nl", "nl-NL", "nl-BE"],
  20: ["no", "nb", "nn"],
  21: ["pl"],
  22: ["pt", "pt-BR", "pt-PT"],
  23: ["rm"],
  24: ["ro"],
  25: ["ru"],
  26: ["hr", null, "sr"],
  27: ["sk"],
  28: ["sq"],
  29: ["sv", "sv-SE", "sv-FI"],
  30: ["th"],
  31: ["tr"],
  32: ["ur"],
  33: ["id"],
  34: ["uk"],
  35: ["be"],
  36: ["sl"],
  37: ["et"],
  38: ["lv"],
  39: ["lt"],
  41: ["fa"],
  42: ["vi"],
  43: ["hy"],
  44: ["az"],
  45: ["eu"],
  46: ["hsb"],
  47: ["mk"],
  48: ["st"],
  49: ["ts"],
  50: ["tn"],
  52: ["xh"],
  53: ["zu"],
  54: ["af"],
  55: ["ka"],
  56: ["fo"],
  57: ["hi"],
  58: ["mt"],
  59: ["se"],
  62: ["ms"],
  63: ["kk"],
  65: ["sw"],
  67: ["uz", null, "uz-UZ"],
  68: ["tt"],
  69: ["bn"],
  70: ["pa"],
  71: ["gu"],
  72: ["or"],
  73: ["ta"],
  74: ["te"],
  75: ["kn"],
  76: ["ml"],
  77: ["as"],
  78: ["mr"],
  79: ["sa"],
  82: ["cy", "cy-GB"],
  83: ["gl", "gl-ES"],
  87: ["kok"],
  97: ["ne"],
  98: ["fy"]
};
const concatTypedArray = (a2, b2) => {
  const result = new a2.constructor(a2.length + b2.length);
  result.set(a2);
  result.set(b2, a2.length);
  return result;
};
const concatTypedArray3 = (a2, b2, c) => {
  const result = new a2.constructor(a2.length + b2.length + c.length);
  result.set(a2);
  result.set(b2, a2.length);
  result.set(c, a2.length + b2.length);
  return result;
};
const decoder = new TextDecoder();
const getString = (buffer) => decoder.decode(buffer);
const getUint = (buffer) => {
  if (!buffer)
    return;
  const l2 = buffer.byteLength;
  const func = l2 === 4 ? "getUint32" : l2 === 2 ? "getUint16" : "getUint8";
  return new DataView(buffer)[func](0);
};
const getStruct = (def2, buffer) => Object.fromEntries(
  Array.from(Object.entries(def2)).map(([key, [start, len, type]]) => [
    key,
    (type === "string" ? getString : getUint)(buffer.slice(start, start + len))
  ])
);
const getDecoder = (x2) => new TextDecoder(MOBI_ENCODING[x2]);
const getVarLen = (byteArray, i2 = 0) => {
  let value = 0, length = 0;
  for (const byte of byteArray.subarray(i2, i2 + 4)) {
    value = value << 7 | (byte & 127) >>> 0;
    length++;
    if (byte & 128)
      break;
  }
  return { value, length };
};
const getVarLenFromEnd = (byteArray) => {
  let value = 0;
  for (const byte of byteArray.subarray(-4)) {
    if (byte & 128)
      value = 0;
    value = value << 7 | byte & 127;
  }
  return value;
};
const countBitsSet = (x2) => {
  let count = 0;
  for (; x2 > 0; x2 = x2 >> 1)
    if ((x2 & 1) === 1)
      count++;
  return count;
};
const countUnsetEnd = (x2) => {
  let count = 0;
  while ((x2 & 1) === 0)
    x2 = x2 >> 1, count++;
  return count;
};
const decompressPalmDOC = (array) => {
  let output = [];
  for (let i2 = 0; i2 < array.length; i2++) {
    const byte = array[i2];
    if (byte === 0)
      output.push(0);
    else if (byte <= 8)
      for (const x2 of array.subarray(i2 + 1, (i2 += byte) + 1))
        output.push(x2);
    else if (byte <= 127)
      output.push(byte);
    else if (byte <= 191) {
      const bytes = byte << 8 | array[i2++ + 1];
      const distance = (bytes & 16383) >>> 3;
      const length = (bytes & 7) + 3;
      for (let j = 0; j < length; j++)
        output.push(output[output.length - distance]);
    } else
      output.push(32, byte ^ 128);
  }
  return Uint8Array.from(output);
};
const read32Bits = (byteArray, from2) => {
  const startByte = from2 >> 3;
  const end = from2 + 32;
  const endByte = end >> 3;
  let bits = 0n;
  for (let i2 = startByte; i2 <= endByte; i2++)
    bits = bits << 8n | BigInt(byteArray[i2] ?? 0);
  return bits >> 8n - BigInt(end & 7) & 0xffffffffn;
};
const huffcdic = async (mobi, loadRecord) => {
  const huffRecord = await loadRecord(mobi.huffcdic);
  const { magic, offset1, offset2 } = getStruct(HUFF_HEADER, huffRecord);
  if (magic !== "HUFF")
    throw new Error("Invalid HUFF record");
  const table1 = Array.from({ length: 256 }, (_2, i2) => offset1 + i2 * 4).map((offset) => getUint(huffRecord.slice(offset, offset + 4))).map((x2) => [x2 & 128, x2 & 31, x2 >>> 8]);
  const table2 = [null].concat(
    Array.from({ length: 32 }, (_2, i2) => offset2 + i2 * 8).map((offset) => [
      getUint(huffRecord.slice(offset, offset + 4)),
      getUint(huffRecord.slice(offset + 4, offset + 8))
    ])
  );
  const dictionary = [];
  for (let i2 = 1; i2 < mobi.numHuffcdic; i2++) {
    const record = await loadRecord(mobi.huffcdic + i2);
    const cdic = getStruct(CDIC_HEADER, record);
    if (cdic.magic !== "CDIC")
      throw new Error("Invalid CDIC record");
    const n2 = Math.min(1 << cdic.codeLength, cdic.numEntries - dictionary.length);
    const buffer = record.slice(cdic.length);
    for (let i3 = 0; i3 < n2; i3++) {
      const offset = getUint(buffer.slice(i3 * 2, i3 * 2 + 2));
      const x2 = getUint(buffer.slice(offset, offset + 2));
      const length = x2 & 32767;
      const decompressed = x2 & 32768;
      const value = new Uint8Array(buffer.slice(offset + 2, offset + 2 + length));
      dictionary.push([value, decompressed]);
    }
  }
  const decompress = (byteArray) => {
    let output = new Uint8Array();
    const bitLength = byteArray.byteLength * 8;
    for (let i2 = 0; i2 < bitLength; ) {
      const bits = Number(read32Bits(byteArray, i2));
      let [found, codeLength, value] = table1[bits >>> 24];
      if (!found) {
        while (bits >>> 32 - codeLength < table2[codeLength][0])
          codeLength += 1;
        value = table2[codeLength][1];
      }
      if ((i2 += codeLength) > bitLength)
        break;
      const code2 = value - (bits >>> 32 - codeLength);
      let [result, decompressed] = dictionary[code2];
      if (!decompressed) {
        result = decompress(result);
        dictionary[code2] = [result, true];
      }
      output = concatTypedArray(output, result);
    }
    return output;
  };
  return decompress;
};
const getIndexData = async (indxIndex, loadRecord) => {
  const indxRecord = await loadRecord(indxIndex);
  const indx = getStruct(INDX_HEADER, indxRecord);
  if (indx.magic !== "INDX")
    throw new Error("Invalid INDX record");
  const decoder2 = getDecoder(indx.encoding);
  const tagxBuffer = indxRecord.slice(indx.length);
  const tagx = getStruct(TAGX_HEADER, tagxBuffer);
  if (tagx.magic !== "TAGX")
    throw new Error("Invalid TAGX section");
  const numTags = (tagx.length - 12) / 4;
  const tagTable = Array.from(
    { length: numTags },
    (_2, i2) => new Uint8Array(tagxBuffer.slice(12 + i2 * 4, 12 + i2 * 4 + 4))
  );
  const cncx = {};
  let cncxRecordOffset = 0;
  for (let i2 = 0; i2 < indx.numCncx; i2++) {
    const record = await loadRecord(indxIndex + indx.numRecords + i2 + 1);
    const array = new Uint8Array(record);
    for (let pos = 0; pos < array.byteLength; ) {
      const index = pos;
      const { value, length } = getVarLen(array, pos);
      pos += length;
      const result = record.slice(pos, pos + value);
      pos += value;
      cncx[cncxRecordOffset + index] = decoder2.decode(result);
    }
    cncxRecordOffset += 65536;
  }
  const table = [];
  for (let i2 = 0; i2 < indx.numRecords; i2++) {
    const record = await loadRecord(indxIndex + 1 + i2);
    const array = new Uint8Array(record);
    const indx2 = getStruct(INDX_HEADER, record);
    if (indx2.magic !== "INDX")
      throw new Error("Invalid INDX record");
    for (let j = 0; j < indx2.numRecords; j++) {
      const offsetOffset = indx2.idxt + 4 + 2 * j;
      const offset = getUint(record.slice(offsetOffset, offsetOffset + 2));
      const length = getUint(record.slice(offset, offset + 1));
      const name = getString(record.slice(offset + 1, offset + 1 + length));
      const tags = [];
      const startPos = offset + 1 + length;
      let controlByteIndex = 0;
      let pos = startPos + tagx.numControlBytes;
      for (const [tag2, numValues, mask, end] of tagTable) {
        if (end & 1) {
          controlByteIndex++;
          continue;
        }
        const offset2 = startPos + controlByteIndex;
        const value = getUint(record.slice(offset2, offset2 + 1)) & mask;
        if (value === mask) {
          if (countBitsSet(mask) > 1) {
            const { value: value2, length: length2 } = getVarLen(array, pos);
            tags.push([tag2, null, value2, numValues]);
            pos += length2;
          } else
            tags.push([tag2, 1, null, numValues]);
        } else
          tags.push([tag2, value >> countUnsetEnd(mask), null, numValues]);
      }
      const tagMap = {};
      for (const [tag2, valueCount, valueBytes, numValues] of tags) {
        const values2 = [];
        if (valueCount != null) {
          for (let i3 = 0; i3 < valueCount * numValues; i3++) {
            const { value, length: length2 } = getVarLen(array, pos);
            values2.push(value);
            pos += length2;
          }
        } else {
          let count = 0;
          while (count < valueBytes) {
            const { value, length: length2 } = getVarLen(array, pos);
            values2.push(value);
            pos += length2;
            count += length2;
          }
        }
        tagMap[tag2] = values2;
      }
      table.push({ name, tagMap });
    }
  }
  return { table, cncx };
};
const getNCX = async (indxIndex, loadRecord) => {
  const { table, cncx } = await getIndexData(indxIndex, loadRecord);
  const items = table.map(({ tagMap }, index) => ({
    index,
    offset: tagMap[1]?.[0],
    size: tagMap[2]?.[0],
    label: cncx[tagMap[3]] ?? "",
    headingLevel: tagMap[4]?.[0],
    pos: tagMap[6],
    parent: tagMap[21]?.[0],
    firstChild: tagMap[22]?.[0],
    lastChild: tagMap[23]?.[0]
  }));
  const getChildren = (item) => {
    if (item.firstChild == null)
      return item;
    item.children = items.filter((x2) => x2.parent === item.index).map(getChildren);
    return item;
  };
  return items.filter((item) => item.headingLevel === 0).map(getChildren);
};
const getEXTH = (buf, encoding) => {
  const { magic, count } = getStruct(EXTH_HEADER, buf);
  if (magic !== "EXTH")
    throw new Error("Invalid EXTH header");
  const decoder2 = getDecoder(encoding);
  const results = {};
  let offset = 12;
  for (let i2 = 0; i2 < count; i2++) {
    const type = getUint(buf.slice(offset, offset + 4));
    const length = getUint(buf.slice(offset + 4, offset + 8));
    if (type in EXTH_RECORD_TYPE) {
      const [name, typ, many] = EXTH_RECORD_TYPE[type];
      const data2 = buf.slice(offset + 8, offset + length);
      const value = typ === "uint" ? getUint(data2) : decoder2.decode(data2);
      if (many) {
        results[name] ??= [];
        results[name].push(value);
      } else
        results[name] = value;
    }
    offset += length;
  }
  return results;
};
const getFont = async (buf, unzlib) => {
  const { flags, dataStart, keyLength, keyStart } = getStruct(FONT_HEADER, buf);
  const array = new Uint8Array(buf.slice(dataStart));
  if (flags & 2) {
    const bytes = keyLength === 16 ? 1024 : 1040;
    const key = new Uint8Array(buf.slice(keyStart, keyStart + keyLength));
    const length = Math.min(bytes, array.length);
    for (var i2 = 0; i2 < length; i2++)
      array[i2] = array[i2] ^ key[i2 % key.length];
  }
  if (flags & 1)
    try {
      return await unzlib(array);
    } catch (e2) {
      console.warn(e2);
      console.warn("Failed to decompress font");
    }
  return array;
};
const isMOBI = async (file2) => {
  const magic = getString(await file2.slice(60, 68).arrayBuffer());
  return magic === "BOOKMOBI";
};
class PDB {
  #file;
  #offsets;
  pdb;
  async open(file2) {
    this.#file = file2;
    const pdb = getStruct(PDB_HEADER, await file2.slice(0, 78).arrayBuffer());
    this.pdb = pdb;
    const buffer = await file2.slice(78, 78 + pdb.numRecords * 8).arrayBuffer();
    this.#offsets = Array.from(
      { length: pdb.numRecords },
      (_2, i2) => getUint(buffer.slice(i2 * 8, i2 * 8 + 4))
    ).map((x2, i2, a2) => [x2, a2[i2 + 1]]);
  }
  loadRecord(index) {
    const offsets = this.#offsets[index];
    if (!offsets)
      throw new RangeError("Record index out of bounds");
    return this.#file.slice(...offsets).arrayBuffer();
  }
  async loadMagic(index) {
    const start = this.#offsets[index][0];
    return getString(await this.#file.slice(start, start + 4).arrayBuffer());
  }
}
class MOBI extends PDB {
  #start = 0;
  #resourceStart;
  #decoder;
  #encoder;
  #decompress;
  #removeTrailingEntries;
  constructor({ unzlib }) {
    super();
    this.unzlib = unzlib;
  }
  async open(file2) {
    await super.open(file2);
    this.headers = this.#getHeaders(await super.loadRecord(0));
    this.#resourceStart = this.headers.mobi.resourceStart;
    let isKF8 = this.headers.mobi.version >= 8;
    if (!isKF8) {
      const boundary = this.headers.exth?.boundary;
      if (boundary < 4294967295)
        try {
          this.headers = this.#getHeaders(await super.loadRecord(boundary));
          this.#start = boundary;
          isKF8 = true;
        } catch (e2) {
          console.warn(e2);
          console.warn("Failed to open KF8; falling back to MOBI");
        }
    }
    await this.#setup();
    return isKF8 ? new KF8(this).init() : new MOBI6(this).init();
  }
  #getHeaders(buf) {
    const palmdoc = getStruct(PALMDOC_HEADER, buf);
    const mobi = getStruct(MOBI_HEADER, buf);
    if (mobi.magic !== "MOBI")
      throw new Error("Missing MOBI header");
    const { titleOffset, titleLength, localeLanguage, localeRegion } = mobi;
    mobi.title = buf.slice(titleOffset, titleOffset + titleLength);
    const lang = MOBI_LANG[localeLanguage];
    mobi.language = lang?.[localeRegion >> 2] ?? lang?.[0];
    const exth = mobi.exthFlag & 64 ? getEXTH(buf.slice(mobi.length + 16), mobi.encoding) : null;
    const kf8 = mobi.version >= 8 ? getStruct(KF8_HEADER, buf) : null;
    return { palmdoc, mobi, exth, kf8 };
  }
  async #setup() {
    const { palmdoc, mobi } = this.headers;
    this.#decoder = getDecoder(mobi.encoding);
    this.#encoder = new TextEncoder();
    const { compression } = palmdoc;
    this.#decompress = compression === 1 ? (f2) => f2 : compression === 2 ? decompressPalmDOC : compression === 17480 ? await huffcdic(mobi, this.loadRecord.bind(this)) : null;
    if (!this.#decompress)
      throw new Error("Unknown compression type");
    const { trailingFlags } = mobi;
    const multibyte = trailingFlags & 1;
    const numTrailingEntries = countBitsSet(trailingFlags >>> 1);
    this.#removeTrailingEntries = (array) => {
      for (let i2 = 0; i2 < numTrailingEntries; i2++) {
        const length = getVarLenFromEnd(array);
        array = array.subarray(0, -length);
      }
      if (multibyte) {
        const length = (array[array.length - 1] & 3) + 1;
        array = array.subarray(0, -length);
      }
      return array;
    };
  }
  decode(...args) {
    return this.#decoder.decode(...args);
  }
  encode(...args) {
    return this.#encoder.encode(...args);
  }
  loadRecord(index) {
    return super.loadRecord(this.#start + index);
  }
  loadMagic(index) {
    return super.loadMagic(this.#start + index);
  }
  loadText(index) {
    return this.loadRecord(index + 1).then((buf) => new Uint8Array(buf)).then(this.#removeTrailingEntries).then(this.#decompress);
  }
  async loadResource(index) {
    const buf = await super.loadRecord(this.#resourceStart + index);
    const magic = getString(buf.slice(0, 4));
    if (magic === "FONT")
      return getFont(buf, this.unzlib);
    if (magic === "VIDE" || magic === "AUDI")
      return buf.slice(12);
    return buf;
  }
  getNCX() {
    const index = this.headers.mobi.indx;
    if (index < 4294967295)
      return getNCX(index, this.loadRecord.bind(this));
  }
  getMetadata() {
    const { mobi, exth } = this.headers;
    return {
      identifier: mobi.uid.toString(),
      title: unescapeHTML(exth?.title || this.decode(mobi.title)),
      author: exth?.creator?.map(unescapeHTML),
      publisher: unescapeHTML(exth?.publisher),
      language: exth?.language ?? mobi.language,
      published: exth?.date,
      description: unescapeHTML(exth?.description),
      subject: exth?.subject?.map(unescapeHTML),
      rights: unescapeHTML(exth?.rights)
    };
  }
  async getCover() {
    const { exth } = this.headers;
    const offset = exth?.coverOffset < 4294967295 ? exth?.coverOffset : exth?.thumbnailOffset < 4294967295 ? exth?.thumbnailOffset : null;
    if (offset != null) {
      const buf = await this.loadResource(offset);
      return new Blob([buf]);
    }
  }
}
const mbpPagebreakRegex = /<\s*(?:mbp:)?pagebreak[^>]*>/gi;
const fileposRegex = /<[^<>]+filepos=['"]{0,1}(\d+)[^<>]*>/gi;
const getIndent = (el) => {
  let x2 = 0;
  while (el) {
    const parent = el.parentElement;
    if (parent) {
      const tag2 = parent.tagName.toLowerCase();
      if (tag2 === "p")
        x2 += 1.5;
      else if (tag2 === "blockquote")
        x2 += 2;
    }
    el = parent;
  }
  return x2;
};
class MOBI6 {
  parser = new DOMParser();
  serializer = new XMLSerializer();
  #resourceCache = /* @__PURE__ */ new Map();
  #textCache = /* @__PURE__ */ new Map();
  #cache = /* @__PURE__ */ new Map();
  #sections;
  #fileposList = [];
  #type = MIME.HTML;
  constructor(mobi) {
    this.mobi = mobi;
  }
  async init() {
    let array = new Uint8Array();
    for (let i2 = 0; i2 < this.mobi.headers.palmdoc.numTextRecords; i2++)
      array = concatTypedArray(array, await this.mobi.loadText(i2));
    const str = Array.from(new Uint8Array(array), (c) => String.fromCharCode(c)).join("");
    this.#sections = [0].concat(Array.from(str.matchAll(mbpPagebreakRegex), (m2) => m2.index)).map((x2, i2, a2) => str.slice(x2, a2[i2 + 1])).map((str2) => Uint8Array.from(str2, (x2) => x2.charCodeAt(0))).map((raw) => ({ book: this, raw })).reduce((arr, x2) => {
      const last2 = arr[arr.length - 1];
      x2.start = last2?.end ?? 0;
      x2.end = x2.start + x2.raw.byteLength;
      return arr.concat(x2);
    }, []);
    this.sections = this.#sections.map((section, index) => ({
      id: index,
      load: () => this.loadSection(section),
      createDocument: () => this.createDocument(section),
      size: section.end - section.start
    }));
    try {
      this.landmarks = await this.getGuide();
      const tocHref = this.landmarks.find(({ type }) => type?.includes("toc"))?.href;
      if (tocHref) {
        const { index } = this.resolveHref(tocHref);
        const doc2 = await this.sections[index].createDocument();
        let lastItem;
        let lastLevel = 0;
        let lastIndent = 0;
        const lastLevelOfIndent = /* @__PURE__ */ new Map();
        const lastParentOfLevel = /* @__PURE__ */ new Map();
        this.toc = Array.from(doc2.querySelectorAll("a[filepos]")).reduce((arr, a2) => {
          const indent = getIndent(a2);
          const item = {
            label: a2.innerText?.trim(),
            href: `filepos:${a2.getAttribute("filepos")}`
          };
          const level = indent > lastIndent ? lastLevel + 1 : indent === lastIndent ? lastLevel : lastLevelOfIndent.get(indent) ?? Math.max(0, lastLevel - 1);
          if (level > lastLevel) {
            if (lastItem) {
              lastItem.subitems ??= [];
              lastItem.subitems.push(item);
              lastParentOfLevel.set(level, lastItem);
            } else
              arr.push(item);
          } else {
            const parent = lastParentOfLevel.get(level);
            if (parent)
              parent.subitems.push(item);
            else
              arr.push(item);
          }
          lastItem = item;
          lastLevel = level;
          lastIndent = indent;
          lastLevelOfIndent.set(indent, level);
          return arr;
        }, []);
      }
    } catch (e2) {
      console.warn(e2);
    }
    this.#fileposList = [...new Set(Array.from(str.matchAll(fileposRegex), (m2) => m2[1]))].map((filepos) => ({ filepos, number: Number(filepos) })).sort((a2, b2) => a2.number - b2.number);
    this.metadata = this.mobi.getMetadata();
    this.getCover = this.mobi.getCover.bind(this.mobi);
    return this;
  }
  async getGuide() {
    const doc2 = await this.createDocument(this.#sections[0]);
    return Array.from(doc2.getElementsByTagName("reference"), (ref2) => ({
      label: ref2.getAttribute("title"),
      type: ref2.getAttribute("type")?.split(/\s/),
      href: `filepos:${ref2.getAttribute("filepos")}`
    }));
  }
  async loadResource(index) {
    if (this.#resourceCache.has(index))
      return this.#resourceCache.get(index);
    const raw = await this.mobi.loadResource(index);
    const url = URL.createObjectURL(new Blob([raw]));
    this.#resourceCache.set(index, url);
    return url;
  }
  async loadRecindex(recindex) {
    return this.loadResource(Number(recindex) - 1);
  }
  async loadBlob(recindex) {
    const raw = await this.mobi.loadResource(Number(recindex) - 1);
    return new Blob([raw]);
  }
  async replaceResources(doc2) {
    for (const img of doc2.querySelectorAll("img[recindex]")) {
      const recindex = img.getAttribute("recindex");
      try {
        img.src = await this.loadRecindex(recindex);
      } catch {
        console.warn(`Failed to load image ${recindex}`);
      }
    }
    for (const media of doc2.querySelectorAll("[mediarecindex]")) {
      const mediarecindex = media.getAttribute("mediarecindex");
      const recindex = media.getAttribute("recindex");
      try {
        media.src = await this.loadRecindex(mediarecindex);
        if (recindex)
          media.poster = await this.loadRecindex(recindex);
      } catch {
        console.warn(`Failed to load media ${mediarecindex}`);
      }
    }
    for (const a2 of doc2.querySelectorAll("[filepos]")) {
      const filepos = a2.getAttribute("filepos");
      a2.href = `filepos:${filepos}`;
    }
  }
  async loadText(section) {
    if (this.#textCache.has(section))
      return this.#textCache.get(section);
    const { raw } = section;
    const fileposList = this.#fileposList.filter(({ number: number2 }) => number2 >= section.start && number2 < section.end).map((obj) => ({ ...obj, offset: obj.number - section.start }));
    let arr = raw;
    if (fileposList.length) {
      arr = raw.subarray(0, fileposList[0].offset);
      fileposList.forEach(({ filepos, offset }, i2) => {
        const next = fileposList[i2 + 1];
        const a2 = this.mobi.encode(`<a id="filepos${filepos}"></a>`);
        arr = concatTypedArray3(arr, a2, raw.subarray(offset, next?.offset));
      });
    }
    const str = this.mobi.decode(arr).replaceAll(mbpPagebreakRegex, "");
    this.#textCache.set(section, str);
    return str;
  }
  async createDocument(section) {
    const str = await this.loadText(section);
    return this.parser.parseFromString(str, this.#type);
  }
  async loadSection(section) {
    if (this.#cache.has(section))
      return this.#cache.get(section);
    const doc2 = await this.createDocument(section);
    const style2 = doc2.createElement("style");
    doc2.head.append(style2);
    style2.append(
      doc2.createTextNode(`blockquote {
          margin-block-start: 0;
          margin-block-end: 0;
          margin-inline-start: 1em;
          margin-inline-end: 0;
      }`)
    );
    await this.replaceResources(doc2);
    const result = this.serializer.serializeToString(doc2);
    const url = URL.createObjectURL(new Blob([result], { type: this.#type }));
    this.#cache.set(section, url);
    return url;
  }
  resolveHref(href) {
    const filepos = href.match(/filepos:(.*)/)[1];
    const number2 = Number(filepos);
    const index = this.#sections.findIndex((section) => section.end > number2);
    const anchor = (doc2) => doc2.getElementById(`filepos${filepos}`);
    return { index, anchor };
  }
  splitTOCHref(href) {
    const filepos = href.match(/filepos:(.*)/)[1];
    const number2 = Number(filepos);
    const index = this.#sections.findIndex((section) => section.end > number2);
    return [index, `filepos${filepos}`];
  }
  getTOCFragment(doc2, id2) {
    return doc2.getElementById(id2);
  }
  isExternal(uri) {
    return /^(?!blob|filepos)\w+:/i.test(uri);
  }
  destroy() {
    for (const url of this.#resourceCache.values())
      URL.revokeObjectURL(url);
    for (const url of this.#cache.values())
      URL.revokeObjectURL(url);
  }
}
const kindleResourceRegex = /kindle:(flow|embed):(\w+)(?:\?mime=(\w+\/[-+.\w]+))?/;
const kindlePosRegex = /kindle:pos:fid:(\w+):off:(\w+)/;
const parseResourceURI = (str) => {
  const [resourceType, id2, type] = str.match(kindleResourceRegex).slice(1);
  return { resourceType, id: parseInt(id2, 32), type };
};
const parsePosURI = (str) => {
  const [fid, off] = str.match(kindlePosRegex).slice(1);
  return { fid: parseInt(fid, 32), off: parseInt(off, 32) };
};
const makePosURI = (fid = 0, off = 0) => `kindle:pos:fid:${fid.toString(32).toUpperCase().padStart(4, "0")}:off:${off.toString(32).toUpperCase().padStart(10, "0")}`;
const getFragmentSelector = (str) => {
  const match2 = str.match(/\s(id|name|aid)\s*=\s*['"]([^'"]*)['"]/i);
  if (!match2)
    return;
  const [, attr, value] = match2;
  return `[${attr}="${CSS.escape(value)}"]`;
};
const replaceSeries = async (str, regex, f2) => {
  const matches = [];
  str.replace(regex, (...args) => (matches.push(args), null));
  const results = [];
  for (const args of matches)
    results.push(await f2(...args));
  return str.replace(regex, () => results.shift());
};
const getPageSpread = (properties) => {
  for (const p2 of properties) {
    if (p2 === "page-spread-left" || p2 === "rendition:page-spread-left")
      return "left";
    if (p2 === "page-spread-right" || p2 === "rendition:page-spread-right")
      return "right";
    if (p2 === "rendition:page-spread-center")
      return "center";
  }
};
class KF8 {
  parser = new DOMParser();
  serializer = new XMLSerializer();
  #cache = /* @__PURE__ */ new Map();
  #fragmentOffsets = /* @__PURE__ */ new Map();
  #fragmentSelectors = /* @__PURE__ */ new Map();
  #tables = {};
  #sections;
  #fullRawLength;
  #rawHead = new Uint8Array();
  #rawTail = new Uint8Array();
  #lastLoadedHead = -1;
  #lastLoadedTail = -1;
  #type = MIME.XHTML;
  #inlineMap = /* @__PURE__ */ new Map();
  constructor(mobi) {
    this.mobi = mobi;
  }
  async init() {
    const loadRecord = this.mobi.loadRecord.bind(this.mobi);
    const { kf8 } = this.mobi.headers;
    try {
      const fdstBuffer = await loadRecord(kf8.fdst);
      const fdst = getStruct(FDST_HEADER, fdstBuffer);
      if (fdst.magic !== "FDST")
        throw new Error("Missing FDST record");
      const fdstTable = Array.from({ length: fdst.numEntries }, (_2, i2) => 12 + i2 * 8).map(
        (offset) => [
          getUint(fdstBuffer.slice(offset, offset + 4)),
          getUint(fdstBuffer.slice(offset + 4, offset + 8))
        ]
      );
      this.#tables.fdstTable = fdstTable;
      this.#fullRawLength = fdstTable[fdstTable.length - 1][1];
    } catch {
    }
    const skelTable = (await getIndexData(kf8.skel, loadRecord)).table.map(
      ({ name, tagMap }, index) => ({
        index,
        name,
        numFrag: tagMap[1][0],
        offset: tagMap[6][0],
        length: tagMap[6][1]
      })
    );
    const fragData = await getIndexData(kf8.frag, loadRecord);
    const fragTable = fragData.table.map(({ name, tagMap }) => ({
      insertOffset: parseInt(name),
      selector: fragData.cncx[tagMap[2][0]],
      index: tagMap[4][0],
      offset: tagMap[6][0],
      length: tagMap[6][1]
    }));
    this.#tables.skelTable = skelTable;
    this.#tables.fragTable = fragTable;
    this.#sections = skelTable.reduce((arr, skel) => {
      const last2 = arr[arr.length - 1];
      const fragStart = last2?.fragEnd ?? 0, fragEnd = fragStart + skel.numFrag;
      const frags = fragTable.slice(fragStart, fragEnd);
      const length = skel.length + frags.map((f2) => f2.length).reduce((a2, b2) => a2 + b2);
      const totalLength = (last2?.totalLength ?? 0) + length;
      return arr.concat({ skel, frags, fragEnd, length, totalLength });
    }, []);
    const resources = await this.getResourcesByMagic(["RESC", "PAGE"]);
    const pageSpreads = /* @__PURE__ */ new Map();
    if (resources.RESC) {
      const buf = await this.mobi.loadRecord(resources.RESC);
      const str = this.mobi.decode(buf.slice(16)).replace(/\0/g, "");
      const index = str.search(/\?>/);
      const xmlStr = `<package>${str.slice(index)}</package>`;
      const opf = this.parser.parseFromString(xmlStr, MIME.XML);
      for (const $itemref of opf.querySelectorAll("spine > itemref")) {
        const i2 = parseInt($itemref.getAttribute("skelid"));
        pageSpreads.set(i2, getPageSpread($itemref.getAttribute("properties")?.split(" ") ?? []));
      }
    }
    this.sections = this.#sections.map(
      (section, index) => section.frags.length ? {
        id: index,
        load: () => this.loadSection(section),
        createDocument: () => this.createDocument(section),
        size: section.length,
        pageSpread: pageSpreads.get(index)
      } : { linear: "no" }
    );
    try {
      const ncx = await this.mobi.getNCX();
      const map = ({ label, pos, children }) => {
        const [fid, off] = pos;
        const href = makePosURI(fid, off);
        const arr = this.#fragmentOffsets.get(fid);
        if (arr)
          arr.push(off);
        else
          this.#fragmentOffsets.set(fid, [off]);
        return { label: unescapeHTML(label), href, subitems: children?.map(map) };
      };
      this.toc = ncx?.map(map);
      this.landmarks = await this.getGuide();
    } catch (e2) {
      console.warn(e2);
    }
    const { exth } = this.mobi.headers;
    this.dir = exth.pageProgressionDirection;
    this.rendition = {
      layout: exth.fixedLayout === "true" ? "pre-paginated" : "reflowable",
      viewport: Object.fromEntries(
        exth.originalResolution?.split("x")?.slice(0, 2)?.map((x2, i2) => [i2 ? "height" : "width", x2]) ?? []
      )
    };
    this.metadata = this.mobi.getMetadata();
    this.getCover = this.mobi.getCover.bind(this.mobi);
    return this;
  }
  // is this really the only way of getting to RESC, PAGE, etc.?
  async getResourcesByMagic(keys) {
    const results = {};
    const start = this.mobi.headers.kf8.resourceStart;
    const end = this.mobi.pdb.numRecords;
    for (let i2 = start; i2 < end; i2++) {
      try {
        const magic = await this.mobi.loadMagic(i2);
        const match2 = keys.find((key) => key === magic);
        if (match2)
          results[match2] = i2;
      } catch {
      }
    }
    return results;
  }
  async getGuide() {
    const index = this.mobi.headers.kf8.guide;
    if (index < 4294967295) {
      const loadRecord = this.mobi.loadRecord.bind(this.mobi);
      const { table, cncx } = await getIndexData(index, loadRecord);
      return table.map(({ name, tagMap }) => ({
        label: cncx[tagMap[1][0]] ?? "",
        type: name?.split(/\s/),
        href: makePosURI(tagMap[6]?.[0] ?? tagMap[3]?.[0])
      }));
    }
  }
  async loadResourceBlob(str) {
    const { resourceType, id: id2, type } = parseResourceURI(str);
    const raw = resourceType === "flow" ? await this.loadFlow(id2) : await this.mobi.loadResource(id2 - 1);
    const result = [MIME.XHTML, MIME.HTML, MIME.CSS, MIME.SVG].includes(type) ? await this.replaceResources(this.mobi.decode(raw)) : raw;
    const doc2 = type === MIME.SVG ? this.parser.parseFromString(result, type) : null;
    return [
      new Blob([result], { type }),
      // SVG wrappers need to be inlined
      // as browsers don't allow external resources when loading SVG as an image
      doc2?.getElementsByTagNameNS("http://www.w3.org/2000/svg", "image")?.length ? doc2.documentElement : null
    ];
  }
  async loadResource(str) {
    if (this.#cache.has(str))
      return this.#cache.get(str);
    const [blob, inline] = await this.loadResourceBlob(str);
    const url = inline ? str : URL.createObjectURL(blob);
    if (inline)
      this.#inlineMap.set(url, inline);
    this.#cache.set(str, url);
    return url;
  }
  replaceResources(str) {
    const regex = new RegExp(kindleResourceRegex, "g");
    return replaceSeries(str, regex, this.loadResource.bind(this));
  }
  // NOTE: there doesn't seem to be a way to access text randomly?
  // how to know the decompressed size of the records without decompressing?
  // 4096 is just the maximum size
  async loadRaw(start, end) {
    const distanceHead = end - this.#rawHead.length;
    const distanceEnd = this.#fullRawLength == null ? Infinity : this.#fullRawLength - this.#rawTail.length - start;
    if (distanceHead < 0 || distanceHead < distanceEnd) {
      while (this.#rawHead.length < end) {
        const index = ++this.#lastLoadedHead;
        const data2 = await this.mobi.loadText(index);
        this.#rawHead = concatTypedArray(this.#rawHead, data2);
      }
      return this.#rawHead.slice(start, end);
    }
    while (this.#fullRawLength - this.#rawTail.length > start) {
      const index = this.mobi.headers.palmdoc.numTextRecords - 1 - ++this.#lastLoadedTail;
      const data2 = await this.mobi.loadText(index);
      this.#rawTail = concatTypedArray(data2, this.#rawTail);
    }
    const rawTailStart = this.#fullRawLength - this.#rawTail.length;
    return this.#rawTail.slice(start - rawTailStart, end - rawTailStart);
  }
  loadFlow(index) {
    if (index < 4294967295)
      return this.loadRaw(...this.#tables.fdstTable[index]);
  }
  async loadText(section) {
    const { skel, frags, length } = section;
    const raw = await this.loadRaw(skel.offset, skel.offset + length);
    let skeleton = raw.slice(0, skel.length);
    for (const frag of frags) {
      const insertOffset = frag.insertOffset - skel.offset;
      const offset = skel.length + frag.offset;
      const fragRaw = raw.slice(offset, offset + frag.length);
      skeleton = concatTypedArray3(
        skeleton.slice(0, insertOffset),
        fragRaw,
        skeleton.slice(insertOffset)
      );
      const offsets = this.#fragmentOffsets.get(frag.index);
      if (offsets)
        for (const offset2 of offsets) {
          const str = this.mobi.decode(fragRaw).slice(offset2);
          const selector2 = getFragmentSelector(str);
          this.#setFragmentSelector(frag.index, offset2, selector2);
        }
    }
    return this.mobi.decode(skeleton);
  }
  async createDocument(section) {
    const str = await this.loadText(section);
    return this.parser.parseFromString(str, this.#type);
  }
  async loadSection(section) {
    if (this.#cache.has(section))
      return this.#cache.get(section);
    const str = await this.loadText(section);
    const replaced = await this.replaceResources(str);
    let doc2 = this.parser.parseFromString(replaced, this.#type);
    if (doc2.querySelector("parsererror")) {
      this.#type = MIME.HTML;
      doc2 = this.parser.parseFromString(replaced, this.#type);
    }
    for (const [url2, node] of this.#inlineMap) {
      for (const el of doc2.querySelectorAll(`img[src="${url2}"]`))
        el.replaceWith(node);
    }
    const url = URL.createObjectURL(
      new Blob([this.serializer.serializeToString(doc2)], { type: this.#type })
    );
    this.#cache.set(section, url);
    return url;
  }
  getIndexByFID(fid) {
    return this.#sections.findIndex((section) => section.frags.some((frag) => frag.index === fid));
  }
  #setFragmentSelector(id2, offset, selector2) {
    const map = this.#fragmentSelectors.get(id2);
    if (map)
      map.set(offset, selector2);
    else {
      const map2 = /* @__PURE__ */ new Map();
      this.#fragmentSelectors.set(id2, map2);
      map2.set(offset, selector2);
    }
  }
  async resolveHref(href) {
    const { fid, off } = parsePosURI(href);
    const index = this.getIndexByFID(fid);
    if (index < 0)
      return;
    const saved = this.#fragmentSelectors.get(fid)?.get(off);
    if (saved)
      return { index, anchor: (doc2) => doc2.querySelector(saved) };
    const { skel, frags } = this.#sections[index];
    const frag = frags.find((frag2) => frag2.index === fid);
    const offset = skel.offset + skel.length + frag.offset;
    const fragRaw = await this.loadRaw(offset, offset + frag.length);
    const str = this.mobi.decode(fragRaw).slice(off);
    const selector2 = getFragmentSelector(str);
    this.#setFragmentSelector(fid, off, selector2);
    const anchor = (doc2) => doc2.querySelector(selector2);
    return { index, anchor };
  }
  splitTOCHref(href) {
    const pos = parsePosURI(href);
    const index = this.getIndexByFID(pos.fid);
    return [index, pos];
  }
  getTOCFragment(doc2, { fid, off }) {
    const selector2 = this.#fragmentSelectors.get(fid)?.get(off);
    return doc2.querySelector(selector2);
  }
  isExternal(uri) {
    return /^(?!blob|kindle)\w+:/i.test(uri);
  }
  destroy() {
    for (const url of this.#cache.values())
      URL.revokeObjectURL(url);
  }
}
var r = Uint8Array, e = Uint16Array, n = Uint32Array, a = new r([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  0,
  0,
  0
]), t = new r([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  0,
  0
]), i = new r([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), f = function(r2, a2) {
  for (var t2 = new e(31), i2 = 0; i2 < 31; ++i2)
    t2[i2] = a2 += 1 << r2[i2 - 1];
  var f2 = new n(t2[30]);
  for (i2 = 1; i2 < 30; ++i2)
    for (var o2 = t2[i2]; o2 < t2[i2 + 1]; ++o2)
      f2[o2] = o2 - t2[i2] << 5 | i2;
  return [t2, f2];
}, o = f(a, 2), v = o[0], l = o[1];
v[28] = 258, l[258] = 28;
for (var u = f(t, 0)[0], c = new e(32768), d = 0; d < 32768; ++d) {
  var s = (43690 & d) >>> 1 | (21845 & d) << 1;
  s = (61680 & (s = (52428 & s) >>> 2 | (13107 & s) << 2)) >>> 4 | (3855 & s) << 4, c[d] = ((65280 & s) >>> 8 | (255 & s) << 8) >>> 1;
}
var w = function(r2, n2, a2) {
  for (var t2 = r2.length, i2 = 0, f2 = new e(n2); i2 < t2; ++i2)
    r2[i2] && ++f2[r2[i2] - 1];
  var o2, v2 = new e(n2);
  for (i2 = 0; i2 < n2; ++i2)
    v2[i2] = v2[i2 - 1] + f2[i2 - 1] << 1;
  {
    o2 = new e(1 << n2);
    var l2 = 15 - n2;
    for (i2 = 0; i2 < t2; ++i2)
      if (r2[i2])
        for (var u = i2 << 4 | r2[i2], d = n2 - r2[i2], s = v2[r2[i2] - 1]++ << d, w2 = s | (1 << d) - 1; s <= w2; ++s)
          o2[c[s] >>> l2] = u;
  }
  return o2;
}, b = new r(288);
for (d = 0; d < 144; ++d)
  b[d] = 8;
for (d = 144; d < 256; ++d)
  b[d] = 9;
for (d = 256; d < 280; ++d)
  b[d] = 7;
for (d = 280; d < 288; ++d)
  b[d] = 8;
var h = new r(32);
for (d = 0; d < 32; ++d)
  h[d] = 5;
var E = w(b, 9), p = w(h, 5), g = function(r2) {
  for (var e2 = r2[0], n2 = 1; n2 < r2.length; ++n2)
    r2[n2] > e2 && (e2 = r2[n2]);
  return e2;
}, y = function(r2, e2, n2) {
  var a2 = e2 / 8 | 0;
  return (r2[a2] | r2[a2 + 1] << 8) >> (7 & e2) & n2;
}, k = function(r2, e2) {
  var n2 = e2 / 8 | 0;
  return (r2[n2] | r2[n2 + 1] << 8 | r2[n2 + 2] << 16) >> (7 & e2);
}, T = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
], m = function(r2, e2, n2) {
  var a2 = new Error(e2 || T[r2]);
  if (a2.code = r2, Error.captureStackTrace && Error.captureStackTrace(a2, m), !n2)
    throw a2;
  return a2;
}, x = function(f2, o2, l2) {
  var c = f2.length;
  if (!c || l2 && l2.f && !l2.l)
    return o2 || new r(0);
  var d = !o2 || l2, s = !l2 || l2.i;
  l2 || (l2 = {}), o2 || (o2 = new r(3 * c));
  var b2 = function(e2) {
    var n2 = o2.length;
    if (e2 > n2) {
      var a2 = new r(Math.max(2 * n2, e2));
      a2.set(o2), o2 = a2;
    }
  }, h2 = l2.f || 0, T2 = l2.p || 0, x2 = l2.b || 0, S2 = l2.l, U2 = l2.d, _2 = l2.m, z2 = l2.n, A = 8 * c;
  do {
    if (!S2) {
      h2 = y(f2, T2, 1);
      var M = y(f2, T2 + 1, 3);
      if (T2 += 3, !M) {
        var B = f2[(C = 4 + ((T2 + 7) / 8 | 0)) - 4] | f2[C - 3] << 8, D = C + B;
        if (D > c) {
          s && m(0);
          break;
        }
        d && b2(x2 + B), o2.set(f2.subarray(C, D), x2), l2.b = x2 += B, l2.p = T2 = 8 * D, l2.f = h2;
        continue;
      }
      if (1 == M)
        S2 = E, U2 = p, _2 = 9, z2 = 5;
      else if (2 == M) {
        var F = y(f2, T2, 31) + 257, L = y(f2, T2 + 10, 15) + 4, N = F + y(f2, T2 + 5, 31) + 1;
        T2 += 14;
        for (var P = new r(N), R = new r(19), Y = 0; Y < L; ++Y)
          R[i[Y]] = y(f2, T2 + 3 * Y, 7);
        T2 += 3 * L;
        var O = g(R), j = (1 << O) - 1, q = w(R, O);
        for (Y = 0; Y < N; ) {
          var C, G = q[y(f2, T2, j)];
          if (T2 += 15 & G, (C = G >>> 4) < 16)
            P[Y++] = C;
          else {
            var H = 0, I = 0;
            for (16 == C ? (I = 3 + y(f2, T2, 3), T2 += 2, H = P[Y - 1]) : 17 == C ? (I = 3 + y(f2, T2, 7), T2 += 3) : 18 == C && (I = 11 + y(f2, T2, 127), T2 += 7); I--; )
              P[Y++] = H;
          }
        }
        var J = P.subarray(0, F), K = P.subarray(F);
        _2 = g(J), z2 = g(K), S2 = w(J, _2), U2 = w(K, z2);
      } else
        m(1);
      if (T2 > A) {
        s && m(0);
        break;
      }
    }
    d && b2(x2 + 131072);
    for (var Q = (1 << _2) - 1, V = (1 << z2) - 1, W = T2; ; W = T2) {
      var X2 = (H = S2[k(f2, T2) & Q]) >>> 4;
      if ((T2 += 15 & H) > A) {
        s && m(0);
        break;
      }
      if (H || m(2), X2 < 256)
        o2[x2++] = X2;
      else {
        if (256 == X2) {
          W = T2, S2 = null;
          break;
        }
        var Z = X2 - 254;
        if (X2 > 264) {
          var $2 = a[Y = X2 - 257];
          Z = y(f2, T2, (1 << $2) - 1) + v[Y], T2 += $2;
        }
        var rr = U2[k(f2, T2) & V], er = rr >>> 4;
        rr || m(3), T2 += 15 & rr;
        K = u[er];
        if (er > 3) {
          $2 = t[er];
          K += k(f2, T2) & (1 << $2) - 1, T2 += $2;
        }
        if (T2 > A) {
          s && m(0);
          break;
        }
        d && b2(x2 + 131072);
        for (var nr = x2 + Z; x2 < nr; x2 += 4)
          o2[x2] = o2[x2 - K], o2[x2 + 1] = o2[x2 + 1 - K], o2[x2 + 2] = o2[x2 + 2 - K], o2[x2 + 3] = o2[x2 + 3 - K];
        x2 = nr;
      }
    }
    l2.l = S2, l2.p = W, l2.b = x2, l2.f = h2, S2 && (h2 = 1, l2.m = _2, l2.d = U2, l2.n = z2);
  } while (!h2);
  return x2 == o2.length ? o2 : function(a2, t2, i2) {
    (null == i2 || i2 > a2.length) && (i2 = a2.length);
    var f3 = new (2 == a2.BYTES_PER_ELEMENT ? e : 4 == a2.BYTES_PER_ELEMENT ? n : r)(i2 - t2);
    return f3.set(a2.subarray(t2, i2)), f3;
  }(o2, 0, x2);
}, S = new r(0), U = function(r2) {
  (8 != (15 & r2[0]) || r2[0] >>> 4 > 7 || (r2[0] << 8 | r2[1]) % 31) && m(6, "invalid zlib data"), 32 & r2[1] && m(6, "invalid zlib data: preset dictionaries not supported");
};
function _(r2, e2) {
  return x((U(r2), r2.subarray(2, -4)), e2);
}
var z = "undefined" != typeof TextDecoder && new TextDecoder();
try {
  z.decode(S, { stream: true }), 1;
} catch (r2) {
}
const isZip = async (file2) => {
  const arr = new Uint8Array(await file2.slice(0, 4).arrayBuffer());
  return arr[0] === 80 && arr[1] === 75 && arr[2] === 3 && arr[3] === 4;
};
const isPDF = async (file2) => {
  const arr = new Uint8Array(await file2.slice(0, 5).arrayBuffer());
  return arr[0] === 37 && arr[1] === 80 && arr[2] === 68 && arr[3] === 70 && arr[4] === 45;
};
const makeZipLoader = async (file2) => {
  const { configure, ZipReader, BlobReader, TextWriter, BlobWriter } = await __vitePreload(() => import("./zip-CpYcQdIF.js"), true ? [] : void 0, import.meta.url);
  configure({ useWebWorkers: false });
  const reader = new ZipReader(new BlobReader(file2));
  const entries = await reader.getEntries();
  const map = new Map(entries.map((entry) => [entry.filename, entry]));
  const load = (f2) => (name, ...args) => map.has(name) ? f2(map.get(name), ...args) : null;
  const loadText = load((entry) => entry.getData(new TextWriter()));
  const loadBlob = load((entry, type) => entry.getData(new BlobWriter(type)));
  const getSize = (name) => map.get(name)?.uncompressedSize ?? 0;
  return { entries, loadText, loadBlob, getSize };
};
const getFileEntries = async (entry) => entry.isFile ? entry : (await Promise.all(
  Array.from(
    await new Promise(
      (resolve2, reject) => entry.createReader().readEntries(
        (entries) => resolve2(entries),
        (error) => reject(error)
      )
    ),
    getFileEntries
  )
)).flat();
const makeDirectoryLoader = async (entry) => {
  const entries = await getFileEntries(entry);
  const files = await Promise.all(
    entries.map(
      (entry2) => new Promise(
        (resolve2, reject) => entry2.file(
          (file2) => resolve2([file2, entry2.fullPath]),
          (error) => reject(error)
        )
      )
    )
  );
  const map = new Map(files.map(([file2, path]) => [path.replace(entry.fullPath + "/", ""), file2]));
  const decoder2 = new TextDecoder();
  const decode2 = (x2) => x2 ? decoder2.decode(x2) : null;
  const getBuffer = (name) => map.get(name)?.arrayBuffer() ?? null;
  const loadText = async (name) => decode2(await getBuffer(name));
  const loadBlob = (name) => map.get(name);
  const getSize = (name) => map.get(name)?.size ?? 0;
  return { loadText, loadBlob, getSize };
};
const isCBZ = ({ name, type }) => type === "application/vnd.comicbook+zip" || name.endsWith(".cbz");
const isFB2 = ({ name, type }) => type === "application/x-fictionbook+xml" || name.endsWith(".fb2");
const isFBZ = ({ name, type }) => type === "application/x-zip-compressed-fb2" || name.endsWith(".fb2.zip") || name.endsWith(".fbz");
const getBook = async (file2) => {
  let book2;
  if (file2.isDirectory) {
    const loader = await makeDirectoryLoader(file2);
    book2 = await new EPUB(loader).init();
  } else if (!file2.size)
    throw new Error("File not found");
  else if (await isZip(file2)) {
    const loader = await makeZipLoader(file2);
    if (isCBZ(file2)) {
      book2 = makeComicBook(loader, file2);
    } else if (isFBZ(file2)) {
      const { entries } = loader;
      const entry = entries.find((entry2) => entry2.filename.endsWith(".fb2"));
      const blob = await loader.loadBlob((entry ?? entries[0]).filename);
      book2 = await makeFB2(blob);
    } else {
      book2 = await new EPUB(loader).init();
    }
  } else if (await isPDF(file2)) {
    const { makePDF } = await __vitePreload(() => import("./pdf-kWcBJVdw.js"), true ? [] : void 0, import.meta.url);
    book2 = await makePDF(file2);
  } else {
    if (await isMOBI(file2)) {
      book2 = await new MOBI({ unzlib: _ }).open(file2);
    } else if (isFB2(file2)) {
      book2 = await makeFB2(file2);
    }
  }
  if (!book2)
    throw new Error("File type not supported");
  return book2;
};
const estimatedHeight = (node) => {
  node.classList.add("prose", "prose-width", "prose-hidden");
  document.body.appendChild(node);
  const height = window.getComputedStyle(node).height;
  document.body.removeChild(node);
  return +height.replace("px", "");
};
class Reader {
  blobs = /* @__PURE__ */ new Map();
  //  blob
  book;
  constructor() {
    this.#handleImg.bind(this);
    this.#handleLinks.bind(this);
    this.#resolveCFI.bind(this);
    this.#handleRecIndexImg.bind(this);
  }
  /**
   * 
   * @param {*} file 
   * @param {*} isHandle 
   * @returns
   */
  open = async (file2) => {
    this.book = await getBook(file2);
  };
  /**
   * href blob
   * @param {*} href
   * @returns
   */
  getImgBlob = (href) => {
    let result = null;
    if (href && this.blobs.has(href)) {
      result = this.blobs.get(href);
    }
    return result;
  };
  /**
   * 
   */
  getMetadata = () => {
    return this.book.metadata;
  };
  /**
   * 
   * @returns
   */
  getCover = async () => {
    return await Promise.resolve(this.book.getCover?.());
  };
  getSections = async () => {
    if (this.book.type !== "pdf") {
      const result = [];
      for (const section of this.book.sections) {
        const id2 = section.id;
        const doc2 = await section.createDocument();
        const body = doc2.querySelector("body");
        const height = estimatedHeight(body.cloneNode(true));
        this.#handleLinks(body, section);
        await this.#handleImg(body, section);
        const html = body.innerHTML.replace(/xmlns=".*?"/g, "").replace(/<([a-zA-Z0-9]+)(\s[^>]*)?>\s*<\/\1>/g, "");
        result.push({ height, html, id: id2 });
      }
      return result;
    } else {
      return this.book.sections;
    }
  };
  /**
   * 
   * @param {*} href
   * @returns
   */
  isExternal = (href) => {
    return this.book.isExternal?.(href);
  };
  resolveNavigation = (target) => {
    try {
      if (typeof target === "number")
        return { index: target };
      if (isCFI.test(target))
        return this.resolveCFI(target);
      return this.book.resolveHref(target);
    } catch (e2) {
      console.error(e2);
      console.error(`Could not resolve target ${target}`);
    }
  };
  destroy = () => {
    this.book.destroy();
    this.blobs.clear();
  };
  #resolveCFI(cfi) {
    if (this.book.resolveCFI)
      return this.book.resolveCFI(cfi);
    else {
      const parts = parse(cfi);
      const index = fake.toIndex((parts.parent ?? parts).shift());
      const anchor = (doc2) => toRange(doc2, parts);
      return { index, anchor };
    }
  }
  #replace(dom, section, attr) {
    const href_ = dom.getAttribute(attr);
    const href = section?.resolveHref?.(href_) ?? href_;
    dom.setAttribute(attr, href);
    return href;
  }
  /**
   * 
   */
  #handleLinks(dom, section) {
    const links = dom.querySelectorAll("a[href]");
    for (const item of links) {
      this.#replace(item, section, "href");
    }
  }
  async #handleRecIndexImg(dom, section) {
    for (const img of dom.querySelectorAll("img[recindex]")) {
      const href = this.#replace(img, section, "recindex");
      if (href) {
        const blob = await this.book?.loadBlob(href);
        if (blob) {
          this.blobs.set(href, blob);
        }
      }
    }
  }
  /**
   * 
   * @param dom
   * @param section
   */
  async #handleImg(dom, section) {
    try {
      await this.#handleRecIndexImg(dom, section);
      const imgs = dom.querySelectorAll("img[src]");
      for (const img of imgs) {
        const href = this.#replace(img, section, "src");
        if (href) {
          if (this.book.loadBlob) {
            const blob = await this.book?.loadBlob(href);
            if (blob) {
              this.blobs.set(href, blob);
            }
          } else if (this.book.loadResourceBlob) {
            console.log("mobi azw3 loadResourceBlob");
            const blob = await this.book.loadResourceBlob(href);
            if (blob) {
              this.blobs.set(href, blob);
            }
          } else {
            console.log("todo handle imgae resource");
          }
        }
      }
    } catch (e2) {
      console.error("handle img to blob error: ", e2);
    }
  }
  /**
   * 
   * @param {*} author
   * @returns
   */
  static handleAuthor = (author) => {
    return typeof author === "string" ? author : author?.map((author2) => typeof author2 === "string" ? author2 : author2.name)?.join(", ") ?? "";
  };
  /**
   * 
   * @param {*} language
   * @returns
   */
  static handleLanguage = (language) => {
    return typeof language === "string" ? language : language?.join(", ") ?? "";
  };
}
var __webpack_require__$1 = {};
(() => {
  __webpack_require__$1.d = (exports, definition) => {
    for (var key in definition) {
      if (__webpack_require__$1.o(definition, key) && !__webpack_require__$1.o(exports, key)) {
        Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
      }
    }
  };
})();
(() => {
  __webpack_require__$1.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
})();
var __webpack_exports__$1 = globalThis.pdfjsLib = {};
__webpack_require__$1.d(__webpack_exports__$1, {
  AbortException: () => (
    /* reexport */
    AbortException$1
  ),
  AnnotationEditorLayer: () => (
    /* reexport */
    AnnotationEditorLayer$1
  ),
  AnnotationEditorParamsType: () => (
    /* reexport */
    AnnotationEditorParamsType$1
  ),
  AnnotationEditorType: () => (
    /* reexport */
    AnnotationEditorType$1
  ),
  AnnotationEditorUIManager: () => (
    /* reexport */
    AnnotationEditorUIManager$1
  ),
  AnnotationLayer: () => (
    /* reexport */
    AnnotationLayer$1
  ),
  AnnotationMode: () => (
    /* reexport */
    AnnotationMode$1
  ),
  CMapCompressionType: () => (
    /* reexport */
    CMapCompressionType$1
  ),
  ColorPicker: () => (
    /* reexport */
    ColorPicker$1
  ),
  DOMSVGFactory: () => (
    /* reexport */
    DOMSVGFactory$1
  ),
  DrawLayer: () => (
    /* reexport */
    DrawLayer$1
  ),
  FeatureTest: () => (
    /* reexport */
    util_FeatureTest
  ),
  GlobalWorkerOptions: () => (
    /* reexport */
    GlobalWorkerOptions$1
  ),
  ImageKind: () => (
    /* reexport */
    util_ImageKind
  ),
  InvalidPDFException: () => (
    /* reexport */
    InvalidPDFException$1
  ),
  MissingPDFException: () => (
    /* reexport */
    MissingPDFException$1
  ),
  OPS: () => (
    /* reexport */
    OPS$1
  ),
  Outliner: () => (
    /* reexport */
    Outliner$1
  ),
  PDFDataRangeTransport: () => (
    /* reexport */
    PDFDataRangeTransport$1
  ),
  PDFDateString: () => (
    /* reexport */
    PDFDateString$1
  ),
  PDFWorker: () => (
    /* reexport */
    PDFWorker$1
  ),
  PasswordResponses: () => (
    /* reexport */
    PasswordResponses$1
  ),
  PermissionFlag: () => (
    /* reexport */
    PermissionFlag$1
  ),
  PixelsPerInch: () => (
    /* reexport */
    PixelsPerInch$1
  ),
  RenderingCancelledException: () => (
    /* reexport */
    RenderingCancelledException$1
  ),
  TextLayer: () => (
    /* reexport */
    TextLayer$1
  ),
  UnexpectedResponseException: () => (
    /* reexport */
    UnexpectedResponseException$1
  ),
  Util: () => (
    /* reexport */
    Util$1
  ),
  VerbosityLevel: () => (
    /* reexport */
    VerbosityLevel$1
  ),
  XfaLayer: () => (
    /* reexport */
    XfaLayer$1
  ),
  build: () => (
    /* reexport */
    build$1
  ),
  createValidAbsoluteUrl: () => (
    /* reexport */
    createValidAbsoluteUrl$1
  ),
  fetchData: () => (
    /* reexport */
    fetchData$1
  ),
  getDocument: () => (
    /* reexport */
    getDocument$1
  ),
  getFilenameFromUrl: () => (
    /* reexport */
    getFilenameFromUrl$1
  ),
  getPdfFilenameFromUrl: () => (
    /* reexport */
    getPdfFilenameFromUrl$1
  ),
  getXfaPageViewport: () => (
    /* reexport */
    getXfaPageViewport$1
  ),
  isDataScheme: () => (
    /* reexport */
    isDataScheme$1
  ),
  isPdfFile: () => (
    /* reexport */
    isPdfFile$1
  ),
  noContextMenu: () => (
    /* reexport */
    noContextMenu$1
  ),
  normalizeUnicode: () => (
    /* reexport */
    normalizeUnicode$1
  ),
  renderTextLayer: () => (
    /* reexport */
    renderTextLayer$1
  ),
  setLayerDimensions: () => (
    /* reexport */
    setLayerDimensions$1
  ),
  shadow: () => (
    /* reexport */
    shadow$1
  ),
  updateTextLayer: () => (
    /* reexport */
    updateTextLayer$1
  ),
  version: () => (
    /* reexport */
    version$1
  )
});
const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
const MAX_IMAGE_SIZE_TO_CACHE = 1e7;
const LINE_FACTOR = 1.35;
const RenderingIntentFlag = {
  ANY: 1,
  DISPLAY: 2,
  PRINT: 4,
  SAVE: 8,
  ANNOTATIONS_FORMS: 16,
  ANNOTATIONS_STORAGE: 32,
  ANNOTATIONS_DISABLE: 64,
  OPLIST: 256
};
const AnnotationMode$1 = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
};
const AnnotationEditorPrefix = "pdfjs_internal_editor_";
const AnnotationEditorType$1 = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  HIGHLIGHT: 9,
  STAMP: 13,
  INK: 15
};
const AnnotationEditorParamsType$1 = {
  RESIZE: 1,
  CREATE: 2,
  FREETEXT_SIZE: 11,
  FREETEXT_COLOR: 12,
  FREETEXT_OPACITY: 13,
  INK_COLOR: 21,
  INK_THICKNESS: 22,
  INK_OPACITY: 23,
  HIGHLIGHT_COLOR: 31,
  HIGHLIGHT_DEFAULT_COLOR: 32,
  HIGHLIGHT_THICKNESS: 33,
  HIGHLIGHT_FREE: 34,
  HIGHLIGHT_SHOW_ALL: 35
};
const PermissionFlag$1 = {
  PRINT: 4,
  MODIFY_CONTENTS: 8,
  COPY: 16,
  MODIFY_ANNOTATIONS: 32,
  FILL_INTERACTIVE_FORMS: 256,
  COPY_FOR_ACCESSIBILITY: 512,
  ASSEMBLE: 1024,
  PRINT_HIGH_QUALITY: 2048
};
const TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
const util_ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
const AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
};
const AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
const VerbosityLevel$1 = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
};
const CMapCompressionType$1 = {
  NONE: 0,
  BINARY: 1
};
const OPS$1 = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};
const PasswordResponses$1 = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
let verbosity = VerbosityLevel$1.WARNINGS;
function setVerbosityLevel(level) {
  if (Number.isInteger(level)) {
    verbosity = level;
  }
}
function getVerbosityLevel() {
  return verbosity;
}
function info(msg) {
  if (verbosity >= VerbosityLevel$1.INFOS) {
    console.log(`Info: ${msg}`);
  }
}
function warn(msg) {
  if (verbosity >= VerbosityLevel$1.WARNINGS) {
    console.log(`Warning: ${msg}`);
  }
}
function unreachable(msg) {
  throw new Error(msg);
}
function assert(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}
function _isValidProtocol(url) {
  switch (url?.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return true;
    default:
      return false;
  }
}
function createValidAbsoluteUrl$1(url, baseUrl = null, options = null) {
  if (!url) {
    return null;
  }
  try {
    if (options && typeof url === "string") {
      if (options.addDefaultProtocol && url.startsWith("www.")) {
        const dots = url.match(/\./g);
        if (dots?.length >= 2) {
          url = `http://${url}`;
        }
      }
      if (options.tryConvertEncoding) {
        try {
          url = stringToUTF8String(url);
        } catch {
        }
      }
    }
    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
    if (_isValidProtocol(absoluteUrl)) {
      return absoluteUrl;
    }
  } catch {
  }
  return null;
}
function shadow$1(obj, prop, value, nonSerializable = false) {
  Object.defineProperty(obj, prop, {
    value,
    enumerable: !nonSerializable,
    configurable: true,
    writable: false
  });
  return value;
}
const BaseException = function BaseExceptionClosure() {
  function BaseException2(message, name) {
    if (this.constructor === BaseException2) {
      unreachable("Cannot initialize BaseException.");
    }
    this.message = message;
    this.name = name;
  }
  BaseException2.prototype = new Error();
  BaseException2.constructor = BaseException2;
  return BaseException2;
}();
class PasswordException extends BaseException {
  constructor(msg, code2) {
    super(msg, "PasswordException");
    this.code = code2;
  }
}
class UnknownErrorException extends BaseException {
  constructor(msg, details) {
    super(msg, "UnknownErrorException");
    this.details = details;
  }
}
let InvalidPDFException$1 = class InvalidPDFException extends BaseException {
  constructor(msg) {
    super(msg, "InvalidPDFException");
  }
};
let MissingPDFException$1 = class MissingPDFException extends BaseException {
  constructor(msg) {
    super(msg, "MissingPDFException");
  }
};
let UnexpectedResponseException$1 = class UnexpectedResponseException extends BaseException {
  constructor(msg, status) {
    super(msg, "UnexpectedResponseException");
    this.status = status;
  }
};
class FormatError extends BaseException {
  constructor(msg) {
    super(msg, "FormatError");
  }
}
let AbortException$1 = class AbortException extends BaseException {
  constructor(msg) {
    super(msg, "AbortException");
  }
};
function bytesToString(bytes) {
  if (typeof bytes !== "object" || bytes?.length === void 0) {
    unreachable("Invalid argument for bytesToString");
  }
  const length = bytes.length;
  const MAX_ARGUMENT_COUNT = 8192;
  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }
  const strBuf = [];
  for (let i2 = 0; i2 < length; i2 += MAX_ARGUMENT_COUNT) {
    const chunkEnd = Math.min(i2 + MAX_ARGUMENT_COUNT, length);
    const chunk = bytes.subarray(i2, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }
  return strBuf.join("");
}
function stringToBytes(str) {
  if (typeof str !== "string") {
    unreachable("Invalid argument for stringToBytes");
  }
  const length = str.length;
  const bytes = new Uint8Array(length);
  for (let i2 = 0; i2 < length; ++i2) {
    bytes[i2] = str.charCodeAt(i2) & 255;
  }
  return bytes;
}
function string32(value) {
  return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
}
function objectFromMap(map) {
  const obj = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of map) {
    obj[key] = value;
  }
  return obj;
}
function isLittleEndian() {
  const buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}
function isEvalSupported() {
  try {
    new Function("");
    return true;
  } catch {
    return false;
  }
}
class util_FeatureTest {
  static get isLittleEndian() {
    return shadow$1(this, "isLittleEndian", isLittleEndian());
  }
  static get isEvalSupported() {
    return shadow$1(this, "isEvalSupported", isEvalSupported());
  }
  static get isOffscreenCanvasSupported() {
    return shadow$1(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
  }
  static get platform() {
    if (typeof navigator !== "undefined" && typeof navigator?.platform === "string") {
      return shadow$1(this, "platform", {
        isMac: navigator.platform.includes("Mac")
      });
    }
    return shadow$1(this, "platform", {
      isMac: false
    });
  }
  static get isCSSRoundSupported() {
    return shadow$1(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
  }
}
const hexNumbers = Array.from(Array(256).keys(), (n2) => n2.toString(16).padStart(2, "0"));
let Util$1 = class Util {
  static makeHexColor(r2, g2, b2) {
    return `#${hexNumbers[r2]}${hexNumbers[g2]}${hexNumbers[b2]}`;
  }
  static scaleMinMax(transform2, minMax) {
    let temp;
    if (transform2[0]) {
      if (transform2[0] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[2];
        minMax[2] = temp;
      }
      minMax[0] *= transform2[0];
      minMax[2] *= transform2[0];
      if (transform2[3] < 0) {
        temp = minMax[1];
        minMax[1] = minMax[3];
        minMax[3] = temp;
      }
      minMax[1] *= transform2[3];
      minMax[3] *= transform2[3];
    } else {
      temp = minMax[0];
      minMax[0] = minMax[1];
      minMax[1] = temp;
      temp = minMax[2];
      minMax[2] = minMax[3];
      minMax[3] = temp;
      if (transform2[1] < 0) {
        temp = minMax[1];
        minMax[1] = minMax[3];
        minMax[3] = temp;
      }
      minMax[1] *= transform2[1];
      minMax[3] *= transform2[1];
      if (transform2[2] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[2];
        minMax[2] = temp;
      }
      minMax[0] *= transform2[2];
      minMax[2] *= transform2[2];
    }
    minMax[0] += transform2[4];
    minMax[1] += transform2[5];
    minMax[2] += transform2[4];
    minMax[3] += transform2[5];
  }
  static transform(m1, m2) {
    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  }
  static applyTransform(p2, m2) {
    const xt = p2[0] * m2[0] + p2[1] * m2[2] + m2[4];
    const yt = p2[0] * m2[1] + p2[1] * m2[3] + m2[5];
    return [xt, yt];
  }
  static applyInverseTransform(p2, m2) {
    const d = m2[0] * m2[3] - m2[1] * m2[2];
    const xt = (p2[0] * m2[3] - p2[1] * m2[2] + m2[2] * m2[5] - m2[4] * m2[3]) / d;
    const yt = (-p2[0] * m2[1] + p2[1] * m2[0] + m2[4] * m2[1] - m2[5] * m2[0]) / d;
    return [xt, yt];
  }
  static getAxialAlignedBoundingBox(r2, m2) {
    const p1 = this.applyTransform(r2, m2);
    const p2 = this.applyTransform(r2.slice(2, 4), m2);
    const p3 = this.applyTransform([r2[0], r2[3]], m2);
    const p4 = this.applyTransform([r2[2], r2[1]], m2);
    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
  }
  static inverseTransform(m2) {
    const d = m2[0] * m2[3] - m2[1] * m2[2];
    return [m2[3] / d, -m2[1] / d, -m2[2] / d, m2[0] / d, (m2[2] * m2[5] - m2[4] * m2[3]) / d, (m2[4] * m2[1] - m2[5] * m2[0]) / d];
  }
  static singularValueDecompose2dScale(m2) {
    const transpose = [m2[0], m2[2], m2[1], m2[3]];
    const a2 = m2[0] * transpose[0] + m2[1] * transpose[2];
    const b2 = m2[0] * transpose[1] + m2[1] * transpose[3];
    const c = m2[2] * transpose[0] + m2[3] * transpose[2];
    const d = m2[2] * transpose[1] + m2[3] * transpose[3];
    const first = (a2 + d) / 2;
    const second = Math.sqrt((a2 + d) ** 2 - 4 * (a2 * d - c * b2)) / 2;
    const sx = first + second || 1;
    const sy = first - second || 1;
    return [Math.sqrt(sx), Math.sqrt(sy)];
  }
  static normalizeRect(rect) {
    const r2 = rect.slice(0);
    if (rect[0] > rect[2]) {
      r2[0] = rect[2];
      r2[2] = rect[0];
    }
    if (rect[1] > rect[3]) {
      r2[1] = rect[3];
      r2[3] = rect[1];
    }
    return r2;
  }
  static intersect(rect1, rect2) {
    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
    if (xLow > xHigh) {
      return null;
    }
    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
    if (yLow > yHigh) {
      return null;
    }
    return [xLow, yLow, xHigh, yHigh];
  }
  static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t2, minMax) {
    if (t2 <= 0 || t2 >= 1) {
      return;
    }
    const mt = 1 - t2;
    const tt = t2 * t2;
    const ttt = tt * t2;
    const x4 = mt * (mt * (mt * x0 + 3 * t2 * x1) + 3 * tt * x2) + ttt * x3;
    const y4 = mt * (mt * (mt * y0 + 3 * t2 * y1) + 3 * tt * y2) + ttt * y3;
    minMax[0] = Math.min(minMax[0], x4);
    minMax[1] = Math.min(minMax[1], y4);
    minMax[2] = Math.max(minMax[2], x4);
    minMax[3] = Math.max(minMax[3], y4);
  }
  static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a2, b2, c, minMax) {
    if (Math.abs(a2) < 1e-12) {
      if (Math.abs(b2) >= 1e-12) {
        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b2, minMax);
      }
      return;
    }
    const delta = b2 ** 2 - 4 * c * a2;
    if (delta < 0) {
      return;
    }
    const sqrtDelta = Math.sqrt(delta);
    const a22 = 2 * a2;
    this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b2 + sqrtDelta) / a22, minMax);
    this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b2 - sqrtDelta) / a22, minMax);
  }
  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
    if (minMax) {
      minMax[0] = Math.min(minMax[0], x0, x3);
      minMax[1] = Math.min(minMax[1], y0, y3);
      minMax[2] = Math.max(minMax[2], x0, x3);
      minMax[3] = Math.max(minMax[3], y0, y3);
    } else {
      minMax = [Math.min(x0, x3), Math.min(y0, y3), Math.max(x0, x3), Math.max(y0, y3)];
    }
    this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);
    this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);
    return minMax;
  }
};
function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}
let NormalizeRegex = null;
let NormalizationMap = null;
function normalizeUnicode$1(str) {
  if (!NormalizeRegex) {
    NormalizeRegex = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
    NormalizationMap = /* @__PURE__ */ new Map([["", "t"]]);
  }
  return str.replaceAll(NormalizeRegex, (_2, p1, p2) => p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2));
}
function getUuid() {
  if (typeof crypto !== "undefined" && typeof crypto?.randomUUID === "function") {
    return crypto.randomUUID();
  }
  const buf = new Uint8Array(32);
  if (typeof crypto !== "undefined" && typeof crypto?.getRandomValues === "function") {
    crypto.getRandomValues(buf);
  } else {
    for (let i2 = 0; i2 < 32; i2++) {
      buf[i2] = Math.floor(Math.random() * 255);
    }
  }
  return bytesToString(buf);
}
const AnnotationPrefix = "pdfjs_internal_id_";
const FontRenderOps = {
  BEZIER_CURVE_TO: 0,
  MOVE_TO: 1,
  LINE_TO: 2,
  QUADRATIC_CURVE_TO: 3,
  RESTORE: 4,
  SAVE: 5,
  SCALE: 6,
  TRANSFORM: 7,
  TRANSLATE: 8
};
class BaseFilterFactory {
  constructor() {
    if (this.constructor === BaseFilterFactory) {
      unreachable("Cannot initialize BaseFilterFactory.");
    }
  }
  addFilter(maps) {
    return "none";
  }
  addHCMFilter(fgColor, bgColor) {
    return "none";
  }
  addAlphaFilter(map) {
    return "none";
  }
  addLuminosityFilter(map) {
    return "none";
  }
  addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
    return "none";
  }
  destroy(keepHCM = false) {
  }
}
class BaseCanvasFactory {
  constructor() {
    if (this.constructor === BaseCanvasFactory) {
      unreachable("Cannot initialize BaseCanvasFactory.");
    }
  }
  create(width, height) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }
    const canvas = this._createCanvas(width, height);
    return {
      canvas,
      context: canvas.getContext("2d")
    };
  }
  reset(canvasAndContext, width, height) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }
    canvasAndContext.canvas.width = width;
    canvasAndContext.canvas.height = height;
  }
  destroy(canvasAndContext) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }
    canvasAndContext.canvas.width = 0;
    canvasAndContext.canvas.height = 0;
    canvasAndContext.canvas = null;
    canvasAndContext.context = null;
  }
  _createCanvas(width, height) {
    unreachable("Abstract method `_createCanvas` called.");
  }
}
class BaseCMapReaderFactory {
  constructor({
    baseUrl = null,
    isCompressed = true
  }) {
    if (this.constructor === BaseCMapReaderFactory) {
      unreachable("Cannot initialize BaseCMapReaderFactory.");
    }
    this.baseUrl = baseUrl;
    this.isCompressed = isCompressed;
  }
  async fetch({
    name
  }) {
    if (!this.baseUrl) {
      throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
    }
    if (!name) {
      throw new Error("CMap name must be specified.");
    }
    const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
    const compressionType = this.isCompressed ? CMapCompressionType$1.BINARY : CMapCompressionType$1.NONE;
    return this._fetchData(url, compressionType).catch((reason) => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
    });
  }
  _fetchData(url, compressionType) {
    unreachable("Abstract method `_fetchData` called.");
  }
}
class BaseStandardFontDataFactory {
  constructor({
    baseUrl = null
  }) {
    if (this.constructor === BaseStandardFontDataFactory) {
      unreachable("Cannot initialize BaseStandardFontDataFactory.");
    }
    this.baseUrl = baseUrl;
  }
  async fetch({
    filename
  }) {
    if (!this.baseUrl) {
      throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
    }
    if (!filename) {
      throw new Error("Font filename must be specified.");
    }
    const url = `${this.baseUrl}${filename}`;
    return this._fetchData(url).catch((reason) => {
      throw new Error(`Unable to load font data at: ${url}`);
    });
  }
  _fetchData(url) {
    unreachable("Abstract method `_fetchData` called.");
  }
}
class BaseSVGFactory {
  constructor() {
    if (this.constructor === BaseSVGFactory) {
      unreachable("Cannot initialize BaseSVGFactory.");
    }
  }
  create(width, height, skipDimensions = false) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid SVG dimensions");
    }
    const svg = this._createSVG("svg:svg");
    svg.setAttribute("version", "1.1");
    if (!skipDimensions) {
      svg.setAttribute("width", `${width}px`);
      svg.setAttribute("height", `${height}px`);
    }
    svg.setAttribute("preserveAspectRatio", "none");
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    return svg;
  }
  createElement(type) {
    if (typeof type !== "string") {
      throw new Error("Invalid SVG element type");
    }
    return this._createSVG(type);
  }
  _createSVG(type) {
    unreachable("Abstract method `_createSVG` called.");
  }
}
const SVG_NS = "http://www.w3.org/2000/svg";
let PixelsPerInch$1 = class PixelsPerInch {
  static CSS = 96;
  static PDF = 72;
  static PDF_TO_CSS_UNITS = this.CSS / this.PDF;
};
class DOMFilterFactory extends BaseFilterFactory {
  #_cache;
  #_defs;
  #docId;
  #document;
  #_hcmCache;
  #id = 0;
  constructor({
    docId,
    ownerDocument = globalThis.document
  } = {}) {
    super();
    this.#docId = docId;
    this.#document = ownerDocument;
  }
  get #cache() {
    return this.#_cache ||= /* @__PURE__ */ new Map();
  }
  get #hcmCache() {
    return this.#_hcmCache ||= /* @__PURE__ */ new Map();
  }
  get #defs() {
    if (!this.#_defs) {
      const div = this.#document.createElement("div");
      const {
        style: style2
      } = div;
      style2.visibility = "hidden";
      style2.contain = "strict";
      style2.width = style2.height = 0;
      style2.position = "absolute";
      style2.top = style2.left = 0;
      style2.zIndex = -1;
      const svg = this.#document.createElementNS(SVG_NS, "svg");
      svg.setAttribute("width", 0);
      svg.setAttribute("height", 0);
      this.#_defs = this.#document.createElementNS(SVG_NS, "defs");
      div.append(svg);
      svg.append(this.#_defs);
      this.#document.body.append(div);
    }
    return this.#_defs;
  }
  #createTables(maps) {
    if (maps.length === 1) {
      const mapR2 = maps[0];
      const buffer = new Array(256);
      for (let i2 = 0; i2 < 256; i2++) {
        buffer[i2] = mapR2[i2] / 255;
      }
      const table = buffer.join(",");
      return [table, table, table];
    }
    const [mapR, mapG, mapB] = maps;
    const bufferR = new Array(256);
    const bufferG = new Array(256);
    const bufferB = new Array(256);
    for (let i2 = 0; i2 < 256; i2++) {
      bufferR[i2] = mapR[i2] / 255;
      bufferG[i2] = mapG[i2] / 255;
      bufferB[i2] = mapB[i2] / 255;
    }
    return [bufferR.join(","), bufferG.join(","), bufferB.join(",")];
  }
  addFilter(maps) {
    if (!maps) {
      return "none";
    }
    let value = this.#cache.get(maps);
    if (value) {
      return value;
    }
    const [tableR, tableG, tableB] = this.#createTables(maps);
    const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;
    value = this.#cache.get(key);
    if (value) {
      this.#cache.set(maps, value);
      return value;
    }
    const id2 = `g_${this.#docId}_transfer_map_${this.#id++}`;
    const url = `url(#${id2})`;
    this.#cache.set(maps, url);
    this.#cache.set(key, url);
    const filter = this.#createFilter(id2);
    this.#addTransferMapConversion(tableR, tableG, tableB, filter);
    return url;
  }
  addHCMFilter(fgColor, bgColor) {
    const key = `${fgColor}-${bgColor}`;
    const filterName = "base";
    let info2 = this.#hcmCache.get(filterName);
    if (info2?.key === key) {
      return info2.url;
    }
    if (info2) {
      info2.filter?.remove();
      info2.key = key;
      info2.url = "none";
      info2.filter = null;
    } else {
      info2 = {
        key,
        url: "none",
        filter: null
      };
      this.#hcmCache.set(filterName, info2);
    }
    if (!fgColor || !bgColor) {
      return info2.url;
    }
    const fgRGB = this.#getRGB(fgColor);
    fgColor = Util$1.makeHexColor(...fgRGB);
    const bgRGB = this.#getRGB(bgColor);
    bgColor = Util$1.makeHexColor(...bgRGB);
    this.#defs.style.color = "";
    if (fgColor === "#000000" && bgColor === "#ffffff" || fgColor === bgColor) {
      return info2.url;
    }
    const map = new Array(256);
    for (let i2 = 0; i2 <= 255; i2++) {
      const x2 = i2 / 255;
      map[i2] = x2 <= 0.03928 ? x2 / 12.92 : ((x2 + 0.055) / 1.055) ** 2.4;
    }
    const table = map.join(",");
    const id2 = `g_${this.#docId}_hcm_filter`;
    const filter = info2.filter = this.#createFilter(id2);
    this.#addTransferMapConversion(table, table, table, filter);
    this.#addGrayConversion(filter);
    const getSteps = (c, n2) => {
      const start = fgRGB[c] / 255;
      const end = bgRGB[c] / 255;
      const arr = new Array(n2 + 1);
      for (let i2 = 0; i2 <= n2; i2++) {
        arr[i2] = start + i2 / n2 * (end - start);
      }
      return arr.join(",");
    };
    this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);
    info2.url = `url(#${id2})`;
    return info2.url;
  }
  addAlphaFilter(map) {
    let value = this.#cache.get(map);
    if (value) {
      return value;
    }
    const [tableA] = this.#createTables([map]);
    const key = `alpha_${tableA}`;
    value = this.#cache.get(key);
    if (value) {
      this.#cache.set(map, value);
      return value;
    }
    const id2 = `g_${this.#docId}_alpha_map_${this.#id++}`;
    const url = `url(#${id2})`;
    this.#cache.set(map, url);
    this.#cache.set(key, url);
    const filter = this.#createFilter(id2);
    this.#addTransferMapAlphaConversion(tableA, filter);
    return url;
  }
  addLuminosityFilter(map) {
    let value = this.#cache.get(map || "luminosity");
    if (value) {
      return value;
    }
    let tableA, key;
    if (map) {
      [tableA] = this.#createTables([map]);
      key = `luminosity_${tableA}`;
    } else {
      key = "luminosity";
    }
    value = this.#cache.get(key);
    if (value) {
      this.#cache.set(map, value);
      return value;
    }
    const id2 = `g_${this.#docId}_luminosity_map_${this.#id++}`;
    const url = `url(#${id2})`;
    this.#cache.set(map, url);
    this.#cache.set(key, url);
    const filter = this.#createFilter(id2);
    this.#addLuminosityConversion(filter);
    if (map) {
      this.#addTransferMapAlphaConversion(tableA, filter);
    }
    return url;
  }
  addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
    const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;
    let info2 = this.#hcmCache.get(filterName);
    if (info2?.key === key) {
      return info2.url;
    }
    if (info2) {
      info2.filter?.remove();
      info2.key = key;
      info2.url = "none";
      info2.filter = null;
    } else {
      info2 = {
        key,
        url: "none",
        filter: null
      };
      this.#hcmCache.set(filterName, info2);
    }
    if (!fgColor || !bgColor) {
      return info2.url;
    }
    const [fgRGB, bgRGB] = [fgColor, bgColor].map(this.#getRGB.bind(this));
    let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);
    let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);
    let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(this.#getRGB.bind(this));
    if (bgGray < fgGray) {
      [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];
    }
    this.#defs.style.color = "";
    const getSteps = (fg, bg, n2) => {
      const arr = new Array(256);
      const step = (bgGray - fgGray) / n2;
      const newStart = fg / 255;
      const newStep = (bg - fg) / (255 * n2);
      let prev = 0;
      for (let i2 = 0; i2 <= n2; i2++) {
        const k2 = Math.round(fgGray + i2 * step);
        const value = newStart + i2 * newStep;
        for (let j = prev; j <= k2; j++) {
          arr[j] = value;
        }
        prev = k2 + 1;
      }
      for (let i2 = prev; i2 < 256; i2++) {
        arr[i2] = arr[prev - 1];
      }
      return arr.join(",");
    };
    const id2 = `g_${this.#docId}_hcm_${filterName}_filter`;
    const filter = info2.filter = this.#createFilter(id2);
    this.#addGrayConversion(filter);
    this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);
    info2.url = `url(#${id2})`;
    return info2.url;
  }
  destroy(keepHCM = false) {
    if (keepHCM && this.#hcmCache.size !== 0) {
      return;
    }
    if (this.#_defs) {
      this.#_defs.parentNode.parentNode.remove();
      this.#_defs = null;
    }
    if (this.#_cache) {
      this.#_cache.clear();
      this.#_cache = null;
    }
    this.#id = 0;
  }
  #addLuminosityConversion(filter) {
    const feColorMatrix = this.#document.createElementNS(SVG_NS, "feColorMatrix");
    feColorMatrix.setAttribute("type", "matrix");
    feColorMatrix.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0");
    filter.append(feColorMatrix);
  }
  #addGrayConversion(filter) {
    const feColorMatrix = this.#document.createElementNS(SVG_NS, "feColorMatrix");
    feColorMatrix.setAttribute("type", "matrix");
    feColorMatrix.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");
    filter.append(feColorMatrix);
  }
  #createFilter(id2) {
    const filter = this.#document.createElementNS(SVG_NS, "filter");
    filter.setAttribute("color-interpolation-filters", "sRGB");
    filter.setAttribute("id", id2);
    this.#defs.append(filter);
    return filter;
  }
  #appendFeFunc(feComponentTransfer, func, table) {
    const feFunc = this.#document.createElementNS(SVG_NS, func);
    feFunc.setAttribute("type", "discrete");
    feFunc.setAttribute("tableValues", table);
    feComponentTransfer.append(feFunc);
  }
  #addTransferMapConversion(rTable, gTable, bTable, filter) {
    const feComponentTransfer = this.#document.createElementNS(SVG_NS, "feComponentTransfer");
    filter.append(feComponentTransfer);
    this.#appendFeFunc(feComponentTransfer, "feFuncR", rTable);
    this.#appendFeFunc(feComponentTransfer, "feFuncG", gTable);
    this.#appendFeFunc(feComponentTransfer, "feFuncB", bTable);
  }
  #addTransferMapAlphaConversion(aTable, filter) {
    const feComponentTransfer = this.#document.createElementNS(SVG_NS, "feComponentTransfer");
    filter.append(feComponentTransfer);
    this.#appendFeFunc(feComponentTransfer, "feFuncA", aTable);
  }
  #getRGB(color) {
    this.#defs.style.color = color;
    return getRGB(getComputedStyle(this.#defs).getPropertyValue("color"));
  }
}
class DOMCanvasFactory extends BaseCanvasFactory {
  constructor({
    ownerDocument = globalThis.document
  } = {}) {
    super();
    this._document = ownerDocument;
  }
  _createCanvas(width, height) {
    const canvas = this._document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }
}
async function fetchData$1(url, type = "text") {
  if (isValidFetchUrl(url, document.baseURI)) {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(response.statusText);
    }
    switch (type) {
      case "arraybuffer":
        return response.arrayBuffer();
      case "blob":
        return response.blob();
      case "json":
        return response.json();
    }
    return response.text();
  }
  return new Promise((resolve2, reject) => {
    const request = new XMLHttpRequest();
    request.open("GET", url, true);
    request.responseType = type;
    request.onreadystatechange = () => {
      if (request.readyState !== XMLHttpRequest.DONE) {
        return;
      }
      if (request.status === 200 || request.status === 0) {
        switch (type) {
          case "arraybuffer":
          case "blob":
          case "json":
            resolve2(request.response);
            return;
        }
        resolve2(request.responseText);
        return;
      }
      reject(new Error(request.statusText));
    };
    request.send(null);
  });
}
class DOMCMapReaderFactory extends BaseCMapReaderFactory {
  _fetchData(url, compressionType) {
    return fetchData$1(url, this.isCompressed ? "arraybuffer" : "text").then((data2) => ({
      cMapData: data2 instanceof ArrayBuffer ? new Uint8Array(data2) : stringToBytes(data2),
      compressionType
    }));
  }
}
class DOMStandardFontDataFactory extends BaseStandardFontDataFactory {
  _fetchData(url) {
    return fetchData$1(url, "arraybuffer").then((data2) => new Uint8Array(data2));
  }
}
let DOMSVGFactory$1 = class DOMSVGFactory extends BaseSVGFactory {
  _createSVG(type) {
    return document.createElementNS(SVG_NS, type);
  }
};
class PageViewport {
  constructor({
    viewBox,
    scale,
    rotation,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  }) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    const centerX = (viewBox[2] + viewBox[0]) / 2;
    const centerY = (viewBox[3] + viewBox[1]) / 2;
    let rotateA, rotateB, rotateC, rotateD;
    rotation %= 360;
    if (rotation < 0) {
      rotation += 360;
    }
    switch (rotation) {
      case 180:
        rotateA = -1;
        rotateB = 0;
        rotateC = 0;
        rotateD = 1;
        break;
      case 90:
        rotateA = 0;
        rotateB = 1;
        rotateC = 1;
        rotateD = 0;
        break;
      case 270:
        rotateA = 0;
        rotateB = -1;
        rotateC = -1;
        rotateD = 0;
        break;
      case 0:
        rotateA = 1;
        rotateB = 0;
        rotateC = 0;
        rotateD = -1;
        break;
      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }
    if (dontFlip) {
      rotateC = -rotateC;
      rotateD = -rotateD;
    }
    let offsetCanvasX, offsetCanvasY;
    let width, height;
    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = (viewBox[3] - viewBox[1]) * scale;
      height = (viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = (viewBox[2] - viewBox[0]) * scale;
      height = (viewBox[3] - viewBox[1]) * scale;
    }
    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
    this.width = width;
    this.height = height;
  }
  get rawDims() {
    const {
      viewBox
    } = this;
    return shadow$1(this, "rawDims", {
      pageWidth: viewBox[2] - viewBox[0],
      pageHeight: viewBox[3] - viewBox[1],
      pageX: viewBox[0],
      pageY: viewBox[1]
    });
  }
  clone({
    scale = this.scale,
    rotation = this.rotation,
    offsetX = this.offsetX,
    offsetY = this.offsetY,
    dontFlip = false
  } = {}) {
    return new PageViewport({
      viewBox: this.viewBox.slice(),
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }
  convertToViewportPoint(x2, y2) {
    return Util$1.applyTransform([x2, y2], this.transform);
  }
  convertToViewportRectangle(rect) {
    const topLeft = Util$1.applyTransform([rect[0], rect[1]], this.transform);
    const bottomRight = Util$1.applyTransform([rect[2], rect[3]], this.transform);
    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
  }
  convertToPdfPoint(x2, y2) {
    return Util$1.applyInverseTransform([x2, y2], this.transform);
  }
}
let RenderingCancelledException$1 = class RenderingCancelledException extends BaseException {
  constructor(msg, extraDelay = 0) {
    super(msg, "RenderingCancelledException");
    this.extraDelay = extraDelay;
  }
};
function isDataScheme$1(url) {
  const ii = url.length;
  let i2 = 0;
  while (i2 < ii && url[i2].trim() === "") {
    i2++;
  }
  return url.substring(i2, i2 + 5).toLowerCase() === "data:";
}
function isPdfFile$1(filename) {
  return typeof filename === "string" && /\.pdf$/i.test(filename);
}
function getFilenameFromUrl$1(url) {
  [url] = url.split(/[#?]/, 1);
  return url.substring(url.lastIndexOf("/") + 1);
}
function getPdfFilenameFromUrl$1(url, defaultFilename = "document.pdf") {
  if (typeof url !== "string") {
    return defaultFilename;
  }
  if (isDataScheme$1(url)) {
    warn('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
    return defaultFilename;
  }
  const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
  const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
  const splitURI = reURI.exec(url);
  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
  if (suggestedFilename) {
    suggestedFilename = suggestedFilename[0];
    if (suggestedFilename.includes("%")) {
      try {
        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
      } catch {
      }
    }
  }
  return suggestedFilename || defaultFilename;
}
class StatTimer {
  started = /* @__PURE__ */ Object.create(null);
  times = [];
  time(name) {
    if (name in this.started) {
      warn(`Timer is already running for ${name}`);
    }
    this.started[name] = Date.now();
  }
  timeEnd(name) {
    if (!(name in this.started)) {
      warn(`Timer has not been started for ${name}`);
    }
    this.times.push({
      name,
      start: this.started[name],
      end: Date.now()
    });
    delete this.started[name];
  }
  toString() {
    const outBuf = [];
    let longest = 0;
    for (const {
      name
    } of this.times) {
      longest = Math.max(name.length, longest);
    }
    for (const {
      name,
      start,
      end
    } of this.times) {
      outBuf.push(`${name.padEnd(longest)} ${end - start}ms
`);
    }
    return outBuf.join("");
  }
}
function isValidFetchUrl(url, baseUrl) {
  try {
    const {
      protocol
    } = baseUrl ? new URL(url, baseUrl) : new URL(url);
    return protocol === "http:" || protocol === "https:";
  } catch {
    return false;
  }
}
function noContextMenu$1(e2) {
  e2.preventDefault();
}
function deprecated(details) {
  console.log("Deprecated API usage: " + details);
}
let pdfDateStringRegex;
let PDFDateString$1 = class PDFDateString {
  static toDateObject(input) {
    if (!input || typeof input !== "string") {
      return null;
    }
    pdfDateStringRegex ||= new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
    const matches = pdfDateStringRegex.exec(input);
    if (!matches) {
      return null;
    }
    const year = parseInt(matches[1], 10);
    let month = parseInt(matches[2], 10);
    month = month >= 1 && month <= 12 ? month - 1 : 0;
    let day = parseInt(matches[3], 10);
    day = day >= 1 && day <= 31 ? day : 1;
    let hour = parseInt(matches[4], 10);
    hour = hour >= 0 && hour <= 23 ? hour : 0;
    let minute = parseInt(matches[5], 10);
    minute = minute >= 0 && minute <= 59 ? minute : 0;
    let second = parseInt(matches[6], 10);
    second = second >= 0 && second <= 59 ? second : 0;
    const universalTimeRelation = matches[7] || "Z";
    let offsetHour = parseInt(matches[8], 10);
    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
    let offsetMinute = parseInt(matches[9], 10) || 0;
    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
    if (universalTimeRelation === "-") {
      hour += offsetHour;
      minute += offsetMinute;
    } else if (universalTimeRelation === "+") {
      hour -= offsetHour;
      minute -= offsetMinute;
    }
    return new Date(Date.UTC(year, month, day, hour, minute, second));
  }
};
function getXfaPageViewport$1(xfaPage, {
  scale = 1,
  rotation = 0
}) {
  const {
    width,
    height
  } = xfaPage.attributes.style;
  const viewBox = [0, 0, parseInt(width), parseInt(height)];
  return new PageViewport({
    viewBox,
    scale,
    rotation
  });
}
function getRGB(color) {
  if (color.startsWith("#")) {
    const colorRGB = parseInt(color.slice(1), 16);
    return [(colorRGB & 16711680) >> 16, (colorRGB & 65280) >> 8, colorRGB & 255];
  }
  if (color.startsWith("rgb(")) {
    return color.slice(4, -1).split(",").map((x2) => parseInt(x2));
  }
  if (color.startsWith("rgba(")) {
    return color.slice(5, -1).split(",").map((x2) => parseInt(x2)).slice(0, 3);
  }
  warn(`Not a valid color format: "${color}"`);
  return [0, 0, 0];
}
function getColorValues(colors) {
  const span = document.createElement("span");
  span.style.visibility = "hidden";
  document.body.append(span);
  for (const name of colors.keys()) {
    span.style.color = name;
    const computedColor = window.getComputedStyle(span).color;
    colors.set(name, getRGB(computedColor));
  }
  span.remove();
}
function getCurrentTransform(ctx) {
  const {
    a: a2,
    b: b2,
    c,
    d,
    e: e2,
    f: f2
  } = ctx.getTransform();
  return [a2, b2, c, d, e2, f2];
}
function getCurrentTransformInverse(ctx) {
  const {
    a: a2,
    b: b2,
    c,
    d,
    e: e2,
    f: f2
  } = ctx.getTransform().invertSelf();
  return [a2, b2, c, d, e2, f2];
}
function setLayerDimensions$1(div, viewport, mustFlip = false, mustRotate = true) {
  if (viewport instanceof PageViewport) {
    const {
      pageWidth,
      pageHeight
    } = viewport.rawDims;
    const {
      style: style2
    } = div;
    const useRound = util_FeatureTest.isCSSRoundSupported;
    const w2 = `var(--scale-factor) * ${pageWidth}px`, h2 = `var(--scale-factor) * ${pageHeight}px`;
    const widthStr = useRound ? `round(${w2}, 1px)` : `calc(${w2})`, heightStr = useRound ? `round(${h2}, 1px)` : `calc(${h2})`;
    if (!mustFlip || viewport.rotation % 180 === 0) {
      style2.width = widthStr;
      style2.height = heightStr;
    } else {
      style2.width = heightStr;
      style2.height = widthStr;
    }
  }
  if (mustRotate) {
    div.setAttribute("data-main-rotation", viewport.rotation);
  }
}
class EditorToolbar {
  #toolbar = null;
  #colorPicker = null;
  #editor;
  #buttons = null;
  constructor(editor) {
    this.#editor = editor;
  }
  render() {
    const editToolbar = this.#toolbar = document.createElement("div");
    editToolbar.className = "editToolbar";
    editToolbar.setAttribute("role", "toolbar");
    editToolbar.addEventListener("contextmenu", noContextMenu$1);
    editToolbar.addEventListener("pointerdown", EditorToolbar.#pointerDown);
    const buttons = this.#buttons = document.createElement("div");
    buttons.className = "buttons";
    editToolbar.append(buttons);
    const position = this.#editor.toolbarPosition;
    if (position) {
      const {
        style: style2
      } = editToolbar;
      const x2 = this.#editor._uiManager.direction === "ltr" ? 1 - position[0] : position[0];
      style2.insetInlineEnd = `${100 * x2}%`;
      style2.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;
    }
    this.#addDeleteButton();
    return editToolbar;
  }
  static #pointerDown(e2) {
    e2.stopPropagation();
  }
  #focusIn(e2) {
    this.#editor._focusEventsAllowed = false;
    e2.preventDefault();
    e2.stopPropagation();
  }
  #focusOut(e2) {
    this.#editor._focusEventsAllowed = true;
    e2.preventDefault();
    e2.stopPropagation();
  }
  #addListenersToElement(element) {
    element.addEventListener("focusin", this.#focusIn.bind(this), {
      capture: true
    });
    element.addEventListener("focusout", this.#focusOut.bind(this), {
      capture: true
    });
    element.addEventListener("contextmenu", noContextMenu$1);
  }
  hide() {
    this.#toolbar.classList.add("hidden");
    this.#colorPicker?.hideDropdown();
  }
  show() {
    this.#toolbar.classList.remove("hidden");
  }
  #addDeleteButton() {
    const button = document.createElement("button");
    button.className = "delete";
    button.tabIndex = 0;
    button.setAttribute("data-l10n-id", `pdfjs-editor-remove-${this.#editor.editorType}-button`);
    this.#addListenersToElement(button);
    button.addEventListener("click", (e2) => {
      this.#editor._uiManager.delete();
    });
    this.#buttons.append(button);
  }
  get #divider() {
    const divider = document.createElement("div");
    divider.className = "divider";
    return divider;
  }
  addAltTextButton(button) {
    this.#addListenersToElement(button);
    this.#buttons.prepend(button, this.#divider);
  }
  addColorPicker(colorPicker) {
    this.#colorPicker = colorPicker;
    const button = colorPicker.renderButton();
    this.#addListenersToElement(button);
    this.#buttons.prepend(button, this.#divider);
  }
  remove() {
    this.#toolbar.remove();
    this.#colorPicker?.destroy();
    this.#colorPicker = null;
  }
}
class HighlightToolbar {
  #buttons = null;
  #toolbar = null;
  #uiManager;
  constructor(uiManager) {
    this.#uiManager = uiManager;
  }
  #render() {
    const editToolbar = this.#toolbar = document.createElement("div");
    editToolbar.className = "editToolbar";
    editToolbar.setAttribute("role", "toolbar");
    editToolbar.addEventListener("contextmenu", noContextMenu$1);
    const buttons = this.#buttons = document.createElement("div");
    buttons.className = "buttons";
    editToolbar.append(buttons);
    this.#addHighlightButton();
    return editToolbar;
  }
  #getLastPoint(boxes, isLTR) {
    let lastY = 0;
    let lastX = 0;
    for (const box of boxes) {
      const y2 = box.y + box.height;
      if (y2 < lastY) {
        continue;
      }
      const x2 = box.x + (isLTR ? box.width : 0);
      if (y2 > lastY) {
        lastX = x2;
        lastY = y2;
        continue;
      }
      if (isLTR) {
        if (x2 > lastX) {
          lastX = x2;
        }
      } else if (x2 < lastX) {
        lastX = x2;
      }
    }
    return [isLTR ? 1 - lastX : lastX, lastY];
  }
  show(parent, boxes, isLTR) {
    const [x2, y2] = this.#getLastPoint(boxes, isLTR);
    const {
      style: style2
    } = this.#toolbar ||= this.#render();
    parent.append(this.#toolbar);
    style2.insetInlineEnd = `${100 * x2}%`;
    style2.top = `calc(${100 * y2}% + var(--editor-toolbar-vert-offset))`;
  }
  hide() {
    this.#toolbar.remove();
  }
  #addHighlightButton() {
    const button = document.createElement("button");
    button.className = "highlightButton";
    button.tabIndex = 0;
    button.setAttribute("data-l10n-id", `pdfjs-highlight-floating-button1`);
    const span = document.createElement("span");
    button.append(span);
    span.className = "visuallyHidden";
    span.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label");
    button.addEventListener("contextmenu", noContextMenu$1);
    button.addEventListener("click", () => {
      this.#uiManager.highlightSelection("floating_button");
    });
    this.#buttons.append(button);
  }
}
function bindEvents(obj, element, names) {
  for (const name of names) {
    element.addEventListener(name, obj[name].bind(obj));
  }
}
function opacityToHex(opacity) {
  return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, "0");
}
class IdManager {
  #id = 0;
  get id() {
    return `${AnnotationEditorPrefix}${this.#id++}`;
  }
}
class ImageManager {
  #baseId = getUuid();
  #id = 0;
  #cache = null;
  static get _isSVGFittingCanvas() {
    const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>`;
    const canvas = new OffscreenCanvas(1, 3);
    const ctx = canvas.getContext("2d");
    const image = new Image();
    image.src = svg;
    const promise = image.decode().then(() => {
      ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);
      return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
    });
    return shadow$1(this, "_isSVGFittingCanvas", promise);
  }
  async #get(key, rawData) {
    this.#cache ||= /* @__PURE__ */ new Map();
    let data2 = this.#cache.get(key);
    if (data2 === null) {
      return null;
    }
    if (data2?.bitmap) {
      data2.refCounter += 1;
      return data2;
    }
    try {
      data2 ||= {
        bitmap: null,
        id: `image_${this.#baseId}_${this.#id++}`,
        refCounter: 0,
        isSvg: false
      };
      let image;
      if (typeof rawData === "string") {
        data2.url = rawData;
        image = await fetchData$1(rawData, "blob");
      } else {
        image = data2.file = rawData;
      }
      if (image.type === "image/svg+xml") {
        const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;
        const fileReader = new FileReader();
        const imageElement = new Image();
        const imagePromise = new Promise((resolve2, reject) => {
          imageElement.onload = () => {
            data2.bitmap = imageElement;
            data2.isSvg = true;
            resolve2();
          };
          fileReader.onload = async () => {
            const url = data2.svgUrl = fileReader.result;
            imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;
          };
          imageElement.onerror = fileReader.onerror = reject;
        });
        fileReader.readAsDataURL(image);
        await imagePromise;
      } else {
        data2.bitmap = await createImageBitmap(image);
      }
      data2.refCounter = 1;
    } catch (e2) {
      console.error(e2);
      data2 = null;
    }
    this.#cache.set(key, data2);
    if (data2) {
      this.#cache.set(data2.id, data2);
    }
    return data2;
  }
  async getFromFile(file2) {
    const {
      lastModified,
      name,
      size: size2,
      type
    } = file2;
    return this.#get(`${lastModified}_${name}_${size2}_${type}`, file2);
  }
  async getFromUrl(url) {
    return this.#get(url, url);
  }
  async getFromId(id2) {
    this.#cache ||= /* @__PURE__ */ new Map();
    const data2 = this.#cache.get(id2);
    if (!data2) {
      return null;
    }
    if (data2.bitmap) {
      data2.refCounter += 1;
      return data2;
    }
    if (data2.file) {
      return this.getFromFile(data2.file);
    }
    return this.getFromUrl(data2.url);
  }
  getSvgUrl(id2) {
    const data2 = this.#cache.get(id2);
    if (!data2?.isSvg) {
      return null;
    }
    return data2.svgUrl;
  }
  deleteId(id2) {
    this.#cache ||= /* @__PURE__ */ new Map();
    const data2 = this.#cache.get(id2);
    if (!data2) {
      return;
    }
    data2.refCounter -= 1;
    if (data2.refCounter !== 0) {
      return;
    }
    data2.bitmap = null;
  }
  isValidId(id2) {
    return id2.startsWith(`image_${this.#baseId}_`);
  }
}
class CommandManager {
  #commands = [];
  #locked = false;
  #maxSize;
  #position = -1;
  constructor(maxSize = 128) {
    this.#maxSize = maxSize;
  }
  add({
    cmd,
    undo,
    post,
    mustExec,
    type = NaN,
    overwriteIfSameType = false,
    keepUndo = false
  }) {
    if (mustExec) {
      cmd();
    }
    if (this.#locked) {
      return;
    }
    const save = {
      cmd,
      undo,
      post,
      type
    };
    if (this.#position === -1) {
      if (this.#commands.length > 0) {
        this.#commands.length = 0;
      }
      this.#position = 0;
      this.#commands.push(save);
      return;
    }
    if (overwriteIfSameType && this.#commands[this.#position].type === type) {
      if (keepUndo) {
        save.undo = this.#commands[this.#position].undo;
      }
      this.#commands[this.#position] = save;
      return;
    }
    const next = this.#position + 1;
    if (next === this.#maxSize) {
      this.#commands.splice(0, 1);
    } else {
      this.#position = next;
      if (next < this.#commands.length) {
        this.#commands.splice(next);
      }
    }
    this.#commands.push(save);
  }
  undo() {
    if (this.#position === -1) {
      return;
    }
    this.#locked = true;
    const {
      undo,
      post
    } = this.#commands[this.#position];
    undo();
    post?.();
    this.#locked = false;
    this.#position -= 1;
  }
  redo() {
    if (this.#position < this.#commands.length - 1) {
      this.#position += 1;
      this.#locked = true;
      const {
        cmd,
        post
      } = this.#commands[this.#position];
      cmd();
      post?.();
      this.#locked = false;
    }
  }
  hasSomethingToUndo() {
    return this.#position !== -1;
  }
  hasSomethingToRedo() {
    return this.#position < this.#commands.length - 1;
  }
  destroy() {
    this.#commands = null;
  }
}
class KeyboardManager {
  constructor(callbacks) {
    this.buffer = [];
    this.callbacks = /* @__PURE__ */ new Map();
    this.allKeys = /* @__PURE__ */ new Set();
    const {
      isMac
    } = util_FeatureTest.platform;
    for (const [keys, callback, options = {}] of callbacks) {
      for (const key of keys) {
        const isMacKey = key.startsWith("mac+");
        if (isMac && isMacKey) {
          this.callbacks.set(key.slice(4), {
            callback,
            options
          });
          this.allKeys.add(key.split("+").at(-1));
        } else if (!isMac && !isMacKey) {
          this.callbacks.set(key, {
            callback,
            options
          });
          this.allKeys.add(key.split("+").at(-1));
        }
      }
    }
  }
  #serialize(event) {
    if (event.altKey) {
      this.buffer.push("alt");
    }
    if (event.ctrlKey) {
      this.buffer.push("ctrl");
    }
    if (event.metaKey) {
      this.buffer.push("meta");
    }
    if (event.shiftKey) {
      this.buffer.push("shift");
    }
    this.buffer.push(event.key);
    const str = this.buffer.join("+");
    this.buffer.length = 0;
    return str;
  }
  exec(self2, event) {
    if (!this.allKeys.has(event.key)) {
      return;
    }
    const info2 = this.callbacks.get(this.#serialize(event));
    if (!info2) {
      return;
    }
    const {
      callback,
      options: {
        bubbles = false,
        args = [],
        checker = null
      }
    } = info2;
    if (checker && !checker(self2, event)) {
      return;
    }
    callback.bind(self2, ...args, event)();
    if (!bubbles) {
      event.stopPropagation();
      event.preventDefault();
    }
  }
}
class ColorManager {
  static _colorsMapping = /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]);
  get _colors() {
    const colors = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
    getColorValues(colors);
    return shadow$1(this, "_colors", colors);
  }
  convert(color) {
    const rgb = getRGB(color);
    if (!window.matchMedia("(forced-colors: active)").matches) {
      return rgb;
    }
    for (const [name, RGB] of this._colors) {
      if (RGB.every((x2, i2) => x2 === rgb[i2])) {
        return ColorManager._colorsMapping.get(name);
      }
    }
    return rgb;
  }
  getHexCode(name) {
    const rgb = this._colors.get(name);
    if (!rgb) {
      return name;
    }
    return Util$1.makeHexColor(...rgb);
  }
}
let AnnotationEditorUIManager$1 = class AnnotationEditorUIManager {
  #activeEditor = null;
  #allEditors = /* @__PURE__ */ new Map();
  #allLayers = /* @__PURE__ */ new Map();
  #altTextManager = null;
  #annotationStorage = null;
  #changedExistingAnnotations = null;
  #commandManager = new CommandManager();
  #currentPageIndex = 0;
  #deletedAnnotationsElementIds = /* @__PURE__ */ new Set();
  #draggingEditors = null;
  #editorTypes = null;
  #editorsToRescale = /* @__PURE__ */ new Set();
  #enableHighlightFloatingButton = false;
  #filterFactory = null;
  #focusMainContainerTimeoutId = null;
  #highlightColors = null;
  #highlightWhenShiftUp = false;
  #highlightToolbar = null;
  #idManager = new IdManager();
  #isEnabled = false;
  #isWaiting = false;
  #lastActiveElement = null;
  #mainHighlightColorPicker = null;
  #mlManager = null;
  #mode = AnnotationEditorType$1.NONE;
  #selectedEditors = /* @__PURE__ */ new Set();
  #selectedTextNode = null;
  #pageColors = null;
  #showAllStates = null;
  #boundBlur = this.blur.bind(this);
  #boundFocus = this.focus.bind(this);
  #boundCopy = this.copy.bind(this);
  #boundCut = this.cut.bind(this);
  #boundPaste = this.paste.bind(this);
  #boundKeydown = this.keydown.bind(this);
  #boundKeyup = this.keyup.bind(this);
  #boundOnEditingAction = this.onEditingAction.bind(this);
  #boundOnPageChanging = this.onPageChanging.bind(this);
  #boundOnScaleChanging = this.onScaleChanging.bind(this);
  #boundSelectionChange = this.#selectionChange.bind(this);
  #boundOnRotationChanging = this.onRotationChanging.bind(this);
  #previousStates = {
    isEditing: false,
    isEmpty: true,
    hasSomethingToUndo: false,
    hasSomethingToRedo: false,
    hasSelectedEditor: false,
    hasSelectedText: false
  };
  #translation = [0, 0];
  #translationTimeoutId = null;
  #container = null;
  #viewer = null;
  static TRANSLATE_SMALL = 1;
  static TRANSLATE_BIG = 10;
  static get _keyboardManager() {
    const proto = AnnotationEditorUIManager.prototype;
    const arrowChecker = (self2) => self2.#container.contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && self2.hasSomethingToControl();
    const textInputChecker = (_self, {
      target: el
    }) => {
      if (el instanceof HTMLInputElement) {
        const {
          type
        } = el;
        return type !== "text" && type !== "number";
      }
      return true;
    };
    const small = this.TRANSLATE_SMALL;
    const big = this.TRANSLATE_BIG;
    return shadow$1(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], proto.selectAll, {
      checker: textInputChecker
    }], [["ctrl+z", "mac+meta+z"], proto.undo, {
      checker: textInputChecker
    }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], proto.redo, {
      checker: textInputChecker
    }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], proto.delete, {
      checker: textInputChecker
    }], [["Enter", "mac+Enter"], proto.addNewEditorFromKeyboard, {
      checker: (self2, {
        target: el
      }) => !(el instanceof HTMLButtonElement) && self2.#container.contains(el) && !self2.isEnterHandled
    }], [[" ", "mac+ "], proto.addNewEditorFromKeyboard, {
      checker: (self2, {
        target: el
      }) => !(el instanceof HTMLButtonElement) && self2.#container.contains(document.activeElement)
    }], [["Escape", "mac+Escape"], proto.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], proto.translateSelectedEditors, {
      args: [-small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto.translateSelectedEditors, {
      args: [-big, 0],
      checker: arrowChecker
    }], [["ArrowRight", "mac+ArrowRight"], proto.translateSelectedEditors, {
      args: [small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto.translateSelectedEditors, {
      args: [big, 0],
      checker: arrowChecker
    }], [["ArrowUp", "mac+ArrowUp"], proto.translateSelectedEditors, {
      args: [0, -small],
      checker: arrowChecker
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto.translateSelectedEditors, {
      args: [0, -big],
      checker: arrowChecker
    }], [["ArrowDown", "mac+ArrowDown"], proto.translateSelectedEditors, {
      args: [0, small],
      checker: arrowChecker
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto.translateSelectedEditors, {
      args: [0, big],
      checker: arrowChecker
    }]]));
  }
  constructor(container, viewer, altTextManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, mlManager) {
    this.#container = container;
    this.#viewer = viewer;
    this.#altTextManager = altTextManager;
    this._eventBus = eventBus;
    this._eventBus._on("editingaction", this.#boundOnEditingAction);
    this._eventBus._on("pagechanging", this.#boundOnPageChanging);
    this._eventBus._on("scalechanging", this.#boundOnScaleChanging);
    this._eventBus._on("rotationchanging", this.#boundOnRotationChanging);
    this.#addSelectionListener();
    this.#addKeyboardManager();
    this.#annotationStorage = pdfDocument.annotationStorage;
    this.#filterFactory = pdfDocument.filterFactory;
    this.#pageColors = pageColors;
    this.#highlightColors = highlightColors || null;
    this.#enableHighlightFloatingButton = enableHighlightFloatingButton;
    this.#mlManager = mlManager || null;
    this.viewParameters = {
      realScale: PixelsPerInch$1.PDF_TO_CSS_UNITS,
      rotation: 0
    };
    this.isShiftKeyDown = false;
  }
  destroy() {
    this.#removeKeyboardManager();
    this.#removeFocusManager();
    this._eventBus._off("editingaction", this.#boundOnEditingAction);
    this._eventBus._off("pagechanging", this.#boundOnPageChanging);
    this._eventBus._off("scalechanging", this.#boundOnScaleChanging);
    this._eventBus._off("rotationchanging", this.#boundOnRotationChanging);
    for (const layer of this.#allLayers.values()) {
      layer.destroy();
    }
    this.#allLayers.clear();
    this.#allEditors.clear();
    this.#editorsToRescale.clear();
    this.#activeEditor = null;
    this.#selectedEditors.clear();
    this.#commandManager.destroy();
    this.#altTextManager?.destroy();
    this.#highlightToolbar?.hide();
    this.#highlightToolbar = null;
    if (this.#focusMainContainerTimeoutId) {
      clearTimeout(this.#focusMainContainerTimeoutId);
      this.#focusMainContainerTimeoutId = null;
    }
    if (this.#translationTimeoutId) {
      clearTimeout(this.#translationTimeoutId);
      this.#translationTimeoutId = null;
    }
    this.#removeSelectionListener();
  }
  async mlGuess(data2) {
    return this.#mlManager?.guess(data2) || null;
  }
  get hasMLManager() {
    return !!this.#mlManager;
  }
  get hcmFilter() {
    return shadow$1(this, "hcmFilter", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : "none");
  }
  get direction() {
    return shadow$1(this, "direction", getComputedStyle(this.#container).direction);
  }
  get highlightColors() {
    return shadow$1(this, "highlightColors", this.#highlightColors ? new Map(this.#highlightColors.split(",").map((pair) => pair.split("=").map((x2) => x2.trim()))) : null);
  }
  get highlightColorNames() {
    return shadow$1(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (e2) => e2.reverse())) : null);
  }
  setMainHighlightColorPicker(colorPicker) {
    this.#mainHighlightColorPicker = colorPicker;
  }
  editAltText(editor) {
    this.#altTextManager?.editAltText(this, editor);
  }
  onPageChanging({
    pageNumber
  }) {
    this.#currentPageIndex = pageNumber - 1;
  }
  focusMainContainer() {
    this.#container.focus();
  }
  findParent(x2, y2) {
    for (const layer of this.#allLayers.values()) {
      const {
        x: layerX,
        y: layerY,
        width,
        height
      } = layer.div.getBoundingClientRect();
      if (x2 >= layerX && x2 <= layerX + width && y2 >= layerY && y2 <= layerY + height) {
        return layer;
      }
    }
    return null;
  }
  disableUserSelect(value = false) {
    this.#viewer.classList.toggle("noUserSelect", value);
  }
  addShouldRescale(editor) {
    this.#editorsToRescale.add(editor);
  }
  removeShouldRescale(editor) {
    this.#editorsToRescale.delete(editor);
  }
  onScaleChanging({
    scale
  }) {
    this.commitOrRemove();
    this.viewParameters.realScale = scale * PixelsPerInch$1.PDF_TO_CSS_UNITS;
    for (const editor of this.#editorsToRescale) {
      editor.onScaleChanging();
    }
  }
  onRotationChanging({
    pagesRotation
  }) {
    this.commitOrRemove();
    this.viewParameters.rotation = pagesRotation;
  }
  #getAnchorElementForSelection({
    anchorNode
  }) {
    return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;
  }
  highlightSelection(methodOfCreation = "") {
    const selection = document.getSelection();
    if (!selection || selection.isCollapsed) {
      return;
    }
    const {
      anchorNode,
      anchorOffset,
      focusNode,
      focusOffset
    } = selection;
    const text = selection.toString();
    const anchorElement = this.#getAnchorElementForSelection(selection);
    const textLayer = anchorElement.closest(".textLayer");
    const boxes = this.getSelectionBoxes(textLayer);
    if (!boxes) {
      return;
    }
    selection.empty();
    if (this.#mode === AnnotationEditorType$1.NONE) {
      this._eventBus.dispatch("showannotationeditorui", {
        source: this,
        mode: AnnotationEditorType$1.HIGHLIGHT
      });
      this.showAllEditors("highlight", true, true);
    }
    for (const layer of this.#allLayers.values()) {
      if (layer.hasTextLayer(textLayer)) {
        layer.createAndAddNewEditor({
          x: 0,
          y: 0
        }, false, {
          methodOfCreation,
          boxes,
          anchorNode,
          anchorOffset,
          focusNode,
          focusOffset,
          text
        });
        break;
      }
    }
  }
  #displayHighlightToolbar() {
    const selection = document.getSelection();
    if (!selection || selection.isCollapsed) {
      return;
    }
    const anchorElement = this.#getAnchorElementForSelection(selection);
    const textLayer = anchorElement.closest(".textLayer");
    const boxes = this.getSelectionBoxes(textLayer);
    if (!boxes) {
      return;
    }
    this.#highlightToolbar ||= new HighlightToolbar(this);
    this.#highlightToolbar.show(textLayer, boxes, this.direction === "ltr");
  }
  addToAnnotationStorage(editor) {
    if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {
      this.#annotationStorage.setValue(editor.id, editor);
    }
  }
  #selectionChange() {
    const selection = document.getSelection();
    if (!selection || selection.isCollapsed) {
      if (this.#selectedTextNode) {
        this.#highlightToolbar?.hide();
        this.#selectedTextNode = null;
        this.#dispatchUpdateStates({
          hasSelectedText: false
        });
      }
      return;
    }
    const {
      anchorNode
    } = selection;
    if (anchorNode === this.#selectedTextNode) {
      return;
    }
    const anchorElement = this.#getAnchorElementForSelection(selection);
    const textLayer = anchorElement.closest(".textLayer");
    if (!textLayer) {
      if (this.#selectedTextNode) {
        this.#highlightToolbar?.hide();
        this.#selectedTextNode = null;
        this.#dispatchUpdateStates({
          hasSelectedText: false
        });
      }
      return;
    }
    this.#highlightToolbar?.hide();
    this.#selectedTextNode = anchorNode;
    this.#dispatchUpdateStates({
      hasSelectedText: true
    });
    if (this.#mode !== AnnotationEditorType$1.HIGHLIGHT && this.#mode !== AnnotationEditorType$1.NONE) {
      return;
    }
    if (this.#mode === AnnotationEditorType$1.HIGHLIGHT) {
      this.showAllEditors("highlight", true, true);
    }
    this.#highlightWhenShiftUp = this.isShiftKeyDown;
    if (!this.isShiftKeyDown) {
      const pointerup = (e2) => {
        if (e2.type === "pointerup" && e2.button !== 0) {
          return;
        }
        window.removeEventListener("pointerup", pointerup);
        window.removeEventListener("blur", pointerup);
        if (e2.type === "pointerup") {
          this.#onSelectEnd("main_toolbar");
        }
      };
      window.addEventListener("pointerup", pointerup);
      window.addEventListener("blur", pointerup);
    }
  }
  #onSelectEnd(methodOfCreation = "") {
    if (this.#mode === AnnotationEditorType$1.HIGHLIGHT) {
      this.highlightSelection(methodOfCreation);
    } else if (this.#enableHighlightFloatingButton) {
      this.#displayHighlightToolbar();
    }
  }
  #addSelectionListener() {
    document.addEventListener("selectionchange", this.#boundSelectionChange);
  }
  #removeSelectionListener() {
    document.removeEventListener("selectionchange", this.#boundSelectionChange);
  }
  #addFocusManager() {
    window.addEventListener("focus", this.#boundFocus);
    window.addEventListener("blur", this.#boundBlur);
  }
  #removeFocusManager() {
    window.removeEventListener("focus", this.#boundFocus);
    window.removeEventListener("blur", this.#boundBlur);
  }
  blur() {
    this.isShiftKeyDown = false;
    if (this.#highlightWhenShiftUp) {
      this.#highlightWhenShiftUp = false;
      this.#onSelectEnd("main_toolbar");
    }
    if (!this.hasSelection) {
      return;
    }
    const {
      activeElement
    } = document;
    for (const editor of this.#selectedEditors) {
      if (editor.div.contains(activeElement)) {
        this.#lastActiveElement = [editor, activeElement];
        editor._focusEventsAllowed = false;
        break;
      }
    }
  }
  focus() {
    if (!this.#lastActiveElement) {
      return;
    }
    const [lastEditor, lastActiveElement] = this.#lastActiveElement;
    this.#lastActiveElement = null;
    lastActiveElement.addEventListener("focusin", () => {
      lastEditor._focusEventsAllowed = true;
    }, {
      once: true
    });
    lastActiveElement.focus();
  }
  #addKeyboardManager() {
    window.addEventListener("keydown", this.#boundKeydown);
    window.addEventListener("keyup", this.#boundKeyup);
  }
  #removeKeyboardManager() {
    window.removeEventListener("keydown", this.#boundKeydown);
    window.removeEventListener("keyup", this.#boundKeyup);
  }
  #addCopyPasteListeners() {
    document.addEventListener("copy", this.#boundCopy);
    document.addEventListener("cut", this.#boundCut);
    document.addEventListener("paste", this.#boundPaste);
  }
  #removeCopyPasteListeners() {
    document.removeEventListener("copy", this.#boundCopy);
    document.removeEventListener("cut", this.#boundCut);
    document.removeEventListener("paste", this.#boundPaste);
  }
  addEditListeners() {
    this.#addKeyboardManager();
    this.#addCopyPasteListeners();
  }
  removeEditListeners() {
    this.#removeKeyboardManager();
    this.#removeCopyPasteListeners();
  }
  copy(event) {
    event.preventDefault();
    this.#activeEditor?.commitOrRemove();
    if (!this.hasSelection) {
      return;
    }
    const editors = [];
    for (const editor of this.#selectedEditors) {
      const serialized = editor.serialize(true);
      if (serialized) {
        editors.push(serialized);
      }
    }
    if (editors.length === 0) {
      return;
    }
    event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
  }
  cut(event) {
    this.copy(event);
    this.delete();
  }
  paste(event) {
    event.preventDefault();
    const {
      clipboardData
    } = event;
    for (const item of clipboardData.items) {
      for (const editorType of this.#editorTypes) {
        if (editorType.isHandlingMimeForPasting(item.type)) {
          editorType.paste(item, this.currentLayer);
          return;
        }
      }
    }
    let data2 = clipboardData.getData("application/pdfjs");
    if (!data2) {
      return;
    }
    try {
      data2 = JSON.parse(data2);
    } catch (ex) {
      warn(`paste: "${ex.message}".`);
      return;
    }
    if (!Array.isArray(data2)) {
      return;
    }
    this.unselectAll();
    const layer = this.currentLayer;
    try {
      const newEditors = [];
      for (const editor of data2) {
        const deserializedEditor = layer.deserialize(editor);
        if (!deserializedEditor) {
          return;
        }
        newEditors.push(deserializedEditor);
      }
      const cmd = () => {
        for (const editor of newEditors) {
          this.#addEditorToLayer(editor);
        }
        this.#selectEditors(newEditors);
      };
      const undo = () => {
        for (const editor of newEditors) {
          editor.remove();
        }
      };
      this.addCommands({
        cmd,
        undo,
        mustExec: true
      });
    } catch (ex) {
      warn(`paste: "${ex.message}".`);
    }
  }
  keydown(event) {
    if (!this.isShiftKeyDown && event.key === "Shift") {
      this.isShiftKeyDown = true;
    }
    if (this.#mode !== AnnotationEditorType$1.NONE && !this.isEditorHandlingKeyboard) {
      AnnotationEditorUIManager._keyboardManager.exec(this, event);
    }
  }
  keyup(event) {
    if (this.isShiftKeyDown && event.key === "Shift") {
      this.isShiftKeyDown = false;
      if (this.#highlightWhenShiftUp) {
        this.#highlightWhenShiftUp = false;
        this.#onSelectEnd("main_toolbar");
      }
    }
  }
  onEditingAction({
    name
  }) {
    switch (name) {
      case "undo":
      case "redo":
      case "delete":
      case "selectAll":
        this[name]();
        break;
      case "highlightSelection":
        this.highlightSelection("context_menu");
        break;
    }
  }
  #dispatchUpdateStates(details) {
    const hasChanged2 = Object.entries(details).some(([key, value]) => this.#previousStates[key] !== value);
    if (hasChanged2) {
      this._eventBus.dispatch("annotationeditorstateschanged", {
        source: this,
        details: Object.assign(this.#previousStates, details)
      });
      if (this.#mode === AnnotationEditorType$1.HIGHLIGHT && details.hasSelectedEditor === false) {
        this.#dispatchUpdateUI([[AnnotationEditorParamsType$1.HIGHLIGHT_FREE, true]]);
      }
    }
  }
  #dispatchUpdateUI(details) {
    this._eventBus.dispatch("annotationeditorparamschanged", {
      source: this,
      details
    });
  }
  setEditingState(isEditing) {
    if (isEditing) {
      this.#addFocusManager();
      this.#addCopyPasteListeners();
      this.#dispatchUpdateStates({
        isEditing: this.#mode !== AnnotationEditorType$1.NONE,
        isEmpty: this.#isEmpty(),
        hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
        hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
        hasSelectedEditor: false
      });
    } else {
      this.#removeFocusManager();
      this.#removeCopyPasteListeners();
      this.#dispatchUpdateStates({
        isEditing: false
      });
      this.disableUserSelect(false);
    }
  }
  registerEditorTypes(types) {
    if (this.#editorTypes) {
      return;
    }
    this.#editorTypes = types;
    for (const editorType of this.#editorTypes) {
      this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
    }
  }
  getId() {
    return this.#idManager.id;
  }
  get currentLayer() {
    return this.#allLayers.get(this.#currentPageIndex);
  }
  getLayer(pageIndex) {
    return this.#allLayers.get(pageIndex);
  }
  get currentPageIndex() {
    return this.#currentPageIndex;
  }
  addLayer(layer) {
    this.#allLayers.set(layer.pageIndex, layer);
    if (this.#isEnabled) {
      layer.enable();
    } else {
      layer.disable();
    }
  }
  removeLayer(layer) {
    this.#allLayers.delete(layer.pageIndex);
  }
  updateMode(mode, editId = null, isFromKeyboard = false) {
    if (this.#mode === mode) {
      return;
    }
    this.#mode = mode;
    if (mode === AnnotationEditorType$1.NONE) {
      this.setEditingState(false);
      this.#disableAll();
      return;
    }
    this.setEditingState(true);
    this.#enableAll();
    this.unselectAll();
    for (const layer of this.#allLayers.values()) {
      layer.updateMode(mode);
    }
    if (!editId && isFromKeyboard) {
      this.addNewEditorFromKeyboard();
      return;
    }
    if (!editId) {
      return;
    }
    for (const editor of this.#allEditors.values()) {
      if (editor.annotationElementId === editId) {
        this.setSelected(editor);
        editor.enterInEditMode();
        break;
      }
    }
  }
  addNewEditorFromKeyboard() {
    if (this.currentLayer.canCreateNewEmptyEditor()) {
      this.currentLayer.addNewEditor();
    }
  }
  updateToolbar(mode) {
    if (mode === this.#mode) {
      return;
    }
    this._eventBus.dispatch("switchannotationeditormode", {
      source: this,
      mode
    });
  }
  updateParams(type, value) {
    if (!this.#editorTypes) {
      return;
    }
    switch (type) {
      case AnnotationEditorParamsType$1.CREATE:
        this.currentLayer.addNewEditor();
        return;
      case AnnotationEditorParamsType$1.HIGHLIGHT_DEFAULT_COLOR:
        this.#mainHighlightColorPicker?.updateColor(value);
        break;
      case AnnotationEditorParamsType$1.HIGHLIGHT_SHOW_ALL:
        this._eventBus.dispatch("reporttelemetry", {
          source: this,
          details: {
            type: "editing",
            data: {
              type: "highlight",
              action: "toggle_visibility"
            }
          }
        });
        (this.#showAllStates ||= /* @__PURE__ */ new Map()).set(type, value);
        this.showAllEditors("highlight", value);
        break;
    }
    for (const editor of this.#selectedEditors) {
      editor.updateParams(type, value);
    }
    for (const editorType of this.#editorTypes) {
      editorType.updateDefaultParams(type, value);
    }
  }
  showAllEditors(type, visible, updateButton = false) {
    for (const editor of this.#allEditors.values()) {
      if (editor.editorType === type) {
        editor.show(visible);
      }
    }
    const state = this.#showAllStates?.get(AnnotationEditorParamsType$1.HIGHLIGHT_SHOW_ALL) ?? true;
    if (state !== visible) {
      this.#dispatchUpdateUI([[AnnotationEditorParamsType$1.HIGHLIGHT_SHOW_ALL, visible]]);
    }
  }
  enableWaiting(mustWait = false) {
    if (this.#isWaiting === mustWait) {
      return;
    }
    this.#isWaiting = mustWait;
    for (const layer of this.#allLayers.values()) {
      if (mustWait) {
        layer.disableClick();
      } else {
        layer.enableClick();
      }
      layer.div.classList.toggle("waiting", mustWait);
    }
  }
  #enableAll() {
    if (!this.#isEnabled) {
      this.#isEnabled = true;
      for (const layer of this.#allLayers.values()) {
        layer.enable();
      }
      for (const editor of this.#allEditors.values()) {
        editor.enable();
      }
    }
  }
  #disableAll() {
    this.unselectAll();
    if (this.#isEnabled) {
      this.#isEnabled = false;
      for (const layer of this.#allLayers.values()) {
        layer.disable();
      }
      for (const editor of this.#allEditors.values()) {
        editor.disable();
      }
    }
  }
  getEditors(pageIndex) {
    const editors = [];
    for (const editor of this.#allEditors.values()) {
      if (editor.pageIndex === pageIndex) {
        editors.push(editor);
      }
    }
    return editors;
  }
  getEditor(id2) {
    return this.#allEditors.get(id2);
  }
  addEditor(editor) {
    this.#allEditors.set(editor.id, editor);
  }
  removeEditor(editor) {
    if (editor.div.contains(document.activeElement)) {
      if (this.#focusMainContainerTimeoutId) {
        clearTimeout(this.#focusMainContainerTimeoutId);
      }
      this.#focusMainContainerTimeoutId = setTimeout(() => {
        this.focusMainContainer();
        this.#focusMainContainerTimeoutId = null;
      }, 0);
    }
    this.#allEditors.delete(editor.id);
    this.unselect(editor);
    if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {
      this.#annotationStorage?.remove(editor.id);
    }
  }
  addDeletedAnnotationElement(editor) {
    this.#deletedAnnotationsElementIds.add(editor.annotationElementId);
    this.addChangedExistingAnnotation(editor);
    editor.deleted = true;
  }
  isDeletedAnnotationElement(annotationElementId) {
    return this.#deletedAnnotationsElementIds.has(annotationElementId);
  }
  removeDeletedAnnotationElement(editor) {
    this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);
    this.removeChangedExistingAnnotation(editor);
    editor.deleted = false;
  }
  #addEditorToLayer(editor) {
    const layer = this.#allLayers.get(editor.pageIndex);
    if (layer) {
      layer.addOrRebuild(editor);
    } else {
      this.addEditor(editor);
      this.addToAnnotationStorage(editor);
    }
  }
  setActiveEditor(editor) {
    if (this.#activeEditor === editor) {
      return;
    }
    this.#activeEditor = editor;
    if (editor) {
      this.#dispatchUpdateUI(editor.propertiesToUpdate);
    }
  }
  get #lastSelectedEditor() {
    let ed = null;
    for (ed of this.#selectedEditors) {
    }
    return ed;
  }
  updateUI(editor) {
    if (this.#lastSelectedEditor === editor) {
      this.#dispatchUpdateUI(editor.propertiesToUpdate);
    }
  }
  toggleSelected(editor) {
    if (this.#selectedEditors.has(editor)) {
      this.#selectedEditors.delete(editor);
      editor.unselect();
      this.#dispatchUpdateStates({
        hasSelectedEditor: this.hasSelection
      });
      return;
    }
    this.#selectedEditors.add(editor);
    editor.select();
    this.#dispatchUpdateUI(editor.propertiesToUpdate);
    this.#dispatchUpdateStates({
      hasSelectedEditor: true
    });
  }
  setSelected(editor) {
    for (const ed of this.#selectedEditors) {
      if (ed !== editor) {
        ed.unselect();
      }
    }
    this.#selectedEditors.clear();
    this.#selectedEditors.add(editor);
    editor.select();
    this.#dispatchUpdateUI(editor.propertiesToUpdate);
    this.#dispatchUpdateStates({
      hasSelectedEditor: true
    });
  }
  isSelected(editor) {
    return this.#selectedEditors.has(editor);
  }
  get firstSelectedEditor() {
    return this.#selectedEditors.values().next().value;
  }
  unselect(editor) {
    editor.unselect();
    this.#selectedEditors.delete(editor);
    this.#dispatchUpdateStates({
      hasSelectedEditor: this.hasSelection
    });
  }
  get hasSelection() {
    return this.#selectedEditors.size !== 0;
  }
  get isEnterHandled() {
    return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;
  }
  undo() {
    this.#commandManager.undo();
    this.#dispatchUpdateStates({
      hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
      hasSomethingToRedo: true,
      isEmpty: this.#isEmpty()
    });
  }
  redo() {
    this.#commandManager.redo();
    this.#dispatchUpdateStates({
      hasSomethingToUndo: true,
      hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
      isEmpty: this.#isEmpty()
    });
  }
  addCommands(params) {
    this.#commandManager.add(params);
    this.#dispatchUpdateStates({
      hasSomethingToUndo: true,
      hasSomethingToRedo: false,
      isEmpty: this.#isEmpty()
    });
  }
  #isEmpty() {
    if (this.#allEditors.size === 0) {
      return true;
    }
    if (this.#allEditors.size === 1) {
      for (const editor of this.#allEditors.values()) {
        return editor.isEmpty();
      }
    }
    return false;
  }
  delete() {
    this.commitOrRemove();
    if (!this.hasSelection) {
      return;
    }
    const editors = [...this.#selectedEditors];
    const cmd = () => {
      for (const editor of editors) {
        editor.remove();
      }
    };
    const undo = () => {
      for (const editor of editors) {
        this.#addEditorToLayer(editor);
      }
    };
    this.addCommands({
      cmd,
      undo,
      mustExec: true
    });
  }
  commitOrRemove() {
    this.#activeEditor?.commitOrRemove();
  }
  hasSomethingToControl() {
    return this.#activeEditor || this.hasSelection;
  }
  #selectEditors(editors) {
    for (const editor of this.#selectedEditors) {
      editor.unselect();
    }
    this.#selectedEditors.clear();
    for (const editor of editors) {
      if (editor.isEmpty()) {
        continue;
      }
      this.#selectedEditors.add(editor);
      editor.select();
    }
    this.#dispatchUpdateStates({
      hasSelectedEditor: this.hasSelection
    });
  }
  selectAll() {
    for (const editor of this.#selectedEditors) {
      editor.commit();
    }
    this.#selectEditors(this.#allEditors.values());
  }
  unselectAll() {
    if (this.#activeEditor) {
      this.#activeEditor.commitOrRemove();
      if (this.#mode !== AnnotationEditorType$1.NONE) {
        return;
      }
    }
    if (!this.hasSelection) {
      return;
    }
    for (const editor of this.#selectedEditors) {
      editor.unselect();
    }
    this.#selectedEditors.clear();
    this.#dispatchUpdateStates({
      hasSelectedEditor: false
    });
  }
  translateSelectedEditors(x2, y2, noCommit = false) {
    if (!noCommit) {
      this.commitOrRemove();
    }
    if (!this.hasSelection) {
      return;
    }
    this.#translation[0] += x2;
    this.#translation[1] += y2;
    const [totalX, totalY] = this.#translation;
    const editors = [...this.#selectedEditors];
    const TIME_TO_WAIT = 1e3;
    if (this.#translationTimeoutId) {
      clearTimeout(this.#translationTimeoutId);
    }
    this.#translationTimeoutId = setTimeout(() => {
      this.#translationTimeoutId = null;
      this.#translation[0] = this.#translation[1] = 0;
      this.addCommands({
        cmd: () => {
          for (const editor of editors) {
            if (this.#allEditors.has(editor.id)) {
              editor.translateInPage(totalX, totalY);
            }
          }
        },
        undo: () => {
          for (const editor of editors) {
            if (this.#allEditors.has(editor.id)) {
              editor.translateInPage(-totalX, -totalY);
            }
          }
        },
        mustExec: false
      });
    }, TIME_TO_WAIT);
    for (const editor of editors) {
      editor.translateInPage(x2, y2);
    }
  }
  setUpDragSession() {
    if (!this.hasSelection) {
      return;
    }
    this.disableUserSelect(true);
    this.#draggingEditors = /* @__PURE__ */ new Map();
    for (const editor of this.#selectedEditors) {
      this.#draggingEditors.set(editor, {
        savedX: editor.x,
        savedY: editor.y,
        savedPageIndex: editor.pageIndex,
        newX: 0,
        newY: 0,
        newPageIndex: -1
      });
    }
  }
  endDragSession() {
    if (!this.#draggingEditors) {
      return false;
    }
    this.disableUserSelect(false);
    const map = this.#draggingEditors;
    this.#draggingEditors = null;
    let mustBeAddedInUndoStack = false;
    for (const [{
      x: x2,
      y: y2,
      pageIndex
    }, value] of map) {
      value.newX = x2;
      value.newY = y2;
      value.newPageIndex = pageIndex;
      mustBeAddedInUndoStack ||= x2 !== value.savedX || y2 !== value.savedY || pageIndex !== value.savedPageIndex;
    }
    if (!mustBeAddedInUndoStack) {
      return false;
    }
    const move = (editor, x2, y2, pageIndex) => {
      if (this.#allEditors.has(editor.id)) {
        const parent = this.#allLayers.get(pageIndex);
        if (parent) {
          editor._setParentAndPosition(parent, x2, y2);
        } else {
          editor.pageIndex = pageIndex;
          editor.x = x2;
          editor.y = y2;
        }
      }
    };
    this.addCommands({
      cmd: () => {
        for (const [editor, {
          newX,
          newY,
          newPageIndex
        }] of map) {
          move(editor, newX, newY, newPageIndex);
        }
      },
      undo: () => {
        for (const [editor, {
          savedX,
          savedY,
          savedPageIndex
        }] of map) {
          move(editor, savedX, savedY, savedPageIndex);
        }
      },
      mustExec: true
    });
    return true;
  }
  dragSelectedEditors(tx, ty) {
    if (!this.#draggingEditors) {
      return;
    }
    for (const editor of this.#draggingEditors.keys()) {
      editor.drag(tx, ty);
    }
  }
  rebuild(editor) {
    if (editor.parent === null) {
      const parent = this.getLayer(editor.pageIndex);
      if (parent) {
        parent.changeParent(editor);
        parent.addOrRebuild(editor);
      } else {
        this.addEditor(editor);
        this.addToAnnotationStorage(editor);
        editor.rebuild();
      }
    } else {
      editor.parent.addOrRebuild(editor);
    }
  }
  get isEditorHandlingKeyboard() {
    return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
  }
  isActive(editor) {
    return this.#activeEditor === editor;
  }
  getActive() {
    return this.#activeEditor;
  }
  getMode() {
    return this.#mode;
  }
  get imageManager() {
    return shadow$1(this, "imageManager", new ImageManager());
  }
  getSelectionBoxes(textLayer) {
    if (!textLayer) {
      return null;
    }
    const selection = document.getSelection();
    for (let i2 = 0, ii = selection.rangeCount; i2 < ii; i2++) {
      if (!textLayer.contains(selection.getRangeAt(i2).commonAncestorContainer)) {
        return null;
      }
    }
    const {
      x: layerX,
      y: layerY,
      width: parentWidth,
      height: parentHeight
    } = textLayer.getBoundingClientRect();
    let rotator;
    switch (textLayer.getAttribute("data-main-rotation")) {
      case "90":
        rotator = (x2, y2, w2, h2) => ({
          x: (y2 - layerY) / parentHeight,
          y: 1 - (x2 + w2 - layerX) / parentWidth,
          width: h2 / parentHeight,
          height: w2 / parentWidth
        });
        break;
      case "180":
        rotator = (x2, y2, w2, h2) => ({
          x: 1 - (x2 + w2 - layerX) / parentWidth,
          y: 1 - (y2 + h2 - layerY) / parentHeight,
          width: w2 / parentWidth,
          height: h2 / parentHeight
        });
        break;
      case "270":
        rotator = (x2, y2, w2, h2) => ({
          x: 1 - (y2 + h2 - layerY) / parentHeight,
          y: (x2 - layerX) / parentWidth,
          width: h2 / parentHeight,
          height: w2 / parentWidth
        });
        break;
      default:
        rotator = (x2, y2, w2, h2) => ({
          x: (x2 - layerX) / parentWidth,
          y: (y2 - layerY) / parentHeight,
          width: w2 / parentWidth,
          height: h2 / parentHeight
        });
        break;
    }
    const boxes = [];
    for (let i2 = 0, ii = selection.rangeCount; i2 < ii; i2++) {
      const range = selection.getRangeAt(i2);
      if (range.collapsed) {
        continue;
      }
      for (const {
        x: x2,
        y: y2,
        width,
        height
      } of range.getClientRects()) {
        if (width === 0 || height === 0) {
          continue;
        }
        boxes.push(rotator(x2, y2, width, height));
      }
    }
    return boxes.length === 0 ? null : boxes;
  }
  addChangedExistingAnnotation({
    annotationElementId,
    id: id2
  }) {
    (this.#changedExistingAnnotations ||= /* @__PURE__ */ new Map()).set(annotationElementId, id2);
  }
  removeChangedExistingAnnotation({
    annotationElementId
  }) {
    this.#changedExistingAnnotations?.delete(annotationElementId);
  }
  renderAnnotationElement(annotation) {
    const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);
    if (!editorId) {
      return;
    }
    const editor = this.#annotationStorage.getRawValue(editorId);
    if (!editor) {
      return;
    }
    if (this.#mode === AnnotationEditorType$1.NONE && !editor.hasBeenModified) {
      return;
    }
    editor.renderAnnotationElement(annotation);
  }
};
class AltText {
  #altText = "";
  #altTextDecorative = false;
  #altTextButton = null;
  #altTextTooltip = null;
  #altTextTooltipTimeout = null;
  #altTextWasFromKeyBoard = false;
  #editor = null;
  static _l10nPromise = null;
  constructor(editor) {
    this.#editor = editor;
  }
  static initialize(l10nPromise) {
    AltText._l10nPromise ||= l10nPromise;
  }
  async render() {
    const altText = this.#altTextButton = document.createElement("button");
    altText.className = "altText";
    const msg = await AltText._l10nPromise.get("pdfjs-editor-alt-text-button-label");
    altText.textContent = msg;
    altText.setAttribute("aria-label", msg);
    altText.tabIndex = "0";
    altText.addEventListener("contextmenu", noContextMenu$1);
    altText.addEventListener("pointerdown", (event) => event.stopPropagation());
    const onClick = (event) => {
      event.preventDefault();
      this.#editor._uiManager.editAltText(this.#editor);
    };
    altText.addEventListener("click", onClick, {
      capture: true
    });
    altText.addEventListener("keydown", (event) => {
      if (event.target === altText && event.key === "Enter") {
        this.#altTextWasFromKeyBoard = true;
        onClick(event);
      }
    });
    await this.#setState();
    return altText;
  }
  finish() {
    if (!this.#altTextButton) {
      return;
    }
    this.#altTextButton.focus({
      focusVisible: this.#altTextWasFromKeyBoard
    });
    this.#altTextWasFromKeyBoard = false;
  }
  isEmpty() {
    return !this.#altText && !this.#altTextDecorative;
  }
  get data() {
    return {
      altText: this.#altText,
      decorative: this.#altTextDecorative
    };
  }
  set data({
    altText,
    decorative
  }) {
    if (this.#altText === altText && this.#altTextDecorative === decorative) {
      return;
    }
    this.#altText = altText;
    this.#altTextDecorative = decorative;
    this.#setState();
  }
  toggle(enabled = false) {
    if (!this.#altTextButton) {
      return;
    }
    if (!enabled && this.#altTextTooltipTimeout) {
      clearTimeout(this.#altTextTooltipTimeout);
      this.#altTextTooltipTimeout = null;
    }
    this.#altTextButton.disabled = !enabled;
  }
  destroy() {
    this.#altTextButton?.remove();
    this.#altTextButton = null;
    this.#altTextTooltip = null;
  }
  async #setState() {
    const button = this.#altTextButton;
    if (!button) {
      return;
    }
    if (!this.#altText && !this.#altTextDecorative) {
      button.classList.remove("done");
      this.#altTextTooltip?.remove();
      return;
    }
    button.classList.add("done");
    AltText._l10nPromise.get("pdfjs-editor-alt-text-edit-button-label").then((msg) => {
      button.setAttribute("aria-label", msg);
    });
    let tooltip = this.#altTextTooltip;
    if (!tooltip) {
      this.#altTextTooltip = tooltip = document.createElement("span");
      tooltip.className = "tooltip";
      tooltip.setAttribute("role", "tooltip");
      const id2 = tooltip.id = `alt-text-tooltip-${this.#editor.id}`;
      button.setAttribute("aria-describedby", id2);
      const DELAY_TO_SHOW_TOOLTIP = 100;
      button.addEventListener("mouseenter", () => {
        this.#altTextTooltipTimeout = setTimeout(() => {
          this.#altTextTooltipTimeout = null;
          this.#altTextTooltip.classList.add("show");
          this.#editor._reportTelemetry({
            action: "alt_text_tooltip"
          });
        }, DELAY_TO_SHOW_TOOLTIP);
      });
      button.addEventListener("mouseleave", () => {
        if (this.#altTextTooltipTimeout) {
          clearTimeout(this.#altTextTooltipTimeout);
          this.#altTextTooltipTimeout = null;
        }
        this.#altTextTooltip?.classList.remove("show");
      });
    }
    tooltip.innerText = this.#altTextDecorative ? await AltText._l10nPromise.get("pdfjs-editor-alt-text-decorative-tooltip") : this.#altText;
    if (!tooltip.parentNode) {
      button.append(tooltip);
    }
    const element = this.#editor.getImageForAltText();
    element?.setAttribute("aria-describedby", tooltip.id);
  }
}
class AnnotationEditor {
  #allResizerDivs = null;
  #altText = null;
  #disabled = false;
  #keepAspectRatio = false;
  #resizersDiv = null;
  #savedDimensions = null;
  #boundFocusin = this.focusin.bind(this);
  #boundFocusout = this.focusout.bind(this);
  #editToolbar = null;
  #focusedResizerName = "";
  #hasBeenClicked = false;
  #initialPosition = null;
  #isEditing = false;
  #isInEditMode = false;
  #isResizerEnabledForKeyboard = false;
  #moveInDOMTimeout = null;
  #prevDragX = 0;
  #prevDragY = 0;
  #telemetryTimeouts = null;
  _initialOptions = /* @__PURE__ */ Object.create(null);
  _isVisible = true;
  _uiManager = null;
  _focusEventsAllowed = true;
  _l10nPromise = null;
  #isDraggable = false;
  #zIndex = AnnotationEditor._zIndex++;
  static _borderLineWidth = -1;
  static _colorManager = new ColorManager();
  static _zIndex = 1;
  static _telemetryTimeout = 1e3;
  static get _resizerKeyboardManager() {
    const resize = AnnotationEditor.prototype._resizeWithKeyboard;
    const small = AnnotationEditorUIManager$1.TRANSLATE_SMALL;
    const big = AnnotationEditorUIManager$1.TRANSLATE_BIG;
    return shadow$1(this, "_resizerKeyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], resize, {
      args: [-small, 0]
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], resize, {
      args: [-big, 0]
    }], [["ArrowRight", "mac+ArrowRight"], resize, {
      args: [small, 0]
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], resize, {
      args: [big, 0]
    }], [["ArrowUp", "mac+ArrowUp"], resize, {
      args: [0, -small]
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], resize, {
      args: [0, -big]
    }], [["ArrowDown", "mac+ArrowDown"], resize, {
      args: [0, small]
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], resize, {
      args: [0, big]
    }], [["Escape", "mac+Escape"], AnnotationEditor.prototype._stopResizingWithKeyboard]]));
  }
  constructor(parameters) {
    if (this.constructor === AnnotationEditor) {
      unreachable("Cannot initialize AnnotationEditor.");
    }
    this.parent = parameters.parent;
    this.id = parameters.id;
    this.width = this.height = null;
    this.pageIndex = parameters.parent.pageIndex;
    this.name = parameters.name;
    this.div = null;
    this._uiManager = parameters.uiManager;
    this.annotationElementId = null;
    this._willKeepAspectRatio = false;
    this._initialOptions.isCentered = parameters.isCentered;
    this._structTreeParentId = null;
    const {
      rotation,
      rawDims: {
        pageWidth,
        pageHeight,
        pageX,
        pageY
      }
    } = this.parent.viewport;
    this.rotation = rotation;
    this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;
    this.pageDimensions = [pageWidth, pageHeight];
    this.pageTranslation = [pageX, pageY];
    const [width, height] = this.parentDimensions;
    this.x = parameters.x / width;
    this.y = parameters.y / height;
    this.isAttachedToDOM = false;
    this.deleted = false;
  }
  get editorType() {
    return Object.getPrototypeOf(this).constructor._type;
  }
  static get _defaultLineColor() {
    return shadow$1(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }
  static deleteAnnotationElement(editor) {
    const fakeEditor = new FakeEditor({
      id: editor.parent.getNextId(),
      parent: editor.parent,
      uiManager: editor._uiManager
    });
    fakeEditor.annotationElementId = editor.annotationElementId;
    fakeEditor.deleted = true;
    fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);
  }
  static initialize(l10n, _uiManager, options) {
    AnnotationEditor._l10nPromise ||= new Map(["pdfjs-editor-alt-text-button-label", "pdfjs-editor-alt-text-edit-button-label", "pdfjs-editor-alt-text-decorative-tooltip", "pdfjs-editor-resizer-label-topLeft", "pdfjs-editor-resizer-label-topMiddle", "pdfjs-editor-resizer-label-topRight", "pdfjs-editor-resizer-label-middleRight", "pdfjs-editor-resizer-label-bottomRight", "pdfjs-editor-resizer-label-bottomMiddle", "pdfjs-editor-resizer-label-bottomLeft", "pdfjs-editor-resizer-label-middleLeft"].map((str) => [str, l10n.get(str.replaceAll(/([A-Z])/g, (c) => `-${c.toLowerCase()}`))]));
    if (options?.strings) {
      for (const str of options.strings) {
        AnnotationEditor._l10nPromise.set(str, l10n.get(str));
      }
    }
    if (AnnotationEditor._borderLineWidth !== -1) {
      return;
    }
    const style2 = getComputedStyle(document.documentElement);
    AnnotationEditor._borderLineWidth = parseFloat(style2.getPropertyValue("--outline-width")) || 0;
  }
  static updateDefaultParams(_type, _value) {
  }
  static get defaultPropertiesToUpdate() {
    return [];
  }
  static isHandlingMimeForPasting(mime) {
    return false;
  }
  static paste(item, parent) {
    unreachable("Not implemented");
  }
  get propertiesToUpdate() {
    return [];
  }
  get _isDraggable() {
    return this.#isDraggable;
  }
  set _isDraggable(value) {
    this.#isDraggable = value;
    this.div?.classList.toggle("draggable", value);
  }
  get isEnterHandled() {
    return true;
  }
  center() {
    const [pageWidth, pageHeight] = this.pageDimensions;
    switch (this.parentRotation) {
      case 90:
        this.x -= this.height * pageHeight / (pageWidth * 2);
        this.y += this.width * pageWidth / (pageHeight * 2);
        break;
      case 180:
        this.x += this.width / 2;
        this.y += this.height / 2;
        break;
      case 270:
        this.x += this.height * pageHeight / (pageWidth * 2);
        this.y -= this.width * pageWidth / (pageHeight * 2);
        break;
      default:
        this.x -= this.width / 2;
        this.y -= this.height / 2;
        break;
    }
    this.fixAndSetPosition();
  }
  addCommands(params) {
    this._uiManager.addCommands(params);
  }
  get currentLayer() {
    return this._uiManager.currentLayer;
  }
  setInBackground() {
    this.div.style.zIndex = 0;
  }
  setInForeground() {
    this.div.style.zIndex = this.#zIndex;
  }
  setParent(parent) {
    if (parent !== null) {
      this.pageIndex = parent.pageIndex;
      this.pageDimensions = parent.pageDimensions;
    } else {
      this.#stopResizing();
    }
    this.parent = parent;
  }
  focusin(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    if (!this.#hasBeenClicked) {
      this.parent.setSelected(this);
    } else {
      this.#hasBeenClicked = false;
    }
  }
  focusout(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    if (!this.isAttachedToDOM) {
      return;
    }
    const target = event.relatedTarget;
    if (target?.closest(`#${this.id}`)) {
      return;
    }
    event.preventDefault();
    if (!this.parent?.isMultipleSelection) {
      this.commitOrRemove();
    }
  }
  commitOrRemove() {
    if (this.isEmpty()) {
      this.remove();
    } else {
      this.commit();
    }
  }
  commit() {
    this.addToAnnotationStorage();
  }
  addToAnnotationStorage() {
    this._uiManager.addToAnnotationStorage(this);
  }
  setAt(x2, y2, tx, ty) {
    const [width, height] = this.parentDimensions;
    [tx, ty] = this.screenToPageTranslation(tx, ty);
    this.x = (x2 + tx) / width;
    this.y = (y2 + ty) / height;
    this.fixAndSetPosition();
  }
  #translate([width, height], x2, y2) {
    [x2, y2] = this.screenToPageTranslation(x2, y2);
    this.x += x2 / width;
    this.y += y2 / height;
    this.fixAndSetPosition();
  }
  translate(x2, y2) {
    this.#translate(this.parentDimensions, x2, y2);
  }
  translateInPage(x2, y2) {
    this.#initialPosition ||= [this.x, this.y];
    this.#translate(this.pageDimensions, x2, y2);
    this.div.scrollIntoView({
      block: "nearest"
    });
  }
  drag(tx, ty) {
    this.#initialPosition ||= [this.x, this.y];
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.x += tx / parentWidth;
    this.y += ty / parentHeight;
    if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
      const {
        x: x3,
        y: y3
      } = this.div.getBoundingClientRect();
      if (this.parent.findNewParent(this, x3, y3)) {
        this.x -= Math.floor(this.x);
        this.y -= Math.floor(this.y);
      }
    }
    let {
      x: x2,
      y: y2
    } = this;
    const [bx, by] = this.getBaseTranslation();
    x2 += bx;
    y2 += by;
    this.div.style.left = `${(100 * x2).toFixed(2)}%`;
    this.div.style.top = `${(100 * y2).toFixed(2)}%`;
    this.div.scrollIntoView({
      block: "nearest"
    });
  }
  get _hasBeenMoved() {
    return !!this.#initialPosition && (this.#initialPosition[0] !== this.x || this.#initialPosition[1] !== this.y);
  }
  getBaseTranslation() {
    const [parentWidth, parentHeight] = this.parentDimensions;
    const {
      _borderLineWidth
    } = AnnotationEditor;
    const x2 = _borderLineWidth / parentWidth;
    const y2 = _borderLineWidth / parentHeight;
    switch (this.rotation) {
      case 90:
        return [-x2, y2];
      case 180:
        return [x2, y2];
      case 270:
        return [x2, -y2];
      default:
        return [-x2, -y2];
    }
  }
  get _mustFixPosition() {
    return true;
  }
  fixAndSetPosition(rotation = this.rotation) {
    const [pageWidth, pageHeight] = this.pageDimensions;
    let {
      x: x2,
      y: y2,
      width,
      height
    } = this;
    width *= pageWidth;
    height *= pageHeight;
    x2 *= pageWidth;
    y2 *= pageHeight;
    if (this._mustFixPosition) {
      switch (rotation) {
        case 0:
          x2 = Math.max(0, Math.min(pageWidth - width, x2));
          y2 = Math.max(0, Math.min(pageHeight - height, y2));
          break;
        case 90:
          x2 = Math.max(0, Math.min(pageWidth - height, x2));
          y2 = Math.min(pageHeight, Math.max(width, y2));
          break;
        case 180:
          x2 = Math.min(pageWidth, Math.max(width, x2));
          y2 = Math.min(pageHeight, Math.max(height, y2));
          break;
        case 270:
          x2 = Math.min(pageWidth, Math.max(height, x2));
          y2 = Math.max(0, Math.min(pageHeight - width, y2));
          break;
      }
    }
    this.x = x2 /= pageWidth;
    this.y = y2 /= pageHeight;
    const [bx, by] = this.getBaseTranslation();
    x2 += bx;
    y2 += by;
    const {
      style: style2
    } = this.div;
    style2.left = `${(100 * x2).toFixed(2)}%`;
    style2.top = `${(100 * y2).toFixed(2)}%`;
    this.moveInDOM();
  }
  static #rotatePoint(x2, y2, angle) {
    switch (angle) {
      case 90:
        return [y2, -x2];
      case 180:
        return [-x2, -y2];
      case 270:
        return [-y2, x2];
      default:
        return [x2, y2];
    }
  }
  screenToPageTranslation(x2, y2) {
    return AnnotationEditor.#rotatePoint(x2, y2, this.parentRotation);
  }
  pageTranslationToScreen(x2, y2) {
    return AnnotationEditor.#rotatePoint(x2, y2, 360 - this.parentRotation);
  }
  #getRotationMatrix(rotation) {
    switch (rotation) {
      case 90: {
        const [pageWidth, pageHeight] = this.pageDimensions;
        return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];
      }
      case 180:
        return [-1, 0, 0, -1];
      case 270: {
        const [pageWidth, pageHeight] = this.pageDimensions;
        return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];
      }
      default:
        return [1, 0, 0, 1];
    }
  }
  get parentScale() {
    return this._uiManager.viewParameters.realScale;
  }
  get parentRotation() {
    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
  }
  get parentDimensions() {
    const {
      parentScale,
      pageDimensions: [pageWidth, pageHeight]
    } = this;
    const scaledWidth = pageWidth * parentScale;
    const scaledHeight = pageHeight * parentScale;
    return util_FeatureTest.isCSSRoundSupported ? [Math.round(scaledWidth), Math.round(scaledHeight)] : [scaledWidth, scaledHeight];
  }
  setDims(width, height) {
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.div.style.width = `${(100 * width / parentWidth).toFixed(2)}%`;
    if (!this.#keepAspectRatio) {
      this.div.style.height = `${(100 * height / parentHeight).toFixed(2)}%`;
    }
  }
  fixDims() {
    const {
      style: style2
    } = this.div;
    const {
      height,
      width
    } = style2;
    const widthPercent = width.endsWith("%");
    const heightPercent = !this.#keepAspectRatio && height.endsWith("%");
    if (widthPercent && heightPercent) {
      return;
    }
    const [parentWidth, parentHeight] = this.parentDimensions;
    if (!widthPercent) {
      style2.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;
    }
    if (!this.#keepAspectRatio && !heightPercent) {
      style2.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;
    }
  }
  getInitialTranslation() {
    return [0, 0];
  }
  #createResizers() {
    if (this.#resizersDiv) {
      return;
    }
    this.#resizersDiv = document.createElement("div");
    this.#resizersDiv.classList.add("resizers");
    const classes = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"];
    for (const name of classes) {
      const div = document.createElement("div");
      this.#resizersDiv.append(div);
      div.classList.add("resizer", name);
      div.setAttribute("data-resizer-name", name);
      div.addEventListener("pointerdown", this.#resizerPointerdown.bind(this, name));
      div.addEventListener("contextmenu", noContextMenu$1);
      div.tabIndex = -1;
    }
    this.div.prepend(this.#resizersDiv);
  }
  #resizerPointerdown(name, event) {
    event.preventDefault();
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    this.#altText?.toggle(false);
    const boundResizerPointermove = this.#resizerPointermove.bind(this, name);
    const savedDraggable = this._isDraggable;
    this._isDraggable = false;
    const pointerMoveOptions = {
      passive: true,
      capture: true
    };
    this.parent.togglePointerEvents(false);
    window.addEventListener("pointermove", boundResizerPointermove, pointerMoveOptions);
    window.addEventListener("contextmenu", noContextMenu$1);
    const savedX = this.x;
    const savedY = this.y;
    const savedWidth = this.width;
    const savedHeight = this.height;
    const savedParentCursor = this.parent.div.style.cursor;
    const savedCursor = this.div.style.cursor;
    this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;
    const pointerUpCallback = () => {
      this.parent.togglePointerEvents(true);
      this.#altText?.toggle(true);
      this._isDraggable = savedDraggable;
      window.removeEventListener("pointerup", pointerUpCallback);
      window.removeEventListener("blur", pointerUpCallback);
      window.removeEventListener("pointermove", boundResizerPointermove, pointerMoveOptions);
      window.removeEventListener("contextmenu", noContextMenu$1);
      this.parent.div.style.cursor = savedParentCursor;
      this.div.style.cursor = savedCursor;
      this.#addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight);
    };
    window.addEventListener("pointerup", pointerUpCallback);
    window.addEventListener("blur", pointerUpCallback);
  }
  #addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight) {
    const newX = this.x;
    const newY = this.y;
    const newWidth = this.width;
    const newHeight = this.height;
    if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {
      return;
    }
    this.addCommands({
      cmd: () => {
        this.width = newWidth;
        this.height = newHeight;
        this.x = newX;
        this.y = newY;
        const [parentWidth, parentHeight] = this.parentDimensions;
        this.setDims(parentWidth * newWidth, parentHeight * newHeight);
        this.fixAndSetPosition();
      },
      undo: () => {
        this.width = savedWidth;
        this.height = savedHeight;
        this.x = savedX;
        this.y = savedY;
        const [parentWidth, parentHeight] = this.parentDimensions;
        this.setDims(parentWidth * savedWidth, parentHeight * savedHeight);
        this.fixAndSetPosition();
      },
      mustExec: true
    });
  }
  #resizerPointermove(name, event) {
    const [parentWidth, parentHeight] = this.parentDimensions;
    const savedX = this.x;
    const savedY = this.y;
    const savedWidth = this.width;
    const savedHeight = this.height;
    const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;
    const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;
    const round = (x2) => Math.round(x2 * 1e4) / 1e4;
    const rotationMatrix = this.#getRotationMatrix(this.rotation);
    const transf = (x2, y2) => [rotationMatrix[0] * x2 + rotationMatrix[2] * y2, rotationMatrix[1] * x2 + rotationMatrix[3] * y2];
    const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);
    const invTransf = (x2, y2) => [invRotationMatrix[0] * x2 + invRotationMatrix[2] * y2, invRotationMatrix[1] * x2 + invRotationMatrix[3] * y2];
    let getPoint;
    let getOpposite;
    let isDiagonal = false;
    let isHorizontal = false;
    switch (name) {
      case "topLeft":
        isDiagonal = true;
        getPoint = (w2, h2) => [0, 0];
        getOpposite = (w2, h2) => [w2, h2];
        break;
      case "topMiddle":
        getPoint = (w2, h2) => [w2 / 2, 0];
        getOpposite = (w2, h2) => [w2 / 2, h2];
        break;
      case "topRight":
        isDiagonal = true;
        getPoint = (w2, h2) => [w2, 0];
        getOpposite = (w2, h2) => [0, h2];
        break;
      case "middleRight":
        isHorizontal = true;
        getPoint = (w2, h2) => [w2, h2 / 2];
        getOpposite = (w2, h2) => [0, h2 / 2];
        break;
      case "bottomRight":
        isDiagonal = true;
        getPoint = (w2, h2) => [w2, h2];
        getOpposite = (w2, h2) => [0, 0];
        break;
      case "bottomMiddle":
        getPoint = (w2, h2) => [w2 / 2, h2];
        getOpposite = (w2, h2) => [w2 / 2, 0];
        break;
      case "bottomLeft":
        isDiagonal = true;
        getPoint = (w2, h2) => [0, h2];
        getOpposite = (w2, h2) => [w2, 0];
        break;
      case "middleLeft":
        isHorizontal = true;
        getPoint = (w2, h2) => [0, h2 / 2];
        getOpposite = (w2, h2) => [w2, h2 / 2];
        break;
    }
    const point = getPoint(savedWidth, savedHeight);
    const oppositePoint = getOpposite(savedWidth, savedHeight);
    let transfOppositePoint = transf(...oppositePoint);
    const oppositeX = round(savedX + transfOppositePoint[0]);
    const oppositeY = round(savedY + transfOppositePoint[1]);
    let ratioX = 1;
    let ratioY = 1;
    let [deltaX, deltaY] = this.screenToPageTranslation(event.movementX, event.movementY);
    [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);
    if (isDiagonal) {
      const oldDiag = Math.hypot(savedWidth, savedHeight);
      ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
    } else if (isHorizontal) {
      ratioX = Math.max(minWidth, Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))) / savedWidth;
    } else {
      ratioY = Math.max(minHeight, Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))) / savedHeight;
    }
    const newWidth = round(savedWidth * ratioX);
    const newHeight = round(savedHeight * ratioY);
    transfOppositePoint = transf(...getOpposite(newWidth, newHeight));
    const newX = oppositeX - transfOppositePoint[0];
    const newY = oppositeY - transfOppositePoint[1];
    this.width = newWidth;
    this.height = newHeight;
    this.x = newX;
    this.y = newY;
    this.setDims(parentWidth * newWidth, parentHeight * newHeight);
    this.fixAndSetPosition();
  }
  altTextFinish() {
    this.#altText?.finish();
  }
  async addEditToolbar() {
    if (this.#editToolbar || this.#isInEditMode) {
      return this.#editToolbar;
    }
    this.#editToolbar = new EditorToolbar(this);
    this.div.append(this.#editToolbar.render());
    if (this.#altText) {
      this.#editToolbar.addAltTextButton(await this.#altText.render());
    }
    return this.#editToolbar;
  }
  removeEditToolbar() {
    if (!this.#editToolbar) {
      return;
    }
    this.#editToolbar.remove();
    this.#editToolbar = null;
    this.#altText?.destroy();
  }
  getClientDimensions() {
    return this.div.getBoundingClientRect();
  }
  async addAltTextButton() {
    if (this.#altText) {
      return;
    }
    AltText.initialize(AnnotationEditor._l10nPromise);
    this.#altText = new AltText(this);
    await this.addEditToolbar();
  }
  get altTextData() {
    return this.#altText?.data;
  }
  set altTextData(data2) {
    if (!this.#altText) {
      return;
    }
    this.#altText.data = data2;
  }
  hasAltText() {
    return !this.#altText?.isEmpty();
  }
  render() {
    this.div = document.createElement("div");
    this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
    this.div.className = this.name;
    this.div.setAttribute("id", this.id);
    this.div.tabIndex = this.#disabled ? -1 : 0;
    if (!this._isVisible) {
      this.div.classList.add("hidden");
    }
    this.setInForeground();
    this.div.addEventListener("focusin", this.#boundFocusin);
    this.div.addEventListener("focusout", this.#boundFocusout);
    const [parentWidth, parentHeight] = this.parentDimensions;
    if (this.parentRotation % 180 !== 0) {
      this.div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;
      this.div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;
    }
    const [tx, ty] = this.getInitialTranslation();
    this.translate(tx, ty);
    bindEvents(this, this.div, ["pointerdown"]);
    return this.div;
  }
  pointerdown(event) {
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      event.preventDefault();
      return;
    }
    this.#hasBeenClicked = true;
    if (this._isDraggable) {
      this.#setUpDragSession(event);
      return;
    }
    this.#selectOnPointerEvent(event);
  }
  #selectOnPointerEvent(event) {
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
      this.parent.toggleSelected(this);
    } else {
      this.parent.setSelected(this);
    }
  }
  #setUpDragSession(event) {
    const isSelected = this._uiManager.isSelected(this);
    this._uiManager.setUpDragSession();
    let pointerMoveOptions, pointerMoveCallback;
    if (isSelected) {
      this.div.classList.add("moving");
      pointerMoveOptions = {
        passive: true,
        capture: true
      };
      this.#prevDragX = event.clientX;
      this.#prevDragY = event.clientY;
      pointerMoveCallback = (e2) => {
        const {
          clientX: x2,
          clientY: y2
        } = e2;
        const [tx, ty] = this.screenToPageTranslation(x2 - this.#prevDragX, y2 - this.#prevDragY);
        this.#prevDragX = x2;
        this.#prevDragY = y2;
        this._uiManager.dragSelectedEditors(tx, ty);
      };
      window.addEventListener("pointermove", pointerMoveCallback, pointerMoveOptions);
    }
    const pointerUpCallback = () => {
      window.removeEventListener("pointerup", pointerUpCallback);
      window.removeEventListener("blur", pointerUpCallback);
      if (isSelected) {
        this.div.classList.remove("moving");
        window.removeEventListener("pointermove", pointerMoveCallback, pointerMoveOptions);
      }
      this.#hasBeenClicked = false;
      if (!this._uiManager.endDragSession()) {
        this.#selectOnPointerEvent(event);
      }
    };
    window.addEventListener("pointerup", pointerUpCallback);
    window.addEventListener("blur", pointerUpCallback);
  }
  moveInDOM() {
    if (this.#moveInDOMTimeout) {
      clearTimeout(this.#moveInDOMTimeout);
    }
    this.#moveInDOMTimeout = setTimeout(() => {
      this.#moveInDOMTimeout = null;
      this.parent?.moveEditorInDOM(this);
    }, 0);
  }
  _setParentAndPosition(parent, x2, y2) {
    parent.changeParent(this);
    this.x = x2;
    this.y = y2;
    this.fixAndSetPosition();
  }
  getRect(tx, ty, rotation = this.rotation) {
    const scale = this.parentScale;
    const [pageWidth, pageHeight] = this.pageDimensions;
    const [pageX, pageY] = this.pageTranslation;
    const shiftX = tx / scale;
    const shiftY = ty / scale;
    const x2 = this.x * pageWidth;
    const y2 = this.y * pageHeight;
    const width = this.width * pageWidth;
    const height = this.height * pageHeight;
    switch (rotation) {
      case 0:
        return [x2 + shiftX + pageX, pageHeight - y2 - shiftY - height + pageY, x2 + shiftX + width + pageX, pageHeight - y2 - shiftY + pageY];
      case 90:
        return [x2 + shiftY + pageX, pageHeight - y2 + shiftX + pageY, x2 + shiftY + height + pageX, pageHeight - y2 + shiftX + width + pageY];
      case 180:
        return [x2 - shiftX - width + pageX, pageHeight - y2 + shiftY + pageY, x2 - shiftX + pageX, pageHeight - y2 + shiftY + height + pageY];
      case 270:
        return [x2 - shiftY - height + pageX, pageHeight - y2 - shiftX - width + pageY, x2 - shiftY + pageX, pageHeight - y2 - shiftX + pageY];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getRectInCurrentCoords(rect, pageHeight) {
    const [x1, y1, x2, y2] = rect;
    const width = x2 - x1;
    const height = y2 - y1;
    switch (this.rotation) {
      case 0:
        return [x1, pageHeight - y2, width, height];
      case 90:
        return [x1, pageHeight - y1, height, width];
      case 180:
        return [x2, pageHeight - y1, width, height];
      case 270:
        return [x2, pageHeight - y2, height, width];
      default:
        throw new Error("Invalid rotation");
    }
  }
  onceAdded() {
  }
  isEmpty() {
    return false;
  }
  enableEditMode() {
    this.#isInEditMode = true;
  }
  disableEditMode() {
    this.#isInEditMode = false;
  }
  isInEditMode() {
    return this.#isInEditMode;
  }
  shouldGetKeyboardEvents() {
    return this.#isResizerEnabledForKeyboard;
  }
  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }
  rebuild() {
    this.div?.addEventListener("focusin", this.#boundFocusin);
    this.div?.addEventListener("focusout", this.#boundFocusout);
  }
  rotate(_angle) {
  }
  serialize(isForCopying = false, context = null) {
    unreachable("An editor must be serializable");
  }
  static deserialize(data2, parent, uiManager) {
    const editor = new this.prototype.constructor({
      parent,
      id: parent.getNextId(),
      uiManager
    });
    editor.rotation = data2.rotation;
    const [pageWidth, pageHeight] = editor.pageDimensions;
    const [x2, y2, width, height] = editor.getRectInCurrentCoords(data2.rect, pageHeight);
    editor.x = x2 / pageWidth;
    editor.y = y2 / pageHeight;
    editor.width = width / pageWidth;
    editor.height = height / pageHeight;
    return editor;
  }
  get hasBeenModified() {
    return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
  }
  remove() {
    this.div.removeEventListener("focusin", this.#boundFocusin);
    this.div.removeEventListener("focusout", this.#boundFocusout);
    if (!this.isEmpty()) {
      this.commit();
    }
    if (this.parent) {
      this.parent.remove(this);
    } else {
      this._uiManager.removeEditor(this);
    }
    if (this.#moveInDOMTimeout) {
      clearTimeout(this.#moveInDOMTimeout);
      this.#moveInDOMTimeout = null;
    }
    this.#stopResizing();
    this.removeEditToolbar();
    if (this.#telemetryTimeouts) {
      for (const timeout of this.#telemetryTimeouts.values()) {
        clearTimeout(timeout);
      }
      this.#telemetryTimeouts = null;
    }
    this.parent = null;
  }
  get isResizable() {
    return false;
  }
  makeResizable() {
    if (this.isResizable) {
      this.#createResizers();
      this.#resizersDiv.classList.remove("hidden");
      bindEvents(this, this.div, ["keydown"]);
    }
  }
  get toolbarPosition() {
    return null;
  }
  keydown(event) {
    if (!this.isResizable || event.target !== this.div || event.key !== "Enter") {
      return;
    }
    this._uiManager.setSelected(this);
    this.#savedDimensions = {
      savedX: this.x,
      savedY: this.y,
      savedWidth: this.width,
      savedHeight: this.height
    };
    const children = this.#resizersDiv.children;
    if (!this.#allResizerDivs) {
      this.#allResizerDivs = Array.from(children);
      const boundResizerKeydown = this.#resizerKeydown.bind(this);
      const boundResizerBlur = this.#resizerBlur.bind(this);
      for (const div of this.#allResizerDivs) {
        const name = div.getAttribute("data-resizer-name");
        div.setAttribute("role", "spinbutton");
        div.addEventListener("keydown", boundResizerKeydown);
        div.addEventListener("blur", boundResizerBlur);
        div.addEventListener("focus", this.#resizerFocus.bind(this, name));
        AnnotationEditor._l10nPromise.get(`pdfjs-editor-resizer-label-${name}`).then((msg) => div.setAttribute("aria-label", msg));
      }
    }
    const first = this.#allResizerDivs[0];
    let firstPosition = 0;
    for (const div of children) {
      if (div === first) {
        break;
      }
      firstPosition++;
    }
    const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);
    if (nextFirstPosition !== firstPosition) {
      if (nextFirstPosition < firstPosition) {
        for (let i3 = 0; i3 < firstPosition - nextFirstPosition; i3++) {
          this.#resizersDiv.append(this.#resizersDiv.firstChild);
        }
      } else if (nextFirstPosition > firstPosition) {
        for (let i3 = 0; i3 < nextFirstPosition - firstPosition; i3++) {
          this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);
        }
      }
      let i2 = 0;
      for (const child of children) {
        const div = this.#allResizerDivs[i2++];
        const name = div.getAttribute("data-resizer-name");
        AnnotationEditor._l10nPromise.get(`pdfjs-editor-resizer-label-${name}`).then((msg) => child.setAttribute("aria-label", msg));
      }
    }
    this.#setResizerTabIndex(0);
    this.#isResizerEnabledForKeyboard = true;
    this.#resizersDiv.firstChild.focus({
      focusVisible: true
    });
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  #resizerKeydown(event) {
    AnnotationEditor._resizerKeyboardManager.exec(this, event);
  }
  #resizerBlur(event) {
    if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {
      this.#stopResizing();
    }
  }
  #resizerFocus(name) {
    this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : "";
  }
  #setResizerTabIndex(value) {
    if (!this.#allResizerDivs) {
      return;
    }
    for (const div of this.#allResizerDivs) {
      div.tabIndex = value;
    }
  }
  _resizeWithKeyboard(x2, y2) {
    if (!this.#isResizerEnabledForKeyboard) {
      return;
    }
    this.#resizerPointermove(this.#focusedResizerName, {
      movementX: x2,
      movementY: y2
    });
  }
  #stopResizing() {
    this.#isResizerEnabledForKeyboard = false;
    this.#setResizerTabIndex(-1);
    if (this.#savedDimensions) {
      const {
        savedX,
        savedY,
        savedWidth,
        savedHeight
      } = this.#savedDimensions;
      this.#addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight);
      this.#savedDimensions = null;
    }
  }
  _stopResizingWithKeyboard() {
    this.#stopResizing();
    this.div.focus();
  }
  select() {
    this.makeResizable();
    this.div?.classList.add("selectedEditor");
    if (!this.#editToolbar) {
      this.addEditToolbar().then(() => {
        if (this.div?.classList.contains("selectedEditor")) {
          this.#editToolbar?.show();
        }
      });
      return;
    }
    this.#editToolbar?.show();
  }
  unselect() {
    this.#resizersDiv?.classList.add("hidden");
    this.div?.classList.remove("selectedEditor");
    if (this.div?.contains(document.activeElement)) {
      this._uiManager.currentLayer.div.focus({
        preventScroll: true
      });
    }
    this.#editToolbar?.hide();
  }
  updateParams(type, value) {
  }
  disableEditing() {
  }
  enableEditing() {
  }
  enterInEditMode() {
  }
  getImageForAltText() {
    return null;
  }
  get contentDiv() {
    return this.div;
  }
  get isEditing() {
    return this.#isEditing;
  }
  set isEditing(value) {
    this.#isEditing = value;
    if (!this.parent) {
      return;
    }
    if (value) {
      this.parent.setSelected(this);
      this.parent.setActiveEditor(this);
    } else {
      this.parent.setActiveEditor(null);
    }
  }
  setAspectRatio(width, height) {
    this.#keepAspectRatio = true;
    const aspectRatio = width / height;
    const {
      style: style2
    } = this.div;
    style2.aspectRatio = aspectRatio;
    style2.height = "auto";
  }
  static get MIN_SIZE() {
    return 16;
  }
  static canCreateNewEmptyEditor() {
    return true;
  }
  get telemetryInitialData() {
    return {
      action: "added"
    };
  }
  get telemetryFinalData() {
    return null;
  }
  _reportTelemetry(data2, mustWait = false) {
    if (mustWait) {
      this.#telemetryTimeouts ||= /* @__PURE__ */ new Map();
      const {
        action
      } = data2;
      let timeout = this.#telemetryTimeouts.get(action);
      if (timeout) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(() => {
        this._reportTelemetry(data2);
        this.#telemetryTimeouts.delete(action);
        if (this.#telemetryTimeouts.size === 0) {
          this.#telemetryTimeouts = null;
        }
      }, AnnotationEditor._telemetryTimeout);
      this.#telemetryTimeouts.set(action, timeout);
      return;
    }
    data2.type ||= this.editorType;
    this._uiManager._eventBus.dispatch("reporttelemetry", {
      source: this,
      details: {
        type: "editing",
        data: data2
      }
    });
  }
  show(visible = this._isVisible) {
    this.div.classList.toggle("hidden", !visible);
    this._isVisible = visible;
  }
  enable() {
    if (this.div) {
      this.div.tabIndex = 0;
    }
    this.#disabled = false;
  }
  disable() {
    if (this.div) {
      this.div.tabIndex = -1;
    }
    this.#disabled = true;
  }
  renderAnnotationElement(annotation) {
    let content = annotation.container.querySelector(".annotationContent");
    if (!content) {
      content = document.createElement("div");
      content.classList.add("annotationContent", this.editorType);
      annotation.container.prepend(content);
    } else if (content.nodeName === "CANVAS") {
      const canvas = content;
      content = document.createElement("div");
      content.classList.add("annotationContent", this.editorType);
      canvas.before(content);
    }
    return content;
  }
  resetAnnotationElement(annotation) {
    const {
      firstChild
    } = annotation.container;
    if (firstChild.nodeName === "DIV" && firstChild.classList.contains("annotationContent")) {
      firstChild.remove();
    }
  }
}
class FakeEditor extends AnnotationEditor {
  constructor(params) {
    super(params);
    this.annotationElementId = params.annotationElementId;
    this.deleted = true;
  }
  serialize() {
    return {
      id: this.annotationElementId,
      deleted: true,
      pageIndex: this.pageIndex
    };
  }
}
const SEED = 3285377520;
const MASK_HIGH = 4294901760;
const MASK_LOW = 65535;
class MurmurHash3_64 {
  constructor(seed) {
    this.h1 = seed ? seed & 4294967295 : SEED;
    this.h2 = seed ? seed & 4294967295 : SEED;
  }
  update(input) {
    let data2, length;
    if (typeof input === "string") {
      data2 = new Uint8Array(input.length * 2);
      length = 0;
      for (let i2 = 0, ii = input.length; i2 < ii; i2++) {
        const code2 = input.charCodeAt(i2);
        if (code2 <= 255) {
          data2[length++] = code2;
        } else {
          data2[length++] = code2 >>> 8;
          data2[length++] = code2 & 255;
        }
      }
    } else if (ArrayBuffer.isView(input)) {
      data2 = input.slice();
      length = data2.byteLength;
    } else {
      throw new Error("Invalid data format, must be a string or TypedArray.");
    }
    const blockCounts = length >> 2;
    const tailLength = length - blockCounts * 4;
    const dataUint32 = new Uint32Array(data2.buffer, 0, blockCounts);
    let k1 = 0, k2 = 0;
    let h1 = this.h1, h2 = this.h2;
    const C1 = 3432918353, C2 = 461845907;
    const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
    for (let i2 = 0; i2 < blockCounts; i2++) {
      if (i2 & 1) {
        k1 = dataUint32[i2];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1 = h1 * 5 + 3864292196;
      } else {
        k2 = dataUint32[i2];
        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
        k2 = k2 << 15 | k2 >>> 17;
        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
        h2 ^= k2;
        h2 = h2 << 13 | h2 >>> 19;
        h2 = h2 * 5 + 3864292196;
      }
    }
    k1 = 0;
    switch (tailLength) {
      case 3:
        k1 ^= data2[blockCounts * 4 + 2] << 16;
      case 2:
        k1 ^= data2[blockCounts * 4 + 1] << 8;
      case 1:
        k1 ^= data2[blockCounts * 4];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        if (blockCounts & 1) {
          h1 ^= k1;
        } else {
          h2 ^= k1;
        }
    }
    this.h1 = h1;
    this.h2 = h2;
  }
  hexdigest() {
    let h1 = this.h1, h2 = this.h2;
    h1 ^= h2 >>> 1;
    h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
    h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
    h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    return (h1 >>> 0).toString(16).padStart(8, "0") + (h2 >>> 0).toString(16).padStart(8, "0");
  }
}
const SerializableEmpty = Object.freeze({
  map: null,
  hash: "",
  transfer: void 0
});
class AnnotationStorage {
  #modified = false;
  #storage = /* @__PURE__ */ new Map();
  constructor() {
    this.onSetModified = null;
    this.onResetModified = null;
    this.onAnnotationEditor = null;
  }
  getValue(key, defaultValue) {
    const value = this.#storage.get(key);
    if (value === void 0) {
      return defaultValue;
    }
    return Object.assign(defaultValue, value);
  }
  getRawValue(key) {
    return this.#storage.get(key);
  }
  remove(key) {
    this.#storage.delete(key);
    if (this.#storage.size === 0) {
      this.resetModified();
    }
    if (typeof this.onAnnotationEditor === "function") {
      for (const value of this.#storage.values()) {
        if (value instanceof AnnotationEditor) {
          return;
        }
      }
      this.onAnnotationEditor(null);
    }
  }
  setValue(key, value) {
    const obj = this.#storage.get(key);
    let modified = false;
    if (obj !== void 0) {
      for (const [entry, val] of Object.entries(value)) {
        if (obj[entry] !== val) {
          modified = true;
          obj[entry] = val;
        }
      }
    } else {
      modified = true;
      this.#storage.set(key, value);
    }
    if (modified) {
      this.#setModified();
    }
    if (value instanceof AnnotationEditor && typeof this.onAnnotationEditor === "function") {
      this.onAnnotationEditor(value.constructor._type);
    }
  }
  has(key) {
    return this.#storage.has(key);
  }
  getAll() {
    return this.#storage.size > 0 ? objectFromMap(this.#storage) : null;
  }
  setAll(obj) {
    for (const [key, val] of Object.entries(obj)) {
      this.setValue(key, val);
    }
  }
  get size() {
    return this.#storage.size;
  }
  #setModified() {
    if (!this.#modified) {
      this.#modified = true;
      if (typeof this.onSetModified === "function") {
        this.onSetModified();
      }
    }
  }
  resetModified() {
    if (this.#modified) {
      this.#modified = false;
      if (typeof this.onResetModified === "function") {
        this.onResetModified();
      }
    }
  }
  get print() {
    return new PrintAnnotationStorage(this);
  }
  get serializable() {
    if (this.#storage.size === 0) {
      return SerializableEmpty;
    }
    const map = /* @__PURE__ */ new Map(), hash = new MurmurHash3_64(), transfer = [];
    const context = /* @__PURE__ */ Object.create(null);
    let hasBitmap = false;
    for (const [key, val] of this.#storage) {
      const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;
      if (serialized) {
        map.set(key, serialized);
        hash.update(`${key}:${JSON.stringify(serialized)}`);
        hasBitmap ||= !!serialized.bitmap;
      }
    }
    if (hasBitmap) {
      for (const value of map.values()) {
        if (value.bitmap) {
          transfer.push(value.bitmap);
        }
      }
    }
    return map.size > 0 ? {
      map,
      hash: hash.hexdigest(),
      transfer
    } : SerializableEmpty;
  }
  get editorStats() {
    let stats = null;
    const typeToEditor = /* @__PURE__ */ new Map();
    for (const value of this.#storage.values()) {
      if (!(value instanceof AnnotationEditor)) {
        continue;
      }
      const editorStats = value.telemetryFinalData;
      if (!editorStats) {
        continue;
      }
      const {
        type
      } = editorStats;
      if (!typeToEditor.has(type)) {
        typeToEditor.set(type, Object.getPrototypeOf(value).constructor);
      }
      stats ||= /* @__PURE__ */ Object.create(null);
      const map = stats[type] ||= /* @__PURE__ */ new Map();
      for (const [key, val] of Object.entries(editorStats)) {
        if (key === "type") {
          continue;
        }
        let counters = map.get(key);
        if (!counters) {
          counters = /* @__PURE__ */ new Map();
          map.set(key, counters);
        }
        const count = counters.get(val) ?? 0;
        counters.set(val, count + 1);
      }
    }
    for (const [type, editor] of typeToEditor) {
      stats[type] = editor.computeTelemetryFinalData(stats[type]);
    }
    return stats;
  }
}
class PrintAnnotationStorage extends AnnotationStorage {
  #serializable;
  constructor(parent) {
    super();
    const {
      map,
      hash,
      transfer
    } = parent.serializable;
    const clone = structuredClone(map, transfer ? {
      transfer
    } : null);
    this.#serializable = {
      map: clone,
      hash,
      transfer
    };
  }
  get print() {
    unreachable("Should not call PrintAnnotationStorage.print");
  }
  get serializable() {
    return this.#serializable;
  }
}
class FontLoader {
  #systemFonts = /* @__PURE__ */ new Set();
  constructor({
    ownerDocument = globalThis.document,
    styleElement = null
  }) {
    this._document = ownerDocument;
    this.nativeFontFaces = /* @__PURE__ */ new Set();
    this.styleElement = null;
    this.loadingRequests = [];
    this.loadTestFontId = 0;
  }
  addNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.add(nativeFontFace);
    this._document.fonts.add(nativeFontFace);
  }
  removeNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.delete(nativeFontFace);
    this._document.fonts.delete(nativeFontFace);
  }
  insertRule(rule) {
    if (!this.styleElement) {
      this.styleElement = this._document.createElement("style");
      this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement);
    }
    const styleSheet = this.styleElement.sheet;
    styleSheet.insertRule(rule, styleSheet.cssRules.length);
  }
  clear() {
    for (const nativeFontFace of this.nativeFontFaces) {
      this._document.fonts.delete(nativeFontFace);
    }
    this.nativeFontFaces.clear();
    this.#systemFonts.clear();
    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
  }
  async loadSystemFont({
    systemFontInfo: info2,
    _inspectFont
  }) {
    if (!info2 || this.#systemFonts.has(info2.loadedName)) {
      return;
    }
    assert(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set.");
    if (this.isFontLoadingAPISupported) {
      const {
        loadedName,
        src,
        style: style2
      } = info2;
      const fontFace = new FontFace(loadedName, src, style2);
      this.addNativeFontFace(fontFace);
      try {
        await fontFace.load();
        this.#systemFonts.add(loadedName);
        _inspectFont?.(info2);
      } catch {
        warn(`Cannot load system font: ${info2.baseFontName}, installing it could help to improve PDF rendering.`);
        this.removeNativeFontFace(fontFace);
      }
      return;
    }
    unreachable("Not implemented: loadSystemFont without the Font Loading API.");
  }
  async bind(font) {
    if (font.attached || font.missingFile && !font.systemFontInfo) {
      return;
    }
    font.attached = true;
    if (font.systemFontInfo) {
      await this.loadSystemFont(font);
      return;
    }
    if (this.isFontLoadingAPISupported) {
      const nativeFontFace = font.createNativeFontFace();
      if (nativeFontFace) {
        this.addNativeFontFace(nativeFontFace);
        try {
          await nativeFontFace.loaded;
        } catch (ex) {
          warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
          font.disableFontFace = true;
          throw ex;
        }
      }
      return;
    }
    const rule = font.createFontFaceRule();
    if (rule) {
      this.insertRule(rule);
      if (this.isSyncFontLoadingSupported) {
        return;
      }
      await new Promise((resolve2) => {
        const request = this._queueLoadingCallback(resolve2);
        this._prepareFontLoadEvent(font, request);
      });
    }
  }
  get isFontLoadingAPISupported() {
    const hasFonts = !!this._document?.fonts;
    return shadow$1(this, "isFontLoadingAPISupported", hasFonts);
  }
  get isSyncFontLoadingSupported() {
    let supported = false;
    if (isNodeJS) {
      supported = true;
    } else if (typeof navigator !== "undefined" && typeof navigator?.userAgent === "string" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) {
      supported = true;
    }
    return shadow$1(this, "isSyncFontLoadingSupported", supported);
  }
  _queueLoadingCallback(callback) {
    function completeRequest() {
      assert(!request.done, "completeRequest() cannot be called twice.");
      request.done = true;
      while (loadingRequests.length > 0 && loadingRequests[0].done) {
        const otherRequest = loadingRequests.shift();
        setTimeout(otherRequest.callback, 0);
      }
    }
    const {
      loadingRequests
    } = this;
    const request = {
      done: false,
      complete: completeRequest,
      callback
    };
    loadingRequests.push(request);
    return request;
  }
  get _loadTestFont() {
    const testFont = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
    return shadow$1(this, "_loadTestFont", testFont);
  }
  _prepareFontLoadEvent(font, request) {
    function int32(data3, offset) {
      return data3.charCodeAt(offset) << 24 | data3.charCodeAt(offset + 1) << 16 | data3.charCodeAt(offset + 2) << 8 | data3.charCodeAt(offset + 3) & 255;
    }
    function spliceString(s, offset, remove2, insert) {
      const chunk1 = s.substring(0, offset);
      const chunk2 = s.substring(offset + remove2);
      return chunk1 + insert + chunk2;
    }
    let i2, ii;
    const canvas = this._document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext("2d");
    let called = 0;
    function isFontReady(name, callback) {
      if (++called > 30) {
        warn("Load test font never loaded.");
        callback();
        return;
      }
      ctx.font = "30px " + name;
      ctx.fillText(".", 0, 20);
      const imageData = ctx.getImageData(0, 0, 1, 1);
      if (imageData.data[3] > 0) {
        callback();
        return;
      }
      setTimeout(isFontReady.bind(null, name, callback));
    }
    const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
    let data2 = this._loadTestFont;
    const COMMENT_OFFSET = 976;
    data2 = spliceString(data2, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
    const CFF_CHECKSUM_OFFSET = 16;
    const XXXX_VALUE = 1482184792;
    let checksum = int32(data2, CFF_CHECKSUM_OFFSET);
    for (i2 = 0, ii = loadTestFontId.length - 3; i2 < ii; i2 += 4) {
      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i2) | 0;
    }
    if (i2 < loadTestFontId.length) {
      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i2) | 0;
    }
    data2 = spliceString(data2, CFF_CHECKSUM_OFFSET, 4, string32(checksum));
    const url = `url(data:font/opentype;base64,${btoa(data2)});`;
    const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
    this.insertRule(rule);
    const div = this._document.createElement("div");
    div.style.visibility = "hidden";
    div.style.width = div.style.height = "10px";
    div.style.position = "absolute";
    div.style.top = div.style.left = "0px";
    for (const name of [font.loadedName, loadTestFontId]) {
      const span = this._document.createElement("span");
      span.textContent = "Hi";
      span.style.fontFamily = name;
      div.append(span);
    }
    this._document.body.append(div);
    isFontReady(loadTestFontId, () => {
      div.remove();
      request.complete();
    });
  }
}
class FontFaceObject {
  constructor(translatedData, {
    disableFontFace = false,
    inspectFont = null
  }) {
    this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
    for (const i2 in translatedData) {
      this[i2] = translatedData[i2];
    }
    this.disableFontFace = disableFontFace === true;
    this._inspectFont = inspectFont;
  }
  createNativeFontFace() {
    if (!this.data || this.disableFontFace) {
      return null;
    }
    let nativeFontFace;
    if (!this.cssFontInfo) {
      nativeFontFace = new FontFace(this.loadedName, this.data, {});
    } else {
      const css = {
        weight: this.cssFontInfo.fontWeight
      };
      if (this.cssFontInfo.italicAngle) {
        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
      }
      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
    }
    this._inspectFont?.(this);
    return nativeFontFace;
  }
  createFontFaceRule() {
    if (!this.data || this.disableFontFace) {
      return null;
    }
    const data2 = bytesToString(this.data);
    const url = `url(data:${this.mimetype};base64,${btoa(data2)});`;
    let rule;
    if (!this.cssFontInfo) {
      rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
    } else {
      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
      if (this.cssFontInfo.italicAngle) {
        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
      }
      rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
    }
    this._inspectFont?.(this, url);
    return rule;
  }
  getPathGenerator(objs, character) {
    if (this.compiledGlyphs[character] !== void 0) {
      return this.compiledGlyphs[character];
    }
    let cmds;
    try {
      cmds = objs.get(this.loadedName + "_path_" + character);
    } catch (ex) {
      warn(`getPathGenerator - ignoring character: "${ex}".`);
    }
    if (!Array.isArray(cmds) || cmds.length === 0) {
      return this.compiledGlyphs[character] = function(c, size2) {
      };
    }
    const commands = [];
    for (let i2 = 0, ii = cmds.length; i2 < ii; ) {
      switch (cmds[i2++]) {
        case FontRenderOps.BEZIER_CURVE_TO:
          {
            const [a2, b2, c, d, e2, f2] = cmds.slice(i2, i2 + 6);
            commands.push((ctx) => ctx.bezierCurveTo(a2, b2, c, d, e2, f2));
            i2 += 6;
          }
          break;
        case FontRenderOps.MOVE_TO:
          {
            const [a2, b2] = cmds.slice(i2, i2 + 2);
            commands.push((ctx) => ctx.moveTo(a2, b2));
            i2 += 2;
          }
          break;
        case FontRenderOps.LINE_TO:
          {
            const [a2, b2] = cmds.slice(i2, i2 + 2);
            commands.push((ctx) => ctx.lineTo(a2, b2));
            i2 += 2;
          }
          break;
        case FontRenderOps.QUADRATIC_CURVE_TO:
          {
            const [a2, b2, c, d] = cmds.slice(i2, i2 + 4);
            commands.push((ctx) => ctx.quadraticCurveTo(a2, b2, c, d));
            i2 += 4;
          }
          break;
        case FontRenderOps.RESTORE:
          commands.push((ctx) => ctx.restore());
          break;
        case FontRenderOps.SAVE:
          commands.push((ctx) => ctx.save());
          break;
        case FontRenderOps.SCALE:
          assert(commands.length === 2, "Scale command is only valid at the third position.");
          break;
        case FontRenderOps.TRANSFORM:
          {
            const [a2, b2, c, d, e2, f2] = cmds.slice(i2, i2 + 6);
            commands.push((ctx) => ctx.transform(a2, b2, c, d, e2, f2));
            i2 += 6;
          }
          break;
        case FontRenderOps.TRANSLATE:
          {
            const [a2, b2] = cmds.slice(i2, i2 + 2);
            commands.push((ctx) => ctx.translate(a2, b2));
            i2 += 2;
          }
          break;
      }
    }
    return this.compiledGlyphs[character] = function glyphDrawer(ctx, size2) {
      commands[0](ctx);
      commands[1](ctx);
      ctx.scale(size2, -size2);
      for (let i2 = 2, ii = commands.length; i2 < ii; i2++) {
        commands[i2](ctx);
      }
    };
  }
}
if (isNodeJS) {
  var packageCapability = Promise.withResolvers();
  var packageMap = null;
  const loadPackages = async () => {
    const fs = await __vitePreload(() => import(
      /*webpackIgnore: true*/
      "./__vite-browser-external-2Ng8QIWW.js"
    ), true ? [] : void 0, import.meta.url), http = await __vitePreload(() => import(
      /*webpackIgnore: true*/
      "./__vite-browser-external-2Ng8QIWW.js"
    ), true ? [] : void 0, import.meta.url), https = await __vitePreload(() => import(
      /*webpackIgnore: true*/
      "./__vite-browser-external-2Ng8QIWW.js"
    ), true ? [] : void 0, import.meta.url), url = await __vitePreload(() => import(
      /*webpackIgnore: true*/
      "./__vite-browser-external-2Ng8QIWW.js"
    ), true ? [] : void 0, import.meta.url);
    let canvas, path2d;
    return new Map(Object.entries({
      fs,
      http,
      https,
      url,
      canvas,
      path2d
    }));
  };
  loadPackages().then((map) => {
    packageMap = map;
    packageCapability.resolve();
  }, (reason) => {
    warn(`loadPackages: ${reason}`);
    packageMap = /* @__PURE__ */ new Map();
    packageCapability.resolve();
  });
}
class NodePackages {
  static get promise() {
    return packageCapability.promise;
  }
  static get(name) {
    return packageMap?.get(name);
  }
}
const node_utils_fetchData = function(url) {
  const fs = NodePackages.get("fs");
  return fs.promises.readFile(url).then((data2) => new Uint8Array(data2));
};
class NodeFilterFactory extends BaseFilterFactory {
}
class NodeCanvasFactory extends BaseCanvasFactory {
  _createCanvas(width, height) {
    const canvas = NodePackages.get("canvas");
    return canvas.createCanvas(width, height);
  }
}
class NodeCMapReaderFactory extends BaseCMapReaderFactory {
  _fetchData(url, compressionType) {
    return node_utils_fetchData(url).then((data2) => ({
      cMapData: data2,
      compressionType
    }));
  }
}
class NodeStandardFontDataFactory extends BaseStandardFontDataFactory {
  _fetchData(url) {
    return node_utils_fetchData(url);
  }
}
const PathType = {
  FILL: "Fill",
  STROKE: "Stroke",
  SHADING: "Shading"
};
function applyBoundingBox(ctx, bbox) {
  if (!bbox) {
    return;
  }
  const width = bbox[2] - bbox[0];
  const height = bbox[3] - bbox[1];
  const region = new Path2D();
  region.rect(bbox[0], bbox[1], width, height);
  ctx.clip(region);
}
class BaseShadingPattern {
  constructor() {
    if (this.constructor === BaseShadingPattern) {
      unreachable("Cannot initialize BaseShadingPattern.");
    }
  }
  getPattern() {
    unreachable("Abstract method `getPattern` called.");
  }
}
class RadialAxialShadingPattern extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._type = IR[1];
    this._bbox = IR[2];
    this._colorStops = IR[3];
    this._p0 = IR[4];
    this._p1 = IR[5];
    this._r0 = IR[6];
    this._r1 = IR[7];
    this.matrix = null;
  }
  _createGradient(ctx) {
    let grad;
    if (this._type === "axial") {
      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
    } else if (this._type === "radial") {
      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
    }
    for (const colorStop of this._colorStops) {
      grad.addColorStop(colorStop[0], colorStop[1]);
    }
    return grad;
  }
  getPattern(ctx, owner, inverse, pathType) {
    let pattern;
    if (pathType === PathType.STROKE || pathType === PathType.FILL) {
      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [0, 0, 0, 0];
      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
      const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
      const tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.beginPath();
      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
      inverse = Util$1.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
      tmpCtx.transform(...owner.baseTransform);
      if (this.matrix) {
        tmpCtx.transform(...this.matrix);
      }
      applyBoundingBox(tmpCtx, this._bbox);
      tmpCtx.fillStyle = this._createGradient(tmpCtx);
      tmpCtx.fill();
      pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
      const domMatrix = new DOMMatrix(inverse);
      pattern.setTransform(domMatrix);
    } else {
      applyBoundingBox(ctx, this._bbox);
      pattern = this._createGradient(ctx);
    }
    return pattern;
  }
}
function drawTriangle(data2, context, p1, p2, p3, c1, c2, c3) {
  const coords = context.coords, colors = context.colors;
  const bytes = data2.data, rowSize = data2.width * 4;
  let tmp;
  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }
  if (coords[p2 + 1] > coords[p3 + 1]) {
    tmp = p2;
    p2 = p3;
    p3 = tmp;
    tmp = c2;
    c2 = c3;
    c3 = tmp;
  }
  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }
  const x1 = (coords[p1] + context.offsetX) * context.scaleX;
  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
  const x2 = (coords[p2] + context.offsetX) * context.scaleX;
  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
  const x3 = (coords[p3] + context.offsetX) * context.scaleX;
  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
  if (y1 >= y3) {
    return;
  }
  const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
  const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
  const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
  const minY = Math.round(y1), maxY = Math.round(y3);
  let xa, car, cag, cab;
  let xb, cbr, cbg, cbb;
  for (let y4 = minY; y4 <= maxY; y4++) {
    if (y4 < y2) {
      const k3 = y4 < y1 ? 0 : (y1 - y4) / (y1 - y2);
      xa = x1 - (x1 - x2) * k3;
      car = c1r - (c1r - c2r) * k3;
      cag = c1g - (c1g - c2g) * k3;
      cab = c1b - (c1b - c2b) * k3;
    } else {
      let k3;
      if (y4 > y3) {
        k3 = 1;
      } else if (y2 === y3) {
        k3 = 0;
      } else {
        k3 = (y2 - y4) / (y2 - y3);
      }
      xa = x2 - (x2 - x3) * k3;
      car = c2r - (c2r - c3r) * k3;
      cag = c2g - (c2g - c3g) * k3;
      cab = c2b - (c2b - c3b) * k3;
    }
    let k2;
    if (y4 < y1) {
      k2 = 0;
    } else if (y4 > y3) {
      k2 = 1;
    } else {
      k2 = (y1 - y4) / (y1 - y3);
    }
    xb = x1 - (x1 - x3) * k2;
    cbr = c1r - (c1r - c3r) * k2;
    cbg = c1g - (c1g - c3g) * k2;
    cbb = c1b - (c1b - c3b) * k2;
    const x1_ = Math.round(Math.min(xa, xb));
    const x2_ = Math.round(Math.max(xa, xb));
    let j = rowSize * y4 + x1_ * 4;
    for (let x4 = x1_; x4 <= x2_; x4++) {
      k2 = (xa - x4) / (xa - xb);
      if (k2 < 0) {
        k2 = 0;
      } else if (k2 > 1) {
        k2 = 1;
      }
      bytes[j++] = car - (car - cbr) * k2 | 0;
      bytes[j++] = cag - (cag - cbg) * k2 | 0;
      bytes[j++] = cab - (cab - cbb) * k2 | 0;
      bytes[j++] = 255;
    }
  }
}
function drawFigure(data2, figure, context) {
  const ps = figure.coords;
  const cs = figure.colors;
  let i2, ii;
  switch (figure.type) {
    case "lattice":
      const verticesPerRow = figure.verticesPerRow;
      const rows = Math.floor(ps.length / verticesPerRow) - 1;
      const cols = verticesPerRow - 1;
      for (i2 = 0; i2 < rows; i2++) {
        let q = i2 * verticesPerRow;
        for (let j = 0; j < cols; j++, q++) {
          drawTriangle(data2, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
          drawTriangle(data2, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
        }
      }
      break;
    case "triangles":
      for (i2 = 0, ii = ps.length; i2 < ii; i2 += 3) {
        drawTriangle(data2, context, ps[i2], ps[i2 + 1], ps[i2 + 2], cs[i2], cs[i2 + 1], cs[i2 + 2]);
      }
      break;
    default:
      throw new Error("illegal figure");
  }
}
class MeshShadingPattern extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._coords = IR[2];
    this._colors = IR[3];
    this._figures = IR[4];
    this._bounds = IR[5];
    this._bbox = IR[7];
    this._background = IR[8];
    this.matrix = null;
  }
  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
    const EXPECTED_SCALE = 1.1;
    const MAX_PATTERN_SIZE = 3e3;
    const BORDER_SIZE = 2;
    const offsetX = Math.floor(this._bounds[0]);
    const offsetY = Math.floor(this._bounds[1]);
    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const scaleX = boundsWidth / width;
    const scaleY = boundsHeight / height;
    const context = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -offsetX,
      offsetY: -offsetY,
      scaleX: 1 / scaleX,
      scaleY: 1 / scaleY
    };
    const paddedWidth = width + BORDER_SIZE * 2;
    const paddedHeight = height + BORDER_SIZE * 2;
    const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
    const tmpCtx = tmpCanvas.context;
    const data2 = tmpCtx.createImageData(width, height);
    if (backgroundColor) {
      const bytes = data2.data;
      for (let i2 = 0, ii = bytes.length; i2 < ii; i2 += 4) {
        bytes[i2] = backgroundColor[0];
        bytes[i2 + 1] = backgroundColor[1];
        bytes[i2 + 2] = backgroundColor[2];
        bytes[i2 + 3] = 255;
      }
    }
    for (const figure of this._figures) {
      drawFigure(data2, figure, context);
    }
    tmpCtx.putImageData(data2, BORDER_SIZE, BORDER_SIZE);
    const canvas = tmpCanvas.canvas;
    return {
      canvas,
      offsetX: offsetX - BORDER_SIZE * scaleX,
      offsetY: offsetY - BORDER_SIZE * scaleY,
      scaleX,
      scaleY
    };
  }
  getPattern(ctx, owner, inverse, pathType) {
    applyBoundingBox(ctx, this._bbox);
    let scale;
    if (pathType === PathType.SHADING) {
      scale = Util$1.singularValueDecompose2dScale(getCurrentTransform(ctx));
    } else {
      scale = Util$1.singularValueDecompose2dScale(owner.baseTransform);
      if (this.matrix) {
        const matrixScale = Util$1.singularValueDecompose2dScale(this.matrix);
        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
      }
    }
    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
    if (pathType !== PathType.SHADING) {
      ctx.setTransform(...owner.baseTransform);
      if (this.matrix) {
        ctx.transform(...this.matrix);
      }
    }
    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
  }
}
class DummyShadingPattern extends BaseShadingPattern {
  getPattern() {
    return "hotpink";
  }
}
function getShadingPattern(IR) {
  switch (IR[0]) {
    case "RadialAxial":
      return new RadialAxialShadingPattern(IR);
    case "Mesh":
      return new MeshShadingPattern(IR);
    case "Dummy":
      return new DummyShadingPattern();
  }
  throw new Error(`Unknown IR type: ${IR[0]}`);
}
const PaintType = {
  COLORED: 1,
  UNCOLORED: 2
};
class TilingPattern {
  static MAX_PATTERN_SIZE = 3e3;
  constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
    this.operatorList = IR[2];
    this.matrix = IR[3];
    this.bbox = IR[4];
    this.xstep = IR[5];
    this.ystep = IR[6];
    this.paintType = IR[7];
    this.tilingType = IR[8];
    this.color = color;
    this.ctx = ctx;
    this.canvasGraphicsFactory = canvasGraphicsFactory;
    this.baseTransform = baseTransform;
  }
  createPatternCanvas(owner) {
    const operatorList = this.operatorList;
    const bbox = this.bbox;
    const xstep = this.xstep;
    const ystep = this.ystep;
    const paintType = this.paintType;
    const tilingType = this.tilingType;
    const color = this.color;
    const canvasGraphicsFactory = this.canvasGraphicsFactory;
    info("TilingType: " + tilingType);
    const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
    const matrixScale = Util$1.singularValueDecompose2dScale(this.matrix);
    const curMatrixScale = Util$1.singularValueDecompose2dScale(this.baseTransform);
    const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
    const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
    const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
    const tmpCtx = tmpCanvas.context;
    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
    graphics.groupLevel = owner.groupLevel;
    this.setFillAndStrokeStyleToContext(graphics, paintType, color);
    let adjustedX0 = x0;
    let adjustedY0 = y0;
    let adjustedX1 = x1;
    let adjustedY1 = y1;
    if (x0 < 0) {
      adjustedX0 = 0;
      adjustedX1 += Math.abs(x0);
    }
    if (y0 < 0) {
      adjustedY0 = 0;
      adjustedY1 += Math.abs(y0);
    }
    tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
    tmpCtx.save();
    this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
    graphics.baseTransform = getCurrentTransform(graphics.ctx);
    graphics.executeOperatorList(operatorList);
    graphics.endDrawing();
    return {
      canvas: tmpCanvas.canvas,
      scaleX: dimx.scale,
      scaleY: dimy.scale,
      offsetX: adjustedX0,
      offsetY: adjustedY0
    };
  }
  getSizeAndScale(step, realOutputSize, scale) {
    step = Math.abs(step);
    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
    let size2 = Math.ceil(step * scale);
    if (size2 >= maxSize) {
      size2 = maxSize;
    } else {
      scale = size2 / step;
    }
    return {
      scale,
      size: size2
    };
  }
  clipBbox(graphics, x0, y0, x1, y1) {
    const bboxWidth = x1 - x0;
    const bboxHeight = y1 - y0;
    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
    graphics.current.updateRectMinMax(getCurrentTransform(graphics.ctx), [x0, y0, x1, y1]);
    graphics.clip();
    graphics.endPath();
  }
  setFillAndStrokeStyleToContext(graphics, paintType, color) {
    const context = graphics.ctx, current = graphics.current;
    switch (paintType) {
      case PaintType.COLORED:
        const ctx = this.ctx;
        context.fillStyle = ctx.fillStyle;
        context.strokeStyle = ctx.strokeStyle;
        current.fillColor = ctx.fillStyle;
        current.strokeColor = ctx.strokeStyle;
        break;
      case PaintType.UNCOLORED:
        const cssColor = Util$1.makeHexColor(color[0], color[1], color[2]);
        context.fillStyle = cssColor;
        context.strokeStyle = cssColor;
        current.fillColor = cssColor;
        current.strokeColor = cssColor;
        break;
      default:
        throw new FormatError(`Unsupported paint type: ${paintType}`);
    }
  }
  getPattern(ctx, owner, inverse, pathType) {
    let matrix = inverse;
    if (pathType !== PathType.SHADING) {
      matrix = Util$1.transform(matrix, owner.baseTransform);
      if (this.matrix) {
        matrix = Util$1.transform(matrix, this.matrix);
      }
    }
    const temporaryPatternCanvas = this.createPatternCanvas(owner);
    let domMatrix = new DOMMatrix(matrix);
    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
    pattern.setTransform(domMatrix);
    return pattern;
  }
}
function convertBlackAndWhiteToRGBA({
  src,
  srcPos = 0,
  dest,
  width,
  height,
  nonBlackColor = 4294967295,
  inverseDecode = false
}) {
  const black = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
  const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];
  const widthInSource = width >> 3;
  const widthRemainder = width & 7;
  const srcLength = src.length;
  dest = new Uint32Array(dest.buffer);
  let destPos = 0;
  for (let i2 = 0; i2 < height; i2++) {
    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
      const elem2 = srcPos < srcLength ? src[srcPos] : 255;
      dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;
    }
    if (widthRemainder === 0) {
      continue;
    }
    const elem = srcPos < srcLength ? src[srcPos++] : 255;
    for (let j = 0; j < widthRemainder; j++) {
      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
    }
  }
  return {
    srcPos,
    destPos
  };
}
const MIN_FONT_SIZE = 16;
const MAX_FONT_SIZE = 100;
const EXECUTION_TIME = 15;
const EXECUTION_STEPS = 10;
const MAX_SIZE_TO_COMPILE = 1e3;
const FULL_CHUNK_HEIGHT = 16;
function mirrorContextOperations(ctx, destCtx) {
  if (ctx._removeMirroring) {
    throw new Error("Context is already forwarding operations.");
  }
  ctx.__originalSave = ctx.save;
  ctx.__originalRestore = ctx.restore;
  ctx.__originalRotate = ctx.rotate;
  ctx.__originalScale = ctx.scale;
  ctx.__originalTranslate = ctx.translate;
  ctx.__originalTransform = ctx.transform;
  ctx.__originalSetTransform = ctx.setTransform;
  ctx.__originalResetTransform = ctx.resetTransform;
  ctx.__originalClip = ctx.clip;
  ctx.__originalMoveTo = ctx.moveTo;
  ctx.__originalLineTo = ctx.lineTo;
  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
  ctx.__originalRect = ctx.rect;
  ctx.__originalClosePath = ctx.closePath;
  ctx.__originalBeginPath = ctx.beginPath;
  ctx._removeMirroring = () => {
    ctx.save = ctx.__originalSave;
    ctx.restore = ctx.__originalRestore;
    ctx.rotate = ctx.__originalRotate;
    ctx.scale = ctx.__originalScale;
    ctx.translate = ctx.__originalTranslate;
    ctx.transform = ctx.__originalTransform;
    ctx.setTransform = ctx.__originalSetTransform;
    ctx.resetTransform = ctx.__originalResetTransform;
    ctx.clip = ctx.__originalClip;
    ctx.moveTo = ctx.__originalMoveTo;
    ctx.lineTo = ctx.__originalLineTo;
    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
    ctx.rect = ctx.__originalRect;
    ctx.closePath = ctx.__originalClosePath;
    ctx.beginPath = ctx.__originalBeginPath;
    delete ctx._removeMirroring;
  };
  ctx.save = function ctxSave() {
    destCtx.save();
    this.__originalSave();
  };
  ctx.restore = function ctxRestore() {
    destCtx.restore();
    this.__originalRestore();
  };
  ctx.translate = function ctxTranslate(x2, y2) {
    destCtx.translate(x2, y2);
    this.__originalTranslate(x2, y2);
  };
  ctx.scale = function ctxScale(x2, y2) {
    destCtx.scale(x2, y2);
    this.__originalScale(x2, y2);
  };
  ctx.transform = function ctxTransform(a2, b2, c, d, e2, f2) {
    destCtx.transform(a2, b2, c, d, e2, f2);
    this.__originalTransform(a2, b2, c, d, e2, f2);
  };
  ctx.setTransform = function ctxSetTransform(a2, b2, c, d, e2, f2) {
    destCtx.setTransform(a2, b2, c, d, e2, f2);
    this.__originalSetTransform(a2, b2, c, d, e2, f2);
  };
  ctx.resetTransform = function ctxResetTransform() {
    destCtx.resetTransform();
    this.__originalResetTransform();
  };
  ctx.rotate = function ctxRotate(angle) {
    destCtx.rotate(angle);
    this.__originalRotate(angle);
  };
  ctx.clip = function ctxRotate(rule) {
    destCtx.clip(rule);
    this.__originalClip(rule);
  };
  ctx.moveTo = function(x2, y2) {
    destCtx.moveTo(x2, y2);
    this.__originalMoveTo(x2, y2);
  };
  ctx.lineTo = function(x2, y2) {
    destCtx.lineTo(x2, y2);
    this.__originalLineTo(x2, y2);
  };
  ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x2, y2) {
    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
  };
  ctx.rect = function(x2, y2, width, height) {
    destCtx.rect(x2, y2, width, height);
    this.__originalRect(x2, y2, width, height);
  };
  ctx.closePath = function() {
    destCtx.closePath();
    this.__originalClosePath();
  };
  ctx.beginPath = function() {
    destCtx.beginPath();
    this.__originalBeginPath();
  };
}
class CachedCanvases {
  constructor(canvasFactory) {
    this.canvasFactory = canvasFactory;
    this.cache = /* @__PURE__ */ Object.create(null);
  }
  getCanvas(id2, width, height) {
    let canvasEntry;
    if (this.cache[id2] !== void 0) {
      canvasEntry = this.cache[id2];
      this.canvasFactory.reset(canvasEntry, width, height);
    } else {
      canvasEntry = this.canvasFactory.create(width, height);
      this.cache[id2] = canvasEntry;
    }
    return canvasEntry;
  }
  delete(id2) {
    delete this.cache[id2];
  }
  clear() {
    for (const id2 in this.cache) {
      const canvasEntry = this.cache[id2];
      this.canvasFactory.destroy(canvasEntry);
      delete this.cache[id2];
    }
  }
}
function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
  const [a2, b2, c, d, tx, ty] = getCurrentTransform(ctx);
  if (b2 === 0 && c === 0) {
    const tlX = destX * a2 + tx;
    const rTlX = Math.round(tlX);
    const tlY = destY * d + ty;
    const rTlY = Math.round(tlY);
    const brX = (destX + destW) * a2 + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destY + destH) * d + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(Math.sign(a2), 0, 0, Math.sign(d), rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
    ctx.setTransform(a2, b2, c, d, tx, ty);
    return [rWidth, rHeight];
  }
  if (a2 === 0 && d === 0) {
    const tlX = destY * c + tx;
    const rTlX = Math.round(tlX);
    const tlY = destX * b2 + ty;
    const rTlY = Math.round(tlY);
    const brX = (destY + destH) * c + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destX + destW) * b2 + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(0, Math.sign(b2), Math.sign(c), 0, rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
    ctx.setTransform(a2, b2, c, d, tx, ty);
    return [rHeight, rWidth];
  }
  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
  const scaleX = Math.hypot(a2, b2);
  const scaleY = Math.hypot(c, d);
  return [scaleX * destW, scaleY * destH];
}
function compileType3Glyph(imgData) {
  const {
    width,
    height
  } = imgData;
  if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
    return null;
  }
  const POINT_TO_PROCESS_LIMIT = 1e3;
  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
  const width1 = width + 1;
  let points = new Uint8Array(width1 * (height + 1));
  let i2, j, j0;
  const lineSize = width + 7 & ~7;
  let data2 = new Uint8Array(lineSize * height), pos = 0;
  for (const elem of imgData.data) {
    let mask = 128;
    while (mask > 0) {
      data2[pos++] = elem & mask ? 0 : 255;
      mask >>= 1;
    }
  }
  let count = 0;
  pos = 0;
  if (data2[pos] !== 0) {
    points[0] = 1;
    ++count;
  }
  for (j = 1; j < width; j++) {
    if (data2[pos] !== data2[pos + 1]) {
      points[j] = data2[pos] ? 2 : 1;
      ++count;
    }
    pos++;
  }
  if (data2[pos] !== 0) {
    points[j] = 2;
    ++count;
  }
  for (i2 = 1; i2 < height; i2++) {
    pos = i2 * lineSize;
    j0 = i2 * width1;
    if (data2[pos - lineSize] !== data2[pos]) {
      points[j0] = data2[pos] ? 1 : 8;
      ++count;
    }
    let sum = (data2[pos] ? 4 : 0) + (data2[pos - lineSize] ? 8 : 0);
    for (j = 1; j < width; j++) {
      sum = (sum >> 2) + (data2[pos + 1] ? 4 : 0) + (data2[pos - lineSize + 1] ? 8 : 0);
      if (POINT_TYPES[sum]) {
        points[j0 + j] = POINT_TYPES[sum];
        ++count;
      }
      pos++;
    }
    if (data2[pos - lineSize] !== data2[pos]) {
      points[j0 + j] = data2[pos] ? 2 : 4;
      ++count;
    }
    if (count > POINT_TO_PROCESS_LIMIT) {
      return null;
    }
  }
  pos = lineSize * (height - 1);
  j0 = i2 * width1;
  if (data2[pos] !== 0) {
    points[j0] = 8;
    ++count;
  }
  for (j = 1; j < width; j++) {
    if (data2[pos] !== data2[pos + 1]) {
      points[j0 + j] = data2[pos] ? 4 : 8;
      ++count;
    }
    pos++;
  }
  if (data2[pos] !== 0) {
    points[j0 + j] = 4;
    ++count;
  }
  if (count > POINT_TO_PROCESS_LIMIT) {
    return null;
  }
  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
  const path = new Path2D();
  for (i2 = 0; count && i2 <= height; i2++) {
    let p2 = i2 * width1;
    const end = p2 + width;
    while (p2 < end && !points[p2]) {
      p2++;
    }
    if (p2 === end) {
      continue;
    }
    path.moveTo(p2 % width1, i2);
    const p0 = p2;
    let type = points[p2];
    do {
      const step = steps[type];
      do {
        p2 += step;
      } while (!points[p2]);
      const pp = points[p2];
      if (pp !== 5 && pp !== 10) {
        type = pp;
        points[p2] = 0;
      } else {
        type = pp & 51 * type >> 4;
        points[p2] &= type >> 2 | type << 2;
      }
      path.lineTo(p2 % width1, p2 / width1 | 0);
      if (!points[p2]) {
        --count;
      }
    } while (p0 !== p2);
    --i2;
  }
  data2 = null;
  points = null;
  const drawOutline = function(c) {
    c.save();
    c.scale(1 / width, -1 / height);
    c.translate(0, -height);
    c.fill(path);
    c.beginPath();
    c.restore();
  };
  return drawOutline;
}
class CanvasExtraState {
  constructor(width, height) {
    this.alphaIsShape = false;
    this.fontSize = 0;
    this.fontSizeScale = 1;
    this.textMatrix = IDENTITY_MATRIX;
    this.textMatrixScale = 1;
    this.fontMatrix = FONT_IDENTITY_MATRIX;
    this.leading = 0;
    this.x = 0;
    this.y = 0;
    this.lineX = 0;
    this.lineY = 0;
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.textHScale = 1;
    this.textRenderingMode = TextRenderingMode.FILL;
    this.textRise = 0;
    this.fillColor = "#000000";
    this.strokeColor = "#000000";
    this.patternFill = false;
    this.fillAlpha = 1;
    this.strokeAlpha = 1;
    this.lineWidth = 1;
    this.activeSMask = null;
    this.transferMaps = "none";
    this.startNewPathAndClipBox([0, 0, width, height]);
  }
  clone() {
    const clone = Object.create(this);
    clone.clipBox = this.clipBox.slice();
    return clone;
  }
  setCurrentPoint(x2, y2) {
    this.x = x2;
    this.y = y2;
  }
  updatePathMinMax(transform2, x2, y2) {
    [x2, y2] = Util$1.applyTransform([x2, y2], transform2);
    this.minX = Math.min(this.minX, x2);
    this.minY = Math.min(this.minY, y2);
    this.maxX = Math.max(this.maxX, x2);
    this.maxY = Math.max(this.maxY, y2);
  }
  updateRectMinMax(transform2, rect) {
    const p1 = Util$1.applyTransform(rect, transform2);
    const p2 = Util$1.applyTransform(rect.slice(2), transform2);
    const p3 = Util$1.applyTransform([rect[0], rect[3]], transform2);
    const p4 = Util$1.applyTransform([rect[2], rect[1]], transform2);
    this.minX = Math.min(this.minX, p1[0], p2[0], p3[0], p4[0]);
    this.minY = Math.min(this.minY, p1[1], p2[1], p3[1], p4[1]);
    this.maxX = Math.max(this.maxX, p1[0], p2[0], p3[0], p4[0]);
    this.maxY = Math.max(this.maxY, p1[1], p2[1], p3[1], p4[1]);
  }
  updateScalingPathMinMax(transform2, minMax) {
    Util$1.scaleMinMax(transform2, minMax);
    this.minX = Math.min(this.minX, minMax[0]);
    this.minY = Math.min(this.minY, minMax[1]);
    this.maxX = Math.max(this.maxX, minMax[2]);
    this.maxY = Math.max(this.maxY, minMax[3]);
  }
  updateCurvePathMinMax(transform2, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
    const box = Util$1.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax);
    if (minMax) {
      return;
    }
    this.updateRectMinMax(transform2, box);
  }
  getPathBoundingBox(pathType = PathType.FILL, transform2 = null) {
    const box = [this.minX, this.minY, this.maxX, this.maxY];
    if (pathType === PathType.STROKE) {
      if (!transform2) {
        unreachable("Stroke bounding box must include transform.");
      }
      const scale = Util$1.singularValueDecompose2dScale(transform2);
      const xStrokePad = scale[0] * this.lineWidth / 2;
      const yStrokePad = scale[1] * this.lineWidth / 2;
      box[0] -= xStrokePad;
      box[1] -= yStrokePad;
      box[2] += xStrokePad;
      box[3] += yStrokePad;
    }
    return box;
  }
  updateClipFromPath() {
    const intersect = Util$1.intersect(this.clipBox, this.getPathBoundingBox());
    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
  }
  isEmptyClip() {
    return this.minX === Infinity;
  }
  startNewPathAndClipBox(box) {
    this.clipBox = box;
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = 0;
    this.maxY = 0;
  }
  getClippedPathBoundingBox(pathType = PathType.FILL, transform2 = null) {
    return Util$1.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform2));
  }
}
function putBinaryImageData(ctx, imgData) {
  if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
    ctx.putImageData(imgData, 0, 0);
    return;
  }
  const height = imgData.height, width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0, destPos;
  const src = imgData.data;
  const dest = chunkImgData.data;
  let i2, j, thisChunkHeight, elemsInThisChunk;
  if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {
    const srcLength = src.byteLength;
    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
    const dest32DataLength = dest32.length;
    const fullSrcDiff = width + 7 >> 3;
    const white = 4294967295;
    const black = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
    for (i2 = 0; i2 < totalChunks; i2++) {
      thisChunkHeight = i2 < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
      destPos = 0;
      for (j = 0; j < thisChunkHeight; j++) {
        const srcDiff = srcLength - srcPos;
        let k2 = 0;
        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
        const kEndUnrolled = kEnd & ~7;
        let mask = 0;
        let srcByte = 0;
        for (; k2 < kEndUnrolled; k2 += 8) {
          srcByte = src[srcPos++];
          dest32[destPos++] = srcByte & 128 ? white : black;
          dest32[destPos++] = srcByte & 64 ? white : black;
          dest32[destPos++] = srcByte & 32 ? white : black;
          dest32[destPos++] = srcByte & 16 ? white : black;
          dest32[destPos++] = srcByte & 8 ? white : black;
          dest32[destPos++] = srcByte & 4 ? white : black;
          dest32[destPos++] = srcByte & 2 ? white : black;
          dest32[destPos++] = srcByte & 1 ? white : black;
        }
        for (; k2 < kEnd; k2++) {
          if (mask === 0) {
            srcByte = src[srcPos++];
            mask = 128;
          }
          dest32[destPos++] = srcByte & mask ? white : black;
          mask >>= 1;
        }
      }
      while (destPos < dest32DataLength) {
        dest32[destPos++] = 0;
      }
      ctx.putImageData(chunkImgData, 0, i2 * FULL_CHUNK_HEIGHT);
    }
  } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {
    j = 0;
    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
    for (i2 = 0; i2 < fullChunks; i2++) {
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      srcPos += elemsInThisChunk;
      ctx.putImageData(chunkImgData, 0, j);
      j += FULL_CHUNK_HEIGHT;
    }
    if (i2 < totalChunks) {
      elemsInThisChunk = width * partialChunkHeight * 4;
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      ctx.putImageData(chunkImgData, 0, j);
    }
  } else if (imgData.kind === util_ImageKind.RGB_24BPP) {
    thisChunkHeight = FULL_CHUNK_HEIGHT;
    elemsInThisChunk = width * thisChunkHeight;
    for (i2 = 0; i2 < totalChunks; i2++) {
      if (i2 >= fullChunks) {
        thisChunkHeight = partialChunkHeight;
        elemsInThisChunk = width * thisChunkHeight;
      }
      destPos = 0;
      for (j = elemsInThisChunk; j--; ) {
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = 255;
      }
      ctx.putImageData(chunkImgData, 0, i2 * FULL_CHUNK_HEIGHT);
    }
  } else {
    throw new Error(`bad image kind: ${imgData.kind}`);
  }
}
function putBinaryImageMask(ctx, imgData) {
  if (imgData.bitmap) {
    ctx.drawImage(imgData.bitmap, 0, 0);
    return;
  }
  const height = imgData.height, width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0;
  const src = imgData.data;
  const dest = chunkImgData.data;
  for (let i2 = 0; i2 < totalChunks; i2++) {
    const thisChunkHeight = i2 < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
    ({
      srcPos
    } = convertBlackAndWhiteToRGBA({
      src,
      srcPos,
      dest,
      width,
      height: thisChunkHeight,
      nonBlackColor: 0
    }));
    ctx.putImageData(chunkImgData, 0, i2 * FULL_CHUNK_HEIGHT);
  }
}
function copyCtxState(sourceCtx, destCtx) {
  const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const property of properties) {
    if (sourceCtx[property] !== void 0) {
      destCtx[property] = sourceCtx[property];
    }
  }
  if (sourceCtx.setLineDash !== void 0) {
    destCtx.setLineDash(sourceCtx.getLineDash());
    destCtx.lineDashOffset = sourceCtx.lineDashOffset;
  }
}
function resetCtxToDefault(ctx) {
  ctx.strokeStyle = ctx.fillStyle = "#000000";
  ctx.fillRule = "nonzero";
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;
  ctx.lineCap = "butt";
  ctx.lineJoin = "miter";
  ctx.miterLimit = 10;
  ctx.globalCompositeOperation = "source-over";
  ctx.font = "10px sans-serif";
  if (ctx.setLineDash !== void 0) {
    ctx.setLineDash([]);
    ctx.lineDashOffset = 0;
  }
  if (!isNodeJS) {
    const {
      filter
    } = ctx;
    if (filter !== "none" && filter !== "") {
      ctx.filter = "none";
    }
  }
}
function getImageSmoothingEnabled(transform2, interpolate) {
  if (interpolate) {
    return true;
  }
  const scale = Util$1.singularValueDecompose2dScale(transform2);
  scale[0] = Math.fround(scale[0]);
  scale[1] = Math.fround(scale[1]);
  const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * PixelsPerInch$1.PDF_TO_CSS_UNITS);
  return scale[0] <= actualScale && scale[1] <= actualScale;
}
const LINE_CAP_STYLES = ["butt", "round", "square"];
const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
const NORMAL_CLIP = {};
const EO_CLIP = {};
class CanvasGraphics {
  constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, {
    optionalContentConfig,
    markedContentStack = null
  }, annotationCanvasMap, pageColors) {
    this.ctx = canvasCtx;
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.stateStack = [];
    this.pendingClip = null;
    this.pendingEOFill = false;
    this.res = null;
    this.xobjs = null;
    this.commonObjs = commonObjs;
    this.objs = objs;
    this.canvasFactory = canvasFactory;
    this.filterFactory = filterFactory;
    this.groupStack = [];
    this.processingType3 = null;
    this.baseTransform = null;
    this.baseTransformStack = [];
    this.groupLevel = 0;
    this.smaskStack = [];
    this.smaskCounter = 0;
    this.tempSMask = null;
    this.suspendedCtx = null;
    this.contentVisible = true;
    this.markedContentStack = markedContentStack || [];
    this.optionalContentConfig = optionalContentConfig;
    this.cachedCanvases = new CachedCanvases(this.canvasFactory);
    this.cachedPatterns = /* @__PURE__ */ new Map();
    this.annotationCanvasMap = annotationCanvasMap;
    this.viewportScale = 1;
    this.outputScaleX = 1;
    this.outputScaleY = 1;
    this.pageColors = pageColors;
    this._cachedScaleForStroking = [-1, 0];
    this._cachedGetSinglePixelWidth = null;
    this._cachedBitmapsMap = /* @__PURE__ */ new Map();
  }
  getObject(data2, fallback = null) {
    if (typeof data2 === "string") {
      return data2.startsWith("g_") ? this.commonObjs.get(data2) : this.objs.get(data2);
    }
    return fallback;
  }
  beginDrawing({
    transform: transform2,
    viewport,
    transparency = false,
    background = null
  }) {
    const width = this.ctx.canvas.width;
    const height = this.ctx.canvas.height;
    const savedFillStyle = this.ctx.fillStyle;
    this.ctx.fillStyle = background || "#ffffff";
    this.ctx.fillRect(0, 0, width, height);
    this.ctx.fillStyle = savedFillStyle;
    if (transparency) {
      const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
      this.compositeCtx = this.ctx;
      this.transparentCanvas = transparentCanvas.canvas;
      this.ctx = transparentCanvas.context;
      this.ctx.save();
      this.ctx.transform(...getCurrentTransform(this.compositeCtx));
    }
    this.ctx.save();
    resetCtxToDefault(this.ctx);
    if (transform2) {
      this.ctx.transform(...transform2);
      this.outputScaleX = transform2[0];
      this.outputScaleY = transform2[0];
    }
    this.ctx.transform(...viewport.transform);
    this.viewportScale = viewport.scale;
    this.baseTransform = getCurrentTransform(this.ctx);
  }
  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
    const argsArray = operatorList.argsArray;
    const fnArray = operatorList.fnArray;
    let i2 = executionStartIdx || 0;
    const argsArrayLen = argsArray.length;
    if (argsArrayLen === i2) {
      return i2;
    }
    const chunkOperations = argsArrayLen - i2 > EXECUTION_STEPS && typeof continueCallback === "function";
    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
    let steps = 0;
    const commonObjs = this.commonObjs;
    const objs = this.objs;
    let fnId;
    while (true) {
      if (stepper !== void 0 && i2 === stepper.nextBreakPoint) {
        stepper.breakIt(i2, continueCallback);
        return i2;
      }
      fnId = fnArray[i2];
      if (fnId !== OPS$1.dependency) {
        this[fnId].apply(this, argsArray[i2]);
      } else {
        for (const depObjId of argsArray[i2]) {
          const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
          if (!objsPool.has(depObjId)) {
            objsPool.get(depObjId, continueCallback);
            return i2;
          }
        }
      }
      i2++;
      if (i2 === argsArrayLen) {
        return i2;
      }
      if (chunkOperations && ++steps > EXECUTION_STEPS) {
        if (Date.now() > endTime) {
          continueCallback();
          return i2;
        }
        steps = 0;
      }
    }
  }
  #restoreInitialState() {
    while (this.stateStack.length || this.inSMaskMode) {
      this.restore();
    }
    this.ctx.restore();
    if (this.transparentCanvas) {
      this.ctx = this.compositeCtx;
      this.ctx.save();
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.ctx.drawImage(this.transparentCanvas, 0, 0);
      this.ctx.restore();
      this.transparentCanvas = null;
    }
  }
  endDrawing() {
    this.#restoreInitialState();
    this.cachedCanvases.clear();
    this.cachedPatterns.clear();
    for (const cache2 of this._cachedBitmapsMap.values()) {
      for (const canvas of cache2.values()) {
        if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
          canvas.width = canvas.height = 0;
        }
      }
      cache2.clear();
    }
    this._cachedBitmapsMap.clear();
    this.#drawFilter();
  }
  #drawFilter() {
    if (this.pageColors) {
      const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
      if (hcmFilterId !== "none") {
        const savedFilter = this.ctx.filter;
        this.ctx.filter = hcmFilterId;
        this.ctx.drawImage(this.ctx.canvas, 0, 0);
        this.ctx.filter = savedFilter;
      }
    }
  }
  _scaleImage(img, inverseTransform) {
    const width = img.width;
    const height = img.height;
    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
    let paintWidth = width, paintHeight = height;
    let tmpCanvasId = "prescale1";
    let tmpCanvas, tmpCtx;
    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
      let newWidth = paintWidth, newHeight = paintHeight;
      if (widthScale > 2 && paintWidth > 1) {
        newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);
        widthScale /= paintWidth / newWidth;
      }
      if (heightScale > 2 && paintHeight > 1) {
        newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;
        heightScale /= paintHeight / newHeight;
      }
      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
      tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, newWidth, newHeight);
      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
      img = tmpCanvas.canvas;
      paintWidth = newWidth;
      paintHeight = newHeight;
      tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
    }
    return {
      img,
      paintWidth,
      paintHeight
    };
  }
  _createMaskCanvas(img) {
    const ctx = this.ctx;
    const {
      width,
      height
    } = img;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    const currentTransform = getCurrentTransform(ctx);
    let cache2, cacheKey, scaled, maskCanvas;
    if ((img.bitmap || img.data) && img.count > 1) {
      const mainKey = img.bitmap || img.data.buffer;
      cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);
      cache2 = this._cachedBitmapsMap.get(mainKey);
      if (!cache2) {
        cache2 = /* @__PURE__ */ new Map();
        this._cachedBitmapsMap.set(mainKey, cache2);
      }
      const cachedImage = cache2.get(cacheKey);
      if (cachedImage && !isPatternFill) {
        const offsetX2 = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
        const offsetY2 = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
        return {
          canvas: cachedImage,
          offsetX: offsetX2,
          offsetY: offsetY2
        };
      }
      scaled = cachedImage;
    }
    if (!scaled) {
      maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      putBinaryImageMask(maskCanvas.context, img);
    }
    let maskToCanvas = Util$1.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
    maskToCanvas = Util$1.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
    const [minX, minY, maxX, maxY] = Util$1.getAxialAlignedBoundingBox([0, 0, width, height], maskToCanvas);
    const drawnWidth = Math.round(maxX - minX) || 1;
    const drawnHeight = Math.round(maxY - minY) || 1;
    const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
    const fillCtx = fillCanvas.context;
    const offsetX = minX;
    const offsetY = minY;
    fillCtx.translate(-offsetX, -offsetY);
    fillCtx.transform(...maskToCanvas);
    if (!scaled) {
      scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));
      scaled = scaled.img;
      if (cache2 && isPatternFill) {
        cache2.set(cacheKey, scaled);
      }
    }
    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);
    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
    fillCtx.globalCompositeOperation = "source-in";
    const inverse = Util$1.transform(getCurrentTransformInverse(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL) : fillColor;
    fillCtx.fillRect(0, 0, width, height);
    if (cache2 && !isPatternFill) {
      this.cachedCanvases.delete("fillCanvas");
      cache2.set(cacheKey, fillCanvas.canvas);
    }
    return {
      canvas: fillCanvas.canvas,
      offsetX: Math.round(offsetX),
      offsetY: Math.round(offsetY)
    };
  }
  setLineWidth(width) {
    if (width !== this.current.lineWidth) {
      this._cachedScaleForStroking[0] = -1;
    }
    this.current.lineWidth = width;
    this.ctx.lineWidth = width;
  }
  setLineCap(style2) {
    this.ctx.lineCap = LINE_CAP_STYLES[style2];
  }
  setLineJoin(style2) {
    this.ctx.lineJoin = LINE_JOIN_STYLES[style2];
  }
  setMiterLimit(limit) {
    this.ctx.miterLimit = limit;
  }
  setDash(dashArray, dashPhase) {
    const ctx = this.ctx;
    if (ctx.setLineDash !== void 0) {
      ctx.setLineDash(dashArray);
      ctx.lineDashOffset = dashPhase;
    }
  }
  setRenderingIntent(intent) {
  }
  setFlatness(flatness) {
  }
  setGState(states) {
    for (const [key, value] of states) {
      switch (key) {
        case "LW":
          this.setLineWidth(value);
          break;
        case "LC":
          this.setLineCap(value);
          break;
        case "LJ":
          this.setLineJoin(value);
          break;
        case "ML":
          this.setMiterLimit(value);
          break;
        case "D":
          this.setDash(value[0], value[1]);
          break;
        case "RI":
          this.setRenderingIntent(value);
          break;
        case "FL":
          this.setFlatness(value);
          break;
        case "Font":
          this.setFont(value[0], value[1]);
          break;
        case "CA":
          this.current.strokeAlpha = value;
          break;
        case "ca":
          this.current.fillAlpha = value;
          this.ctx.globalAlpha = value;
          break;
        case "BM":
          this.ctx.globalCompositeOperation = value;
          break;
        case "SMask":
          this.current.activeSMask = value ? this.tempSMask : null;
          this.tempSMask = null;
          this.checkSMaskState();
          break;
        case "TR":
          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);
          break;
      }
    }
  }
  get inSMaskMode() {
    return !!this.suspendedCtx;
  }
  checkSMaskState() {
    const inSMaskMode = this.inSMaskMode;
    if (this.current.activeSMask && !inSMaskMode) {
      this.beginSMaskMode();
    } else if (!this.current.activeSMask && inSMaskMode) {
      this.endSMaskMode();
    }
  }
  beginSMaskMode() {
    if (this.inSMaskMode) {
      throw new Error("beginSMaskMode called while already in smask mode");
    }
    const drawnWidth = this.ctx.canvas.width;
    const drawnHeight = this.ctx.canvas.height;
    const cacheId = "smaskGroupAt" + this.groupLevel;
    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
    this.suspendedCtx = this.ctx;
    this.ctx = scratchCanvas.context;
    const ctx = this.ctx;
    ctx.setTransform(...getCurrentTransform(this.suspendedCtx));
    copyCtxState(this.suspendedCtx, ctx);
    mirrorContextOperations(ctx, this.suspendedCtx);
    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
  }
  endSMaskMode() {
    if (!this.inSMaskMode) {
      throw new Error("endSMaskMode called while not in smask mode");
    }
    this.ctx._removeMirroring();
    copyCtxState(this.ctx, this.suspendedCtx);
    this.ctx = this.suspendedCtx;
    this.suspendedCtx = null;
  }
  compose(dirtyBox) {
    if (!this.current.activeSMask) {
      return;
    }
    if (!dirtyBox) {
      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    } else {
      dirtyBox[0] = Math.floor(dirtyBox[0]);
      dirtyBox[1] = Math.floor(dirtyBox[1]);
      dirtyBox[2] = Math.ceil(dirtyBox[2]);
      dirtyBox[3] = Math.ceil(dirtyBox[3]);
    }
    const smask = this.current.activeSMask;
    const suspendedCtx = this.suspendedCtx;
    this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    this.ctx.restore();
  }
  composeSMask(ctx, smask, layerCtx, layerBox) {
    const layerOffsetX = layerBox[0];
    const layerOffsetY = layerBox[1];
    const layerWidth = layerBox[2] - layerOffsetX;
    const layerHeight = layerBox[3] - layerOffsetY;
    if (layerWidth === 0 || layerHeight === 0) {
      return;
    }
    this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = "source-over";
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(layerCtx.canvas, 0, 0);
    ctx.restore();
  }
  genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
    let maskCanvas = maskCtx.canvas;
    let maskX = layerOffsetX - maskOffsetX;
    let maskY = layerOffsetY - maskOffsetY;
    if (backdrop) {
      if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {
        const canvas = this.cachedCanvases.getCanvas("maskExtension", width, height);
        const ctx = canvas.context;
        ctx.drawImage(maskCanvas, -maskX, -maskY);
        if (backdrop.some((c) => c !== 0)) {
          ctx.globalCompositeOperation = "destination-atop";
          ctx.fillStyle = Util$1.makeHexColor(...backdrop);
          ctx.fillRect(0, 0, width, height);
          ctx.globalCompositeOperation = "source-over";
        }
        maskCanvas = canvas.canvas;
        maskX = maskY = 0;
      } else if (backdrop.some((c) => c !== 0)) {
        maskCtx.save();
        maskCtx.globalAlpha = 1;
        maskCtx.setTransform(1, 0, 0, 1, 0, 0);
        const clip2 = new Path2D();
        clip2.rect(maskX, maskY, width, height);
        maskCtx.clip(clip2);
        maskCtx.globalCompositeOperation = "destination-atop";
        maskCtx.fillStyle = Util$1.makeHexColor(...backdrop);
        maskCtx.fillRect(maskX, maskY, width, height);
        maskCtx.restore();
      }
    }
    layerCtx.save();
    layerCtx.globalAlpha = 1;
    layerCtx.setTransform(1, 0, 0, 1, 0, 0);
    if (subtype === "Alpha" && transferMap) {
      layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);
    } else if (subtype === "Luminosity") {
      layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);
    }
    const clip = new Path2D();
    clip.rect(layerOffsetX, layerOffsetY, width, height);
    layerCtx.clip(clip);
    layerCtx.globalCompositeOperation = "destination-in";
    layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);
    layerCtx.restore();
  }
  save() {
    if (this.inSMaskMode) {
      copyCtxState(this.ctx, this.suspendedCtx);
      this.suspendedCtx.save();
    } else {
      this.ctx.save();
    }
    const old = this.current;
    this.stateStack.push(old);
    this.current = old.clone();
  }
  restore() {
    if (this.stateStack.length === 0 && this.inSMaskMode) {
      this.endSMaskMode();
    }
    if (this.stateStack.length !== 0) {
      this.current = this.stateStack.pop();
      if (this.inSMaskMode) {
        this.suspendedCtx.restore();
        copyCtxState(this.suspendedCtx, this.ctx);
      } else {
        this.ctx.restore();
      }
      this.checkSMaskState();
      this.pendingClip = null;
      this._cachedScaleForStroking[0] = -1;
      this._cachedGetSinglePixelWidth = null;
    }
  }
  transform(a2, b2, c, d, e2, f2) {
    this.ctx.transform(a2, b2, c, d, e2, f2);
    this._cachedScaleForStroking[0] = -1;
    this._cachedGetSinglePixelWidth = null;
  }
  constructPath(ops, args, minMax) {
    const ctx = this.ctx;
    const current = this.current;
    let x2 = current.x, y2 = current.y;
    let startX, startY;
    const currentTransform = getCurrentTransform(ctx);
    const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
    const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
    for (let i2 = 0, j = 0, ii = ops.length; i2 < ii; i2++) {
      switch (ops[i2] | 0) {
        case OPS$1.rectangle:
          x2 = args[j++];
          y2 = args[j++];
          const width = args[j++];
          const height = args[j++];
          const xw = x2 + width;
          const yh = y2 + height;
          ctx.moveTo(x2, y2);
          if (width === 0 || height === 0) {
            ctx.lineTo(xw, yh);
          } else {
            ctx.lineTo(xw, y2);
            ctx.lineTo(xw, yh);
            ctx.lineTo(x2, yh);
          }
          if (!isScalingMatrix) {
            current.updateRectMinMax(currentTransform, [x2, y2, xw, yh]);
          }
          ctx.closePath();
          break;
        case OPS$1.moveTo:
          x2 = args[j++];
          y2 = args[j++];
          ctx.moveTo(x2, y2);
          if (!isScalingMatrix) {
            current.updatePathMinMax(currentTransform, x2, y2);
          }
          break;
        case OPS$1.lineTo:
          x2 = args[j++];
          y2 = args[j++];
          ctx.lineTo(x2, y2);
          if (!isScalingMatrix) {
            current.updatePathMinMax(currentTransform, x2, y2);
          }
          break;
        case OPS$1.curveTo:
          startX = x2;
          startY = y2;
          x2 = args[j + 4];
          y2 = args[j + 5];
          ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x2, y2);
          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x2, y2, minMaxForBezier);
          j += 6;
          break;
        case OPS$1.curveTo2:
          startX = x2;
          startY = y2;
          ctx.bezierCurveTo(x2, y2, args[j], args[j + 1], args[j + 2], args[j + 3]);
          current.updateCurvePathMinMax(currentTransform, startX, startY, x2, y2, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);
          x2 = args[j + 2];
          y2 = args[j + 3];
          j += 4;
          break;
        case OPS$1.curveTo3:
          startX = x2;
          startY = y2;
          x2 = args[j + 2];
          y2 = args[j + 3];
          ctx.bezierCurveTo(args[j], args[j + 1], x2, y2, x2, y2);
          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x2, y2, x2, y2, minMaxForBezier);
          j += 4;
          break;
        case OPS$1.closePath:
          ctx.closePath();
          break;
      }
    }
    if (isScalingMatrix) {
      current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
    }
    current.setCurrentPoint(x2, y2);
  }
  closePath() {
    this.ctx.closePath();
  }
  stroke(consumePath = true) {
    const ctx = this.ctx;
    const strokeColor = this.current.strokeColor;
    ctx.globalAlpha = this.current.strokeAlpha;
    if (this.contentVisible) {
      if (typeof strokeColor === "object" && strokeColor?.getPattern) {
        ctx.save();
        ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);
        this.rescaleAndStroke(false);
        ctx.restore();
      } else {
        this.rescaleAndStroke(true);
      }
    }
    if (consumePath) {
      this.consumePath(this.current.getClippedPathBoundingBox());
    }
    ctx.globalAlpha = this.current.fillAlpha;
  }
  closeStroke() {
    this.closePath();
    this.stroke();
  }
  fill(consumePath = true) {
    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    let needRestore = false;
    if (isPatternFill) {
      ctx.save();
      ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);
      needRestore = true;
    }
    const intersect = this.current.getClippedPathBoundingBox();
    if (this.contentVisible && intersect !== null) {
      if (this.pendingEOFill) {
        ctx.fill("evenodd");
        this.pendingEOFill = false;
      } else {
        ctx.fill();
      }
    }
    if (needRestore) {
      ctx.restore();
    }
    if (consumePath) {
      this.consumePath(intersect);
    }
  }
  eoFill() {
    this.pendingEOFill = true;
    this.fill();
  }
  fillStroke() {
    this.fill(false);
    this.stroke(false);
    this.consumePath();
  }
  eoFillStroke() {
    this.pendingEOFill = true;
    this.fillStroke();
  }
  closeFillStroke() {
    this.closePath();
    this.fillStroke();
  }
  closeEOFillStroke() {
    this.pendingEOFill = true;
    this.closePath();
    this.fillStroke();
  }
  endPath() {
    this.consumePath();
  }
  clip() {
    this.pendingClip = NORMAL_CLIP;
  }
  eoClip() {
    this.pendingClip = EO_CLIP;
  }
  beginText() {
    this.current.textMatrix = IDENTITY_MATRIX;
    this.current.textMatrixScale = 1;
    this.current.x = this.current.lineX = 0;
    this.current.y = this.current.lineY = 0;
  }
  endText() {
    const paths = this.pendingTextPaths;
    const ctx = this.ctx;
    if (paths === void 0) {
      ctx.beginPath();
      return;
    }
    ctx.save();
    ctx.beginPath();
    for (const path of paths) {
      ctx.setTransform(...path.transform);
      ctx.translate(path.x, path.y);
      path.addToPath(ctx, path.fontSize);
    }
    ctx.restore();
    ctx.clip();
    ctx.beginPath();
    delete this.pendingTextPaths;
  }
  setCharSpacing(spacing) {
    this.current.charSpacing = spacing;
  }
  setWordSpacing(spacing) {
    this.current.wordSpacing = spacing;
  }
  setHScale(scale) {
    this.current.textHScale = scale / 100;
  }
  setLeading(leading) {
    this.current.leading = -leading;
  }
  setFont(fontRefName, size2) {
    const fontObj = this.commonObjs.get(fontRefName);
    const current = this.current;
    if (!fontObj) {
      throw new Error(`Can't find font for ${fontRefName}`);
    }
    current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;
    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
      warn("Invalid font matrix for font " + fontRefName);
    }
    if (size2 < 0) {
      size2 = -size2;
      current.fontDirection = -1;
    } else {
      current.fontDirection = 1;
    }
    this.current.font = fontObj;
    this.current.fontSize = size2;
    if (fontObj.isType3Font) {
      return;
    }
    const name = fontObj.loadedName || "sans-serif";
    const typeface = fontObj.systemFontInfo?.css || `"${name}", ${fontObj.fallbackName}`;
    let bold = "normal";
    if (fontObj.black) {
      bold = "900";
    } else if (fontObj.bold) {
      bold = "bold";
    }
    const italic = fontObj.italic ? "italic" : "normal";
    let browserFontSize = size2;
    if (size2 < MIN_FONT_SIZE) {
      browserFontSize = MIN_FONT_SIZE;
    } else if (size2 > MAX_FONT_SIZE) {
      browserFontSize = MAX_FONT_SIZE;
    }
    this.current.fontSizeScale = size2 / browserFontSize;
    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
  }
  setTextRenderingMode(mode) {
    this.current.textRenderingMode = mode;
  }
  setTextRise(rise) {
    this.current.textRise = rise;
  }
  moveText(x2, y2) {
    this.current.x = this.current.lineX += x2;
    this.current.y = this.current.lineY += y2;
  }
  setLeadingMoveText(x2, y2) {
    this.setLeading(-y2);
    this.moveText(x2, y2);
  }
  setTextMatrix(a2, b2, c, d, e2, f2) {
    this.current.textMatrix = [a2, b2, c, d, e2, f2];
    this.current.textMatrixScale = Math.hypot(a2, b2);
    this.current.x = this.current.lineX = 0;
    this.current.y = this.current.lineY = 0;
  }
  nextLine() {
    this.moveText(0, this.current.leading);
  }
  paintChar(character, x2, y2, patternTransform) {
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const textRenderingMode = current.textRenderingMode;
    const fontSize = current.fontSize / current.fontSizeScale;
    const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
    const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);
    const patternFill = current.patternFill && !font.missingFile;
    let addToPath;
    if (font.disableFontFace || isAddToPathSet || patternFill) {
      addToPath = font.getPathGenerator(this.commonObjs, character);
    }
    if (font.disableFontFace || patternFill) {
      ctx.save();
      ctx.translate(x2, y2);
      ctx.beginPath();
      addToPath(ctx, fontSize);
      if (patternTransform) {
        ctx.setTransform(...patternTransform);
      }
      if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        ctx.fill();
      }
      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        ctx.stroke();
      }
      ctx.restore();
    } else {
      if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        ctx.fillText(character, x2, y2);
      }
      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        ctx.strokeText(character, x2, y2);
      }
    }
    if (isAddToPathSet) {
      const paths = this.pendingTextPaths ||= [];
      paths.push({
        transform: getCurrentTransform(ctx),
        x: x2,
        y: y2,
        fontSize,
        addToPath
      });
    }
  }
  get isFontSubpixelAAEnabled() {
    const {
      context: ctx
    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    ctx.scale(1.5, 1);
    ctx.fillText("I", 0, 10);
    const data2 = ctx.getImageData(0, 0, 10, 10).data;
    let enabled = false;
    for (let i2 = 3; i2 < data2.length; i2 += 4) {
      if (data2[i2] > 0 && data2[i2] < 255) {
        enabled = true;
        break;
      }
    }
    return shadow$1(this, "isFontSubpixelAAEnabled", enabled);
  }
  showText(glyphs) {
    const current = this.current;
    const font = current.font;
    if (font.isType3Font) {
      return this.showType3Text(glyphs);
    }
    const fontSize = current.fontSize;
    if (fontSize === 0) {
      return void 0;
    }
    const ctx = this.ctx;
    const fontSizeScale = current.fontSizeScale;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const fontDirection = current.fontDirection;
    const textHScale = current.textHScale * fontDirection;
    const glyphsLength = glyphs.length;
    const vertical = font.vertical;
    const spacingDir = vertical ? 1 : -1;
    const defaultVMetrics = font.defaultVMetrics;
    const widthAdvanceScale = fontSize * current.fontMatrix[0];
    const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
    ctx.save();
    ctx.transform(...current.textMatrix);
    ctx.translate(current.x, current.y + current.textRise);
    if (fontDirection > 0) {
      ctx.scale(textHScale, -1);
    } else {
      ctx.scale(textHScale, 1);
    }
    let patternTransform;
    if (current.patternFill) {
      ctx.save();
      const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);
      patternTransform = getCurrentTransform(ctx);
      ctx.restore();
      ctx.fillStyle = pattern;
    }
    let lineWidth = current.lineWidth;
    const scale = current.textMatrixScale;
    if (scale === 0 || lineWidth === 0) {
      const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
        lineWidth = this.getSinglePixelWidth();
      }
    } else {
      lineWidth /= scale;
    }
    if (fontSizeScale !== 1) {
      ctx.scale(fontSizeScale, fontSizeScale);
      lineWidth /= fontSizeScale;
    }
    ctx.lineWidth = lineWidth;
    if (font.isInvalidPDFjsFont) {
      const chars = [];
      let width = 0;
      for (const glyph of glyphs) {
        chars.push(glyph.unicode);
        width += glyph.width;
      }
      ctx.fillText(chars.join(""), 0, 0);
      current.x += width * widthAdvanceScale * textHScale;
      ctx.restore();
      this.compose();
      return void 0;
    }
    let x2 = 0, i2;
    for (i2 = 0; i2 < glyphsLength; ++i2) {
      const glyph = glyphs[i2];
      if (typeof glyph === "number") {
        x2 += spacingDir * glyph * fontSize / 1e3;
        continue;
      }
      let restoreNeeded = false;
      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const character = glyph.fontChar;
      const accent = glyph.accent;
      let scaledX, scaledY;
      let width = glyph.width;
      if (vertical) {
        const vmetric = glyph.vmetric || defaultVMetrics;
        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
        const vy = vmetric[2] * widthAdvanceScale;
        width = vmetric ? -vmetric[0] : width;
        scaledX = vx / fontSizeScale;
        scaledY = (x2 + vy) / fontSizeScale;
      } else {
        scaledX = x2 / fontSizeScale;
        scaledY = 0;
      }
      if (font.remeasure && width > 0) {
        const measuredWidth = ctx.measureText(character).width * 1e3 / fontSize * fontSizeScale;
        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
          const characterScaleX = width / measuredWidth;
          restoreNeeded = true;
          ctx.save();
          ctx.scale(characterScaleX, 1);
          scaledX /= characterScaleX;
        } else if (width !== measuredWidth) {
          scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
        }
      }
      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
        if (simpleFillText && !accent) {
          ctx.fillText(character, scaledX, scaledY);
        } else {
          this.paintChar(character, scaledX, scaledY, patternTransform);
          if (accent) {
            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
          }
        }
      }
      const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;
      x2 += charWidth;
      if (restoreNeeded) {
        ctx.restore();
      }
    }
    if (vertical) {
      current.y -= x2;
    } else {
      current.x += x2 * textHScale;
    }
    ctx.restore();
    this.compose();
    return void 0;
  }
  showType3Text(glyphs) {
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const fontSize = current.fontSize;
    const fontDirection = current.fontDirection;
    const spacingDir = font.vertical ? 1 : -1;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const textHScale = current.textHScale * fontDirection;
    const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
    const glyphsLength = glyphs.length;
    const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;
    let i2, glyph, width, spacingLength;
    if (isTextInvisible || fontSize === 0) {
      return;
    }
    this._cachedScaleForStroking[0] = -1;
    this._cachedGetSinglePixelWidth = null;
    ctx.save();
    ctx.transform(...current.textMatrix);
    ctx.translate(current.x, current.y);
    ctx.scale(textHScale, fontDirection);
    for (i2 = 0; i2 < glyphsLength; ++i2) {
      glyph = glyphs[i2];
      if (typeof glyph === "number") {
        spacingLength = spacingDir * glyph * fontSize / 1e3;
        this.ctx.translate(spacingLength, 0);
        current.x += spacingLength * textHScale;
        continue;
      }
      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const operatorList = font.charProcOperatorList[glyph.operatorListId];
      if (!operatorList) {
        warn(`Type3 character "${glyph.operatorListId}" is not available.`);
        continue;
      }
      if (this.contentVisible) {
        this.processingType3 = glyph;
        this.save();
        ctx.scale(fontSize, fontSize);
        ctx.transform(...fontMatrix);
        this.executeOperatorList(operatorList);
        this.restore();
      }
      const transformed = Util$1.applyTransform([glyph.width, 0], fontMatrix);
      width = transformed[0] * fontSize + spacing;
      ctx.translate(width, 0);
      current.x += width * textHScale;
    }
    ctx.restore();
    this.processingType3 = null;
  }
  setCharWidth(xWidth, yWidth) {
  }
  setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
    this.ctx.rect(llx, lly, urx - llx, ury - lly);
    this.ctx.clip();
    this.endPath();
  }
  getColorN_Pattern(IR) {
    let pattern;
    if (IR[0] === "TilingPattern") {
      const color = IR[1];
      const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);
      const canvasGraphicsFactory = {
        createCanvasGraphics: (ctx) => new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
          optionalContentConfig: this.optionalContentConfig,
          markedContentStack: this.markedContentStack
        })
      };
      pattern = new TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
    } else {
      pattern = this._getPattern(IR[1], IR[2]);
    }
    return pattern;
  }
  setStrokeColorN() {
    this.current.strokeColor = this.getColorN_Pattern(arguments);
  }
  setFillColorN() {
    this.current.fillColor = this.getColorN_Pattern(arguments);
    this.current.patternFill = true;
  }
  setStrokeRGBColor(r2, g2, b2) {
    const color = Util$1.makeHexColor(r2, g2, b2);
    this.ctx.strokeStyle = color;
    this.current.strokeColor = color;
  }
  setFillRGBColor(r2, g2, b2) {
    const color = Util$1.makeHexColor(r2, g2, b2);
    this.ctx.fillStyle = color;
    this.current.fillColor = color;
    this.current.patternFill = false;
  }
  _getPattern(objId, matrix = null) {
    let pattern;
    if (this.cachedPatterns.has(objId)) {
      pattern = this.cachedPatterns.get(objId);
    } else {
      pattern = getShadingPattern(this.getObject(objId));
      this.cachedPatterns.set(objId, pattern);
    }
    if (matrix) {
      pattern.matrix = matrix;
    }
    return pattern;
  }
  shadingFill(objId) {
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    this.save();
    const pattern = this._getPattern(objId);
    ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING);
    const inv = getCurrentTransformInverse(ctx);
    if (inv) {
      const {
        width,
        height
      } = ctx.canvas;
      const [x0, y0, x1, y1] = Util$1.getAxialAlignedBoundingBox([0, 0, width, height], inv);
      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
    } else {
      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    }
    this.compose(this.current.getClippedPathBoundingBox());
    this.restore();
  }
  beginInlineImage() {
    unreachable("Should not call beginInlineImage");
  }
  beginImageData() {
    unreachable("Should not call beginImageData");
  }
  paintFormXObjectBegin(matrix, bbox) {
    if (!this.contentVisible) {
      return;
    }
    this.save();
    this.baseTransformStack.push(this.baseTransform);
    if (matrix) {
      this.transform(...matrix);
    }
    this.baseTransform = getCurrentTransform(this.ctx);
    if (bbox) {
      const width = bbox[2] - bbox[0];
      const height = bbox[3] - bbox[1];
      this.ctx.rect(bbox[0], bbox[1], width, height);
      this.current.updateRectMinMax(getCurrentTransform(this.ctx), bbox);
      this.clip();
      this.endPath();
    }
  }
  paintFormXObjectEnd() {
    if (!this.contentVisible) {
      return;
    }
    this.restore();
    this.baseTransform = this.baseTransformStack.pop();
  }
  beginGroup(group) {
    if (!this.contentVisible) {
      return;
    }
    this.save();
    if (this.inSMaskMode) {
      this.endSMaskMode();
      this.current.activeSMask = null;
    }
    const currentCtx = this.ctx;
    if (!group.isolated) {
      info("TODO: Support non-isolated groups.");
    }
    if (group.knockout) {
      warn("Knockout groups not supported.");
    }
    const currentTransform = getCurrentTransform(currentCtx);
    if (group.matrix) {
      currentCtx.transform(...group.matrix);
    }
    if (!group.bbox) {
      throw new Error("Bounding box is required.");
    }
    let bounds = Util$1.getAxialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx));
    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
    bounds = Util$1.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
    const offsetX = Math.floor(bounds[0]);
    const offsetY = Math.floor(bounds[1]);
    const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
    const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
    let cacheId = "groupAt" + this.groupLevel;
    if (group.smask) {
      cacheId += "_smask_" + this.smaskCounter++ % 2;
    }
    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
    const groupCtx = scratchCanvas.context;
    groupCtx.translate(-offsetX, -offsetY);
    groupCtx.transform(...currentTransform);
    if (group.smask) {
      this.smaskStack.push({
        canvas: scratchCanvas.canvas,
        context: groupCtx,
        offsetX,
        offsetY,
        subtype: group.smask.subtype,
        backdrop: group.smask.backdrop,
        transferMap: group.smask.transferMap || null,
        startTransformInverse: null
      });
    } else {
      currentCtx.setTransform(1, 0, 0, 1, 0, 0);
      currentCtx.translate(offsetX, offsetY);
      currentCtx.save();
    }
    copyCtxState(currentCtx, groupCtx);
    this.ctx = groupCtx;
    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
    this.groupStack.push(currentCtx);
    this.groupLevel++;
  }
  endGroup(group) {
    if (!this.contentVisible) {
      return;
    }
    this.groupLevel--;
    const groupCtx = this.ctx;
    const ctx = this.groupStack.pop();
    this.ctx = ctx;
    this.ctx.imageSmoothingEnabled = false;
    if (group.smask) {
      this.tempSMask = this.smaskStack.pop();
      this.restore();
    } else {
      this.ctx.restore();
      const currentMtx = getCurrentTransform(this.ctx);
      this.restore();
      this.ctx.save();
      this.ctx.setTransform(...currentMtx);
      const dirtyBox = Util$1.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);
      this.ctx.drawImage(groupCtx.canvas, 0, 0);
      this.ctx.restore();
      this.compose(dirtyBox);
    }
  }
  beginAnnotation(id2, rect, transform2, matrix, hasOwnCanvas) {
    this.#restoreInitialState();
    resetCtxToDefault(this.ctx);
    this.ctx.save();
    this.save();
    if (this.baseTransform) {
      this.ctx.setTransform(...this.baseTransform);
    }
    if (rect) {
      const width = rect[2] - rect[0];
      const height = rect[3] - rect[1];
      if (hasOwnCanvas && this.annotationCanvasMap) {
        transform2 = transform2.slice();
        transform2[4] -= rect[0];
        transform2[5] -= rect[1];
        rect = rect.slice();
        rect[0] = rect[1] = 0;
        rect[2] = width;
        rect[3] = height;
        const [scaleX, scaleY] = Util$1.singularValueDecompose2dScale(getCurrentTransform(this.ctx));
        const {
          viewportScale
        } = this;
        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
        const {
          canvas,
          context
        } = this.annotationCanvas;
        this.annotationCanvasMap.set(id2, canvas);
        this.annotationCanvas.savedCtx = this.ctx;
        this.ctx = context;
        this.ctx.save();
        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
        resetCtxToDefault(this.ctx);
      } else {
        resetCtxToDefault(this.ctx);
        this.ctx.rect(rect[0], rect[1], width, height);
        this.ctx.clip();
        this.endPath();
      }
    }
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.transform(...transform2);
    this.transform(...matrix);
  }
  endAnnotation() {
    if (this.annotationCanvas) {
      this.ctx.restore();
      this.#drawFilter();
      this.ctx = this.annotationCanvas.savedCtx;
      delete this.annotationCanvas.savedCtx;
      delete this.annotationCanvas;
    }
  }
  paintImageMaskXObject(img) {
    if (!this.contentVisible) {
      return;
    }
    const count = img.count;
    img = this.getObject(img.data, img);
    img.count = count;
    const ctx = this.ctx;
    const glyph = this.processingType3;
    if (glyph) {
      if (glyph.compiled === void 0) {
        glyph.compiled = compileType3Glyph(img);
      }
      if (glyph.compiled) {
        glyph.compiled(ctx);
        return;
      }
    }
    const mask = this._createMaskCanvas(img);
    const maskCanvas = mask.canvas;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
    ctx.restore();
    this.compose();
  }
  paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
    if (!this.contentVisible) {
      return;
    }
    img = this.getObject(img.data, img);
    const ctx = this.ctx;
    ctx.save();
    const currentTransform = getCurrentTransform(ctx);
    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
    const mask = this._createMaskCanvas(img);
    ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);
    for (let i2 = 0, ii = positions.length; i2 < ii; i2 += 2) {
      const trans = Util$1.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i2], positions[i2 + 1]]);
      const [x2, y2] = Util$1.applyTransform([0, 0], trans);
      ctx.drawImage(mask.canvas, x2, y2);
    }
    ctx.restore();
    this.compose();
  }
  paintImageMaskXObjectGroup(images) {
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    for (const image of images) {
      const {
        data: data2,
        width,
        height,
        transform: transform2
      } = image;
      const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      const maskCtx = maskCanvas.context;
      maskCtx.save();
      const img = this.getObject(data2, image);
      putBinaryImageMask(maskCtx, img);
      maskCtx.globalCompositeOperation = "source-in";
      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL) : fillColor;
      maskCtx.fillRect(0, 0, width, height);
      maskCtx.restore();
      ctx.save();
      ctx.transform(...transform2);
      ctx.scale(1, -1);
      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
      ctx.restore();
    }
    this.compose();
  }
  paintImageXObject(objId) {
    if (!this.contentVisible) {
      return;
    }
    const imgData = this.getObject(objId);
    if (!imgData) {
      warn("Dependent image isn't ready yet");
      return;
    }
    this.paintInlineImageXObject(imgData);
  }
  paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
    if (!this.contentVisible) {
      return;
    }
    const imgData = this.getObject(objId);
    if (!imgData) {
      warn("Dependent image isn't ready yet");
      return;
    }
    const width = imgData.width;
    const height = imgData.height;
    const map = [];
    for (let i2 = 0, ii = positions.length; i2 < ii; i2 += 2) {
      map.push({
        transform: [scaleX, 0, 0, scaleY, positions[i2], positions[i2 + 1]],
        x: 0,
        y: 0,
        w: width,
        h: height
      });
    }
    this.paintInlineImageXObjectGroup(imgData, map);
  }
  applyTransferMapsToCanvas(ctx) {
    if (this.current.transferMaps !== "none") {
      ctx.filter = this.current.transferMaps;
      ctx.drawImage(ctx.canvas, 0, 0);
      ctx.filter = "none";
    }
    return ctx.canvas;
  }
  applyTransferMapsToBitmap(imgData) {
    if (this.current.transferMaps === "none") {
      return imgData.bitmap;
    }
    const {
      bitmap,
      width,
      height
    } = imgData;
    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
    const tmpCtx = tmpCanvas.context;
    tmpCtx.filter = this.current.transferMaps;
    tmpCtx.drawImage(bitmap, 0, 0);
    tmpCtx.filter = "none";
    return tmpCanvas.canvas;
  }
  paintInlineImageXObject(imgData) {
    if (!this.contentVisible) {
      return;
    }
    const width = imgData.width;
    const height = imgData.height;
    const ctx = this.ctx;
    this.save();
    if (!isNodeJS) {
      const {
        filter
      } = ctx;
      if (filter !== "none" && filter !== "") {
        ctx.filter = "none";
      }
    }
    ctx.scale(1 / width, -1 / height);
    let imgToPaint;
    if (imgData.bitmap) {
      imgToPaint = this.applyTransferMapsToBitmap(imgData);
    } else if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
      imgToPaint = imgData;
    } else {
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
      const tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData);
      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
    }
    const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));
    ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);
    drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
    this.compose();
    this.restore();
  }
  paintInlineImageXObjectGroup(imgData, map) {
    if (!this.contentVisible) {
      return;
    }
    const ctx = this.ctx;
    let imgToPaint;
    if (imgData.bitmap) {
      imgToPaint = imgData.bitmap;
    } else {
      const w2 = imgData.width;
      const h2 = imgData.height;
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w2, h2);
      const tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData);
      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
    }
    for (const entry of map) {
      ctx.save();
      ctx.transform(...entry.transform);
      ctx.scale(1, -1);
      drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
      ctx.restore();
    }
    this.compose();
  }
  paintSolidColorImageMask() {
    if (!this.contentVisible) {
      return;
    }
    this.ctx.fillRect(0, 0, 1, 1);
    this.compose();
  }
  markPoint(tag2) {
  }
  markPointProps(tag2, properties) {
  }
  beginMarkedContent(tag2) {
    this.markedContentStack.push({
      visible: true
    });
  }
  beginMarkedContentProps(tag2, properties) {
    if (tag2 === "OC") {
      this.markedContentStack.push({
        visible: this.optionalContentConfig.isVisible(properties)
      });
    } else {
      this.markedContentStack.push({
        visible: true
      });
    }
    this.contentVisible = this.isContentVisible();
  }
  endMarkedContent() {
    this.markedContentStack.pop();
    this.contentVisible = this.isContentVisible();
  }
  beginCompat() {
  }
  endCompat() {
  }
  consumePath(clipBox) {
    const isEmpty = this.current.isEmptyClip();
    if (this.pendingClip) {
      this.current.updateClipFromPath();
    }
    if (!this.pendingClip) {
      this.compose(clipBox);
    }
    const ctx = this.ctx;
    if (this.pendingClip) {
      if (!isEmpty) {
        if (this.pendingClip === EO_CLIP) {
          ctx.clip("evenodd");
        } else {
          ctx.clip();
        }
      }
      this.pendingClip = null;
    }
    this.current.startNewPathAndClipBox(this.current.clipBox);
    ctx.beginPath();
  }
  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const m2 = getCurrentTransform(this.ctx);
      if (m2[1] === 0 && m2[2] === 0) {
        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m2[0]), Math.abs(m2[3]));
      } else {
        const absDet = Math.abs(m2[0] * m2[3] - m2[2] * m2[1]);
        const normX = Math.hypot(m2[0], m2[2]);
        const normY = Math.hypot(m2[1], m2[3]);
        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
      }
    }
    return this._cachedGetSinglePixelWidth;
  }
  getScaleForStroking() {
    if (this._cachedScaleForStroking[0] === -1) {
      const {
        lineWidth
      } = this.current;
      const {
        a: a2,
        b: b2,
        c,
        d
      } = this.ctx.getTransform();
      let scaleX, scaleY;
      if (b2 === 0 && c === 0) {
        const normX = Math.abs(a2);
        const normY = Math.abs(d);
        if (normX === normY) {
          if (lineWidth === 0) {
            scaleX = scaleY = 1 / normX;
          } else {
            const scaledLineWidth = normX * lineWidth;
            scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
          }
        } else if (lineWidth === 0) {
          scaleX = 1 / normX;
          scaleY = 1 / normY;
        } else {
          const scaledXLineWidth = normX * lineWidth;
          const scaledYLineWidth = normY * lineWidth;
          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
        }
      } else {
        const absDet = Math.abs(a2 * d - b2 * c);
        const normX = Math.hypot(a2, b2);
        const normY = Math.hypot(c, d);
        if (lineWidth === 0) {
          scaleX = normY / absDet;
          scaleY = normX / absDet;
        } else {
          const baseArea = lineWidth * absDet;
          scaleX = normY > baseArea ? normY / baseArea : 1;
          scaleY = normX > baseArea ? normX / baseArea : 1;
        }
      }
      this._cachedScaleForStroking[0] = scaleX;
      this._cachedScaleForStroking[1] = scaleY;
    }
    return this._cachedScaleForStroking;
  }
  rescaleAndStroke(saveRestore) {
    const {
      ctx
    } = this;
    const {
      lineWidth
    } = this.current;
    const [scaleX, scaleY] = this.getScaleForStroking();
    ctx.lineWidth = lineWidth || 1;
    if (scaleX === 1 && scaleY === 1) {
      ctx.stroke();
      return;
    }
    const dashes = ctx.getLineDash();
    if (saveRestore) {
      ctx.save();
    }
    ctx.scale(scaleX, scaleY);
    if (dashes.length > 0) {
      const scale = Math.max(scaleX, scaleY);
      ctx.setLineDash(dashes.map((x2) => x2 / scale));
      ctx.lineDashOffset /= scale;
    }
    ctx.stroke();
    if (saveRestore) {
      ctx.restore();
    }
  }
  isContentVisible() {
    for (let i2 = this.markedContentStack.length - 1; i2 >= 0; i2--) {
      if (!this.markedContentStack[i2].visible) {
        return false;
      }
    }
    return true;
  }
}
for (const op in OPS$1) {
  if (CanvasGraphics.prototype[op] !== void 0) {
    CanvasGraphics.prototype[OPS$1[op]] = CanvasGraphics.prototype[op];
  }
}
let GlobalWorkerOptions$1 = class GlobalWorkerOptions {
  static #port = null;
  static #src = "";
  static get workerPort() {
    return this.#port;
  }
  static set workerPort(val) {
    if (!(typeof Worker !== "undefined" && val instanceof Worker) && val !== null) {
      throw new Error("Invalid `workerPort` type.");
    }
    this.#port = val;
  }
  static get workerSrc() {
    return this.#src;
  }
  static set workerSrc(val) {
    if (typeof val !== "string") {
      throw new Error("Invalid `workerSrc` type.");
    }
    this.#src = val;
  }
};
const CallbackKind = {
  UNKNOWN: 0,
  DATA: 1,
  ERROR: 2
};
const StreamKind = {
  UNKNOWN: 0,
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function wrapReason(reason) {
  if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
    unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
  }
  switch (reason.name) {
    case "AbortException":
      return new AbortException$1(reason.message);
    case "MissingPDFException":
      return new MissingPDFException$1(reason.message);
    case "PasswordException":
      return new PasswordException(reason.message, reason.code);
    case "UnexpectedResponseException":
      return new UnexpectedResponseException$1(reason.message, reason.status);
    case "UnknownErrorException":
      return new UnknownErrorException(reason.message, reason.details);
    default:
      return new UnknownErrorException(reason.message, reason.toString());
  }
}
class MessageHandler {
  constructor(sourceName, targetName, comObj) {
    this.sourceName = sourceName;
    this.targetName = targetName;
    this.comObj = comObj;
    this.callbackId = 1;
    this.streamId = 1;
    this.streamSinks = /* @__PURE__ */ Object.create(null);
    this.streamControllers = /* @__PURE__ */ Object.create(null);
    this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
    this.actionHandler = /* @__PURE__ */ Object.create(null);
    this._onComObjOnMessage = (event) => {
      const data2 = event.data;
      if (data2.targetName !== this.sourceName) {
        return;
      }
      if (data2.stream) {
        this.#processStreamMessage(data2);
        return;
      }
      if (data2.callback) {
        const callbackId = data2.callbackId;
        const capability = this.callbackCapabilities[callbackId];
        if (!capability) {
          throw new Error(`Cannot resolve callback ${callbackId}`);
        }
        delete this.callbackCapabilities[callbackId];
        if (data2.callback === CallbackKind.DATA) {
          capability.resolve(data2.data);
        } else if (data2.callback === CallbackKind.ERROR) {
          capability.reject(wrapReason(data2.reason));
        } else {
          throw new Error("Unexpected callback case");
        }
        return;
      }
      const action = this.actionHandler[data2.action];
      if (!action) {
        throw new Error(`Unknown action from worker: ${data2.action}`);
      }
      if (data2.callbackId) {
        const cbSourceName = this.sourceName;
        const cbTargetName = data2.sourceName;
        new Promise(function(resolve2) {
          resolve2(action(data2.data));
        }).then(function(result) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.DATA,
            callbackId: data2.callbackId,
            data: result
          });
        }, function(reason) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.ERROR,
            callbackId: data2.callbackId,
            reason: wrapReason(reason)
          });
        });
        return;
      }
      if (data2.streamId) {
        this.#createStreamSink(data2);
        return;
      }
      action(data2.data);
    };
    comObj.addEventListener("message", this._onComObjOnMessage);
  }
  on(actionName, handler) {
    const ah = this.actionHandler;
    if (ah[actionName]) {
      throw new Error(`There is already an actionName called "${actionName}"`);
    }
    ah[actionName] = handler;
  }
  send(actionName, data2, transfers) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data: data2
    }, transfers);
  }
  sendWithPromise(actionName, data2, transfers) {
    const callbackId = this.callbackId++;
    const capability = Promise.withResolvers();
    this.callbackCapabilities[callbackId] = capability;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        callbackId,
        data: data2
      }, transfers);
    } catch (ex) {
      capability.reject(ex);
    }
    return capability.promise;
  }
  sendWithStream(actionName, data2, queueingStrategy, transfers) {
    const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
    return new ReadableStream({
      start: (controller) => {
        const startCapability = Promise.withResolvers();
        this.streamControllers[streamId] = {
          controller,
          startCall: startCapability,
          pullCall: null,
          cancelCall: null,
          isClosed: false
        };
        comObj.postMessage({
          sourceName,
          targetName,
          action: actionName,
          streamId,
          data: data2,
          desiredSize: controller.desiredSize
        }, transfers);
        return startCapability.promise;
      },
      pull: (controller) => {
        const pullCapability = Promise.withResolvers();
        this.streamControllers[streamId].pullCall = pullCapability;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL,
          streamId,
          desiredSize: controller.desiredSize
        });
        return pullCapability.promise;
      },
      cancel: (reason) => {
        assert(reason instanceof Error, "cancel must have a valid reason");
        const cancelCapability = Promise.withResolvers();
        this.streamControllers[streamId].cancelCall = cancelCapability;
        this.streamControllers[streamId].isClosed = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL,
          streamId,
          reason: wrapReason(reason)
        });
        return cancelCapability.promise;
      }
    }, queueingStrategy);
  }
  #createStreamSink(data2) {
    const streamId = data2.streamId, sourceName = this.sourceName, targetName = data2.sourceName, comObj = this.comObj;
    const self2 = this, action = this.actionHandler[data2.action];
    const streamSink = {
      enqueue(chunk, size2 = 1, transfers) {
        if (this.isCancelled) {
          return;
        }
        const lastDesiredSize = this.desiredSize;
        this.desiredSize -= size2;
        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
          this.sinkCapability = Promise.withResolvers();
          this.ready = this.sinkCapability.promise;
        }
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ENQUEUE,
          streamId,
          chunk
        }, transfers);
      },
      close() {
        if (this.isCancelled) {
          return;
        }
        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CLOSE,
          streamId
        });
        delete self2.streamSinks[streamId];
      },
      error(reason) {
        assert(reason instanceof Error, "error must have a valid reason");
        if (this.isCancelled) {
          return;
        }
        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ERROR,
          streamId,
          reason: wrapReason(reason)
        });
      },
      sinkCapability: Promise.withResolvers(),
      onPull: null,
      onCancel: null,
      isCancelled: false,
      desiredSize: data2.desiredSize,
      ready: null
    };
    streamSink.sinkCapability.resolve();
    streamSink.ready = streamSink.sinkCapability.promise;
    this.streamSinks[streamId] = streamSink;
    new Promise(function(resolve2) {
      resolve2(action(data2.data, streamSink));
    }).then(function() {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        success: true
      });
    }, function(reason) {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        reason: wrapReason(reason)
      });
    });
  }
  #processStreamMessage(data2) {
    const streamId = data2.streamId, sourceName = this.sourceName, targetName = data2.sourceName, comObj = this.comObj;
    const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
    switch (data2.stream) {
      case StreamKind.START_COMPLETE:
        if (data2.success) {
          streamController.startCall.resolve();
        } else {
          streamController.startCall.reject(wrapReason(data2.reason));
        }
        break;
      case StreamKind.PULL_COMPLETE:
        if (data2.success) {
          streamController.pullCall.resolve();
        } else {
          streamController.pullCall.reject(wrapReason(data2.reason));
        }
        break;
      case StreamKind.PULL:
        if (!streamSink) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
          break;
        }
        if (streamSink.desiredSize <= 0 && data2.desiredSize > 0) {
          streamSink.sinkCapability.resolve();
        }
        streamSink.desiredSize = data2.desiredSize;
        new Promise(function(resolve2) {
          resolve2(streamSink.onPull?.());
        }).then(function() {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
        }, function(reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        break;
      case StreamKind.ENQUEUE:
        assert(streamController, "enqueue should have stream controller");
        if (streamController.isClosed) {
          break;
        }
        streamController.controller.enqueue(data2.chunk);
        break;
      case StreamKind.CLOSE:
        assert(streamController, "close should have stream controller");
        if (streamController.isClosed) {
          break;
        }
        streamController.isClosed = true;
        streamController.controller.close();
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.ERROR:
        assert(streamController, "error should have stream controller");
        streamController.controller.error(wrapReason(data2.reason));
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.CANCEL_COMPLETE:
        if (data2.success) {
          streamController.cancelCall.resolve();
        } else {
          streamController.cancelCall.reject(wrapReason(data2.reason));
        }
        this.#deleteStreamController(streamController, streamId);
        break;
      case StreamKind.CANCEL:
        if (!streamSink) {
          break;
        }
        new Promise(function(resolve2) {
          resolve2(streamSink.onCancel?.(wrapReason(data2.reason)));
        }).then(function() {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            success: true
          });
        }, function(reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        streamSink.sinkCapability.reject(wrapReason(data2.reason));
        streamSink.isCancelled = true;
        delete this.streamSinks[streamId];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  }
  async #deleteStreamController(streamController, streamId) {
    await Promise.allSettled([streamController.startCall?.promise, streamController.pullCall?.promise, streamController.cancelCall?.promise]);
    delete this.streamControllers[streamId];
  }
  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }
}
class Metadata {
  #metadataMap;
  #data;
  constructor({
    parsedData,
    rawData
  }) {
    this.#metadataMap = parsedData;
    this.#data = rawData;
  }
  getRaw() {
    return this.#data;
  }
  get(name) {
    return this.#metadataMap.get(name) ?? null;
  }
  getAll() {
    return objectFromMap(this.#metadataMap);
  }
  has(name) {
    return this.#metadataMap.has(name);
  }
}
const INTERNAL = Symbol("INTERNAL");
class OptionalContentGroup {
  #isDisplay = false;
  #isPrint = false;
  #userSet = false;
  #visible = true;
  constructor(renderingIntent, {
    name,
    intent,
    usage
  }) {
    this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);
    this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);
    this.name = name;
    this.intent = intent;
    this.usage = usage;
  }
  get visible() {
    if (this.#userSet) {
      return this.#visible;
    }
    if (!this.#visible) {
      return false;
    }
    const {
      print,
      view
    } = this.usage;
    if (this.#isDisplay) {
      return view?.viewState !== "OFF";
    } else if (this.#isPrint) {
      return print?.printState !== "OFF";
    }
    return true;
  }
  _setVisible(internal, visible, userSet = false) {
    if (internal !== INTERNAL) {
      unreachable("Internal method `_setVisible` called.");
    }
    this.#userSet = userSet;
    this.#visible = visible;
  }
}
class OptionalContentConfig {
  #cachedGetHash = null;
  #groups = /* @__PURE__ */ new Map();
  #initialHash = null;
  #order = null;
  constructor(data2, renderingIntent = RenderingIntentFlag.DISPLAY) {
    this.renderingIntent = renderingIntent;
    this.name = null;
    this.creator = null;
    if (data2 === null) {
      return;
    }
    this.name = data2.name;
    this.creator = data2.creator;
    this.#order = data2.order;
    for (const group of data2.groups) {
      this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));
    }
    if (data2.baseState === "OFF") {
      for (const group of this.#groups.values()) {
        group._setVisible(INTERNAL, false);
      }
    }
    for (const on of data2.on) {
      this.#groups.get(on)._setVisible(INTERNAL, true);
    }
    for (const off of data2.off) {
      this.#groups.get(off)._setVisible(INTERNAL, false);
    }
    this.#initialHash = this.getHash();
  }
  #evaluateVisibilityExpression(array) {
    const length = array.length;
    if (length < 2) {
      return true;
    }
    const operator = array[0];
    for (let i2 = 1; i2 < length; i2++) {
      const element = array[i2];
      let state;
      if (Array.isArray(element)) {
        state = this.#evaluateVisibilityExpression(element);
      } else if (this.#groups.has(element)) {
        state = this.#groups.get(element).visible;
      } else {
        warn(`Optional content group not found: ${element}`);
        return true;
      }
      switch (operator) {
        case "And":
          if (!state) {
            return false;
          }
          break;
        case "Or":
          if (state) {
            return true;
          }
          break;
        case "Not":
          return !state;
        default:
          return true;
      }
    }
    return operator === "And";
  }
  isVisible(group) {
    if (this.#groups.size === 0) {
      return true;
    }
    if (!group) {
      info("Optional content group not defined.");
      return true;
    }
    if (group.type === "OCG") {
      if (!this.#groups.has(group.id)) {
        warn(`Optional content group not found: ${group.id}`);
        return true;
      }
      return this.#groups.get(group.id).visible;
    } else if (group.type === "OCMD") {
      if (group.expression) {
        return this.#evaluateVisibilityExpression(group.expression);
      }
      if (!group.policy || group.policy === "AnyOn") {
        for (const id2 of group.ids) {
          if (!this.#groups.has(id2)) {
            warn(`Optional content group not found: ${id2}`);
            return true;
          }
          if (this.#groups.get(id2).visible) {
            return true;
          }
        }
        return false;
      } else if (group.policy === "AllOn") {
        for (const id2 of group.ids) {
          if (!this.#groups.has(id2)) {
            warn(`Optional content group not found: ${id2}`);
            return true;
          }
          if (!this.#groups.get(id2).visible) {
            return false;
          }
        }
        return true;
      } else if (group.policy === "AnyOff") {
        for (const id2 of group.ids) {
          if (!this.#groups.has(id2)) {
            warn(`Optional content group not found: ${id2}`);
            return true;
          }
          if (!this.#groups.get(id2).visible) {
            return true;
          }
        }
        return false;
      } else if (group.policy === "AllOff") {
        for (const id2 of group.ids) {
          if (!this.#groups.has(id2)) {
            warn(`Optional content group not found: ${id2}`);
            return true;
          }
          if (this.#groups.get(id2).visible) {
            return false;
          }
        }
        return true;
      }
      warn(`Unknown optional content policy ${group.policy}.`);
      return true;
    }
    warn(`Unknown group type ${group.type}.`);
    return true;
  }
  setVisibility(id2, visible = true) {
    const group = this.#groups.get(id2);
    if (!group) {
      warn(`Optional content group not found: ${id2}`);
      return;
    }
    group._setVisible(INTERNAL, !!visible, true);
    this.#cachedGetHash = null;
  }
  setOCGState({
    state,
    preserveRB
  }) {
    let operator;
    for (const elem of state) {
      switch (elem) {
        case "ON":
        case "OFF":
        case "Toggle":
          operator = elem;
          continue;
      }
      const group = this.#groups.get(elem);
      if (!group) {
        continue;
      }
      switch (operator) {
        case "ON":
          group._setVisible(INTERNAL, true);
          break;
        case "OFF":
          group._setVisible(INTERNAL, false);
          break;
        case "Toggle":
          group._setVisible(INTERNAL, !group.visible);
          break;
      }
    }
    this.#cachedGetHash = null;
  }
  get hasInitialVisibility() {
    return this.#initialHash === null || this.getHash() === this.#initialHash;
  }
  getOrder() {
    if (!this.#groups.size) {
      return null;
    }
    if (this.#order) {
      return this.#order.slice();
    }
    return [...this.#groups.keys()];
  }
  getGroups() {
    return this.#groups.size > 0 ? objectFromMap(this.#groups) : null;
  }
  getGroup(id2) {
    return this.#groups.get(id2) || null;
  }
  getHash() {
    if (this.#cachedGetHash !== null) {
      return this.#cachedGetHash;
    }
    const hash = new MurmurHash3_64();
    for (const [id2, group] of this.#groups) {
      hash.update(`${id2}:${group.visible}`);
    }
    return this.#cachedGetHash = hash.hexdigest();
  }
}
class PDFDataTransportStream {
  constructor(pdfDataRangeTransport, {
    disableRange = false,
    disableStream = false
  }) {
    assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    const {
      length,
      initialData,
      progressiveDone,
      contentDispositionFilename
    } = pdfDataRangeTransport;
    this._queuedChunks = [];
    this._progressiveDone = progressiveDone;
    this._contentDispositionFilename = contentDispositionFilename;
    if (initialData?.length > 0) {
      const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;
      this._queuedChunks.push(buffer);
    }
    this._pdfDataRangeTransport = pdfDataRangeTransport;
    this._isStreamingSupported = !disableStream;
    this._isRangeSupported = !disableRange;
    this._contentLength = length;
    this._fullRequestReader = null;
    this._rangeReaders = [];
    pdfDataRangeTransport.addRangeListener((begin, chunk) => {
      this._onReceiveData({
        begin,
        chunk
      });
    });
    pdfDataRangeTransport.addProgressListener((loaded, total) => {
      this._onProgress({
        loaded,
        total
      });
    });
    pdfDataRangeTransport.addProgressiveReadListener((chunk) => {
      this._onReceiveData({
        chunk
      });
    });
    pdfDataRangeTransport.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    });
    pdfDataRangeTransport.transportReady();
  }
  _onReceiveData({
    begin,
    chunk
  }) {
    const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;
    if (begin === void 0) {
      if (this._fullRequestReader) {
        this._fullRequestReader._enqueue(buffer);
      } else {
        this._queuedChunks.push(buffer);
      }
    } else {
      const found = this._rangeReaders.some(function(rangeReader) {
        if (rangeReader._begin !== begin) {
          return false;
        }
        rangeReader._enqueue(buffer);
        return true;
      });
      assert(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  _onProgress(evt) {
    if (evt.total === void 0) {
      this._rangeReaders[0]?.onProgress?.({
        loaded: evt.loaded
      });
    } else {
      this._fullRequestReader?.onProgress?.({
        loaded: evt.loaded,
        total: evt.total
      });
    }
  }
  _onProgressiveDone() {
    this._fullRequestReader?.progressiveDone();
    this._progressiveDone = true;
  }
  _removeRangeReader(reader) {
    const i2 = this._rangeReaders.indexOf(reader);
    if (i2 >= 0) {
      this._rangeReaders.splice(i2, 1);
    }
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const queuedChunks = this._queuedChunks;
    this._queuedChunks = null;
    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
  }
  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
    this._pdfDataRangeTransport.requestDataRange(begin, end);
    this._rangeReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeReaders.slice(0)) {
      reader.cancel(reason);
    }
    this._pdfDataRangeTransport.abort();
  }
}
class PDFDataTransportStreamReader {
  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
    this._stream = stream;
    this._done = progressiveDone || false;
    this._filename = isPdfFile$1(contentDispositionFilename) ? contentDispositionFilename : null;
    this._queuedChunks = queuedChunks || [];
    this._loaded = 0;
    for (const chunk of this._queuedChunks) {
      this._loaded += chunk.byteLength;
    }
    this._requests = [];
    this._headersReady = Promise.resolve();
    stream._fullRequestReader = this;
    this.onProgress = null;
  }
  _enqueue(chunk) {
    if (this._done) {
      return;
    }
    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();
      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunks.push(chunk);
    }
    this._loaded += chunk.byteLength;
  }
  get headersReady() {
    return this._headersReady;
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }
  get contentLength() {
    return this._stream._contentLength;
  }
  async read() {
    if (this._queuedChunks.length > 0) {
      const chunk = this._queuedChunks.shift();
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
  }
  progressiveDone() {
    if (this._done) {
      return;
    }
    this._done = true;
  }
}
class PDFDataTransportStreamRangeReader {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._begin = begin;
    this._end = end;
    this._queuedChunk = null;
    this._requests = [];
    this._done = false;
    this.onProgress = null;
  }
  _enqueue(chunk) {
    if (this._done) {
      return;
    }
    if (this._requests.length === 0) {
      this._queuedChunk = chunk;
    } else {
      const requestsCapability = this._requests.shift();
      requestsCapability.resolve({
        value: chunk,
        done: false
      });
      for (const requestCapability of this._requests) {
        requestCapability.resolve({
          value: void 0,
          done: true
        });
      }
      this._requests.length = 0;
    }
    this._done = true;
    this._stream._removeRangeReader(this);
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    if (this._queuedChunk) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
    this._stream._removeRangeReader(this);
  }
}
function getFilenameFromContentDispositionHeader(contentDisposition) {
  let needsEncodingFixup = true;
  let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = unescape(filename);
    filename = rfc5987decode(filename);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }
  tmp = rfc2231getparam(contentDisposition);
  if (tmp) {
    const filename = rfc2047decode(tmp);
    return fixupEncoding(filename);
  }
  tmp = toParamRegExp("filename", "i").exec(contentDisposition);
  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }
  function toParamRegExp(attributePattern, flags) {
    return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
  }
  function textdecode(encoding, value) {
    if (encoding) {
      if (!/^[\x00-\xFF]+$/.test(value)) {
        return value;
      }
      try {
        const decoder2 = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = stringToBytes(value);
        value = decoder2.decode(buffer);
        needsEncodingFixup = false;
      } catch {
      }
    }
    return value;
  }
  function fixupEncoding(value) {
    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
      value = textdecode("utf-8", value);
      if (needsEncodingFixup) {
        value = textdecode("iso-8859-1", value);
      }
    }
    return value;
  }
  function rfc2231getparam(contentDispositionStr) {
    const matches = [];
    let match2;
    const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
    while ((match2 = iter.exec(contentDispositionStr)) !== null) {
      let [, n2, quot, part] = match2;
      n2 = parseInt(n2, 10);
      if (n2 in matches) {
        if (n2 === 0) {
          break;
        }
        continue;
      }
      matches[n2] = [quot, part];
    }
    const parts = [];
    for (let n2 = 0; n2 < matches.length; ++n2) {
      if (!(n2 in matches)) {
        break;
      }
      let [quot, part] = matches[n2];
      part = rfc2616unquote(part);
      if (quot) {
        part = unescape(part);
        if (n2 === 0) {
          part = rfc5987decode(part);
        }
      }
      parts.push(part);
    }
    return parts.join("");
  }
  function rfc2616unquote(value) {
    if (value.startsWith('"')) {
      const parts = value.slice(1).split('\\"');
      for (let i2 = 0; i2 < parts.length; ++i2) {
        const quotindex = parts[i2].indexOf('"');
        if (quotindex !== -1) {
          parts[i2] = parts[i2].slice(0, quotindex);
          parts.length = i2 + 1;
        }
        parts[i2] = parts[i2].replaceAll(/\\(.)/g, "$1");
      }
      value = parts.join('"');
    }
    return value;
  }
  function rfc5987decode(extvalue) {
    const encodingend = extvalue.indexOf("'");
    if (encodingend === -1) {
      return extvalue;
    }
    const encoding = extvalue.slice(0, encodingend);
    const langvalue = extvalue.slice(encodingend + 1);
    const value = langvalue.replace(/^[^']*'/, "");
    return textdecode(encoding, value);
  }
  function rfc2047decode(value) {
    if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
      return value;
    }
    return value.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text) {
      if (encoding === "q" || encoding === "Q") {
        text = text.replaceAll("_", " ");
        text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match2, hex) {
          return String.fromCharCode(parseInt(hex, 16));
        });
        return textdecode(charset, text);
      }
      try {
        text = atob(text);
      } catch {
      }
      return textdecode(charset, text);
    });
  }
  return "";
}
function validateRangeRequestCapabilities({
  getResponseHeader,
  isHttp,
  rangeChunkSize,
  disableRange
}) {
  const returnValues = {
    allowRangeRequests: false,
    suggestedLength: void 0
  };
  const length = parseInt(getResponseHeader("Content-Length"), 10);
  if (!Number.isInteger(length)) {
    return returnValues;
  }
  returnValues.suggestedLength = length;
  if (length <= 2 * rangeChunkSize) {
    return returnValues;
  }
  if (disableRange || !isHttp) {
    return returnValues;
  }
  if (getResponseHeader("Accept-Ranges") !== "bytes") {
    return returnValues;
  }
  const contentEncoding = getResponseHeader("Content-Encoding") || "identity";
  if (contentEncoding !== "identity") {
    return returnValues;
  }
  returnValues.allowRangeRequests = true;
  return returnValues;
}
function extractFilenameFromHeader(getResponseHeader) {
  const contentDisposition = getResponseHeader("Content-Disposition");
  if (contentDisposition) {
    let filename = getFilenameFromContentDispositionHeader(contentDisposition);
    if (filename.includes("%")) {
      try {
        filename = decodeURIComponent(filename);
      } catch {
      }
    }
    if (isPdfFile$1(filename)) {
      return filename;
    }
  }
  return null;
}
function createResponseStatusError(status, url) {
  if (status === 404 || status === 0 && url.startsWith("file:")) {
    return new MissingPDFException$1('Missing PDF "' + url + '".');
  }
  return new UnexpectedResponseException$1(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
}
function validateResponseStatus(status) {
  return status === 200 || status === 206;
}
function createFetchOptions(headers, withCredentials, abortController) {
  return {
    method: "GET",
    headers,
    signal: abortController.signal,
    mode: "cors",
    credentials: withCredentials ? "include" : "same-origin",
    redirect: "follow"
  };
}
function createHeaders(httpHeaders) {
  const headers = new Headers();
  for (const property in httpHeaders) {
    const value = httpHeaders[property];
    if (value === void 0) {
      continue;
    }
    headers.append(property, value);
  }
  return headers;
}
function getArrayBuffer(val) {
  if (val instanceof Uint8Array) {
    return val.buffer;
  }
  if (val instanceof ArrayBuffer) {
    return val;
  }
  warn(`getArrayBuffer - unexpected data format: ${val}`);
  return new Uint8Array(val).buffer;
}
class PDFFetchStream {
  constructor(source) {
    this.source = source;
    this.isHttp = /^https?:/i.test(source.url);
    this.httpHeaders = this.isHttp && source.httpHeaders || {};
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFFetchStreamReader(this);
    return this._fullRequestReader;
  }
  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const reader = new PDFFetchStreamRangeReader(this, begin, end);
    this._rangeRequestReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
}
class PDFFetchStreamReader {
  constructor(stream) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    this._filename = null;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._contentLength = source.length;
    this._headersCapability = Promise.withResolvers();
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._abortController = new AbortController();
    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._headers = createHeaders(this._stream.httpHeaders);
    const url = source.url;
    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
      if (!validateResponseStatus(response.status)) {
        throw createResponseStatusError(response.status, url);
      }
      this._reader = response.body.getReader();
      this._headersCapability.resolve();
      const getResponseHeader = (name) => response.headers.get(name);
      const {
        allowRangeRequests,
        suggestedLength
      } = validateRangeRequestCapabilities({
        getResponseHeader,
        isHttp: this._stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = extractFilenameFromHeader(getResponseHeader);
      if (!this._isStreamingSupported && this._isRangeSupported) {
        this.cancel(new AbortException$1("Streaming is disabled."));
      }
    }).catch(this._headersCapability.reject);
    this.onProgress = null;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._headersCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value,
        done
      };
    }
    this._loaded += value.byteLength;
    this.onProgress?.({
      loaded: this._loaded,
      total: this._contentLength
    });
    return {
      value: getArrayBuffer(value),
      done: false
    };
  }
  cancel(reason) {
    this._reader?.cancel(reason);
    this._abortController.abort();
  }
}
class PDFFetchStreamRangeReader {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._readCapability = Promise.withResolvers();
    this._isStreamingSupported = !source.disableStream;
    this._abortController = new AbortController();
    this._headers = createHeaders(this._stream.httpHeaders);
    this._headers.append("Range", `bytes=${begin}-${end - 1}`);
    const url = source.url;
    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
      if (!validateResponseStatus(response.status)) {
        throw createResponseStatusError(response.status, url);
      }
      this._readCapability.resolve();
      this._reader = response.body.getReader();
    }).catch(this._readCapability.reject);
    this.onProgress = null;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._readCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();
    if (done) {
      return {
        value,
        done
      };
    }
    this._loaded += value.byteLength;
    this.onProgress?.({
      loaded: this._loaded
    });
    return {
      value: getArrayBuffer(value),
      done: false
    };
  }
  cancel(reason) {
    this._reader?.cancel(reason);
    this._abortController.abort();
  }
}
const OK_RESPONSE = 200;
const PARTIAL_CONTENT_RESPONSE = 206;
function network_getArrayBuffer(xhr) {
  const data2 = xhr.response;
  if (typeof data2 !== "string") {
    return data2;
  }
  return stringToBytes(data2).buffer;
}
class NetworkManager {
  constructor(url, args = {}) {
    this.url = url;
    this.isHttp = /^https?:/i.test(url);
    this.httpHeaders = this.isHttp && args.httpHeaders || /* @__PURE__ */ Object.create(null);
    this.withCredentials = args.withCredentials || false;
    this.currXhrId = 0;
    this.pendingRequests = /* @__PURE__ */ Object.create(null);
  }
  requestRange(begin, end, listeners) {
    const args = {
      begin,
      end
    };
    for (const prop in listeners) {
      args[prop] = listeners[prop];
    }
    return this.request(args);
  }
  requestFull(listeners) {
    return this.request(listeners);
  }
  request(args) {
    const xhr = new XMLHttpRequest();
    const xhrId = this.currXhrId++;
    const pendingRequest = this.pendingRequests[xhrId] = {
      xhr
    };
    xhr.open("GET", this.url);
    xhr.withCredentials = this.withCredentials;
    for (const property in this.httpHeaders) {
      const value = this.httpHeaders[property];
      if (value === void 0) {
        continue;
      }
      xhr.setRequestHeader(property, value);
    }
    if (this.isHttp && "begin" in args && "end" in args) {
      xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
    } else {
      pendingRequest.expectedStatus = OK_RESPONSE;
    }
    xhr.responseType = "arraybuffer";
    if (args.onError) {
      xhr.onerror = function(evt) {
        args.onError(xhr.status);
      };
    }
    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
    xhr.onprogress = this.onProgress.bind(this, xhrId);
    pendingRequest.onHeadersReceived = args.onHeadersReceived;
    pendingRequest.onDone = args.onDone;
    pendingRequest.onError = args.onError;
    pendingRequest.onProgress = args.onProgress;
    xhr.send(null);
    return xhrId;
  }
  onProgress(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];
    if (!pendingRequest) {
      return;
    }
    pendingRequest.onProgress?.(evt);
  }
  onStateChange(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];
    if (!pendingRequest) {
      return;
    }
    const xhr = pendingRequest.xhr;
    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
      pendingRequest.onHeadersReceived();
      delete pendingRequest.onHeadersReceived;
    }
    if (xhr.readyState !== 4) {
      return;
    }
    if (!(xhrId in this.pendingRequests)) {
      return;
    }
    delete this.pendingRequests[xhrId];
    if (xhr.status === 0 && this.isHttp) {
      pendingRequest.onError?.(xhr.status);
      return;
    }
    const xhrStatus = xhr.status || OK_RESPONSE;
    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
      pendingRequest.onError?.(xhr.status);
      return;
    }
    const chunk = network_getArrayBuffer(xhr);
    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
      const rangeHeader = xhr.getResponseHeader("Content-Range");
      const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
      pendingRequest.onDone({
        begin: parseInt(matches[1], 10),
        chunk
      });
    } else if (chunk) {
      pendingRequest.onDone({
        begin: 0,
        chunk
      });
    } else {
      pendingRequest.onError?.(xhr.status);
    }
  }
  getRequestXhr(xhrId) {
    return this.pendingRequests[xhrId].xhr;
  }
  isPendingRequest(xhrId) {
    return xhrId in this.pendingRequests;
  }
  abortRequest(xhrId) {
    const xhr = this.pendingRequests[xhrId].xhr;
    delete this.pendingRequests[xhrId];
    xhr.abort();
  }
}
class PDFNetworkStream {
  constructor(source) {
    this._source = source;
    this._manager = new NetworkManager(source.url, {
      httpHeaders: source.httpHeaders,
      withCredentials: source.withCredentials
    });
    this._rangeChunkSize = source.rangeChunkSize;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  _onRangeRequestReaderClosed(reader) {
    const i2 = this._rangeRequestReaders.indexOf(reader);
    if (i2 >= 0) {
      this._rangeRequestReaders.splice(i2, 1);
    }
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
    return this._fullRequestReader;
  }
  getRangeReader(begin, end) {
    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
    this._rangeRequestReaders.push(reader);
    return reader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
}
class PDFNetworkStreamFullRequestReader {
  constructor(manager, source) {
    this._manager = manager;
    const args = {
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = source.url;
    this._fullRequestId = manager.requestFull(args);
    this._headersReceivedCapability = Promise.withResolvers();
    this._disableRange = source.disableRange || false;
    this._contentLength = source.length;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._isStreamingSupported = false;
    this._isRangeSupported = false;
    this._cachedChunks = [];
    this._requests = [];
    this._done = false;
    this._storedError = void 0;
    this._filename = null;
    this.onProgress = null;
  }
  _onHeadersReceived() {
    const fullRequestXhrId = this._fullRequestId;
    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
    const getResponseHeader = (name) => fullRequestXhr.getResponseHeader(name);
    const {
      allowRangeRequests,
      suggestedLength
    } = validateRangeRequestCapabilities({
      getResponseHeader,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });
    if (allowRangeRequests) {
      this._isRangeSupported = true;
    }
    this._contentLength = suggestedLength || this._contentLength;
    this._filename = extractFilenameFromHeader(getResponseHeader);
    if (this._isRangeSupported) {
      this._manager.abortRequest(fullRequestXhrId);
    }
    this._headersReceivedCapability.resolve();
  }
  _onDone(data2) {
    if (data2) {
      if (this._requests.length > 0) {
        const requestCapability = this._requests.shift();
        requestCapability.resolve({
          value: data2.chunk,
          done: false
        });
      } else {
        this._cachedChunks.push(data2.chunk);
      }
    }
    this._done = true;
    if (this._cachedChunks.length > 0) {
      return;
    }
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
  }
  _onError(status) {
    this._storedError = createResponseStatusError(status, this._url);
    this._headersReceivedCapability.reject(this._storedError);
    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }
    this._requests.length = 0;
    this._cachedChunks.length = 0;
  }
  _onProgress(evt) {
    this.onProgress?.({
      loaded: evt.loaded,
      total: evt.lengthComputable ? evt.total : this._contentLength
    });
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get contentLength() {
    return this._contentLength;
  }
  get headersReady() {
    return this._headersReceivedCapability.promise;
  }
  async read() {
    if (this._storedError) {
      throw this._storedError;
    }
    if (this._cachedChunks.length > 0) {
      const chunk = this._cachedChunks.shift();
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    this._headersReceivedCapability.reject(reason);
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
    if (this._manager.isPendingRequest(this._fullRequestId)) {
      this._manager.abortRequest(this._fullRequestId);
    }
    this._fullRequestReader = null;
  }
}
class PDFNetworkStreamRangeRequestReader {
  constructor(manager, begin, end) {
    this._manager = manager;
    const args = {
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = manager.url;
    this._requestId = manager.requestRange(begin, end, args);
    this._requests = [];
    this._queuedChunk = null;
    this._done = false;
    this._storedError = void 0;
    this.onProgress = null;
    this.onClosed = null;
  }
  _close() {
    this.onClosed?.(this);
  }
  _onDone(data2) {
    const chunk = data2.chunk;
    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();
      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunk = chunk;
    }
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
    this._close();
  }
  _onError(status) {
    this._storedError = createResponseStatusError(status, this._url);
    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }
    this._requests.length = 0;
    this._queuedChunk = null;
  }
  _onProgress(evt) {
    if (!this.isStreamingSupported) {
      this.onProgress?.({
        loaded: evt.loaded
      });
    }
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    if (this._storedError) {
      throw this._storedError;
    }
    if (this._queuedChunk !== null) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    const requestCapability = Promise.withResolvers();
    this._requests.push(requestCapability);
    return requestCapability.promise;
  }
  cancel(reason) {
    this._done = true;
    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: void 0,
        done: true
      });
    }
    this._requests.length = 0;
    if (this._manager.isPendingRequest(this._requestId)) {
      this._manager.abortRequest(this._requestId);
    }
    this._close();
  }
}
const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
function parseUrl(sourceUrl) {
  const url = NodePackages.get("url");
  const parsedUrl = url.parse(sourceUrl);
  if (parsedUrl.protocol === "file:" || parsedUrl.host) {
    return parsedUrl;
  }
  if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
    return url.parse(`file:///${sourceUrl}`);
  }
  if (!parsedUrl.host) {
    parsedUrl.protocol = "file:";
  }
  return parsedUrl;
}
class PDFNodeStream {
  constructor(source) {
    this.source = source;
    this.url = parseUrl(source.url);
    this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
    this.isFsUrl = this.url.protocol === "file:";
    this.httpHeaders = this.isHttp && source.httpHeaders || {};
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
    return this._fullRequestReader;
  }
  getRangeReader(start, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }
    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
    this._rangeRequestReaders.push(rangeReader);
    return rangeReader;
  }
  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);
    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }
}
class BaseFullReader {
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    const source = stream.source;
    this._contentLength = source.length;
    this._loaded = 0;
    this._filename = null;
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;
    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }
    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._readableStream = null;
    this._readCapability = Promise.withResolvers();
    this._headersCapability = Promise.withResolvers();
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._readCapability.promise;
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    if (this._storedError) {
      throw this._storedError;
    }
    const chunk = this._readableStream.read();
    if (chunk === null) {
      this._readCapability = Promise.withResolvers();
      return this.read();
    }
    this._loaded += chunk.length;
    this.onProgress?.({
      loaded: this._loaded,
      total: this._contentLength
    });
    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }
  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);
      return;
    }
    this._readableStream.destroy(reason);
  }
  _error(reason) {
    this._storedError = reason;
    this._readCapability.resolve();
  }
  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;
      this._readCapability.resolve();
    });
    readableStream.on("error", (reason) => {
      this._error(reason);
    });
    if (!this._isStreamingSupported && this._isRangeSupported) {
      this._error(new AbortException$1("streaming is disabled"));
    }
    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }
}
class BaseRangeReader {
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    this._loaded = 0;
    this._readableStream = null;
    this._readCapability = Promise.withResolvers();
    const source = stream.source;
    this._isStreamingSupported = !source.disableStream;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    await this._readCapability.promise;
    if (this._done) {
      return {
        value: void 0,
        done: true
      };
    }
    if (this._storedError) {
      throw this._storedError;
    }
    const chunk = this._readableStream.read();
    if (chunk === null) {
      this._readCapability = Promise.withResolvers();
      return this.read();
    }
    this._loaded += chunk.length;
    this.onProgress?.({
      loaded: this._loaded
    });
    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }
  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);
      return;
    }
    this._readableStream.destroy(reason);
  }
  _error(reason) {
    this._storedError = reason;
    this._readCapability.resolve();
  }
  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;
      this._readCapability.resolve();
    });
    readableStream.on("error", (reason) => {
      this._error(reason);
    });
    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }
}
function createRequestOptions(parsedUrl, headers) {
  return {
    protocol: parsedUrl.protocol,
    auth: parsedUrl.auth,
    host: parsedUrl.hostname,
    port: parsedUrl.port,
    path: parsedUrl.path,
    method: "GET",
    headers
  };
}
class PDFNodeStreamFullReader extends BaseFullReader {
  constructor(stream) {
    super(stream);
    const handleResponse = (response) => {
      if (response.statusCode === 404) {
        const error = new MissingPDFException$1(`Missing PDF "${this._url}".`);
        this._storedError = error;
        this._headersCapability.reject(error);
        return;
      }
      this._headersCapability.resolve();
      this._setReadableStream(response);
      const getResponseHeader = (name) => this._readableStream.headers[name.toLowerCase()];
      const {
        allowRangeRequests,
        suggestedLength
      } = validateRangeRequestCapabilities({
        getResponseHeader,
        isHttp: stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = extractFilenameFromHeader(getResponseHeader);
    };
    this._request = null;
    if (this._url.protocol === "http:") {
      const http = NodePackages.get("http");
      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
    } else {
      const https = NodePackages.get("https");
      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
    }
    this._request.on("error", (reason) => {
      this._storedError = reason;
      this._headersCapability.reject(reason);
    });
    this._request.end();
  }
}
class PDFNodeStreamRangeReader extends BaseRangeReader {
  constructor(stream, start, end) {
    super(stream);
    this._httpHeaders = {};
    for (const property in stream.httpHeaders) {
      const value = stream.httpHeaders[property];
      if (value === void 0) {
        continue;
      }
      this._httpHeaders[property] = value;
    }
    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;
    const handleResponse = (response) => {
      if (response.statusCode === 404) {
        const error = new MissingPDFException$1(`Missing PDF "${this._url}".`);
        this._storedError = error;
        return;
      }
      this._setReadableStream(response);
    };
    this._request = null;
    if (this._url.protocol === "http:") {
      const http = NodePackages.get("http");
      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
    } else {
      const https = NodePackages.get("https");
      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
    }
    this._request.on("error", (reason) => {
      this._storedError = reason;
    });
    this._request.end();
  }
}
class PDFNodeStreamFsFullReader extends BaseFullReader {
  constructor(stream) {
    super(stream);
    let path = decodeURIComponent(this._url.path);
    if (fileUriRegex.test(this._url.href)) {
      path = path.replace(/^\//, "");
    }
    const fs = NodePackages.get("fs");
    fs.promises.lstat(path).then((stat) => {
      this._contentLength = stat.size;
      this._setReadableStream(fs.createReadStream(path));
      this._headersCapability.resolve();
    }, (error) => {
      if (error.code === "ENOENT") {
        error = new MissingPDFException$1(`Missing PDF "${path}".`);
      }
      this._storedError = error;
      this._headersCapability.reject(error);
    });
  }
}
class PDFNodeStreamFsRangeReader extends BaseRangeReader {
  constructor(stream, start, end) {
    super(stream);
    let path = decodeURIComponent(this._url.path);
    if (fileUriRegex.test(this._url.href)) {
      path = path.replace(/^\//, "");
    }
    const fs = NodePackages.get("fs");
    this._setReadableStream(fs.createReadStream(path, {
      start,
      end: end - 1
    }));
  }
}
const MAX_TEXT_DIVS_TO_RENDER = 1e5;
const DEFAULT_FONT_SIZE = 30;
const DEFAULT_FONT_ASCENT = 0.8;
let TextLayer$1 = class TextLayer {
  #capability = Promise.withResolvers();
  #container = null;
  #disableProcessItems = false;
  #fontInspectorEnabled = !!globalThis.FontInspector?.enabled;
  #lang = null;
  #layoutTextParams = null;
  #pageHeight = 0;
  #pageWidth = 0;
  #reader = null;
  #rootContainer = null;
  #rotation = 0;
  #scale = 0;
  #styleCache = /* @__PURE__ */ Object.create(null);
  #textContentItemsStr = [];
  #textContentSource = null;
  #textDivs = [];
  #textDivProperties = /* @__PURE__ */ new WeakMap();
  #transform = null;
  static #ascentCache = /* @__PURE__ */ new Map();
  static #canvasContexts = /* @__PURE__ */ new Map();
  static #pendingTextLayers = /* @__PURE__ */ new Set();
  constructor({
    textContentSource,
    container,
    viewport
  }) {
    if (textContentSource instanceof ReadableStream) {
      this.#textContentSource = textContentSource;
    } else if (typeof textContentSource === "object") {
      this.#textContentSource = new ReadableStream({
        start(controller) {
          controller.enqueue(textContentSource);
          controller.close();
        }
      });
    } else {
      throw new Error('No "textContentSource" parameter specified.');
    }
    this.#container = this.#rootContainer = container;
    this.#scale = viewport.scale * (globalThis.devicePixelRatio || 1);
    this.#rotation = viewport.rotation;
    this.#layoutTextParams = {
      prevFontSize: null,
      prevFontFamily: null,
      div: null,
      properties: null,
      ctx: null
    };
    const {
      pageWidth,
      pageHeight,
      pageX,
      pageY
    } = viewport.rawDims;
    this.#transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];
    this.#pageWidth = pageWidth;
    this.#pageHeight = pageHeight;
    setLayerDimensions$1(container, viewport);
    this.#capability.promise.catch(() => {
    }).then(() => {
      TextLayer.#pendingTextLayers.delete(this);
      this.#layoutTextParams = null;
      this.#styleCache = null;
    });
  }
  render() {
    const pump = () => {
      this.#reader.read().then(({
        value,
        done
      }) => {
        if (done) {
          this.#capability.resolve();
          return;
        }
        this.#lang ??= value.lang;
        Object.assign(this.#styleCache, value.styles);
        this.#processItems(value.items);
        pump();
      }, this.#capability.reject);
    };
    this.#reader = this.#textContentSource.getReader();
    TextLayer.#pendingTextLayers.add(this);
    pump();
    return this.#capability.promise;
  }
  update({
    viewport,
    onBefore = null
  }) {
    const scale = viewport.scale * (globalThis.devicePixelRatio || 1);
    const rotation = viewport.rotation;
    if (rotation !== this.#rotation) {
      onBefore?.();
      this.#rotation = rotation;
      setLayerDimensions$1(this.#rootContainer, {
        rotation
      });
    }
    if (scale !== this.#scale) {
      onBefore?.();
      this.#scale = scale;
      const params = {
        prevFontSize: null,
        prevFontFamily: null,
        div: null,
        properties: null,
        ctx: TextLayer.#getCtx(this.#lang)
      };
      for (const div of this.#textDivs) {
        params.properties = this.#textDivProperties.get(div);
        params.div = div;
        this.#layout(params);
      }
    }
  }
  cancel() {
    const abortEx = new AbortException$1("TextLayer task cancelled.");
    this.#reader?.cancel(abortEx).catch(() => {
    });
    this.#reader = null;
    this.#capability.reject(abortEx);
  }
  get textDivs() {
    return this.#textDivs;
  }
  get textContentItemsStr() {
    return this.#textContentItemsStr;
  }
  #processItems(items) {
    if (this.#disableProcessItems) {
      return;
    }
    this.#layoutTextParams.ctx ||= TextLayer.#getCtx(this.#lang);
    const textDivs = this.#textDivs, textContentItemsStr = this.#textContentItemsStr;
    for (const item of items) {
      if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {
        warn("Ignoring additional textDivs for performance reasons.");
        this.#disableProcessItems = true;
        return;
      }
      if (item.str === void 0) {
        if (item.type === "beginMarkedContentProps" || item.type === "beginMarkedContent") {
          const parent = this.#container;
          this.#container = document.createElement("span");
          this.#container.classList.add("markedContent");
          if (item.id !== null) {
            this.#container.setAttribute("id", `${item.id}`);
          }
          parent.append(this.#container);
        } else if (item.type === "endMarkedContent") {
          this.#container = this.#container.parentNode;
        }
        continue;
      }
      textContentItemsStr.push(item.str);
      this.#appendText(item);
    }
  }
  #appendText(geom) {
    const textDiv = document.createElement("span");
    const textDivProperties = {
      angle: 0,
      canvasWidth: 0,
      hasText: geom.str !== "",
      hasEOL: geom.hasEOL,
      fontSize: 0
    };
    this.#textDivs.push(textDiv);
    const tx = Util$1.transform(this.#transform, geom.transform);
    let angle = Math.atan2(tx[1], tx[0]);
    const style2 = this.#styleCache[geom.fontName];
    if (style2.vertical) {
      angle += Math.PI / 2;
    }
    const fontFamily = this.#fontInspectorEnabled && style2.fontSubstitution || style2.fontFamily;
    const fontHeight = Math.hypot(tx[2], tx[3]);
    const fontAscent = fontHeight * TextLayer.#getAscent(fontFamily, this.#lang);
    let left, top;
    if (angle === 0) {
      left = tx[4];
      top = tx[5] - fontAscent;
    } else {
      left = tx[4] + fontAscent * Math.sin(angle);
      top = tx[5] - fontAscent * Math.cos(angle);
    }
    const scaleFactorStr = "calc(var(--scale-factor)*";
    const divStyle = textDiv.style;
    if (this.#container === this.#rootContainer) {
      divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;
      divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;
    } else {
      divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;
      divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;
    }
    divStyle.fontSize = `${scaleFactorStr}${fontHeight.toFixed(2)}px)`;
    divStyle.fontFamily = fontFamily;
    textDivProperties.fontSize = fontHeight;
    textDiv.setAttribute("role", "presentation");
    textDiv.textContent = geom.str;
    textDiv.dir = geom.dir;
    if (this.#fontInspectorEnabled) {
      textDiv.dataset.fontName = style2.fontSubstitutionLoadedName || geom.fontName;
    }
    if (angle !== 0) {
      textDivProperties.angle = angle * (180 / Math.PI);
    }
    let shouldScaleText = false;
    if (geom.str.length > 1) {
      shouldScaleText = true;
    } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
      const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
      if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
        shouldScaleText = true;
      }
    }
    if (shouldScaleText) {
      textDivProperties.canvasWidth = style2.vertical ? geom.height : geom.width;
    }
    this.#textDivProperties.set(textDiv, textDivProperties);
    this.#layoutTextParams.div = textDiv;
    this.#layoutTextParams.properties = textDivProperties;
    this.#layout(this.#layoutTextParams);
    if (textDivProperties.hasText) {
      this.#container.append(textDiv);
    }
    if (textDivProperties.hasEOL) {
      const br = document.createElement("br");
      br.setAttribute("role", "presentation");
      this.#container.append(br);
    }
  }
  #layout(params) {
    const {
      div,
      properties,
      ctx,
      prevFontSize,
      prevFontFamily
    } = params;
    const {
      style: style2
    } = div;
    let transform2 = "";
    if (properties.canvasWidth !== 0 && properties.hasText) {
      const {
        fontFamily
      } = style2;
      const {
        canvasWidth,
        fontSize
      } = properties;
      if (prevFontSize !== fontSize || prevFontFamily !== fontFamily) {
        ctx.font = `${fontSize * this.#scale}px ${fontFamily}`;
        params.prevFontSize = fontSize;
        params.prevFontFamily = fontFamily;
      }
      const {
        width
      } = ctx.measureText(div.textContent);
      if (width > 0) {
        transform2 = `scaleX(${canvasWidth * this.#scale / width})`;
      }
    }
    if (properties.angle !== 0) {
      transform2 = `rotate(${properties.angle}deg) ${transform2}`;
    }
    if (transform2.length > 0) {
      style2.transform = transform2;
    }
  }
  static cleanup() {
    if (this.#pendingTextLayers.size > 0) {
      return;
    }
    this.#ascentCache.clear();
    for (const {
      canvas
    } of this.#canvasContexts.values()) {
      canvas.remove();
    }
    this.#canvasContexts.clear();
  }
  static #getCtx(lang = null) {
    let canvasContext = this.#canvasContexts.get(lang ||= "");
    if (!canvasContext) {
      const canvas = document.createElement("canvas");
      canvas.className = "hiddenCanvasElement";
      canvas.lang = lang;
      document.body.append(canvas);
      canvasContext = canvas.getContext("2d", {
        alpha: false
      });
      this.#canvasContexts.set(lang, canvasContext);
    }
    return canvasContext;
  }
  static #getAscent(fontFamily, lang) {
    const cachedAscent = this.#ascentCache.get(fontFamily);
    if (cachedAscent) {
      return cachedAscent;
    }
    const ctx = this.#getCtx(lang);
    const savedFont = ctx.font;
    ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;
    ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
    const metrics = ctx.measureText("");
    let ascent = metrics.fontBoundingBoxAscent;
    let descent = Math.abs(metrics.fontBoundingBoxDescent);
    if (ascent) {
      const ratio2 = ascent / (ascent + descent);
      this.#ascentCache.set(fontFamily, ratio2);
      ctx.canvas.width = ctx.canvas.height = 0;
      ctx.font = savedFont;
      return ratio2;
    }
    ctx.strokeStyle = "red";
    ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
    ctx.strokeText("g", 0, 0);
    let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
    descent = 0;
    for (let i2 = pixels.length - 1 - 3; i2 >= 0; i2 -= 4) {
      if (pixels[i2] > 0) {
        descent = Math.ceil(i2 / 4 / DEFAULT_FONT_SIZE);
        break;
      }
    }
    ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
    ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
    pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
    ascent = 0;
    for (let i2 = 0, ii = pixels.length; i2 < ii; i2 += 4) {
      if (pixels[i2] > 0) {
        ascent = DEFAULT_FONT_SIZE - Math.floor(i2 / 4 / DEFAULT_FONT_SIZE);
        break;
      }
    }
    ctx.canvas.width = ctx.canvas.height = 0;
    ctx.font = savedFont;
    const ratio = ascent ? ascent / (ascent + descent) : DEFAULT_FONT_ASCENT;
    this.#ascentCache.set(fontFamily, ratio);
    return ratio;
  }
};
function renderTextLayer$1() {
  deprecated("`renderTextLayer`, please use `TextLayer` instead.");
  const {
    textContentSource,
    container,
    viewport,
    ...rest
  } = arguments[0];
  const restKeys = Object.keys(rest);
  if (restKeys.length > 0) {
    warn("Ignoring `renderTextLayer` parameters: " + restKeys.join(", "));
  }
  const textLayer = new TextLayer$1({
    textContentSource,
    container,
    viewport
  });
  const {
    textDivs,
    textContentItemsStr
  } = textLayer;
  const promise = textLayer.render();
  return {
    promise,
    textDivs,
    textContentItemsStr
  };
}
function updateTextLayer$1() {
  deprecated("`updateTextLayer`, please use `TextLayer` instead.");
}
class XfaText {
  static textContent(xfa) {
    const items = [];
    const output = {
      items,
      styles: /* @__PURE__ */ Object.create(null)
    };
    function walk(node) {
      if (!node) {
        return;
      }
      let str = null;
      const name = node.name;
      if (name === "#text") {
        str = node.value;
      } else if (!XfaText.shouldBuildText(name)) {
        return;
      } else if (node?.attributes?.textContent) {
        str = node.attributes.textContent;
      } else if (node.value) {
        str = node.value;
      }
      if (str !== null) {
        items.push({
          str
        });
      }
      if (!node.children) {
        return;
      }
      for (const child of node.children) {
        walk(child);
      }
    }
    walk(xfa);
    return output;
  }
  static shouldBuildText(name) {
    return !(name === "textarea" || name === "input" || name === "option" || name === "select");
  }
}
const DEFAULT_RANGE_CHUNK_SIZE = 65536;
const RENDERING_CANCELLED_TIMEOUT = 100;
const DELAYED_CLEANUP_TIMEOUT = 5e3;
const DefaultCanvasFactory = isNodeJS ? NodeCanvasFactory : DOMCanvasFactory;
const DefaultCMapReaderFactory = isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory;
const DefaultFilterFactory = isNodeJS ? NodeFilterFactory : DOMFilterFactory;
const DefaultStandardFontDataFactory = isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory;
function getDocument$1(src) {
  if (typeof src === "string" || src instanceof URL) {
    src = {
      url: src
    };
  } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {
    src = {
      data: src
    };
  }
  if (typeof src !== "object") {
    throw new Error("Invalid parameter in getDocument, need parameter object.");
  }
  if (!src.url && !src.data && !src.range) {
    throw new Error("Invalid parameter object: need either .data, .range or .url");
  }
  const task = new PDFDocumentLoadingTask();
  const {
    docId
  } = task;
  const url = src.url ? getUrlProp(src.url) : null;
  const data2 = src.data ? getDataProp(src.data) : null;
  const httpHeaders = src.httpHeaders || null;
  const withCredentials = src.withCredentials === true;
  const password = src.password ?? null;
  const rangeTransport = src.range instanceof PDFDataRangeTransport$1 ? src.range : null;
  const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
  let worker = src.worker instanceof PDFWorker$1 ? src.worker : null;
  const verbosity2 = src.verbosity;
  const docBaseUrl = typeof src.docBaseUrl === "string" && !isDataScheme$1(src.docBaseUrl) ? src.docBaseUrl : null;
  const cMapUrl = typeof src.cMapUrl === "string" ? src.cMapUrl : null;
  const cMapPacked = src.cMapPacked !== false;
  const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;
  const standardFontDataUrl = typeof src.standardFontDataUrl === "string" ? src.standardFontDataUrl : null;
  const StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;
  const ignoreErrors = src.stopAtErrors !== true;
  const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;
  const isEvalSupported2 = src.isEvalSupported !== false;
  const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === "boolean" ? src.isOffscreenCanvasSupported : !isNodeJS;
  const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;
  const disableFontFace = typeof src.disableFontFace === "boolean" ? src.disableFontFace : isNodeJS;
  const fontExtraProperties = src.fontExtraProperties === true;
  const enableXfa = src.enableXfa === true;
  const ownerDocument = src.ownerDocument || globalThis.document;
  const disableRange = src.disableRange === true;
  const disableStream = src.disableStream === true;
  const disableAutoFetch = src.disableAutoFetch === true;
  const pdfBug = src.pdfBug === true;
  const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;
  const useSystemFonts = typeof src.useSystemFonts === "boolean" ? src.useSystemFonts : !isNodeJS && !disableFontFace;
  const useWorkerFetch = typeof src.useWorkerFetch === "boolean" ? src.useWorkerFetch : CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && cMapUrl && standardFontDataUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI);
  const canvasFactory = src.canvasFactory || new DefaultCanvasFactory({
    ownerDocument
  });
  const filterFactory = src.filterFactory || new DefaultFilterFactory({
    docId,
    ownerDocument
  });
  const styleElement = null;
  setVerbosityLevel(verbosity2);
  const transportFactory = {
    canvasFactory,
    filterFactory
  };
  if (!useWorkerFetch) {
    transportFactory.cMapReaderFactory = new CMapReaderFactory({
      baseUrl: cMapUrl,
      isCompressed: cMapPacked
    });
    transportFactory.standardFontDataFactory = new StandardFontDataFactory({
      baseUrl: standardFontDataUrl
    });
  }
  if (!worker) {
    const workerParams = {
      verbosity: verbosity2,
      port: GlobalWorkerOptions$1.workerPort
    };
    worker = workerParams.port ? PDFWorker$1.fromPort(workerParams) : new PDFWorker$1(workerParams);
    task._worker = worker;
  }
  const docParams = {
    docId,
    apiVersion: "4.3.136",
    data: data2,
    password,
    disableAutoFetch,
    rangeChunkSize,
    length,
    docBaseUrl,
    enableXfa,
    evaluatorOptions: {
      maxImageSize,
      disableFontFace,
      ignoreErrors,
      isEvalSupported: isEvalSupported2,
      isOffscreenCanvasSupported,
      canvasMaxAreaInBytes,
      fontExtraProperties,
      useSystemFonts,
      cMapUrl: useWorkerFetch ? cMapUrl : null,
      standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null
    }
  };
  const transportParams = {
    disableFontFace,
    fontExtraProperties,
    ownerDocument,
    pdfBug,
    styleElement,
    loadingParams: {
      disableAutoFetch,
      enableXfa
    }
  };
  worker.promise.then(function() {
    if (task.destroyed) {
      throw new Error("Loading aborted");
    }
    if (worker.destroyed) {
      throw new Error("Worker was destroyed");
    }
    const workerIdPromise = worker.messageHandler.sendWithPromise("GetDocRequest", docParams, data2 ? [data2.buffer] : null);
    let networkStream;
    if (rangeTransport) {
      networkStream = new PDFDataTransportStream(rangeTransport, {
        disableRange,
        disableStream
      });
    } else if (!data2) {
      const createPDFNetworkStream = (params) => {
        if (isNodeJS) {
          const isFetchSupported = function() {
            return typeof fetch !== "undefined" && typeof Response !== "undefined" && "body" in Response.prototype;
          };
          return isFetchSupported() && isValidFetchUrl(params.url) ? new PDFFetchStream(params) : new PDFNodeStream(params);
        }
        return isValidFetchUrl(params.url) ? new PDFFetchStream(params) : new PDFNetworkStream(params);
      };
      networkStream = createPDFNetworkStream({
        url,
        length,
        httpHeaders,
        withCredentials,
        rangeChunkSize,
        disableRange,
        disableStream
      });
    }
    return workerIdPromise.then((workerId) => {
      if (task.destroyed) {
        throw new Error("Loading aborted");
      }
      if (worker.destroyed) {
        throw new Error("Worker was destroyed");
      }
      const messageHandler = new MessageHandler(docId, workerId, worker.port);
      const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);
      task._transport = transport;
      messageHandler.send("Ready", null);
    });
  }).catch(task._capability.reject);
  return task;
}
function getUrlProp(val) {
  if (val instanceof URL) {
    return val.href;
  }
  try {
    return new URL(val, window.location).href;
  } catch {
    if (isNodeJS && typeof val === "string") {
      return val;
    }
  }
  throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
}
function getDataProp(val) {
  if (isNodeJS && typeof Buffer !== "undefined" && val instanceof Buffer) {
    throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
  }
  if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {
    return val;
  }
  if (typeof val === "string") {
    return stringToBytes(val);
  }
  if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === "object" && !isNaN(val?.length)) {
    return new Uint8Array(val);
  }
  throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
}
function isRefProxy(ref2) {
  return typeof ref2 === "object" && Number.isInteger(ref2?.num) && ref2.num >= 0 && Number.isInteger(ref2?.gen) && ref2.gen >= 0;
}
class PDFDocumentLoadingTask {
  static #docId = 0;
  constructor() {
    this._capability = Promise.withResolvers();
    this._transport = null;
    this._worker = null;
    this.docId = `d${PDFDocumentLoadingTask.#docId++}`;
    this.destroyed = false;
    this.onPassword = null;
    this.onProgress = null;
  }
  get promise() {
    return this._capability.promise;
  }
  async destroy() {
    this.destroyed = true;
    try {
      if (this._worker?.port) {
        this._worker._pendingDestroy = true;
      }
      await this._transport?.destroy();
    } catch (ex) {
      if (this._worker?.port) {
        delete this._worker._pendingDestroy;
      }
      throw ex;
    }
    this._transport = null;
    if (this._worker) {
      this._worker.destroy();
      this._worker = null;
    }
  }
}
let PDFDataRangeTransport$1 = class PDFDataRangeTransport {
  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
    this.length = length;
    this.initialData = initialData;
    this.progressiveDone = progressiveDone;
    this.contentDispositionFilename = contentDispositionFilename;
    this._rangeListeners = [];
    this._progressListeners = [];
    this._progressiveReadListeners = [];
    this._progressiveDoneListeners = [];
    this._readyCapability = Promise.withResolvers();
  }
  addRangeListener(listener2) {
    this._rangeListeners.push(listener2);
  }
  addProgressListener(listener2) {
    this._progressListeners.push(listener2);
  }
  addProgressiveReadListener(listener2) {
    this._progressiveReadListeners.push(listener2);
  }
  addProgressiveDoneListener(listener2) {
    this._progressiveDoneListeners.push(listener2);
  }
  onDataRange(begin, chunk) {
    for (const listener2 of this._rangeListeners) {
      listener2(begin, chunk);
    }
  }
  onDataProgress(loaded, total) {
    this._readyCapability.promise.then(() => {
      for (const listener2 of this._progressListeners) {
        listener2(loaded, total);
      }
    });
  }
  onDataProgressiveRead(chunk) {
    this._readyCapability.promise.then(() => {
      for (const listener2 of this._progressiveReadListeners) {
        listener2(chunk);
      }
    });
  }
  onDataProgressiveDone() {
    this._readyCapability.promise.then(() => {
      for (const listener2 of this._progressiveDoneListeners) {
        listener2();
      }
    });
  }
  transportReady() {
    this._readyCapability.resolve();
  }
  requestDataRange(begin, end) {
    unreachable("Abstract method PDFDataRangeTransport.requestDataRange");
  }
  abort() {
  }
};
class PDFDocumentProxy {
  constructor(pdfInfo, transport) {
    this._pdfInfo = pdfInfo;
    this._transport = transport;
  }
  get annotationStorage() {
    return this._transport.annotationStorage;
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get numPages() {
    return this._pdfInfo.numPages;
  }
  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }
  get isPureXfa() {
    return shadow$1(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }
  getPage(pageNumber) {
    return this._transport.getPage(pageNumber);
  }
  getPageIndex(ref2) {
    return this._transport.getPageIndex(ref2);
  }
  getDestinations() {
    return this._transport.getDestinations();
  }
  getDestination(id2) {
    return this._transport.getDestination(id2);
  }
  getPageLabels() {
    return this._transport.getPageLabels();
  }
  getPageLayout() {
    return this._transport.getPageLayout();
  }
  getPageMode() {
    return this._transport.getPageMode();
  }
  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }
  getOpenAction() {
    return this._transport.getOpenAction();
  }
  getAttachments() {
    return this._transport.getAttachments();
  }
  getJSActions() {
    return this._transport.getDocJSActions();
  }
  getOutline() {
    return this._transport.getOutline();
  }
  getOptionalContentConfig({
    intent = "display"
  } = {}) {
    const {
      renderingIntent
    } = this._transport.getRenderingIntent(intent);
    return this._transport.getOptionalContentConfig(renderingIntent);
  }
  getPermissions() {
    return this._transport.getPermissions();
  }
  getMetadata() {
    return this._transport.getMetadata();
  }
  getMarkInfo() {
    return this._transport.getMarkInfo();
  }
  getData() {
    return this._transport.getData();
  }
  saveDocument() {
    return this._transport.saveDocument();
  }
  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }
  cleanup(keepLoadedFonts = false) {
    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
  }
  destroy() {
    return this.loadingTask.destroy();
  }
  cachedPageNumber(ref2) {
    return this._transport.cachedPageNumber(ref2);
  }
  get loadingParams() {
    return this._transport.loadingParams;
  }
  get loadingTask() {
    return this._transport.loadingTask;
  }
  getFieldObjects() {
    return this._transport.getFieldObjects();
  }
  hasJSActions() {
    return this._transport.hasJSActions();
  }
  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }
}
class PDFPageProxy {
  #delayedCleanupTimeout = null;
  #pendingCleanup = false;
  constructor(pageIndex, pageInfo, transport, pdfBug = false) {
    this._pageIndex = pageIndex;
    this._pageInfo = pageInfo;
    this._transport = transport;
    this._stats = pdfBug ? new StatTimer() : null;
    this._pdfBug = pdfBug;
    this.commonObjs = transport.commonObjs;
    this.objs = new PDFObjects();
    this._maybeCleanupAfterRender = false;
    this._intentStates = /* @__PURE__ */ new Map();
    this.destroyed = false;
  }
  get pageNumber() {
    return this._pageIndex + 1;
  }
  get rotate() {
    return this._pageInfo.rotate;
  }
  get ref() {
    return this._pageInfo.ref;
  }
  get userUnit() {
    return this._pageInfo.userUnit;
  }
  get view() {
    return this._pageInfo.view;
  }
  getViewport({
    scale,
    rotation = this.rotate,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  } = {}) {
    return new PageViewport({
      viewBox: this.view,
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }
  getAnnotations({
    intent = "display"
  } = {}) {
    const {
      renderingIntent
    } = this._transport.getRenderingIntent(intent);
    return this._transport.getAnnotations(this._pageIndex, renderingIntent);
  }
  getJSActions() {
    return this._transport.getPageJSActions(this._pageIndex);
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get isPureXfa() {
    return shadow$1(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  async getXfa() {
    return this._transport._htmlForXfa?.children[this._pageIndex] || null;
  }
  render({
    canvasContext,
    viewport,
    intent = "display",
    annotationMode = AnnotationMode$1.ENABLE,
    transform: transform2 = null,
    background = null,
    optionalContentConfigPromise = null,
    annotationCanvasMap = null,
    pageColors = null,
    printAnnotationStorage = null
  }) {
    this._stats?.time("Overall");
    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);
    const {
      renderingIntent,
      cacheKey
    } = intentArgs;
    this.#pendingCleanup = false;
    this.#abortDelayedCleanup();
    optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);
    let intentState = this._intentStates.get(cacheKey);
    if (!intentState) {
      intentState = /* @__PURE__ */ Object.create(null);
      this._intentStates.set(cacheKey, intentState);
    }
    if (intentState.streamReaderCancelTimeout) {
      clearTimeout(intentState.streamReaderCancelTimeout);
      intentState.streamReaderCancelTimeout = null;
    }
    const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);
    if (!intentState.displayReadyCapability) {
      intentState.displayReadyCapability = Promise.withResolvers();
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false,
        separateAnnots: null
      };
      this._stats?.time("Page Request");
      this._pumpOperatorList(intentArgs);
    }
    const complete = (error) => {
      intentState.renderTasks.delete(internalRenderTask);
      if (this._maybeCleanupAfterRender || intentPrint) {
        this.#pendingCleanup = true;
      }
      this.#tryCleanup(!intentPrint);
      if (error) {
        internalRenderTask.capability.reject(error);
        this._abortOperatorList({
          intentState,
          reason: error instanceof Error ? error : new Error(error)
        });
      } else {
        internalRenderTask.capability.resolve();
      }
      if (this._stats) {
        this._stats.timeEnd("Rendering");
        this._stats.timeEnd("Overall");
        if (globalThis.Stats?.enabled) {
          globalThis.Stats.add(this.pageNumber, this._stats);
        }
      }
    };
    const internalRenderTask = new InternalRenderTask({
      callback: complete,
      params: {
        canvasContext,
        viewport,
        transform: transform2,
        background
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      annotationCanvasMap,
      operatorList: intentState.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: this._transport.canvasFactory,
      filterFactory: this._transport.filterFactory,
      useRequestAnimationFrame: !intentPrint,
      pdfBug: this._pdfBug,
      pageColors
    });
    (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(internalRenderTask);
    const renderTask = internalRenderTask.task;
    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
      if (this.destroyed) {
        complete();
        return;
      }
      this._stats?.time("Rendering");
      if (!(optionalContentConfig.renderingIntent & renderingIntent)) {
        throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
      }
      internalRenderTask.initializeGraphics({
        transparency,
        optionalContentConfig
      });
      internalRenderTask.operatorListChanged();
    }).catch(complete);
    return renderTask;
  }
  getOperatorList({
    intent = "display",
    annotationMode = AnnotationMode$1.ENABLE,
    printAnnotationStorage = null
  } = {}) {
    function operatorListChanged() {
      if (intentState.operatorList.lastChunk) {
        intentState.opListReadCapability.resolve(intentState.operatorList);
        intentState.renderTasks.delete(opListTask);
      }
    }
    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);
    let intentState = this._intentStates.get(intentArgs.cacheKey);
    if (!intentState) {
      intentState = /* @__PURE__ */ Object.create(null);
      this._intentStates.set(intentArgs.cacheKey, intentState);
    }
    let opListTask;
    if (!intentState.opListReadCapability) {
      opListTask = /* @__PURE__ */ Object.create(null);
      opListTask.operatorListChanged = operatorListChanged;
      intentState.opListReadCapability = Promise.withResolvers();
      (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(opListTask);
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false,
        separateAnnots: null
      };
      this._stats?.time("Page Request");
      this._pumpOperatorList(intentArgs);
    }
    return intentState.opListReadCapability.promise;
  }
  streamTextContent({
    includeMarkedContent = false,
    disableNormalization = false
  } = {}) {
    const TEXT_CONTENT_CHUNK_SIZE = 100;
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      includeMarkedContent: includeMarkedContent === true,
      disableNormalization: disableNormalization === true
    }, {
      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
      size(textContent) {
        return textContent.items.length;
      }
    });
  }
  getTextContent(params = {}) {
    if (this._transport._htmlForXfa) {
      return this.getXfa().then((xfa) => XfaText.textContent(xfa));
    }
    const readableStream = this.streamTextContent(params);
    return new Promise(function(resolve2, reject) {
      function pump() {
        reader.read().then(function({
          value,
          done
        }) {
          if (done) {
            resolve2(textContent);
            return;
          }
          textContent.lang ??= value.lang;
          Object.assign(textContent.styles, value.styles);
          textContent.items.push(...value.items);
          pump();
        }, reject);
      }
      const reader = readableStream.getReader();
      const textContent = {
        items: [],
        styles: /* @__PURE__ */ Object.create(null),
        lang: null
      };
      pump();
    });
  }
  getStructTree() {
    return this._transport.getStructTree(this._pageIndex);
  }
  _destroy() {
    this.destroyed = true;
    const waitOn = [];
    for (const intentState of this._intentStates.values()) {
      this._abortOperatorList({
        intentState,
        reason: new Error("Page was destroyed."),
        force: true
      });
      if (intentState.opListReadCapability) {
        continue;
      }
      for (const internalRenderTask of intentState.renderTasks) {
        waitOn.push(internalRenderTask.completed);
        internalRenderTask.cancel();
      }
    }
    this.objs.clear();
    this.#pendingCleanup = false;
    this.#abortDelayedCleanup();
    return Promise.all(waitOn);
  }
  cleanup(resetStats = false) {
    this.#pendingCleanup = true;
    const success = this.#tryCleanup(false);
    if (resetStats && success) {
      this._stats &&= new StatTimer();
    }
    return success;
  }
  #tryCleanup(delayed = false) {
    this.#abortDelayedCleanup();
    if (!this.#pendingCleanup || this.destroyed) {
      return false;
    }
    if (delayed) {
      this.#delayedCleanupTimeout = setTimeout(() => {
        this.#delayedCleanupTimeout = null;
        this.#tryCleanup(false);
      }, DELAYED_CLEANUP_TIMEOUT);
      return false;
    }
    for (const {
      renderTasks,
      operatorList
    } of this._intentStates.values()) {
      if (renderTasks.size > 0 || !operatorList.lastChunk) {
        return false;
      }
    }
    this._intentStates.clear();
    this.objs.clear();
    this.#pendingCleanup = false;
    return true;
  }
  #abortDelayedCleanup() {
    if (this.#delayedCleanupTimeout) {
      clearTimeout(this.#delayedCleanupTimeout);
      this.#delayedCleanupTimeout = null;
    }
  }
  _startRenderPage(transparency, cacheKey) {
    const intentState = this._intentStates.get(cacheKey);
    if (!intentState) {
      return;
    }
    this._stats?.timeEnd("Page Request");
    intentState.displayReadyCapability?.resolve(transparency);
  }
  _renderPageChunk(operatorListChunk, intentState) {
    for (let i2 = 0, ii = operatorListChunk.length; i2 < ii; i2++) {
      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i2]);
      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i2]);
    }
    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
    intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
    for (const internalRenderTask of intentState.renderTasks) {
      internalRenderTask.operatorListChanged();
    }
    if (operatorListChunk.lastChunk) {
      this.#tryCleanup(true);
    }
  }
  _pumpOperatorList({
    renderingIntent,
    cacheKey,
    annotationStorageSerializable
  }) {
    const {
      map,
      transfer
    } = annotationStorageSerializable;
    const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
      pageIndex: this._pageIndex,
      intent: renderingIntent,
      cacheKey,
      annotationStorage: map
    }, transfer);
    const reader = readableStream.getReader();
    const intentState = this._intentStates.get(cacheKey);
    intentState.streamReader = reader;
    const pump = () => {
      reader.read().then(({
        value,
        done
      }) => {
        if (done) {
          intentState.streamReader = null;
          return;
        }
        if (this._transport.destroyed) {
          return;
        }
        this._renderPageChunk(value, intentState);
        pump();
      }, (reason) => {
        intentState.streamReader = null;
        if (this._transport.destroyed) {
          return;
        }
        if (intentState.operatorList) {
          intentState.operatorList.lastChunk = true;
          for (const internalRenderTask of intentState.renderTasks) {
            internalRenderTask.operatorListChanged();
          }
          this.#tryCleanup(true);
        }
        if (intentState.displayReadyCapability) {
          intentState.displayReadyCapability.reject(reason);
        } else if (intentState.opListReadCapability) {
          intentState.opListReadCapability.reject(reason);
        } else {
          throw reason;
        }
      });
    };
    pump();
  }
  _abortOperatorList({
    intentState,
    reason,
    force = false
  }) {
    if (!intentState.streamReader) {
      return;
    }
    if (intentState.streamReaderCancelTimeout) {
      clearTimeout(intentState.streamReaderCancelTimeout);
      intentState.streamReaderCancelTimeout = null;
    }
    if (!force) {
      if (intentState.renderTasks.size > 0) {
        return;
      }
      if (reason instanceof RenderingCancelledException$1) {
        let delay = RENDERING_CANCELLED_TIMEOUT;
        if (reason.extraDelay > 0 && reason.extraDelay < 1e3) {
          delay += reason.extraDelay;
        }
        intentState.streamReaderCancelTimeout = setTimeout(() => {
          intentState.streamReaderCancelTimeout = null;
          this._abortOperatorList({
            intentState,
            reason,
            force: true
          });
        }, delay);
        return;
      }
    }
    intentState.streamReader.cancel(new AbortException$1(reason.message)).catch(() => {
    });
    intentState.streamReader = null;
    if (this._transport.destroyed) {
      return;
    }
    for (const [curCacheKey, curIntentState] of this._intentStates) {
      if (curIntentState === intentState) {
        this._intentStates.delete(curCacheKey);
        break;
      }
    }
    this.cleanup();
  }
  get stats() {
    return this._stats;
  }
}
class LoopbackPort {
  #listeners = /* @__PURE__ */ new Set();
  #deferred = Promise.resolve();
  postMessage(obj, transfer) {
    const event = {
      data: structuredClone(obj, transfer ? {
        transfer
      } : null)
    };
    this.#deferred.then(() => {
      for (const listener2 of this.#listeners) {
        listener2.call(this, event);
      }
    });
  }
  addEventListener(name, listener2) {
    this.#listeners.add(listener2);
  }
  removeEventListener(name, listener2) {
    this.#listeners.delete(listener2);
  }
  terminate() {
    this.#listeners.clear();
  }
}
const PDFWorkerUtil = {
  isWorkerDisabled: false,
  fakeWorkerId: 0
};
{
  if (isNodeJS) {
    PDFWorkerUtil.isWorkerDisabled = true;
    GlobalWorkerOptions$1.workerSrc ||= "./pdf.worker.mjs";
  }
  PDFWorkerUtil.isSameOrigin = function(baseUrl, otherUrl) {
    let base;
    try {
      base = new URL(baseUrl);
      if (!base.origin || base.origin === "null") {
        return false;
      }
    } catch {
      return false;
    }
    const other = new URL(otherUrl, base);
    return base.origin === other.origin;
  };
  PDFWorkerUtil.createCDNWrapper = function(url) {
    const wrapper = `await import("${url}");`;
    return URL.createObjectURL(new Blob([wrapper], {
      type: "text/javascript"
    }));
  };
}
let PDFWorker$1 = class PDFWorker {
  static #workerPorts;
  constructor({
    name = null,
    port = null,
    verbosity: verbosity2 = getVerbosityLevel()
  } = {}) {
    this.name = name;
    this.destroyed = false;
    this.verbosity = verbosity2;
    this._readyCapability = Promise.withResolvers();
    this._port = null;
    this._webWorker = null;
    this._messageHandler = null;
    if (port) {
      if (PDFWorker.#workerPorts?.has(port)) {
        throw new Error("Cannot use more than one PDFWorker per port.");
      }
      (PDFWorker.#workerPorts ||= /* @__PURE__ */ new WeakMap()).set(port, this);
      this._initializeFromPort(port);
      return;
    }
    this._initialize();
  }
  get promise() {
    if (isNodeJS) {
      return Promise.all([NodePackages.promise, this._readyCapability.promise]);
    }
    return this._readyCapability.promise;
  }
  get port() {
    return this._port;
  }
  get messageHandler() {
    return this._messageHandler;
  }
  _initializeFromPort(port) {
    this._port = port;
    this._messageHandler = new MessageHandler("main", "worker", port);
    this._messageHandler.on("ready", function() {
    });
    this._readyCapability.resolve();
    this._messageHandler.send("configure", {
      verbosity: this.verbosity
    });
  }
  _initialize() {
    if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker.#mainThreadWorkerMessageHandler) {
      let {
        workerSrc
      } = PDFWorker;
      try {
        if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
          workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
        }
        const worker = new Worker(workerSrc, {
          type: "module"
        });
        const messageHandler = new MessageHandler("main", "worker", worker);
        const terminateEarly = () => {
          worker.removeEventListener("error", onWorkerError);
          messageHandler.destroy();
          worker.terminate();
          if (this.destroyed) {
            this._readyCapability.reject(new Error("Worker was destroyed"));
          } else {
            this._setupFakeWorker();
          }
        };
        const onWorkerError = () => {
          if (!this._webWorker) {
            terminateEarly();
          }
        };
        worker.addEventListener("error", onWorkerError);
        messageHandler.on("test", (data2) => {
          worker.removeEventListener("error", onWorkerError);
          if (this.destroyed) {
            terminateEarly();
            return;
          }
          if (data2) {
            this._messageHandler = messageHandler;
            this._port = worker;
            this._webWorker = worker;
            this._readyCapability.resolve();
            messageHandler.send("configure", {
              verbosity: this.verbosity
            });
          } else {
            this._setupFakeWorker();
            messageHandler.destroy();
            worker.terminate();
          }
        });
        messageHandler.on("ready", (data2) => {
          worker.removeEventListener("error", onWorkerError);
          if (this.destroyed) {
            terminateEarly();
            return;
          }
          try {
            sendTest();
          } catch {
            this._setupFakeWorker();
          }
        });
        const sendTest = () => {
          const testObj = new Uint8Array();
          messageHandler.send("test", testObj, [testObj.buffer]);
        };
        sendTest();
        return;
      } catch {
        info("The worker has been disabled.");
      }
    }
    this._setupFakeWorker();
  }
  _setupFakeWorker() {
    if (!PDFWorkerUtil.isWorkerDisabled) {
      warn("Setting up fake worker.");
      PDFWorkerUtil.isWorkerDisabled = true;
    }
    PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler) => {
      if (this.destroyed) {
        this._readyCapability.reject(new Error("Worker was destroyed"));
        return;
      }
      const port = new LoopbackPort();
      this._port = port;
      const id2 = `fake${PDFWorkerUtil.fakeWorkerId++}`;
      const workerHandler = new MessageHandler(id2 + "_worker", id2, port);
      WorkerMessageHandler.setup(workerHandler, port);
      const messageHandler = new MessageHandler(id2, id2 + "_worker", port);
      this._messageHandler = messageHandler;
      this._readyCapability.resolve();
      messageHandler.send("configure", {
        verbosity: this.verbosity
      });
    }).catch((reason) => {
      this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
    });
  }
  destroy() {
    this.destroyed = true;
    if (this._webWorker) {
      this._webWorker.terminate();
      this._webWorker = null;
    }
    PDFWorker.#workerPorts?.delete(this._port);
    this._port = null;
    if (this._messageHandler) {
      this._messageHandler.destroy();
      this._messageHandler = null;
    }
  }
  static fromPort(params) {
    if (!params?.port) {
      throw new Error("PDFWorker.fromPort - invalid method signature.");
    }
    const cachedPort = this.#workerPorts?.get(params.port);
    if (cachedPort) {
      if (cachedPort._pendingDestroy) {
        throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
      }
      return cachedPort;
    }
    return new PDFWorker(params);
  }
  static get workerSrc() {
    if (GlobalWorkerOptions$1.workerSrc) {
      return GlobalWorkerOptions$1.workerSrc;
    }
    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }
  static get #mainThreadWorkerMessageHandler() {
    try {
      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
    } catch {
      return null;
    }
  }
  static get _setupFakeWorkerGlobal() {
    const loader = async () => {
      if (this.#mainThreadWorkerMessageHandler) {
        return this.#mainThreadWorkerMessageHandler;
      }
      const worker = await import(
        /*webpackIgnore: true*/
        this.workerSrc
      );
      return worker.WorkerMessageHandler;
    };
    return shadow$1(this, "_setupFakeWorkerGlobal", loader());
  }
};
class WorkerTransport {
  #methodPromises = /* @__PURE__ */ new Map();
  #pageCache = /* @__PURE__ */ new Map();
  #pagePromises = /* @__PURE__ */ new Map();
  #pageRefCache = /* @__PURE__ */ new Map();
  #passwordCapability = null;
  constructor(messageHandler, loadingTask, networkStream, params, factory) {
    this.messageHandler = messageHandler;
    this.loadingTask = loadingTask;
    this.commonObjs = new PDFObjects();
    this.fontLoader = new FontLoader({
      ownerDocument: params.ownerDocument,
      styleElement: params.styleElement
    });
    this.loadingParams = params.loadingParams;
    this._params = params;
    this.canvasFactory = factory.canvasFactory;
    this.filterFactory = factory.filterFactory;
    this.cMapReaderFactory = factory.cMapReaderFactory;
    this.standardFontDataFactory = factory.standardFontDataFactory;
    this.destroyed = false;
    this.destroyCapability = null;
    this._networkStream = networkStream;
    this._fullReader = null;
    this._lastProgress = null;
    this.downloadInfoCapability = Promise.withResolvers();
    this.setupMessageHandler();
  }
  #cacheSimpleMethod(name, data2 = null) {
    const cachedPromise = this.#methodPromises.get(name);
    if (cachedPromise) {
      return cachedPromise;
    }
    const promise = this.messageHandler.sendWithPromise(name, data2);
    this.#methodPromises.set(name, promise);
    return promise;
  }
  get annotationStorage() {
    return shadow$1(this, "annotationStorage", new AnnotationStorage());
  }
  getRenderingIntent(intent, annotationMode = AnnotationMode$1.ENABLE, printAnnotationStorage = null, isOpList = false) {
    let renderingIntent = RenderingIntentFlag.DISPLAY;
    let annotationStorageSerializable = SerializableEmpty;
    switch (intent) {
      case "any":
        renderingIntent = RenderingIntentFlag.ANY;
        break;
      case "display":
        break;
      case "print":
        renderingIntent = RenderingIntentFlag.PRINT;
        break;
      default:
        warn(`getRenderingIntent - invalid intent: ${intent}`);
    }
    switch (annotationMode) {
      case AnnotationMode$1.DISABLE:
        renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;
        break;
      case AnnotationMode$1.ENABLE:
        break;
      case AnnotationMode$1.ENABLE_FORMS:
        renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;
        break;
      case AnnotationMode$1.ENABLE_STORAGE:
        renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;
        const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
        annotationStorageSerializable = annotationStorage.serializable;
        break;
      default:
        warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
    }
    if (isOpList) {
      renderingIntent += RenderingIntentFlag.OPLIST;
    }
    return {
      renderingIntent,
      cacheKey: `${renderingIntent}_${annotationStorageSerializable.hash}`,
      annotationStorageSerializable
    };
  }
  destroy() {
    if (this.destroyCapability) {
      return this.destroyCapability.promise;
    }
    this.destroyed = true;
    this.destroyCapability = Promise.withResolvers();
    this.#passwordCapability?.reject(new Error("Worker was destroyed during onPassword callback"));
    const waitOn = [];
    for (const page of this.#pageCache.values()) {
      waitOn.push(page._destroy());
    }
    this.#pageCache.clear();
    this.#pagePromises.clear();
    this.#pageRefCache.clear();
    if (this.hasOwnProperty("annotationStorage")) {
      this.annotationStorage.resetModified();
    }
    const terminated = this.messageHandler.sendWithPromise("Terminate", null);
    waitOn.push(terminated);
    Promise.all(waitOn).then(() => {
      this.commonObjs.clear();
      this.fontLoader.clear();
      this.#methodPromises.clear();
      this.filterFactory.destroy();
      TextLayer$1.cleanup();
      this._networkStream?.cancelAllRequests(new AbortException$1("Worker was terminated."));
      if (this.messageHandler) {
        this.messageHandler.destroy();
        this.messageHandler = null;
      }
      this.destroyCapability.resolve();
    }, this.destroyCapability.reject);
    return this.destroyCapability.promise;
  }
  setupMessageHandler() {
    const {
      messageHandler,
      loadingTask
    } = this;
    messageHandler.on("GetReader", (data2, sink) => {
      assert(this._networkStream, "GetReader - no `IPDFStream` instance available.");
      this._fullReader = this._networkStream.getFullReader();
      this._fullReader.onProgress = (evt) => {
        this._lastProgress = {
          loaded: evt.loaded,
          total: evt.total
        };
      };
      sink.onPull = () => {
        this._fullReader.read().then(function({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }
          assert(value instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch((reason) => {
          sink.error(reason);
        });
      };
      sink.onCancel = (reason) => {
        this._fullReader.cancel(reason);
        sink.ready.catch((readyReason) => {
          if (this.destroyed) {
            return;
          }
          throw readyReason;
        });
      };
    });
    messageHandler.on("ReaderHeadersReady", (data2) => {
      const headersCapability = Promise.withResolvers();
      const fullReader = this._fullReader;
      fullReader.headersReady.then(() => {
        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
          if (this._lastProgress) {
            loadingTask.onProgress?.(this._lastProgress);
          }
          fullReader.onProgress = (evt) => {
            loadingTask.onProgress?.({
              loaded: evt.loaded,
              total: evt.total
            });
          };
        }
        headersCapability.resolve({
          isStreamingSupported: fullReader.isStreamingSupported,
          isRangeSupported: fullReader.isRangeSupported,
          contentLength: fullReader.contentLength
        });
      }, headersCapability.reject);
      return headersCapability.promise;
    });
    messageHandler.on("GetRangeReader", (data2, sink) => {
      assert(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
      const rangeReader = this._networkStream.getRangeReader(data2.begin, data2.end);
      if (!rangeReader) {
        sink.close();
        return;
      }
      sink.onPull = () => {
        rangeReader.read().then(function({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }
          assert(value instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch((reason) => {
          sink.error(reason);
        });
      };
      sink.onCancel = (reason) => {
        rangeReader.cancel(reason);
        sink.ready.catch((readyReason) => {
          if (this.destroyed) {
            return;
          }
          throw readyReason;
        });
      };
    });
    messageHandler.on("GetDoc", ({
      pdfInfo
    }) => {
      this._numPages = pdfInfo.numPages;
      this._htmlForXfa = pdfInfo.htmlForXfa;
      delete pdfInfo.htmlForXfa;
      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
    });
    messageHandler.on("DocException", function(ex) {
      let reason;
      switch (ex.name) {
        case "PasswordException":
          reason = new PasswordException(ex.message, ex.code);
          break;
        case "InvalidPDFException":
          reason = new InvalidPDFException$1(ex.message);
          break;
        case "MissingPDFException":
          reason = new MissingPDFException$1(ex.message);
          break;
        case "UnexpectedResponseException":
          reason = new UnexpectedResponseException$1(ex.message, ex.status);
          break;
        case "UnknownErrorException":
          reason = new UnknownErrorException(ex.message, ex.details);
          break;
        default:
          unreachable("DocException - expected a valid Error.");
      }
      loadingTask._capability.reject(reason);
    });
    messageHandler.on("PasswordRequest", (exception) => {
      this.#passwordCapability = Promise.withResolvers();
      if (loadingTask.onPassword) {
        const updatePassword = (password) => {
          if (password instanceof Error) {
            this.#passwordCapability.reject(password);
          } else {
            this.#passwordCapability.resolve({
              password
            });
          }
        };
        try {
          loadingTask.onPassword(updatePassword, exception.code);
        } catch (ex) {
          this.#passwordCapability.reject(ex);
        }
      } else {
        this.#passwordCapability.reject(new PasswordException(exception.message, exception.code));
      }
      return this.#passwordCapability.promise;
    });
    messageHandler.on("DataLoaded", (data2) => {
      loadingTask.onProgress?.({
        loaded: data2.length,
        total: data2.length
      });
      this.downloadInfoCapability.resolve(data2);
    });
    messageHandler.on("StartRenderPage", (data2) => {
      if (this.destroyed) {
        return;
      }
      const page = this.#pageCache.get(data2.pageIndex);
      page._startRenderPage(data2.transparency, data2.cacheKey);
    });
    messageHandler.on("commonobj", ([id2, type, exportedData]) => {
      if (this.destroyed) {
        return null;
      }
      if (this.commonObjs.has(id2)) {
        return null;
      }
      switch (type) {
        case "Font":
          const {
            disableFontFace,
            fontExtraProperties,
            pdfBug
          } = this._params;
          if ("error" in exportedData) {
            const exportedError = exportedData.error;
            warn(`Error during font loading: ${exportedError}`);
            this.commonObjs.resolve(id2, exportedError);
            break;
          }
          const inspectFont = pdfBug && globalThis.FontInspector?.enabled ? (font2, url) => globalThis.FontInspector.fontAdded(font2, url) : null;
          const font = new FontFaceObject(exportedData, {
            disableFontFace,
            inspectFont
          });
          this.fontLoader.bind(font).catch(() => messageHandler.sendWithPromise("FontFallback", {
            id: id2
          })).finally(() => {
            if (!fontExtraProperties && font.data) {
              font.data = null;
            }
            this.commonObjs.resolve(id2, font);
          });
          break;
        case "CopyLocalImage":
          const {
            imageRef
          } = exportedData;
          assert(imageRef, "The imageRef must be defined.");
          for (const pageProxy of this.#pageCache.values()) {
            for (const [, data2] of pageProxy.objs) {
              if (data2?.ref !== imageRef) {
                continue;
              }
              if (!data2.dataLen) {
                return null;
              }
              this.commonObjs.resolve(id2, structuredClone(data2));
              return data2.dataLen;
            }
          }
          break;
        case "FontPath":
        case "Image":
        case "Pattern":
          this.commonObjs.resolve(id2, exportedData);
          break;
        default:
          throw new Error(`Got unknown common object type ${type}`);
      }
      return null;
    });
    messageHandler.on("obj", ([id2, pageIndex, type, imageData]) => {
      if (this.destroyed) {
        return;
      }
      const pageProxy = this.#pageCache.get(pageIndex);
      if (pageProxy.objs.has(id2)) {
        return;
      }
      if (pageProxy._intentStates.size === 0) {
        imageData?.bitmap?.close();
        return;
      }
      switch (type) {
        case "Image":
          pageProxy.objs.resolve(id2, imageData);
          if (imageData?.dataLen > MAX_IMAGE_SIZE_TO_CACHE) {
            pageProxy._maybeCleanupAfterRender = true;
          }
          break;
        case "Pattern":
          pageProxy.objs.resolve(id2, imageData);
          break;
        default:
          throw new Error(`Got unknown object type ${type}`);
      }
    });
    messageHandler.on("DocProgress", (data2) => {
      if (this.destroyed) {
        return;
      }
      loadingTask.onProgress?.({
        loaded: data2.loaded,
        total: data2.total
      });
    });
    messageHandler.on("FetchBuiltInCMap", (data2) => {
      if (this.destroyed) {
        return Promise.reject(new Error("Worker was destroyed."));
      }
      if (!this.cMapReaderFactory) {
        return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
      }
      return this.cMapReaderFactory.fetch(data2);
    });
    messageHandler.on("FetchStandardFontData", (data2) => {
      if (this.destroyed) {
        return Promise.reject(new Error("Worker was destroyed."));
      }
      if (!this.standardFontDataFactory) {
        return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
      }
      return this.standardFontDataFactory.fetch(data2);
    });
  }
  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }
  saveDocument() {
    if (this.annotationStorage.size <= 0) {
      warn("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
    }
    const {
      map,
      transfer
    } = this.annotationStorage.serializable;
    return this.messageHandler.sendWithPromise("SaveDocument", {
      isPureXfa: !!this._htmlForXfa,
      numPages: this._numPages,
      annotationStorage: map,
      filename: this._fullReader?.filename ?? null
    }, transfer).finally(() => {
      this.annotationStorage.resetModified();
    });
  }
  getPage(pageNumber) {
    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
      return Promise.reject(new Error("Invalid page request."));
    }
    const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex);
    if (cachedPromise) {
      return cachedPromise;
    }
    const promise = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex
    }).then((pageInfo) => {
      if (this.destroyed) {
        throw new Error("Transport destroyed");
      }
      if (pageInfo.refStr) {
        this.#pageRefCache.set(pageInfo.refStr, pageNumber);
      }
      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);
      this.#pageCache.set(pageIndex, page);
      return page;
    });
    this.#pagePromises.set(pageIndex, promise);
    return promise;
  }
  getPageIndex(ref2) {
    if (!isRefProxy(ref2)) {
      return Promise.reject(new Error("Invalid pageIndex request."));
    }
    return this.messageHandler.sendWithPromise("GetPageIndex", {
      num: ref2.num,
      gen: ref2.gen
    });
  }
  getAnnotations(pageIndex, intent) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex,
      intent
    });
  }
  getFieldObjects() {
    return this.#cacheSimpleMethod("GetFieldObjects");
  }
  hasJSActions() {
    return this.#cacheSimpleMethod("HasJSActions");
  }
  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }
  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }
  getDestination(id2) {
    if (typeof id2 !== "string") {
      return Promise.reject(new Error("Invalid destination request."));
    }
    return this.messageHandler.sendWithPromise("GetDestination", {
      id: id2
    });
  }
  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }
  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }
  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }
  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }
  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }
  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }
  getDocJSActions() {
    return this.#cacheSimpleMethod("GetDocJSActions");
  }
  getPageJSActions(pageIndex) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex
    });
  }
  getStructTree(pageIndex) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex
    });
  }
  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }
  getOptionalContentConfig(renderingIntent) {
    return this.#cacheSimpleMethod("GetOptionalContentConfig").then((data2) => new OptionalContentConfig(data2, renderingIntent));
  }
  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }
  getMetadata() {
    const name = "GetMetadata", cachedPromise = this.#methodPromises.get(name);
    if (cachedPromise) {
      return cachedPromise;
    }
    const promise = this.messageHandler.sendWithPromise(name, null).then((results) => ({
      info: results[0],
      metadata: results[1] ? new Metadata(results[1]) : null,
      contentDispositionFilename: this._fullReader?.filename ?? null,
      contentLength: this._fullReader?.contentLength ?? null
    }));
    this.#methodPromises.set(name, promise);
    return promise;
  }
  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }
  async startCleanup(keepLoadedFonts = false) {
    if (this.destroyed) {
      return;
    }
    await this.messageHandler.sendWithPromise("Cleanup", null);
    for (const page of this.#pageCache.values()) {
      const cleanupSuccessful = page.cleanup();
      if (!cleanupSuccessful) {
        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
      }
    }
    this.commonObjs.clear();
    if (!keepLoadedFonts) {
      this.fontLoader.clear();
    }
    this.#methodPromises.clear();
    this.filterFactory.destroy(true);
    TextLayer$1.cleanup();
  }
  cachedPageNumber(ref2) {
    if (!isRefProxy(ref2)) {
      return null;
    }
    const refStr = ref2.gen === 0 ? `${ref2.num}R` : `${ref2.num}R${ref2.gen}`;
    return this.#pageRefCache.get(refStr) ?? null;
  }
}
const INITIAL_DATA = Symbol("INITIAL_DATA");
class PDFObjects {
  #objs = /* @__PURE__ */ Object.create(null);
  #ensureObj(objId) {
    return this.#objs[objId] ||= {
      ...Promise.withResolvers(),
      data: INITIAL_DATA
    };
  }
  get(objId, callback = null) {
    if (callback) {
      const obj2 = this.#ensureObj(objId);
      obj2.promise.then(() => callback(obj2.data));
      return null;
    }
    const obj = this.#objs[objId];
    if (!obj || obj.data === INITIAL_DATA) {
      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
    }
    return obj.data;
  }
  has(objId) {
    const obj = this.#objs[objId];
    return !!obj && obj.data !== INITIAL_DATA;
  }
  resolve(objId, data2 = null) {
    const obj = this.#ensureObj(objId);
    obj.data = data2;
    obj.resolve();
  }
  clear() {
    for (const objId in this.#objs) {
      const {
        data: data2
      } = this.#objs[objId];
      data2?.bitmap?.close();
    }
    this.#objs = /* @__PURE__ */ Object.create(null);
  }
  *[Symbol.iterator]() {
    for (const objId in this.#objs) {
      const {
        data: data2
      } = this.#objs[objId];
      if (data2 === INITIAL_DATA) {
        continue;
      }
      yield [objId, data2];
    }
  }
}
class RenderTask {
  #internalRenderTask = null;
  constructor(internalRenderTask) {
    this.#internalRenderTask = internalRenderTask;
    this.onContinue = null;
  }
  get promise() {
    return this.#internalRenderTask.capability.promise;
  }
  cancel(extraDelay = 0) {
    this.#internalRenderTask.cancel(null, extraDelay);
  }
  get separateAnnots() {
    const {
      separateAnnots
    } = this.#internalRenderTask.operatorList;
    if (!separateAnnots) {
      return false;
    }
    const {
      annotationCanvasMap
    } = this.#internalRenderTask;
    return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;
  }
}
class InternalRenderTask {
  static #canvasInUse = /* @__PURE__ */ new WeakSet();
  constructor({
    callback,
    params,
    objs,
    commonObjs,
    annotationCanvasMap,
    operatorList,
    pageIndex,
    canvasFactory,
    filterFactory,
    useRequestAnimationFrame = false,
    pdfBug = false,
    pageColors = null
  }) {
    this.callback = callback;
    this.params = params;
    this.objs = objs;
    this.commonObjs = commonObjs;
    this.annotationCanvasMap = annotationCanvasMap;
    this.operatorListIdx = null;
    this.operatorList = operatorList;
    this._pageIndex = pageIndex;
    this.canvasFactory = canvasFactory;
    this.filterFactory = filterFactory;
    this._pdfBug = pdfBug;
    this.pageColors = pageColors;
    this.running = false;
    this.graphicsReadyCallback = null;
    this.graphicsReady = false;
    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
    this.cancelled = false;
    this.capability = Promise.withResolvers();
    this.task = new RenderTask(this);
    this._cancelBound = this.cancel.bind(this);
    this._continueBound = this._continue.bind(this);
    this._scheduleNextBound = this._scheduleNext.bind(this);
    this._nextBound = this._next.bind(this);
    this._canvas = params.canvasContext.canvas;
  }
  get completed() {
    return this.capability.promise.catch(function() {
    });
  }
  initializeGraphics({
    transparency = false,
    optionalContentConfig
  }) {
    if (this.cancelled) {
      return;
    }
    if (this._canvas) {
      if (InternalRenderTask.#canvasInUse.has(this._canvas)) {
        throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
      }
      InternalRenderTask.#canvasInUse.add(this._canvas);
    }
    if (this._pdfBug && globalThis.StepperManager?.enabled) {
      this.stepper = globalThis.StepperManager.create(this._pageIndex);
      this.stepper.init(this.operatorList);
      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
    }
    const {
      canvasContext,
      viewport,
      transform: transform2,
      background
    } = this.params;
    this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
      optionalContentConfig
    }, this.annotationCanvasMap, this.pageColors);
    this.gfx.beginDrawing({
      transform: transform2,
      viewport,
      transparency,
      background
    });
    this.operatorListIdx = 0;
    this.graphicsReady = true;
    this.graphicsReadyCallback?.();
  }
  cancel(error = null, extraDelay = 0) {
    this.running = false;
    this.cancelled = true;
    this.gfx?.endDrawing();
    InternalRenderTask.#canvasInUse.delete(this._canvas);
    this.callback(error || new RenderingCancelledException$1(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));
  }
  operatorListChanged() {
    if (!this.graphicsReady) {
      this.graphicsReadyCallback ||= this._continueBound;
      return;
    }
    this.stepper?.updateOperatorList(this.operatorList);
    if (this.running) {
      return;
    }
    this._continue();
  }
  _continue() {
    this.running = true;
    if (this.cancelled) {
      return;
    }
    if (this.task.onContinue) {
      this.task.onContinue(this._scheduleNextBound);
    } else {
      this._scheduleNext();
    }
  }
  _scheduleNext() {
    if (this._useRequestAnimationFrame) {
      window.requestAnimationFrame(() => {
        this._nextBound().catch(this._cancelBound);
      });
    } else {
      Promise.resolve().then(this._nextBound).catch(this._cancelBound);
    }
  }
  async _next() {
    if (this.cancelled) {
      return;
    }
    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
    if (this.operatorListIdx === this.operatorList.argsArray.length) {
      this.running = false;
      if (this.operatorList.lastChunk) {
        this.gfx.endDrawing();
        InternalRenderTask.#canvasInUse.delete(this._canvas);
        this.callback();
      }
    }
  }
}
const version$1 = "4.3.136";
const build$1 = "0cec64437";
function makeColorComp(n2) {
  return Math.floor(Math.max(0, Math.min(1, n2)) * 255).toString(16).padStart(2, "0");
}
function scaleAndClamp(x2) {
  return Math.max(0, Math.min(255, 255 * x2));
}
class ColorConverters {
  static CMYK_G([c, y2, m2, k2]) {
    return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m2 + 0.11 * y2 + k2)];
  }
  static G_CMYK([g2]) {
    return ["CMYK", 0, 0, 0, 1 - g2];
  }
  static G_RGB([g2]) {
    return ["RGB", g2, g2, g2];
  }
  static G_rgb([g2]) {
    g2 = scaleAndClamp(g2);
    return [g2, g2, g2];
  }
  static G_HTML([g2]) {
    const G = makeColorComp(g2);
    return `#${G}${G}${G}`;
  }
  static RGB_G([r2, g2, b2]) {
    return ["G", 0.3 * r2 + 0.59 * g2 + 0.11 * b2];
  }
  static RGB_rgb(color) {
    return color.map(scaleAndClamp);
  }
  static RGB_HTML(color) {
    return `#${color.map(makeColorComp).join("")}`;
  }
  static T_HTML() {
    return "#00000000";
  }
  static T_rgb() {
    return [null];
  }
  static CMYK_RGB([c, y2, m2, k2]) {
    return ["RGB", 1 - Math.min(1, c + k2), 1 - Math.min(1, m2 + k2), 1 - Math.min(1, y2 + k2)];
  }
  static CMYK_rgb([c, y2, m2, k2]) {
    return [scaleAndClamp(1 - Math.min(1, c + k2)), scaleAndClamp(1 - Math.min(1, m2 + k2)), scaleAndClamp(1 - Math.min(1, y2 + k2))];
  }
  static CMYK_HTML(components) {
    const rgb = this.CMYK_RGB(components).slice(1);
    return this.RGB_HTML(rgb);
  }
  static RGB_CMYK([r2, g2, b2]) {
    const c = 1 - r2;
    const m2 = 1 - g2;
    const y2 = 1 - b2;
    const k2 = Math.min(c, m2, y2);
    return ["CMYK", c, m2, y2, k2];
  }
}
let XfaLayer$1 = class XfaLayer {
  static setupStorage(html, id2, element, storage, intent) {
    const storedData = storage.getValue(id2, {
      value: null
    });
    switch (element.name) {
      case "textarea":
        if (storedData.value !== null) {
          html.textContent = storedData.value;
        }
        if (intent === "print") {
          break;
        }
        html.addEventListener("input", (event) => {
          storage.setValue(id2, {
            value: event.target.value
          });
        });
        break;
      case "input":
        if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
          if (storedData.value === element.attributes.xfaOn) {
            html.setAttribute("checked", true);
          } else if (storedData.value === element.attributes.xfaOff) {
            html.removeAttribute("checked");
          }
          if (intent === "print") {
            break;
          }
          html.addEventListener("change", (event) => {
            storage.setValue(id2, {
              value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
            });
          });
        } else {
          if (storedData.value !== null) {
            html.setAttribute("value", storedData.value);
          }
          if (intent === "print") {
            break;
          }
          html.addEventListener("input", (event) => {
            storage.setValue(id2, {
              value: event.target.value
            });
          });
        }
        break;
      case "select":
        if (storedData.value !== null) {
          html.setAttribute("value", storedData.value);
          for (const option of element.children) {
            if (option.attributes.value === storedData.value) {
              option.attributes.selected = true;
            } else if (option.attributes.hasOwnProperty("selected")) {
              delete option.attributes.selected;
            }
          }
        }
        html.addEventListener("input", (event) => {
          const options = event.target.options;
          const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
          storage.setValue(id2, {
            value
          });
        });
        break;
    }
  }
  static setAttributes({
    html,
    element,
    storage = null,
    intent,
    linkService
  }) {
    const {
      attributes
    } = element;
    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
    if (attributes.type === "radio") {
      attributes.name = `${attributes.name}-${intent}`;
    }
    for (const [key, value] of Object.entries(attributes)) {
      if (value === null || value === void 0) {
        continue;
      }
      switch (key) {
        case "class":
          if (value.length) {
            html.setAttribute(key, value.join(" "));
          }
          break;
        case "dataId":
          break;
        case "id":
          html.setAttribute("data-element-id", value);
          break;
        case "style":
          Object.assign(html.style, value);
          break;
        case "textContent":
          html.textContent = value;
          break;
        default:
          if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
            html.setAttribute(key, value);
          }
      }
    }
    if (isHTMLAnchorElement) {
      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
    }
    if (storage && attributes.dataId) {
      this.setupStorage(html, attributes.dataId, element, storage);
    }
  }
  static render(parameters) {
    const storage = parameters.annotationStorage;
    const linkService = parameters.linkService;
    const root = parameters.xfaHtml;
    const intent = parameters.intent || "display";
    const rootHtml = document.createElement(root.name);
    if (root.attributes) {
      this.setAttributes({
        html: rootHtml,
        element: root,
        intent,
        linkService
      });
    }
    const isNotForRichText = intent !== "richText";
    const rootDiv = parameters.div;
    rootDiv.append(rootHtml);
    if (parameters.viewport) {
      const transform2 = `matrix(${parameters.viewport.transform.join(",")})`;
      rootDiv.style.transform = transform2;
    }
    if (isNotForRichText) {
      rootDiv.setAttribute("class", "xfaLayer xfaFont");
    }
    const textDivs = [];
    if (root.children.length === 0) {
      if (root.value) {
        const node = document.createTextNode(root.value);
        rootHtml.append(node);
        if (isNotForRichText && XfaText.shouldBuildText(root.name)) {
          textDivs.push(node);
        }
      }
      return {
        textDivs
      };
    }
    const stack2 = [[root, -1, rootHtml]];
    while (stack2.length > 0) {
      const [parent, i2, html] = stack2.at(-1);
      if (i2 + 1 === parent.children.length) {
        stack2.pop();
        continue;
      }
      const child = parent.children[++stack2.at(-1)[1]];
      if (child === null) {
        continue;
      }
      const {
        name
      } = child;
      if (name === "#text") {
        const node = document.createTextNode(child.value);
        textDivs.push(node);
        html.append(node);
        continue;
      }
      const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);
      html.append(childHtml);
      if (child.attributes) {
        this.setAttributes({
          html: childHtml,
          element: child,
          storage,
          intent,
          linkService
        });
      }
      if (child.children?.length > 0) {
        stack2.push([child, -1, childHtml]);
      } else if (child.value) {
        const node = document.createTextNode(child.value);
        if (isNotForRichText && XfaText.shouldBuildText(name)) {
          textDivs.push(node);
        }
        childHtml.append(node);
      }
    }
    for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
      el.setAttribute("readOnly", true);
    }
    return {
      textDivs
    };
  }
  static update(parameters) {
    const transform2 = `matrix(${parameters.viewport.transform.join(",")})`;
    parameters.div.style.transform = transform2;
    parameters.div.hidden = false;
  }
};
const DEFAULT_TAB_INDEX = 1e3;
const annotation_layer_DEFAULT_FONT_SIZE = 9;
const GetElementsByNameSet = /* @__PURE__ */ new WeakSet();
function getRectDims(rect) {
  return {
    width: rect[2] - rect[0],
    height: rect[3] - rect[1]
  };
}
class AnnotationElementFactory {
  static create(parameters) {
    const subtype = parameters.data.annotationType;
    switch (subtype) {
      case AnnotationType.LINK:
        return new LinkAnnotationElement(parameters);
      case AnnotationType.TEXT:
        return new TextAnnotationElement(parameters);
      case AnnotationType.WIDGET:
        const fieldType = parameters.data.fieldType;
        switch (fieldType) {
          case "Tx":
            return new TextWidgetAnnotationElement(parameters);
          case "Btn":
            if (parameters.data.radioButton) {
              return new RadioButtonWidgetAnnotationElement(parameters);
            } else if (parameters.data.checkBox) {
              return new CheckboxWidgetAnnotationElement(parameters);
            }
            return new PushButtonWidgetAnnotationElement(parameters);
          case "Ch":
            return new ChoiceWidgetAnnotationElement(parameters);
          case "Sig":
            return new SignatureWidgetAnnotationElement(parameters);
        }
        return new WidgetAnnotationElement(parameters);
      case AnnotationType.POPUP:
        return new PopupAnnotationElement(parameters);
      case AnnotationType.FREETEXT:
        return new FreeTextAnnotationElement(parameters);
      case AnnotationType.LINE:
        return new LineAnnotationElement(parameters);
      case AnnotationType.SQUARE:
        return new SquareAnnotationElement(parameters);
      case AnnotationType.CIRCLE:
        return new CircleAnnotationElement(parameters);
      case AnnotationType.POLYLINE:
        return new PolylineAnnotationElement(parameters);
      case AnnotationType.CARET:
        return new CaretAnnotationElement(parameters);
      case AnnotationType.INK:
        return new InkAnnotationElement(parameters);
      case AnnotationType.POLYGON:
        return new PolygonAnnotationElement(parameters);
      case AnnotationType.HIGHLIGHT:
        return new HighlightAnnotationElement(parameters);
      case AnnotationType.UNDERLINE:
        return new UnderlineAnnotationElement(parameters);
      case AnnotationType.SQUIGGLY:
        return new SquigglyAnnotationElement(parameters);
      case AnnotationType.STRIKEOUT:
        return new StrikeOutAnnotationElement(parameters);
      case AnnotationType.STAMP:
        return new StampAnnotationElement(parameters);
      case AnnotationType.FILEATTACHMENT:
        return new FileAttachmentAnnotationElement(parameters);
      default:
        return new AnnotationElement(parameters);
    }
  }
}
class AnnotationElement {
  #updates = null;
  #hasBorder = false;
  #popupElement = null;
  constructor(parameters, {
    isRenderable = false,
    ignoreBorder = false,
    createQuadrilaterals = false
  } = {}) {
    this.isRenderable = isRenderable;
    this.data = parameters.data;
    this.layer = parameters.layer;
    this.linkService = parameters.linkService;
    this.downloadManager = parameters.downloadManager;
    this.imageResourcesPath = parameters.imageResourcesPath;
    this.renderForms = parameters.renderForms;
    this.svgFactory = parameters.svgFactory;
    this.annotationStorage = parameters.annotationStorage;
    this.enableScripting = parameters.enableScripting;
    this.hasJSActions = parameters.hasJSActions;
    this._fieldObjects = parameters.fieldObjects;
    this.parent = parameters.parent;
    if (isRenderable) {
      this.container = this._createContainer(ignoreBorder);
    }
    if (createQuadrilaterals) {
      this._createQuadrilaterals();
    }
  }
  static _hasPopupData({
    titleObj,
    contentsObj,
    richText
  }) {
    return !!(titleObj?.str || contentsObj?.str || richText?.str);
  }
  get hasPopupData() {
    return AnnotationElement._hasPopupData(this.data);
  }
  updateEdited(params) {
    if (!this.container) {
      return;
    }
    this.#updates ||= {
      rect: this.data.rect.slice(0)
    };
    const {
      rect
    } = params;
    if (rect) {
      this.#setRectEdited(rect);
    }
    this.#popupElement?.popup.updateEdited(params);
  }
  resetEdited() {
    if (!this.#updates) {
      return;
    }
    this.#setRectEdited(this.#updates.rect);
    this.#popupElement?.popup.resetEdited();
    this.#updates = null;
  }
  #setRectEdited(rect) {
    const {
      container: {
        style: style2
      },
      data: {
        rect: currentRect,
        rotation
      },
      parent: {
        viewport: {
          rawDims: {
            pageWidth,
            pageHeight,
            pageX,
            pageY
          }
        }
      }
    } = this;
    currentRect?.splice(0, 4, ...rect);
    const {
      width,
      height
    } = getRectDims(rect);
    style2.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
    style2.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;
    if (rotation === 0) {
      style2.width = `${100 * width / pageWidth}%`;
      style2.height = `${100 * height / pageHeight}%`;
    } else {
      this.setRotation(rotation);
    }
  }
  _createContainer(ignoreBorder) {
    const {
      data: data2,
      parent: {
        page,
        viewport
      }
    } = this;
    const container = document.createElement("section");
    container.setAttribute("data-annotation-id", data2.id);
    if (!(this instanceof WidgetAnnotationElement)) {
      container.tabIndex = DEFAULT_TAB_INDEX;
    }
    const {
      style: style2
    } = container;
    style2.zIndex = this.parent.zIndex++;
    if (data2.popupRef) {
      container.setAttribute("aria-haspopup", "dialog");
    }
    if (data2.alternativeText) {
      container.title = data2.alternativeText;
    }
    if (data2.noRotate) {
      container.classList.add("norotate");
    }
    if (!data2.rect || this instanceof PopupAnnotationElement) {
      const {
        rotation: rotation2
      } = data2;
      if (!data2.hasOwnCanvas && rotation2 !== 0) {
        this.setRotation(rotation2, container);
      }
      return container;
    }
    const {
      width,
      height
    } = getRectDims(data2.rect);
    if (!ignoreBorder && data2.borderStyle.width > 0) {
      style2.borderWidth = `${data2.borderStyle.width}px`;
      const horizontalRadius = data2.borderStyle.horizontalCornerRadius;
      const verticalRadius = data2.borderStyle.verticalCornerRadius;
      if (horizontalRadius > 0 || verticalRadius > 0) {
        const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
        style2.borderRadius = radius;
      } else if (this instanceof RadioButtonWidgetAnnotationElement) {
        const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;
        style2.borderRadius = radius;
      }
      switch (data2.borderStyle.style) {
        case AnnotationBorderStyleType.SOLID:
          style2.borderStyle = "solid";
          break;
        case AnnotationBorderStyleType.DASHED:
          style2.borderStyle = "dashed";
          break;
        case AnnotationBorderStyleType.BEVELED:
          warn("Unimplemented border style: beveled");
          break;
        case AnnotationBorderStyleType.INSET:
          warn("Unimplemented border style: inset");
          break;
        case AnnotationBorderStyleType.UNDERLINE:
          style2.borderBottomStyle = "solid";
          break;
      }
      const borderColor = data2.borderColor || null;
      if (borderColor) {
        this.#hasBorder = true;
        style2.borderColor = Util$1.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
      } else {
        style2.borderWidth = 0;
      }
    }
    const rect = Util$1.normalizeRect([data2.rect[0], page.view[3] - data2.rect[1] + page.view[1], data2.rect[2], page.view[3] - data2.rect[3] + page.view[1]]);
    const {
      pageWidth,
      pageHeight,
      pageX,
      pageY
    } = viewport.rawDims;
    style2.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
    style2.top = `${100 * (rect[1] - pageY) / pageHeight}%`;
    const {
      rotation
    } = data2;
    if (data2.hasOwnCanvas || rotation === 0) {
      style2.width = `${100 * width / pageWidth}%`;
      style2.height = `${100 * height / pageHeight}%`;
    } else {
      this.setRotation(rotation, container);
    }
    return container;
  }
  setRotation(angle, container = this.container) {
    if (!this.data.rect) {
      return;
    }
    const {
      pageWidth,
      pageHeight
    } = this.parent.viewport.rawDims;
    const {
      width,
      height
    } = getRectDims(this.data.rect);
    let elementWidth, elementHeight;
    if (angle % 180 === 0) {
      elementWidth = 100 * width / pageWidth;
      elementHeight = 100 * height / pageHeight;
    } else {
      elementWidth = 100 * height / pageWidth;
      elementHeight = 100 * width / pageHeight;
    }
    container.style.width = `${elementWidth}%`;
    container.style.height = `${elementHeight}%`;
    container.setAttribute("data-main-rotation", (360 - angle) % 360);
  }
  get _commonActions() {
    const setColor = (jsName, styleName, event) => {
      const color = event.detail[jsName];
      const colorType = color[0];
      const colorArray = color.slice(1);
      event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);
      this.annotationStorage.setValue(this.data.id, {
        [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)
      });
    };
    return shadow$1(this, "_commonActions", {
      display: (event) => {
        const {
          display
        } = event.detail;
        const hidden = display % 2 === 1;
        this.container.style.visibility = hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          noView: hidden,
          noPrint: display === 1 || display === 2
        });
      },
      print: (event) => {
        this.annotationStorage.setValue(this.data.id, {
          noPrint: !event.detail.print
        });
      },
      hidden: (event) => {
        const {
          hidden
        } = event.detail;
        this.container.style.visibility = hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          noPrint: hidden,
          noView: hidden
        });
      },
      focus: (event) => {
        setTimeout(() => event.target.focus({
          preventScroll: false
        }), 0);
      },
      userName: (event) => {
        event.target.title = event.detail.userName;
      },
      readonly: (event) => {
        event.target.disabled = event.detail.readonly;
      },
      required: (event) => {
        this._setRequired(event.target, event.detail.required);
      },
      bgColor: (event) => {
        setColor("bgColor", "backgroundColor", event);
      },
      fillColor: (event) => {
        setColor("fillColor", "backgroundColor", event);
      },
      fgColor: (event) => {
        setColor("fgColor", "color", event);
      },
      textColor: (event) => {
        setColor("textColor", "color", event);
      },
      borderColor: (event) => {
        setColor("borderColor", "borderColor", event);
      },
      strokeColor: (event) => {
        setColor("strokeColor", "borderColor", event);
      },
      rotation: (event) => {
        const angle = event.detail.rotation;
        this.setRotation(angle);
        this.annotationStorage.setValue(this.data.id, {
          rotation: angle
        });
      }
    });
  }
  _dispatchEventFromSandbox(actions, jsEvent) {
    const commonActions = this._commonActions;
    for (const name of Object.keys(jsEvent.detail)) {
      const action = actions[name] || commonActions[name];
      action?.(jsEvent);
    }
  }
  _setDefaultPropertiesFromJS(element) {
    if (!this.enableScripting) {
      return;
    }
    const storedData = this.annotationStorage.getRawValue(this.data.id);
    if (!storedData) {
      return;
    }
    const commonActions = this._commonActions;
    for (const [actionName, detail] of Object.entries(storedData)) {
      const action = commonActions[actionName];
      if (action) {
        const eventProxy = {
          detail: {
            [actionName]: detail
          },
          target: element
        };
        action(eventProxy);
        delete storedData[actionName];
      }
    }
  }
  _createQuadrilaterals() {
    if (!this.container) {
      return;
    }
    const {
      quadPoints
    } = this.data;
    if (!quadPoints) {
      return;
    }
    const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect;
    if (quadPoints.length === 1) {
      const [, {
        x: trX,
        y: trY
      }, {
        x: blX,
        y: blY
      }] = quadPoints[0];
      if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {
        return;
      }
    }
    const {
      style: style2
    } = this.container;
    let svgBuffer;
    if (this.#hasBorder) {
      const {
        borderColor,
        borderWidth
      } = style2;
      style2.borderWidth = 0;
      svgBuffer = ["url('data:image/svg+xml;utf8,", `<svg xmlns="http://www.w3.org/2000/svg"`, ` preserveAspectRatio="none" viewBox="0 0 1 1">`, `<g fill="transparent" stroke="${borderColor}" stroke-width="${borderWidth}">`];
      this.container.classList.add("hasBorder");
    }
    const width = rectTrX - rectBlX;
    const height = rectTrY - rectBlY;
    const {
      svgFactory
    } = this;
    const svg = svgFactory.createElement("svg");
    svg.classList.add("quadrilateralsContainer");
    svg.setAttribute("width", 0);
    svg.setAttribute("height", 0);
    const defs = svgFactory.createElement("defs");
    svg.append(defs);
    const clipPath = svgFactory.createElement("clipPath");
    const id2 = `clippath_${this.data.id}`;
    clipPath.setAttribute("id", id2);
    clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
    defs.append(clipPath);
    for (const [, {
      x: trX,
      y: trY
    }, {
      x: blX,
      y: blY
    }] of quadPoints) {
      const rect = svgFactory.createElement("rect");
      const x2 = (blX - rectBlX) / width;
      const y2 = (rectTrY - trY) / height;
      const rectWidth = (trX - blX) / width;
      const rectHeight = (trY - blY) / height;
      rect.setAttribute("x", x2);
      rect.setAttribute("y", y2);
      rect.setAttribute("width", rectWidth);
      rect.setAttribute("height", rectHeight);
      clipPath.append(rect);
      svgBuffer?.push(`<rect vector-effect="non-scaling-stroke" x="${x2}" y="${y2}" width="${rectWidth}" height="${rectHeight}"/>`);
    }
    if (this.#hasBorder) {
      svgBuffer.push(`</g></svg>')`);
      style2.backgroundImage = svgBuffer.join("");
    }
    this.container.append(svg);
    this.container.style.clipPath = `url(#${id2})`;
  }
  _createPopup() {
    const {
      container,
      data: data2
    } = this;
    container.setAttribute("aria-haspopup", "dialog");
    const popup = this.#popupElement = new PopupAnnotationElement({
      data: {
        color: data2.color,
        titleObj: data2.titleObj,
        modificationDate: data2.modificationDate,
        contentsObj: data2.contentsObj,
        richText: data2.richText,
        parentRect: data2.rect,
        borderStyle: 0,
        id: `popup_${data2.id}`,
        rotation: data2.rotation
      },
      parent: this.parent,
      elements: [this]
    });
    this.parent.div.append(popup.render());
  }
  render() {
    unreachable("Abstract method `AnnotationElement.render` called");
  }
  _getElementsByName(name, skipId = null) {
    const fields = [];
    if (this._fieldObjects) {
      const fieldObj = this._fieldObjects[name];
      if (fieldObj) {
        for (const {
          page,
          id: id2,
          exportValues
        } of fieldObj) {
          if (page === -1) {
            continue;
          }
          if (id2 === skipId) {
            continue;
          }
          const exportValue = typeof exportValues === "string" ? exportValues : null;
          const domElement = document.querySelector(`[data-element-id="${id2}"]`);
          if (domElement && !GetElementsByNameSet.has(domElement)) {
            warn(`_getElementsByName - element not allowed: ${id2}`);
            continue;
          }
          fields.push({
            id: id2,
            exportValue,
            domElement
          });
        }
      }
      return fields;
    }
    for (const domElement of document.getElementsByName(name)) {
      const {
        exportValue
      } = domElement;
      const id2 = domElement.getAttribute("data-element-id");
      if (id2 === skipId) {
        continue;
      }
      if (!GetElementsByNameSet.has(domElement)) {
        continue;
      }
      fields.push({
        id: id2,
        exportValue,
        domElement
      });
    }
    return fields;
  }
  show() {
    if (this.container) {
      this.container.hidden = false;
    }
    this.popup?.maybeShow();
  }
  hide() {
    if (this.container) {
      this.container.hidden = true;
    }
    this.popup?.forceHide();
  }
  getElementsToTriggerPopup() {
    return this.container;
  }
  addHighlightArea() {
    const triggers = this.getElementsToTriggerPopup();
    if (Array.isArray(triggers)) {
      for (const element of triggers) {
        element.classList.add("highlightArea");
      }
    } else {
      triggers.classList.add("highlightArea");
    }
  }
  get _isEditable() {
    return false;
  }
  _editOnDoubleClick() {
    if (!this._isEditable) {
      return;
    }
    const {
      annotationEditorType: mode,
      data: {
        id: editId
      }
    } = this;
    this.container.addEventListener("dblclick", () => {
      this.linkService.eventBus?.dispatch("switchannotationeditormode", {
        source: this,
        mode,
        editId
      });
    });
  }
}
class LinkAnnotationElement extends AnnotationElement {
  constructor(parameters, options = null) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: !!options?.ignoreBorder,
      createQuadrilaterals: true
    });
    this.isTooltipOnly = parameters.data.isTooltipOnly;
  }
  render() {
    const {
      data: data2,
      linkService
    } = this;
    const link = document.createElement("a");
    link.setAttribute("data-element-id", data2.id);
    let isBound = false;
    if (data2.url) {
      linkService.addLinkAttributes(link, data2.url, data2.newWindow);
      isBound = true;
    } else if (data2.action) {
      this._bindNamedAction(link, data2.action);
      isBound = true;
    } else if (data2.attachment) {
      this.#bindAttachment(link, data2.attachment, data2.attachmentDest);
      isBound = true;
    } else if (data2.setOCGState) {
      this.#bindSetOCGState(link, data2.setOCGState);
      isBound = true;
    } else if (data2.dest) {
      this._bindLink(link, data2.dest);
      isBound = true;
    } else {
      if (data2.actions && (data2.actions.Action || data2.actions["Mouse Up"] || data2.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
        this._bindJSAction(link, data2);
        isBound = true;
      }
      if (data2.resetForm) {
        this._bindResetFormAction(link, data2.resetForm);
        isBound = true;
      } else if (this.isTooltipOnly && !isBound) {
        this._bindLink(link, "");
        isBound = true;
      }
    }
    this.container.classList.add("linkAnnotation");
    if (isBound) {
      this.container.append(link);
    }
    return this.container;
  }
  #setInternalLink() {
    this.container.setAttribute("data-internal-link", "");
  }
  _bindLink(link, destination) {
    link.href = this.linkService.getDestinationHash(destination);
    link.onclick = () => {
      if (destination) {
        this.linkService.goToDestination(destination);
      }
      return false;
    };
    if (destination || destination === "") {
      this.#setInternalLink();
    }
  }
  _bindNamedAction(link, action) {
    link.href = this.linkService.getAnchorUrl("");
    link.onclick = () => {
      this.linkService.executeNamedAction(action);
      return false;
    };
    this.#setInternalLink();
  }
  #bindAttachment(link, attachment, dest = null) {
    link.href = this.linkService.getAnchorUrl("");
    if (attachment.description) {
      link.title = attachment.description;
    }
    link.onclick = () => {
      this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);
      return false;
    };
    this.#setInternalLink();
  }
  #bindSetOCGState(link, action) {
    link.href = this.linkService.getAnchorUrl("");
    link.onclick = () => {
      this.linkService.executeSetOCGState(action);
      return false;
    };
    this.#setInternalLink();
  }
  _bindJSAction(link, data2) {
    link.href = this.linkService.getAnchorUrl("");
    const map = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
    for (const name of Object.keys(data2.actions)) {
      const jsName = map.get(name);
      if (!jsName) {
        continue;
      }
      link[jsName] = () => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: data2.id,
            name
          }
        });
        return false;
      };
    }
    if (!link.onclick) {
      link.onclick = () => false;
    }
    this.#setInternalLink();
  }
  _bindResetFormAction(link, resetForm) {
    const otherClickAction = link.onclick;
    if (!otherClickAction) {
      link.href = this.linkService.getAnchorUrl("");
    }
    this.#setInternalLink();
    if (!this._fieldObjects) {
      warn(`_bindResetFormAction - "resetForm" action not supported, ensure that the \`fieldObjects\` parameter is provided.`);
      if (!otherClickAction) {
        link.onclick = () => false;
      }
      return;
    }
    link.onclick = () => {
      otherClickAction?.();
      const {
        fields: resetFormFields,
        refs: resetFormRefs,
        include
      } = resetForm;
      const allFields = [];
      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
        const fieldIds = new Set(resetFormRefs);
        for (const fieldName of resetFormFields) {
          const fields = this._fieldObjects[fieldName] || [];
          for (const {
            id: id2
          } of fields) {
            fieldIds.add(id2);
          }
        }
        for (const fields of Object.values(this._fieldObjects)) {
          for (const field of fields) {
            if (fieldIds.has(field.id) === include) {
              allFields.push(field);
            }
          }
        }
      } else {
        for (const fields of Object.values(this._fieldObjects)) {
          allFields.push(...fields);
        }
      }
      const storage = this.annotationStorage;
      const allIds = [];
      for (const field of allFields) {
        const {
          id: id2
        } = field;
        allIds.push(id2);
        switch (field.type) {
          case "text": {
            const value = field.defaultValue || "";
            storage.setValue(id2, {
              value
            });
            break;
          }
          case "checkbox":
          case "radiobutton": {
            const value = field.defaultValue === field.exportValues;
            storage.setValue(id2, {
              value
            });
            break;
          }
          case "combobox":
          case "listbox": {
            const value = field.defaultValue || "";
            storage.setValue(id2, {
              value
            });
            break;
          }
          default:
            continue;
        }
        const domElement = document.querySelector(`[data-element-id="${id2}"]`);
        if (!domElement) {
          continue;
        } else if (!GetElementsByNameSet.has(domElement)) {
          warn(`_bindResetFormAction - element not allowed: ${id2}`);
          continue;
        }
        domElement.dispatchEvent(new Event("resetform"));
      }
      if (this.enableScripting) {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: "app",
            ids: allIds,
            name: "ResetForm"
          }
        });
      }
      return false;
    };
  }
}
class TextAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true
    });
  }
  render() {
    this.container.classList.add("textAnnotation");
    const image = document.createElement("img");
    image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
    image.setAttribute("data-l10n-id", "pdfjs-text-annotation-type");
    image.setAttribute("data-l10n-args", JSON.stringify({
      type: this.data.name
    }));
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.append(image);
    return this.container;
  }
}
class WidgetAnnotationElement extends AnnotationElement {
  render() {
    return this.container;
  }
  showElementAndHideCanvas(element) {
    if (this.data.hasOwnCanvas) {
      if (element.previousSibling?.nodeName === "CANVAS") {
        element.previousSibling.hidden = true;
      }
      element.hidden = false;
    }
  }
  _getKeyModifier(event) {
    return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;
  }
  _setEventListener(element, elementData, baseName, eventName, valueGetter) {
    if (baseName.includes("mouse")) {
      element.addEventListener(baseName, (event) => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event),
            shift: event.shiftKey,
            modifier: this._getKeyModifier(event)
          }
        });
      });
    } else {
      element.addEventListener(baseName, (event) => {
        if (baseName === "blur") {
          if (!elementData.focused || !event.relatedTarget) {
            return;
          }
          elementData.focused = false;
        } else if (baseName === "focus") {
          if (elementData.focused) {
            return;
          }
          elementData.focused = true;
        }
        if (!valueGetter) {
          return;
        }
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event)
          }
        });
      });
    }
  }
  _setEventListeners(element, elementData, names, getter) {
    for (const [baseName, eventName] of names) {
      if (eventName === "Action" || this.data.actions?.[eventName]) {
        if (eventName === "Focus" || eventName === "Blur") {
          elementData ||= {
            focused: false
          };
        }
        this._setEventListener(element, elementData, baseName, eventName, getter);
        if (eventName === "Focus" && !this.data.actions?.Blur) {
          this._setEventListener(element, elementData, "blur", "Blur", null);
        } else if (eventName === "Blur" && !this.data.actions?.Focus) {
          this._setEventListener(element, elementData, "focus", "Focus", null);
        }
      }
    }
  }
  _setBackgroundColor(element) {
    const color = this.data.backgroundColor || null;
    element.style.backgroundColor = color === null ? "transparent" : Util$1.makeHexColor(color[0], color[1], color[2]);
  }
  _setTextStyle(element) {
    const TEXT_ALIGNMENT = ["left", "center", "right"];
    const {
      fontColor
    } = this.data.defaultAppearanceData;
    const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;
    const style2 = element.style;
    let computedFontSize;
    const BORDER_SIZE = 2;
    const roundToOneDecimal = (x2) => Math.round(10 * x2) / 10;
    if (this.data.multiLine) {
      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
      const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;
      const lineHeight = height / numberOfLines;
      computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));
    } else {
      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
      computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));
    }
    style2.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
    style2.color = Util$1.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
    if (this.data.textAlignment !== null) {
      style2.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
    }
  }
  _setRequired(element, isRequired) {
    if (isRequired) {
      element.setAttribute("required", true);
    } else {
      element.removeAttribute("required");
    }
    element.setAttribute("aria-required", isRequired);
  }
}
class TextWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
    super(parameters, {
      isRenderable
    });
  }
  setPropertyOnSiblings(base, key, value, keyInStorage) {
    const storage = this.annotationStorage;
    for (const element of this._getElementsByName(base.name, base.id)) {
      if (element.domElement) {
        element.domElement[key] = value;
      }
      storage.setValue(element.id, {
        [keyInStorage]: value
      });
    }
  }
  render() {
    const storage = this.annotationStorage;
    const id2 = this.data.id;
    this.container.classList.add("textWidgetAnnotation");
    let element = null;
    if (this.renderForms) {
      const storedData = storage.getValue(id2, {
        value: this.data.fieldValue
      });
      let textContent = storedData.value || "";
      const maxLen = storage.getValue(id2, {
        charLimit: this.data.maxLen
      }).charLimit;
      if (maxLen && textContent.length > maxLen) {
        textContent = textContent.slice(0, maxLen);
      }
      let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join("\n") || null;
      if (fieldFormattedValues && this.data.comb) {
        fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
      }
      const elementData = {
        userValue: textContent,
        formattedValue: fieldFormattedValues,
        lastCommittedValue: null,
        commitKey: 1,
        focused: false
      };
      if (this.data.multiLine) {
        element = document.createElement("textarea");
        element.textContent = fieldFormattedValues ?? textContent;
        if (this.data.doNotScroll) {
          element.style.overflowY = "hidden";
        }
      } else {
        element = document.createElement("input");
        element.type = "text";
        element.setAttribute("value", fieldFormattedValues ?? textContent);
        if (this.data.doNotScroll) {
          element.style.overflowX = "hidden";
        }
      }
      if (this.data.hasOwnCanvas) {
        element.hidden = true;
      }
      GetElementsByNameSet.add(element);
      element.setAttribute("data-element-id", id2);
      element.disabled = this.data.readOnly;
      element.name = this.data.fieldName;
      element.tabIndex = DEFAULT_TAB_INDEX;
      this._setRequired(element, this.data.required);
      if (maxLen) {
        element.maxLength = maxLen;
      }
      element.addEventListener("input", (event) => {
        storage.setValue(id2, {
          value: event.target.value
        });
        this.setPropertyOnSiblings(element, "value", event.target.value, "value");
        elementData.formattedValue = null;
      });
      element.addEventListener("resetform", (event) => {
        const defaultValue = this.data.defaultFieldValue ?? "";
        element.value = elementData.userValue = defaultValue;
        elementData.formattedValue = null;
      });
      let blurListener = (event) => {
        const {
          formattedValue
        } = elementData;
        if (formattedValue !== null && formattedValue !== void 0) {
          event.target.value = formattedValue;
        }
        event.target.scrollLeft = 0;
      };
      if (this.enableScripting && this.hasJSActions) {
        element.addEventListener("focus", (event) => {
          if (elementData.focused) {
            return;
          }
          const {
            target
          } = event;
          if (elementData.userValue) {
            target.value = elementData.userValue;
          }
          elementData.lastCommittedValue = target.value;
          elementData.commitKey = 1;
          if (!this.data.actions?.Focus) {
            elementData.focused = true;
          }
        });
        element.addEventListener("updatefromsandbox", (jsEvent) => {
          this.showElementAndHideCanvas(jsEvent.target);
          const actions = {
            value(event) {
              elementData.userValue = event.detail.value ?? "";
              storage.setValue(id2, {
                value: elementData.userValue.toString()
              });
              event.target.value = elementData.userValue;
            },
            formattedValue(event) {
              const {
                formattedValue
              } = event.detail;
              elementData.formattedValue = formattedValue;
              if (formattedValue !== null && formattedValue !== void 0 && event.target !== document.activeElement) {
                event.target.value = formattedValue;
              }
              storage.setValue(id2, {
                formattedValue
              });
            },
            selRange(event) {
              event.target.setSelectionRange(...event.detail.selRange);
            },
            charLimit: (event) => {
              const {
                charLimit
              } = event.detail;
              const {
                target
              } = event;
              if (charLimit === 0) {
                target.removeAttribute("maxLength");
                return;
              }
              target.setAttribute("maxLength", charLimit);
              let value = elementData.userValue;
              if (!value || value.length <= charLimit) {
                return;
              }
              value = value.slice(0, charLimit);
              target.value = elementData.userValue = value;
              storage.setValue(id2, {
                value
              });
              this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: id2,
                  name: "Keystroke",
                  value,
                  willCommit: true,
                  commitKey: 1,
                  selStart: target.selectionStart,
                  selEnd: target.selectionEnd
                }
              });
            }
          };
          this._dispatchEventFromSandbox(actions, jsEvent);
        });
        element.addEventListener("keydown", (event) => {
          elementData.commitKey = 1;
          let commitKey = -1;
          if (event.key === "Escape") {
            commitKey = 0;
          } else if (event.key === "Enter" && !this.data.multiLine) {
            commitKey = 2;
          } else if (event.key === "Tab") {
            elementData.commitKey = 3;
          }
          if (commitKey === -1) {
            return;
          }
          const {
            value
          } = event.target;
          if (elementData.lastCommittedValue === value) {
            return;
          }
          elementData.lastCommittedValue = value;
          elementData.userValue = value;
          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: id2,
              name: "Keystroke",
              value,
              willCommit: true,
              commitKey,
              selStart: event.target.selectionStart,
              selEnd: event.target.selectionEnd
            }
          });
        });
        const _blurListener = blurListener;
        blurListener = null;
        element.addEventListener("blur", (event) => {
          if (!elementData.focused || !event.relatedTarget) {
            return;
          }
          if (!this.data.actions?.Blur) {
            elementData.focused = false;
          }
          const {
            value
          } = event.target;
          elementData.userValue = value;
          if (elementData.lastCommittedValue !== value) {
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id: id2,
                name: "Keystroke",
                value,
                willCommit: true,
                commitKey: elementData.commitKey,
                selStart: event.target.selectionStart,
                selEnd: event.target.selectionEnd
              }
            });
          }
          _blurListener(event);
        });
        if (this.data.actions?.Keystroke) {
          element.addEventListener("beforeinput", (event) => {
            elementData.lastCommittedValue = null;
            const {
              data: data2,
              target
            } = event;
            const {
              value,
              selectionStart,
              selectionEnd
            } = target;
            let selStart = selectionStart, selEnd = selectionEnd;
            switch (event.inputType) {
              case "deleteWordBackward": {
                const match2 = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                if (match2) {
                  selStart -= match2[0].length;
                }
                break;
              }
              case "deleteWordForward": {
                const match2 = value.substring(selectionStart).match(/^[^\w]*\w*/);
                if (match2) {
                  selEnd += match2[0].length;
                }
                break;
              }
              case "deleteContentBackward":
                if (selectionStart === selectionEnd) {
                  selStart -= 1;
                }
                break;
              case "deleteContentForward":
                if (selectionStart === selectionEnd) {
                  selEnd += 1;
                }
                break;
            }
            event.preventDefault();
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id: id2,
                name: "Keystroke",
                value,
                change: data2 || "",
                willCommit: false,
                selStart,
                selEnd
              }
            });
          });
        }
        this._setEventListeners(element, elementData, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.value);
      }
      if (blurListener) {
        element.addEventListener("blur", blurListener);
      }
      if (this.data.comb) {
        const fieldWidth = this.data.rect[2] - this.data.rect[0];
        const combWidth = fieldWidth / maxLen;
        element.classList.add("comb");
        element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
      }
    } else {
      element = document.createElement("div");
      element.textContent = this.data.fieldValue;
      element.style.verticalAlign = "middle";
      element.style.display = "table-cell";
      if (this.data.hasOwnCanvas) {
        element.hidden = true;
      }
    }
    this._setTextStyle(element);
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
}
class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: !!parameters.data.hasOwnCanvas
    });
  }
}
class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    const storage = this.annotationStorage;
    const data2 = this.data;
    const id2 = data2.id;
    let value = storage.getValue(id2, {
      value: data2.exportValue === data2.fieldValue
    }).value;
    if (typeof value === "string") {
      value = value !== "Off";
      storage.setValue(id2, {
        value
      });
    }
    this.container.classList.add("buttonWidgetAnnotation", "checkBox");
    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.setAttribute("data-element-id", id2);
    element.disabled = data2.readOnly;
    this._setRequired(element, this.data.required);
    element.type = "checkbox";
    element.name = data2.fieldName;
    if (value) {
      element.setAttribute("checked", true);
    }
    element.setAttribute("exportValue", data2.exportValue);
    element.tabIndex = DEFAULT_TAB_INDEX;
    element.addEventListener("change", (event) => {
      const {
        name,
        checked
      } = event.target;
      for (const checkbox of this._getElementsByName(name, id2)) {
        const curChecked = checked && checkbox.exportValue === data2.exportValue;
        if (checkbox.domElement) {
          checkbox.domElement.checked = curChecked;
        }
        storage.setValue(checkbox.id, {
          value: curChecked
        });
      }
      storage.setValue(id2, {
        value: checked
      });
    });
    element.addEventListener("resetform", (event) => {
      const defaultValue = data2.defaultFieldValue || "Off";
      event.target.checked = defaultValue === data2.exportValue;
    });
    if (this.enableScripting && this.hasJSActions) {
      element.addEventListener("updatefromsandbox", (jsEvent) => {
        const actions = {
          value(event) {
            event.target.checked = event.detail.value !== "Off";
            storage.setValue(id2, {
              value: event.target.checked
            });
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
    }
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
}
class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    this.container.classList.add("buttonWidgetAnnotation", "radioButton");
    const storage = this.annotationStorage;
    const data2 = this.data;
    const id2 = data2.id;
    let value = storage.getValue(id2, {
      value: data2.fieldValue === data2.buttonValue
    }).value;
    if (typeof value === "string") {
      value = value !== data2.buttonValue;
      storage.setValue(id2, {
        value
      });
    }
    if (value) {
      for (const radio of this._getElementsByName(data2.fieldName, id2)) {
        storage.setValue(radio.id, {
          value: false
        });
      }
    }
    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.setAttribute("data-element-id", id2);
    element.disabled = data2.readOnly;
    this._setRequired(element, this.data.required);
    element.type = "radio";
    element.name = data2.fieldName;
    if (value) {
      element.setAttribute("checked", true);
    }
    element.tabIndex = DEFAULT_TAB_INDEX;
    element.addEventListener("change", (event) => {
      const {
        name,
        checked
      } = event.target;
      for (const radio of this._getElementsByName(name, id2)) {
        storage.setValue(radio.id, {
          value: false
        });
      }
      storage.setValue(id2, {
        value: checked
      });
    });
    element.addEventListener("resetform", (event) => {
      const defaultValue = data2.defaultFieldValue;
      event.target.checked = defaultValue !== null && defaultValue !== void 0 && defaultValue === data2.buttonValue;
    });
    if (this.enableScripting && this.hasJSActions) {
      const pdfButtonValue = data2.buttonValue;
      element.addEventListener("updatefromsandbox", (jsEvent) => {
        const actions = {
          value: (event) => {
            const checked = pdfButtonValue === event.detail.value;
            for (const radio of this._getElementsByName(event.target.name)) {
              const curChecked = checked && radio.id === id2;
              if (radio.domElement) {
                radio.domElement.checked = curChecked;
              }
              storage.setValue(radio.id, {
                value: curChecked
              });
            }
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
    }
    this._setBackgroundColor(element);
    this._setDefaultPropertiesFromJS(element);
    this.container.append(element);
    return this.container;
  }
}
class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      ignoreBorder: parameters.data.hasAppearance
    });
  }
  render() {
    const container = super.render();
    container.classList.add("buttonWidgetAnnotation", "pushButton");
    const linkElement = container.lastChild;
    if (this.enableScripting && this.hasJSActions && linkElement) {
      this._setDefaultPropertiesFromJS(linkElement);
      linkElement.addEventListener("updatefromsandbox", (jsEvent) => {
        this._dispatchEventFromSandbox({}, jsEvent);
      });
    }
    return container;
  }
}
class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }
  render() {
    this.container.classList.add("choiceWidgetAnnotation");
    const storage = this.annotationStorage;
    const id2 = this.data.id;
    const storedData = storage.getValue(id2, {
      value: this.data.fieldValue
    });
    const selectElement = document.createElement("select");
    GetElementsByNameSet.add(selectElement);
    selectElement.setAttribute("data-element-id", id2);
    selectElement.disabled = this.data.readOnly;
    this._setRequired(selectElement, this.data.required);
    selectElement.name = this.data.fieldName;
    selectElement.tabIndex = DEFAULT_TAB_INDEX;
    let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
    if (!this.data.combo) {
      selectElement.size = this.data.options.length;
      if (this.data.multiSelect) {
        selectElement.multiple = true;
      }
    }
    selectElement.addEventListener("resetform", (event) => {
      const defaultValue = this.data.defaultFieldValue;
      for (const option of selectElement.options) {
        option.selected = option.value === defaultValue;
      }
    });
    for (const option of this.data.options) {
      const optionElement = document.createElement("option");
      optionElement.textContent = option.displayValue;
      optionElement.value = option.exportValue;
      if (storedData.value.includes(option.exportValue)) {
        optionElement.setAttribute("selected", true);
        addAnEmptyEntry = false;
      }
      selectElement.append(optionElement);
    }
    let removeEmptyEntry = null;
    if (addAnEmptyEntry) {
      const noneOptionElement = document.createElement("option");
      noneOptionElement.value = " ";
      noneOptionElement.setAttribute("hidden", true);
      noneOptionElement.setAttribute("selected", true);
      selectElement.prepend(noneOptionElement);
      removeEmptyEntry = () => {
        noneOptionElement.remove();
        selectElement.removeEventListener("input", removeEmptyEntry);
        removeEmptyEntry = null;
      };
      selectElement.addEventListener("input", removeEmptyEntry);
    }
    const getValue2 = (isExport) => {
      const name = isExport ? "value" : "textContent";
      const {
        options,
        multiple
      } = selectElement;
      if (!multiple) {
        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
      }
      return Array.prototype.filter.call(options, (option) => option.selected).map((option) => option[name]);
    };
    let selectedValues = getValue2(false);
    const getItems = (event) => {
      const options = event.target.options;
      return Array.prototype.map.call(options, (option) => ({
        displayValue: option.textContent,
        exportValue: option.value
      }));
    };
    if (this.enableScripting && this.hasJSActions) {
      selectElement.addEventListener("updatefromsandbox", (jsEvent) => {
        const actions = {
          value(event) {
            removeEmptyEntry?.();
            const value = event.detail.value;
            const values2 = new Set(Array.isArray(value) ? value : [value]);
            for (const option of selectElement.options) {
              option.selected = values2.has(option.value);
            }
            storage.setValue(id2, {
              value: getValue2(true)
            });
            selectedValues = getValue2(false);
          },
          multipleSelection(event) {
            selectElement.multiple = true;
          },
          remove(event) {
            const options = selectElement.options;
            const index = event.detail.remove;
            options[index].selected = false;
            selectElement.remove(index);
            if (options.length > 0) {
              const i2 = Array.prototype.findIndex.call(options, (option) => option.selected);
              if (i2 === -1) {
                options[0].selected = true;
              }
            }
            storage.setValue(id2, {
              value: getValue2(true),
              items: getItems(event)
            });
            selectedValues = getValue2(false);
          },
          clear(event) {
            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }
            storage.setValue(id2, {
              value: null,
              items: []
            });
            selectedValues = getValue2(false);
          },
          insert(event) {
            const {
              index,
              displayValue,
              exportValue
            } = event.detail.insert;
            const selectChild = selectElement.children[index];
            const optionElement = document.createElement("option");
            optionElement.textContent = displayValue;
            optionElement.value = exportValue;
            if (selectChild) {
              selectChild.before(optionElement);
            } else {
              selectElement.append(optionElement);
            }
            storage.setValue(id2, {
              value: getValue2(true),
              items: getItems(event)
            });
            selectedValues = getValue2(false);
          },
          items(event) {
            const {
              items
            } = event.detail;
            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }
            for (const item of items) {
              const {
                displayValue,
                exportValue
              } = item;
              const optionElement = document.createElement("option");
              optionElement.textContent = displayValue;
              optionElement.value = exportValue;
              selectElement.append(optionElement);
            }
            if (selectElement.options.length > 0) {
              selectElement.options[0].selected = true;
            }
            storage.setValue(id2, {
              value: getValue2(true),
              items: getItems(event)
            });
            selectedValues = getValue2(false);
          },
          indices(event) {
            const indices = new Set(event.detail.indices);
            for (const option of event.target.options) {
              option.selected = indices.has(option.index);
            }
            storage.setValue(id2, {
              value: getValue2(true)
            });
            selectedValues = getValue2(false);
          },
          editable(event) {
            event.target.disabled = !event.detail.editable;
          }
        };
        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      selectElement.addEventListener("input", (event) => {
        const exportValue = getValue2(true);
        const change = getValue2(false);
        storage.setValue(id2, {
          value: exportValue
        });
        event.preventDefault();
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: id2,
            name: "Keystroke",
            value: selectedValues,
            change,
            changeEx: exportValue,
            willCommit: false,
            commitKey: 1,
            keyDown: false
          }
        });
      });
      this._setEventListeners(selectElement, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (event) => event.target.value);
    } else {
      selectElement.addEventListener("input", function(event) {
        storage.setValue(id2, {
          value: getValue2(true)
        });
      });
    }
    if (this.data.combo) {
      this._setTextStyle(selectElement);
    }
    this._setBackgroundColor(selectElement);
    this._setDefaultPropertiesFromJS(selectElement);
    this.container.append(selectElement);
    return this.container;
  }
}
class PopupAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const {
      data: data2,
      elements
    } = parameters;
    super(parameters, {
      isRenderable: AnnotationElement._hasPopupData(data2)
    });
    this.elements = elements;
    this.popup = null;
  }
  render() {
    this.container.classList.add("popupAnnotation");
    const popup = this.popup = new PopupElement({
      container: this.container,
      color: this.data.color,
      titleObj: this.data.titleObj,
      modificationDate: this.data.modificationDate,
      contentsObj: this.data.contentsObj,
      richText: this.data.richText,
      rect: this.data.rect,
      parentRect: this.data.parentRect || null,
      parent: this.parent,
      elements: this.elements,
      open: this.data.open
    });
    const elementIds = [];
    for (const element of this.elements) {
      element.popup = popup;
      elementIds.push(element.data.id);
      element.addHighlightArea();
    }
    this.container.setAttribute("aria-controls", elementIds.map((id2) => `${AnnotationPrefix}${id2}`).join(","));
    return this.container;
  }
}
class PopupElement {
  #boundKeyDown = this.#keyDown.bind(this);
  #boundHide = this.#hide.bind(this);
  #boundShow = this.#show.bind(this);
  #boundToggle = this.#toggle.bind(this);
  #color = null;
  #container = null;
  #contentsObj = null;
  #dateObj = null;
  #elements = null;
  #parent = null;
  #parentRect = null;
  #pinned = false;
  #popup = null;
  #position = null;
  #rect = null;
  #richText = null;
  #titleObj = null;
  #updates = null;
  #wasVisible = false;
  constructor({
    container,
    color,
    elements,
    titleObj,
    modificationDate,
    contentsObj,
    richText,
    parent,
    rect,
    parentRect,
    open
  }) {
    this.#container = container;
    this.#titleObj = titleObj;
    this.#contentsObj = contentsObj;
    this.#richText = richText;
    this.#parent = parent;
    this.#color = color;
    this.#rect = rect;
    this.#parentRect = parentRect;
    this.#elements = elements;
    this.#dateObj = PDFDateString$1.toDateObject(modificationDate);
    this.trigger = elements.flatMap((e2) => e2.getElementsToTriggerPopup());
    for (const element of this.trigger) {
      element.addEventListener("click", this.#boundToggle);
      element.addEventListener("mouseenter", this.#boundShow);
      element.addEventListener("mouseleave", this.#boundHide);
      element.classList.add("popupTriggerArea");
    }
    for (const element of elements) {
      element.container?.addEventListener("keydown", this.#boundKeyDown);
    }
    this.#container.hidden = true;
    if (open) {
      this.#toggle();
    }
  }
  render() {
    if (this.#popup) {
      return;
    }
    const popup = this.#popup = document.createElement("div");
    popup.className = "popup";
    if (this.#color) {
      const baseColor = popup.style.outlineColor = Util$1.makeHexColor(...this.#color);
      if (CSS.supports("background-color", "color-mix(in srgb, red 30%, white)")) {
        popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
      } else {
        const BACKGROUND_ENLIGHT = 0.7;
        popup.style.backgroundColor = Util$1.makeHexColor(...this.#color.map((c) => Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)));
      }
    }
    const header = document.createElement("span");
    header.className = "header";
    const title = document.createElement("h1");
    header.append(title);
    ({
      dir: title.dir,
      str: title.textContent
    } = this.#titleObj);
    popup.append(header);
    if (this.#dateObj) {
      const modificationDate = document.createElement("span");
      modificationDate.classList.add("popupDate");
      modificationDate.setAttribute("data-l10n-id", "pdfjs-annotation-date-string");
      modificationDate.setAttribute("data-l10n-args", JSON.stringify({
        date: this.#dateObj.toLocaleDateString(),
        time: this.#dateObj.toLocaleTimeString()
      }));
      header.append(modificationDate);
    }
    const html = this.#html;
    if (html) {
      XfaLayer$1.render({
        xfaHtml: html,
        intent: "richText",
        div: popup
      });
      popup.lastChild.classList.add("richText", "popupContent");
    } else {
      const contents = this._formatContents(this.#contentsObj);
      popup.append(contents);
    }
    this.#container.append(popup);
  }
  get #html() {
    const richText = this.#richText;
    const contentsObj = this.#contentsObj;
    if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {
      return this.#richText.html || null;
    }
    return null;
  }
  get #fontSize() {
    return this.#html?.attributes?.style?.fontSize || 0;
  }
  get #fontColor() {
    return this.#html?.attributes?.style?.color || null;
  }
  #makePopupContent(text) {
    const popupLines = [];
    const popupContent = {
      str: text,
      html: {
        name: "div",
        attributes: {
          dir: "auto"
        },
        children: [{
          name: "p",
          children: popupLines
        }]
      }
    };
    const lineAttributes = {
      style: {
        color: this.#fontColor,
        fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--scale-factor))` : ""
      }
    };
    for (const line2 of text.split("\n")) {
      popupLines.push({
        name: "span",
        value: line2,
        attributes: lineAttributes
      });
    }
    return popupContent;
  }
  _formatContents({
    str,
    dir
  }) {
    const p2 = document.createElement("p");
    p2.classList.add("popupContent");
    p2.dir = dir;
    const lines = str.split(/(?:\r\n?|\n)/);
    for (let i2 = 0, ii = lines.length; i2 < ii; ++i2) {
      const line2 = lines[i2];
      p2.append(document.createTextNode(line2));
      if (i2 < ii - 1) {
        p2.append(document.createElement("br"));
      }
    }
    return p2;
  }
  #keyDown(event) {
    if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
      return;
    }
    if (event.key === "Enter" || event.key === "Escape" && this.#pinned) {
      this.#toggle();
    }
  }
  updateEdited({
    rect,
    popupContent
  }) {
    this.#updates ||= {
      contentsObj: this.#contentsObj,
      richText: this.#richText
    };
    if (rect) {
      this.#position = null;
    }
    if (popupContent) {
      this.#richText = this.#makePopupContent(popupContent);
      this.#contentsObj = null;
    }
    this.#popup?.remove();
    this.#popup = null;
  }
  resetEdited() {
    if (!this.#updates) {
      return;
    }
    ({
      contentsObj: this.#contentsObj,
      richText: this.#richText
    } = this.#updates);
    this.#updates = null;
    this.#popup?.remove();
    this.#popup = null;
    this.#position = null;
  }
  #setPosition() {
    if (this.#position !== null) {
      return;
    }
    const {
      page: {
        view
      },
      viewport: {
        rawDims: {
          pageWidth,
          pageHeight,
          pageX,
          pageY
        }
      }
    } = this.#parent;
    let useParentRect = !!this.#parentRect;
    let rect = useParentRect ? this.#parentRect : this.#rect;
    for (const element of this.#elements) {
      if (!rect || Util$1.intersect(element.data.rect, rect) !== null) {
        rect = element.data.rect;
        useParentRect = true;
        break;
      }
    }
    const normalizedRect = Util$1.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);
    const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
    const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;
    const popupLeft = normalizedRect[0] + parentWidth;
    const popupTop = normalizedRect[1];
    this.#position = [100 * (popupLeft - pageX) / pageWidth, 100 * (popupTop - pageY) / pageHeight];
    const {
      style: style2
    } = this.#container;
    style2.left = `${this.#position[0]}%`;
    style2.top = `${this.#position[1]}%`;
  }
  #toggle() {
    this.#pinned = !this.#pinned;
    if (this.#pinned) {
      this.#show();
      this.#container.addEventListener("click", this.#boundToggle);
      this.#container.addEventListener("keydown", this.#boundKeyDown);
    } else {
      this.#hide();
      this.#container.removeEventListener("click", this.#boundToggle);
      this.#container.removeEventListener("keydown", this.#boundKeyDown);
    }
  }
  #show() {
    if (!this.#popup) {
      this.render();
    }
    if (!this.isVisible) {
      this.#setPosition();
      this.#container.hidden = false;
      this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1e3;
    } else if (this.#pinned) {
      this.#container.classList.add("focused");
    }
  }
  #hide() {
    this.#container.classList.remove("focused");
    if (this.#pinned || !this.isVisible) {
      return;
    }
    this.#container.hidden = true;
    this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1e3;
  }
  forceHide() {
    this.#wasVisible = this.isVisible;
    if (!this.#wasVisible) {
      return;
    }
    this.#container.hidden = true;
  }
  maybeShow() {
    if (!this.#wasVisible) {
      return;
    }
    if (!this.#popup) {
      this.#show();
    }
    this.#wasVisible = false;
    this.#container.hidden = false;
  }
  get isVisible() {
    return this.#container.hidden === false;
  }
}
class FreeTextAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.textContent = parameters.data.textContent;
    this.textPosition = parameters.data.textPosition;
    this.annotationEditorType = AnnotationEditorType$1.FREETEXT;
  }
  render() {
    this.container.classList.add("freeTextAnnotation");
    if (this.textContent) {
      const content = document.createElement("div");
      content.classList.add("annotationTextContent");
      content.setAttribute("role", "comment");
      for (const line2 of this.textContent) {
        const lineSpan = document.createElement("span");
        lineSpan.textContent = line2;
        content.append(lineSpan);
      }
      this.container.append(content);
    }
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this._editOnDoubleClick();
    return this.container;
  }
  get _isEditable() {
    return this.data.hasOwnCanvas;
  }
}
class LineAnnotationElement extends AnnotationElement {
  #line = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("lineAnnotation");
    const data2 = this.data;
    const {
      width,
      height
    } = getRectDims(data2.rect);
    const svg = this.svgFactory.create(width, height, true);
    const line2 = this.#line = this.svgFactory.createElement("svg:line");
    line2.setAttribute("x1", data2.rect[2] - data2.lineCoordinates[0]);
    line2.setAttribute("y1", data2.rect[3] - data2.lineCoordinates[1]);
    line2.setAttribute("x2", data2.rect[2] - data2.lineCoordinates[2]);
    line2.setAttribute("y2", data2.rect[3] - data2.lineCoordinates[3]);
    line2.setAttribute("stroke-width", data2.borderStyle.width || 1);
    line2.setAttribute("stroke", "transparent");
    line2.setAttribute("fill", "transparent");
    svg.append(line2);
    this.container.append(svg);
    if (!data2.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#line;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class SquareAnnotationElement extends AnnotationElement {
  #square = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("squareAnnotation");
    const data2 = this.data;
    const {
      width,
      height
    } = getRectDims(data2.rect);
    const svg = this.svgFactory.create(width, height, true);
    const borderWidth = data2.borderStyle.width;
    const square = this.#square = this.svgFactory.createElement("svg:rect");
    square.setAttribute("x", borderWidth / 2);
    square.setAttribute("y", borderWidth / 2);
    square.setAttribute("width", width - borderWidth);
    square.setAttribute("height", height - borderWidth);
    square.setAttribute("stroke-width", borderWidth || 1);
    square.setAttribute("stroke", "transparent");
    square.setAttribute("fill", "transparent");
    svg.append(square);
    this.container.append(svg);
    if (!data2.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#square;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class CircleAnnotationElement extends AnnotationElement {
  #circle = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("circleAnnotation");
    const data2 = this.data;
    const {
      width,
      height
    } = getRectDims(data2.rect);
    const svg = this.svgFactory.create(width, height, true);
    const borderWidth = data2.borderStyle.width;
    const circle = this.#circle = this.svgFactory.createElement("svg:ellipse");
    circle.setAttribute("cx", width / 2);
    circle.setAttribute("cy", height / 2);
    circle.setAttribute("rx", width / 2 - borderWidth / 2);
    circle.setAttribute("ry", height / 2 - borderWidth / 2);
    circle.setAttribute("stroke-width", borderWidth || 1);
    circle.setAttribute("stroke", "transparent");
    circle.setAttribute("fill", "transparent");
    svg.append(circle);
    this.container.append(svg);
    if (!data2.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#circle;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class PolylineAnnotationElement extends AnnotationElement {
  #polyline = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.containerClassName = "polylineAnnotation";
    this.svgElementName = "svg:polyline";
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const data2 = this.data;
    const {
      width,
      height
    } = getRectDims(data2.rect);
    const svg = this.svgFactory.create(width, height, true);
    let points = [];
    for (const coordinate of data2.vertices) {
      const x2 = coordinate.x - data2.rect[0];
      const y2 = data2.rect[3] - coordinate.y;
      points.push(x2 + "," + y2);
    }
    points = points.join(" ");
    const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);
    polyline.setAttribute("points", points);
    polyline.setAttribute("stroke-width", data2.borderStyle.width || 1);
    polyline.setAttribute("stroke", "transparent");
    polyline.setAttribute("fill", "transparent");
    svg.append(polyline);
    this.container.append(svg);
    if (!data2.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#polyline;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class PolygonAnnotationElement extends PolylineAnnotationElement {
  constructor(parameters) {
    super(parameters);
    this.containerClassName = "polygonAnnotation";
    this.svgElementName = "svg:polygon";
  }
}
class CaretAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("caretAnnotation");
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
}
class InkAnnotationElement extends AnnotationElement {
  #polylines = [];
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
    this.containerClassName = "inkAnnotation";
    this.svgElementName = "svg:polyline";
    this.annotationEditorType = AnnotationEditorType$1.INK;
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const data2 = this.data;
    const {
      width,
      height
    } = getRectDims(data2.rect);
    const svg = this.svgFactory.create(width, height, true);
    for (const inkList of data2.inkLists) {
      let points = [];
      for (const coordinate of inkList) {
        const x2 = coordinate.x - data2.rect[0];
        const y2 = data2.rect[3] - coordinate.y;
        points.push(`${x2},${y2}`);
      }
      points = points.join(" ");
      const polyline = this.svgFactory.createElement(this.svgElementName);
      this.#polylines.push(polyline);
      polyline.setAttribute("points", points);
      polyline.setAttribute("stroke-width", data2.borderStyle.width || 1);
      polyline.setAttribute("stroke", "transparent");
      polyline.setAttribute("fill", "transparent");
      if (!data2.popupRef && this.hasPopupData) {
        this._createPopup();
      }
      svg.append(polyline);
    }
    this.container.append(svg);
    return this.container;
  }
  getElementsToTriggerPopup() {
    return this.#polylines;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
class HighlightAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("highlightAnnotation");
    return this.container;
  }
}
class UnderlineAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("underlineAnnotation");
    return this.container;
  }
}
class SquigglyAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("squigglyAnnotation");
    return this.container;
  }
}
class StrikeOutAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }
  render() {
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    this.container.classList.add("strikeoutAnnotation");
    return this.container;
  }
}
class StampAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: true
    });
  }
  render() {
    this.container.classList.add("stampAnnotation");
    if (!this.data.popupRef && this.hasPopupData) {
      this._createPopup();
    }
    return this.container;
  }
}
class FileAttachmentAnnotationElement extends AnnotationElement {
  #trigger = null;
  constructor(parameters) {
    super(parameters, {
      isRenderable: true
    });
    const {
      file: file2
    } = this.data;
    this.filename = file2.filename;
    this.content = file2.content;
    this.linkService.eventBus?.dispatch("fileattachmentannotation", {
      source: this,
      ...file2
    });
  }
  render() {
    this.container.classList.add("fileAttachmentAnnotation");
    const {
      container,
      data: data2
    } = this;
    let trigger2;
    if (data2.hasAppearance || data2.fillAlpha === 0) {
      trigger2 = document.createElement("div");
    } else {
      trigger2 = document.createElement("img");
      trigger2.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data2.name) ? "paperclip" : "pushpin"}.svg`;
      if (data2.fillAlpha && data2.fillAlpha < 1) {
        trigger2.style = `filter: opacity(${Math.round(data2.fillAlpha * 100)}%);`;
      }
    }
    trigger2.addEventListener("dblclick", this.#download.bind(this));
    this.#trigger = trigger2;
    const {
      isMac
    } = util_FeatureTest.platform;
    container.addEventListener("keydown", (evt) => {
      if (evt.key === "Enter" && (isMac ? evt.metaKey : evt.ctrlKey)) {
        this.#download();
      }
    });
    if (!data2.popupRef && this.hasPopupData) {
      this._createPopup();
    } else {
      trigger2.classList.add("popupTriggerArea");
    }
    container.append(trigger2);
    return container;
  }
  getElementsToTriggerPopup() {
    return this.#trigger;
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
  #download() {
    this.downloadManager?.openOrDownloadData(this.content, this.filename);
  }
}
let AnnotationLayer$1 = class AnnotationLayer {
  #accessibilityManager = null;
  #annotationCanvasMap = null;
  #editableAnnotations = /* @__PURE__ */ new Map();
  constructor({
    div,
    accessibilityManager,
    annotationCanvasMap,
    annotationEditorUIManager,
    page,
    viewport
  }) {
    this.div = div;
    this.#accessibilityManager = accessibilityManager;
    this.#annotationCanvasMap = annotationCanvasMap;
    this.page = page;
    this.viewport = viewport;
    this.zIndex = 0;
    this._annotationEditorUIManager = annotationEditorUIManager;
  }
  #appendElement(element, id2) {
    const contentElement = element.firstChild || element;
    contentElement.id = `${AnnotationPrefix}${id2}`;
    this.div.append(element);
    this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);
  }
  async render(params) {
    const {
      annotations
    } = params;
    const layer = this.div;
    setLayerDimensions$1(layer, this.viewport);
    const popupToElements = /* @__PURE__ */ new Map();
    const elementParams = {
      data: null,
      layer,
      linkService: params.linkService,
      downloadManager: params.downloadManager,
      imageResourcesPath: params.imageResourcesPath || "",
      renderForms: params.renderForms !== false,
      svgFactory: new DOMSVGFactory$1(),
      annotationStorage: params.annotationStorage || new AnnotationStorage(),
      enableScripting: params.enableScripting === true,
      hasJSActions: params.hasJSActions,
      fieldObjects: params.fieldObjects,
      parent: this,
      elements: null
    };
    for (const data2 of annotations) {
      if (data2.noHTML) {
        continue;
      }
      const isPopupAnnotation = data2.annotationType === AnnotationType.POPUP;
      if (!isPopupAnnotation) {
        const {
          width,
          height
        } = getRectDims(data2.rect);
        if (width <= 0 || height <= 0) {
          continue;
        }
      } else {
        const elements = popupToElements.get(data2.id);
        if (!elements) {
          continue;
        }
        elementParams.elements = elements;
      }
      elementParams.data = data2;
      const element = AnnotationElementFactory.create(elementParams);
      if (!element.isRenderable) {
        continue;
      }
      if (!isPopupAnnotation && data2.popupRef) {
        const elements = popupToElements.get(data2.popupRef);
        if (!elements) {
          popupToElements.set(data2.popupRef, [element]);
        } else {
          elements.push(element);
        }
      }
      const rendered = element.render();
      if (data2.hidden) {
        rendered.style.visibility = "hidden";
      }
      this.#appendElement(rendered, data2.id);
      if (element.annotationEditorType > 0) {
        this.#editableAnnotations.set(element.data.id, element);
        this._annotationEditorUIManager?.renderAnnotationElement(element);
      }
    }
    this.#setAnnotationCanvasMap();
  }
  update({
    viewport
  }) {
    const layer = this.div;
    this.viewport = viewport;
    setLayerDimensions$1(layer, {
      rotation: viewport.rotation
    });
    this.#setAnnotationCanvasMap();
    layer.hidden = false;
  }
  #setAnnotationCanvasMap() {
    if (!this.#annotationCanvasMap) {
      return;
    }
    const layer = this.div;
    for (const [id2, canvas] of this.#annotationCanvasMap) {
      const element = layer.querySelector(`[data-annotation-id="${id2}"]`);
      if (!element) {
        continue;
      }
      canvas.className = "annotationContent";
      const {
        firstChild
      } = element;
      if (!firstChild) {
        element.append(canvas);
      } else if (firstChild.nodeName === "CANVAS") {
        firstChild.replaceWith(canvas);
      } else if (!firstChild.classList.contains("annotationContent")) {
        firstChild.before(canvas);
      } else {
        firstChild.after(canvas);
      }
    }
    this.#annotationCanvasMap.clear();
  }
  getEditableAnnotations() {
    return Array.from(this.#editableAnnotations.values());
  }
  getEditableAnnotation(id2) {
    return this.#editableAnnotations.get(id2);
  }
};
const EOL_PATTERN = /\r\n?|\n/g;
class FreeTextEditor extends AnnotationEditor {
  #boundEditorDivBlur = this.editorDivBlur.bind(this);
  #boundEditorDivFocus = this.editorDivFocus.bind(this);
  #boundEditorDivInput = this.editorDivInput.bind(this);
  #boundEditorDivKeydown = this.editorDivKeydown.bind(this);
  #boundEditorDivPaste = this.editorDivPaste.bind(this);
  #color;
  #content = "";
  #editorDivId = `${this.id}-editor`;
  #fontSize;
  #initialData = null;
  static _freeTextDefaultContent = "";
  static _internalPadding = 0;
  static _defaultColor = null;
  static _defaultFontSize = 10;
  static get _keyboardManager() {
    const proto = FreeTextEditor.prototype;
    const arrowChecker = (self2) => self2.isEmpty();
    const small = AnnotationEditorUIManager$1.TRANSLATE_SMALL;
    const big = AnnotationEditorUIManager$1.TRANSLATE_BIG;
    return shadow$1(this, "_keyboardManager", new KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], proto.commitOrRemove, {
      bubbles: true
    }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], proto.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], proto._translateEmpty, {
      args: [-small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto._translateEmpty, {
      args: [-big, 0],
      checker: arrowChecker
    }], [["ArrowRight", "mac+ArrowRight"], proto._translateEmpty, {
      args: [small, 0],
      checker: arrowChecker
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto._translateEmpty, {
      args: [big, 0],
      checker: arrowChecker
    }], [["ArrowUp", "mac+ArrowUp"], proto._translateEmpty, {
      args: [0, -small],
      checker: arrowChecker
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto._translateEmpty, {
      args: [0, -big],
      checker: arrowChecker
    }], [["ArrowDown", "mac+ArrowDown"], proto._translateEmpty, {
      args: [0, small],
      checker: arrowChecker
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto._translateEmpty, {
      args: [0, big],
      checker: arrowChecker
    }]]));
  }
  static _type = "freetext";
  static _editorType = AnnotationEditorType$1.FREETEXT;
  constructor(params) {
    super({
      ...params,
      name: "freeTextEditor"
    });
    this.#color = params.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;
    this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager, {
      strings: ["pdfjs-free-text-default-content"]
    });
    const style2 = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(style2.getPropertyValue("--freetext-padding"));
  }
  static updateDefaultParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType$1.FREETEXT_SIZE:
        FreeTextEditor._defaultFontSize = value;
        break;
      case AnnotationEditorParamsType$1.FREETEXT_COLOR:
        FreeTextEditor._defaultColor = value;
        break;
    }
  }
  updateParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType$1.FREETEXT_SIZE:
        this.#updateFontSize(value);
        break;
      case AnnotationEditorParamsType$1.FREETEXT_COLOR:
        this.#updateColor(value);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[AnnotationEditorParamsType$1.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [AnnotationEditorParamsType$1.FREETEXT_COLOR, FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor]];
  }
  get propertiesToUpdate() {
    return [[AnnotationEditorParamsType$1.FREETEXT_SIZE, this.#fontSize], [AnnotationEditorParamsType$1.FREETEXT_COLOR, this.#color]];
  }
  #updateFontSize(fontSize) {
    const setFontsize = (size2) => {
      this.editorDiv.style.fontSize = `calc(${size2}px * var(--scale-factor))`;
      this.translate(0, -(size2 - this.#fontSize) * this.parentScale);
      this.#fontSize = size2;
      this.#setEditorDimensions();
    };
    const savedFontsize = this.#fontSize;
    this.addCommands({
      cmd: setFontsize.bind(this, fontSize),
      undo: setFontsize.bind(this, savedFontsize),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType$1.FREETEXT_SIZE,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  #updateColor(color) {
    const setColor = (col) => {
      this.#color = this.editorDiv.style.color = col;
    };
    const savedColor = this.#color;
    this.addCommands({
      cmd: setColor.bind(this, color),
      undo: setColor.bind(this, savedColor),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType$1.FREETEXT_COLOR,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  _translateEmpty(x2, y2) {
    this._uiManager.translateSelectedEditors(x2, y2, true);
  }
  getInitialTranslation() {
    const scale = this.parentScale;
    return [-FreeTextEditor._internalPadding * scale, -(FreeTextEditor._internalPadding + this.#fontSize) * scale];
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  enableEditMode() {
    if (this.isInEditMode()) {
      return;
    }
    this.parent.setEditingState(false);
    this.parent.updateToolbar(AnnotationEditorType$1.FREETEXT);
    super.enableEditMode();
    this.overlayDiv.classList.remove("enabled");
    this.editorDiv.contentEditable = true;
    this._isDraggable = false;
    this.div.removeAttribute("aria-activedescendant");
    this.editorDiv.addEventListener("keydown", this.#boundEditorDivKeydown);
    this.editorDiv.addEventListener("focus", this.#boundEditorDivFocus);
    this.editorDiv.addEventListener("blur", this.#boundEditorDivBlur);
    this.editorDiv.addEventListener("input", this.#boundEditorDivInput);
    this.editorDiv.addEventListener("paste", this.#boundEditorDivPaste);
  }
  disableEditMode() {
    if (!this.isInEditMode()) {
      return;
    }
    this.parent.setEditingState(true);
    super.disableEditMode();
    this.overlayDiv.classList.add("enabled");
    this.editorDiv.contentEditable = false;
    this.div.setAttribute("aria-activedescendant", this.#editorDivId);
    this._isDraggable = true;
    this.editorDiv.removeEventListener("keydown", this.#boundEditorDivKeydown);
    this.editorDiv.removeEventListener("focus", this.#boundEditorDivFocus);
    this.editorDiv.removeEventListener("blur", this.#boundEditorDivBlur);
    this.editorDiv.removeEventListener("input", this.#boundEditorDivInput);
    this.editorDiv.removeEventListener("paste", this.#boundEditorDivPaste);
    this.div.focus({
      preventScroll: true
    });
    this.isEditing = false;
    this.parent.div.classList.add("freetextEditing");
  }
  focusin(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    super.focusin(event);
    if (event.target !== this.editorDiv) {
      this.editorDiv.focus();
    }
  }
  onceAdded() {
    if (this.width) {
      return;
    }
    this.enableEditMode();
    this.editorDiv.focus();
    if (this._initialOptions?.isCentered) {
      this.center();
    }
    this._initialOptions = null;
  }
  isEmpty() {
    return !this.editorDiv || this.editorDiv.innerText.trim() === "";
  }
  remove() {
    this.isEditing = false;
    if (this.parent) {
      this.parent.setEditingState(true);
      this.parent.div.classList.add("freetextEditing");
    }
    super.remove();
  }
  #extractText() {
    const buffer = [];
    this.editorDiv.normalize();
    for (const child of this.editorDiv.childNodes) {
      buffer.push(FreeTextEditor.#getNodeContent(child));
    }
    return buffer.join("\n");
  }
  #setEditorDimensions() {
    const [parentWidth, parentHeight] = this.parentDimensions;
    let rect;
    if (this.isAttachedToDOM) {
      rect = this.div.getBoundingClientRect();
    } else {
      const {
        currentLayer,
        div
      } = this;
      const savedDisplay = div.style.display;
      const savedVisibility = div.classList.contains("hidden");
      div.classList.remove("hidden");
      div.style.display = "hidden";
      currentLayer.div.append(this.div);
      rect = div.getBoundingClientRect();
      div.remove();
      div.style.display = savedDisplay;
      div.classList.toggle("hidden", savedVisibility);
    }
    if (this.rotation % 180 === this.parentRotation % 180) {
      this.width = rect.width / parentWidth;
      this.height = rect.height / parentHeight;
    } else {
      this.width = rect.height / parentWidth;
      this.height = rect.width / parentHeight;
    }
    this.fixAndSetPosition();
  }
  commit() {
    if (!this.isInEditMode()) {
      return;
    }
    super.commit();
    this.disableEditMode();
    const savedText = this.#content;
    const newText = this.#content = this.#extractText().trimEnd();
    if (savedText === newText) {
      return;
    }
    const setText = (text) => {
      this.#content = text;
      if (!text) {
        this.remove();
        return;
      }
      this.#setContent();
      this._uiManager.rebuild(this);
      this.#setEditorDimensions();
    };
    this.addCommands({
      cmd: () => {
        setText(newText);
      },
      undo: () => {
        setText(savedText);
      },
      mustExec: false
    });
    this.#setEditorDimensions();
  }
  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }
  enterInEditMode() {
    this.enableEditMode();
    this.editorDiv.focus();
  }
  dblclick(event) {
    this.enterInEditMode();
  }
  keydown(event) {
    if (event.target === this.div && event.key === "Enter") {
      this.enterInEditMode();
      event.preventDefault();
    }
  }
  editorDivKeydown(event) {
    FreeTextEditor._keyboardManager.exec(this, event);
  }
  editorDivFocus(event) {
    this.isEditing = true;
  }
  editorDivBlur(event) {
    this.isEditing = false;
  }
  editorDivInput(event) {
    this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
  }
  disableEditing() {
    this.editorDiv.setAttribute("role", "comment");
    this.editorDiv.removeAttribute("aria-multiline");
  }
  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox");
    this.editorDiv.setAttribute("aria-multiline", true);
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this.width) {
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    this.editorDiv = document.createElement("div");
    this.editorDiv.className = "internal";
    this.editorDiv.setAttribute("id", this.#editorDivId);
    this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text");
    this.enableEditing();
    AnnotationEditor._l10nPromise.get("pdfjs-free-text-default-content").then((msg) => this.editorDiv?.setAttribute("default-content", msg));
    this.editorDiv.contentEditable = true;
    const {
      style: style2
    } = this.editorDiv;
    style2.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;
    style2.color = this.#color;
    this.div.append(this.editorDiv);
    this.overlayDiv = document.createElement("div");
    this.overlayDiv.classList.add("overlay", "enabled");
    this.div.append(this.overlayDiv);
    bindEvents(this, this.div, ["dblclick", "keydown"]);
    if (this.width) {
      const [parentWidth, parentHeight] = this.parentDimensions;
      if (this.annotationElementId) {
        const {
          position
        } = this.#initialData;
        let [tx, ty] = this.getInitialTranslation();
        [tx, ty] = this.pageTranslationToScreen(tx, ty);
        const [pageWidth, pageHeight] = this.pageDimensions;
        const [pageX, pageY] = this.pageTranslation;
        let posX, posY;
        switch (this.rotation) {
          case 0:
            posX = baseX + (position[0] - pageX) / pageWidth;
            posY = baseY + this.height - (position[1] - pageY) / pageHeight;
            break;
          case 90:
            posX = baseX + (position[0] - pageX) / pageWidth;
            posY = baseY - (position[1] - pageY) / pageHeight;
            [tx, ty] = [ty, -tx];
            break;
          case 180:
            posX = baseX - this.width + (position[0] - pageX) / pageWidth;
            posY = baseY - (position[1] - pageY) / pageHeight;
            [tx, ty] = [-tx, -ty];
            break;
          case 270:
            posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;
            posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;
            [tx, ty] = [-ty, tx];
            break;
        }
        this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);
      } else {
        this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
      }
      this.#setContent();
      this._isDraggable = true;
      this.editorDiv.contentEditable = false;
    } else {
      this._isDraggable = false;
      this.editorDiv.contentEditable = true;
    }
    return this.div;
  }
  static #getNodeContent(node) {
    return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, "");
  }
  editorDivPaste(event) {
    const clipboardData = event.clipboardData || window.clipboardData;
    const {
      types
    } = clipboardData;
    if (types.length === 1 && types[0] === "text/plain") {
      return;
    }
    event.preventDefault();
    const paste = FreeTextEditor.#deserializeContent(clipboardData.getData("text") || "").replaceAll(EOL_PATTERN, "\n");
    if (!paste) {
      return;
    }
    const selection = window.getSelection();
    if (!selection.rangeCount) {
      return;
    }
    this.editorDiv.normalize();
    selection.deleteFromDocument();
    const range = selection.getRangeAt(0);
    if (!paste.includes("\n")) {
      range.insertNode(document.createTextNode(paste));
      this.editorDiv.normalize();
      selection.collapseToStart();
      return;
    }
    const {
      startContainer,
      startOffset
    } = range;
    const bufferBefore = [];
    const bufferAfter = [];
    if (startContainer.nodeType === Node.TEXT_NODE) {
      const parent = startContainer.parentElement;
      bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, ""));
      if (parent !== this.editorDiv) {
        let buffer = bufferBefore;
        for (const child of this.editorDiv.childNodes) {
          if (child === parent) {
            buffer = bufferAfter;
            continue;
          }
          buffer.push(FreeTextEditor.#getNodeContent(child));
        }
      }
      bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, ""));
    } else if (startContainer === this.editorDiv) {
      let buffer = bufferBefore;
      let i2 = 0;
      for (const child of this.editorDiv.childNodes) {
        if (i2++ === startOffset) {
          buffer = bufferAfter;
        }
        buffer.push(FreeTextEditor.#getNodeContent(child));
      }
    }
    this.#content = `${bufferBefore.join("\n")}${paste}${bufferAfter.join("\n")}`;
    this.#setContent();
    const newRange = new Range();
    let beforeLength = bufferBefore.reduce((acc, line2) => acc + line2.length, 0);
    for (const {
      firstChild
    } of this.editorDiv.childNodes) {
      if (firstChild.nodeType === Node.TEXT_NODE) {
        const length = firstChild.nodeValue.length;
        if (beforeLength <= length) {
          newRange.setStart(firstChild, beforeLength);
          newRange.setEnd(firstChild, beforeLength);
          break;
        }
        beforeLength -= length;
      }
    }
    selection.removeAllRanges();
    selection.addRange(newRange);
  }
  #setContent() {
    this.editorDiv.replaceChildren();
    if (!this.#content) {
      return;
    }
    for (const line2 of this.#content.split("\n")) {
      const div = document.createElement("div");
      div.append(line2 ? document.createTextNode(line2) : document.createElement("br"));
      this.editorDiv.append(div);
    }
  }
  #serializeContent() {
    return this.#content.replaceAll("", " ");
  }
  static #deserializeContent(content) {
    return content.replaceAll(" ", "");
  }
  get contentDiv() {
    return this.editorDiv;
  }
  static deserialize(data2, parent, uiManager) {
    let initialData = null;
    if (data2 instanceof FreeTextAnnotationElement) {
      const {
        data: {
          defaultAppearanceData: {
            fontSize,
            fontColor
          },
          rect,
          rotation,
          id: id2
        },
        textContent,
        textPosition,
        parent: {
          page: {
            pageNumber
          }
        }
      } = data2;
      if (!textContent || textContent.length === 0) {
        return null;
      }
      initialData = data2 = {
        annotationType: AnnotationEditorType$1.FREETEXT,
        color: Array.from(fontColor),
        fontSize,
        value: textContent.join("\n"),
        position: textPosition,
        pageIndex: pageNumber - 1,
        rect: rect.slice(0),
        rotation,
        id: id2,
        deleted: false
      };
    }
    const editor = super.deserialize(data2, parent, uiManager);
    editor.#fontSize = data2.fontSize;
    editor.#color = Util$1.makeHexColor(...data2.color);
    editor.#content = FreeTextEditor.#deserializeContent(data2.value);
    editor.annotationElementId = data2.id || null;
    editor.#initialData = initialData;
    return editor;
  }
  serialize(isForCopying = false) {
    if (this.isEmpty()) {
      return null;
    }
    if (this.deleted) {
      return {
        pageIndex: this.pageIndex,
        id: this.annotationElementId,
        deleted: true
      };
    }
    const padding = FreeTextEditor._internalPadding * this.parentScale;
    const rect = this.getRect(padding, padding);
    const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);
    const serialized = {
      annotationType: AnnotationEditorType$1.FREETEXT,
      color,
      fontSize: this.#fontSize,
      value: this.#serializeContent(),
      pageIndex: this.pageIndex,
      rect,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
    if (isForCopying) {
      return serialized;
    }
    if (this.annotationElementId && !this.#hasElementChanged(serialized)) {
      return null;
    }
    serialized.id = this.annotationElementId;
    return serialized;
  }
  #hasElementChanged(serialized) {
    const {
      value,
      fontSize,
      color,
      pageIndex
    } = this.#initialData;
    return this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i2) => c !== color[i2]) || serialized.pageIndex !== pageIndex;
  }
  renderAnnotationElement(annotation) {
    const content = super.renderAnnotationElement(annotation);
    if (this.deleted) {
      return content;
    }
    const {
      style: style2
    } = content;
    style2.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;
    style2.color = this.#color;
    content.replaceChildren();
    for (const line2 of this.#content.split("\n")) {
      const div = document.createElement("div");
      div.append(line2 ? document.createTextNode(line2) : document.createElement("br"));
      content.append(div);
    }
    const padding = FreeTextEditor._internalPadding * this.parentScale;
    annotation.updateEdited({
      rect: this.getRect(padding, padding),
      popupContent: this.#content
    });
    return content;
  }
  resetAnnotationElement(annotation) {
    super.resetAnnotationElement(annotation);
    annotation.resetEdited();
  }
}
let Outliner$1 = class Outliner {
  #box;
  #verticalEdges = [];
  #intervals = [];
  constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true) {
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    const NUMBER_OF_DIGITS = 4;
    const EPSILON = 10 ** -NUMBER_OF_DIGITS;
    for (const {
      x: x2,
      y: y2,
      width,
      height
    } of boxes) {
      const x1 = Math.floor((x2 - borderWidth) / EPSILON) * EPSILON;
      const x22 = Math.ceil((x2 + width + borderWidth) / EPSILON) * EPSILON;
      const y1 = Math.floor((y2 - borderWidth) / EPSILON) * EPSILON;
      const y22 = Math.ceil((y2 + height + borderWidth) / EPSILON) * EPSILON;
      const left = [x1, y1, y22, true];
      const right = [x22, y1, y22, false];
      this.#verticalEdges.push(left, right);
      minX = Math.min(minX, x1);
      maxX = Math.max(maxX, x22);
      minY = Math.min(minY, y1);
      maxY = Math.max(maxY, y22);
    }
    const bboxWidth = maxX - minX + 2 * innerMargin;
    const bboxHeight = maxY - minY + 2 * innerMargin;
    const shiftedMinX = minX - innerMargin;
    const shiftedMinY = minY - innerMargin;
    const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);
    const lastPoint = [lastEdge[0], lastEdge[2]];
    for (const edge of this.#verticalEdges) {
      const [x2, y1, y2] = edge;
      edge[0] = (x2 - shiftedMinX) / bboxWidth;
      edge[1] = (y1 - shiftedMinY) / bboxHeight;
      edge[2] = (y2 - shiftedMinY) / bboxHeight;
    }
    this.#box = {
      x: shiftedMinX,
      y: shiftedMinY,
      width: bboxWidth,
      height: bboxHeight,
      lastPoint
    };
  }
  getOutlines() {
    this.#verticalEdges.sort((a2, b2) => a2[0] - b2[0] || a2[1] - b2[1] || a2[2] - b2[2]);
    const outlineVerticalEdges = [];
    for (const edge of this.#verticalEdges) {
      if (edge[3]) {
        outlineVerticalEdges.push(...this.#breakEdge(edge));
        this.#insert(edge);
      } else {
        this.#remove(edge);
        outlineVerticalEdges.push(...this.#breakEdge(edge));
      }
    }
    return this.#getOutlines(outlineVerticalEdges);
  }
  #getOutlines(outlineVerticalEdges) {
    const edges = [];
    const allEdges = /* @__PURE__ */ new Set();
    for (const edge of outlineVerticalEdges) {
      const [x2, y1, y2] = edge;
      edges.push([x2, y1, edge], [x2, y2, edge]);
    }
    edges.sort((a2, b2) => a2[1] - b2[1] || a2[0] - b2[0]);
    for (let i2 = 0, ii = edges.length; i2 < ii; i2 += 2) {
      const edge1 = edges[i2][2];
      const edge2 = edges[i2 + 1][2];
      edge1.push(edge2);
      edge2.push(edge1);
      allEdges.add(edge1);
      allEdges.add(edge2);
    }
    const outlines = [];
    let outline;
    while (allEdges.size > 0) {
      const edge = allEdges.values().next().value;
      let [x2, y1, y2, edge1, edge2] = edge;
      allEdges.delete(edge);
      let lastPointX = x2;
      let lastPointY = y1;
      outline = [x2, y2];
      outlines.push(outline);
      while (true) {
        let e2;
        if (allEdges.has(edge1)) {
          e2 = edge1;
        } else if (allEdges.has(edge2)) {
          e2 = edge2;
        } else {
          break;
        }
        allEdges.delete(e2);
        [x2, y1, y2, edge1, edge2] = e2;
        if (lastPointX !== x2) {
          outline.push(lastPointX, lastPointY, x2, lastPointY === y1 ? y1 : y2);
          lastPointX = x2;
        }
        lastPointY = lastPointY === y1 ? y2 : y1;
      }
      outline.push(lastPointX, lastPointY);
    }
    return new HighlightOutline(outlines, this.#box);
  }
  #binarySearch(y2) {
    const array = this.#intervals;
    let start = 0;
    let end = array.length - 1;
    while (start <= end) {
      const middle = start + end >> 1;
      const y1 = array[middle][0];
      if (y1 === y2) {
        return middle;
      }
      if (y1 < y2) {
        start = middle + 1;
      } else {
        end = middle - 1;
      }
    }
    return end + 1;
  }
  #insert([, y1, y2]) {
    const index = this.#binarySearch(y1);
    this.#intervals.splice(index, 0, [y1, y2]);
  }
  #remove([, y1, y2]) {
    const index = this.#binarySearch(y1);
    for (let i2 = index; i2 < this.#intervals.length; i2++) {
      const [start, end] = this.#intervals[i2];
      if (start !== y1) {
        break;
      }
      if (start === y1 && end === y2) {
        this.#intervals.splice(i2, 1);
        return;
      }
    }
    for (let i2 = index - 1; i2 >= 0; i2--) {
      const [start, end] = this.#intervals[i2];
      if (start !== y1) {
        break;
      }
      if (start === y1 && end === y2) {
        this.#intervals.splice(i2, 1);
        return;
      }
    }
  }
  #breakEdge(edge) {
    const [x2, y1, y2] = edge;
    const results = [[x2, y1, y2]];
    const index = this.#binarySearch(y2);
    for (let i2 = 0; i2 < index; i2++) {
      const [start, end] = this.#intervals[i2];
      for (let j = 0, jj = results.length; j < jj; j++) {
        const [, y3, y4] = results[j];
        if (end <= y3 || y4 <= start) {
          continue;
        }
        if (y3 >= start) {
          if (y4 > end) {
            results[j][1] = end;
          } else {
            if (jj === 1) {
              return [];
            }
            results.splice(j, 1);
            j--;
            jj--;
          }
          continue;
        }
        results[j][2] = start;
        if (y4 > end) {
          results.push([x2, end, y4]);
        }
      }
    }
    return results;
  }
};
class Outline {
  toSVGPath() {
    throw new Error("Abstract method `toSVGPath` must be implemented.");
  }
  get box() {
    throw new Error("Abstract getter `box` must be implemented.");
  }
  serialize(_bbox, _rotation) {
    throw new Error("Abstract method `serialize` must be implemented.");
  }
  get free() {
    return this instanceof FreeHighlightOutline;
  }
}
class HighlightOutline extends Outline {
  #box;
  #outlines;
  constructor(outlines, box) {
    super();
    this.#outlines = outlines;
    this.#box = box;
  }
  toSVGPath() {
    const buffer = [];
    for (const polygon of this.#outlines) {
      let [prevX, prevY] = polygon;
      buffer.push(`M${prevX} ${prevY}`);
      for (let i2 = 2; i2 < polygon.length; i2 += 2) {
        const x2 = polygon[i2];
        const y2 = polygon[i2 + 1];
        if (x2 === prevX) {
          buffer.push(`V${y2}`);
          prevY = y2;
        } else if (y2 === prevY) {
          buffer.push(`H${x2}`);
          prevX = x2;
        }
      }
      buffer.push("Z");
    }
    return buffer.join(" ");
  }
  serialize([blX, blY, trX, trY], _rotation) {
    const outlines = [];
    const width = trX - blX;
    const height = trY - blY;
    for (const outline of this.#outlines) {
      const points = new Array(outline.length);
      for (let i2 = 0; i2 < outline.length; i2 += 2) {
        points[i2] = blX + outline[i2] * width;
        points[i2 + 1] = trY - outline[i2 + 1] * height;
      }
      outlines.push(points);
    }
    return outlines;
  }
  get box() {
    return this.#box;
  }
}
class FreeOutliner {
  #box;
  #bottom = [];
  #innerMargin;
  #isLTR;
  #top = [];
  #last = new Float64Array(18);
  #lastX;
  #lastY;
  #min;
  #min_dist;
  #scaleFactor;
  #thickness;
  #points = [];
  static #MIN_DIST = 8;
  static #MIN_DIFF = 2;
  static #MIN = FreeOutliner.#MIN_DIST + FreeOutliner.#MIN_DIFF;
  constructor({
    x: x2,
    y: y2
  }, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
    this.#box = box;
    this.#thickness = thickness * scaleFactor;
    this.#isLTR = isLTR;
    this.#last.set([NaN, NaN, NaN, NaN, x2, y2], 6);
    this.#innerMargin = innerMargin;
    this.#min_dist = FreeOutliner.#MIN_DIST * scaleFactor;
    this.#min = FreeOutliner.#MIN * scaleFactor;
    this.#scaleFactor = scaleFactor;
    this.#points.push(x2, y2);
  }
  get free() {
    return true;
  }
  isEmpty() {
    return isNaN(this.#last[8]);
  }
  #getLastCoords() {
    const lastTop = this.#last.subarray(4, 6);
    const lastBottom = this.#last.subarray(16, 18);
    const [x2, y2, width, height] = this.#box;
    return [(this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x2) / width, (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y2) / height, (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x2) / width, (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y2) / height];
  }
  add({
    x: x2,
    y: y2
  }) {
    this.#lastX = x2;
    this.#lastY = y2;
    const [layerX, layerY, layerWidth, layerHeight] = this.#box;
    let [x1, y1, x22, y22] = this.#last.subarray(8, 12);
    const diffX = x2 - x22;
    const diffY = y2 - y22;
    const d = Math.hypot(diffX, diffY);
    if (d < this.#min) {
      return false;
    }
    const diffD = d - this.#min_dist;
    const K = diffD / d;
    const shiftX = K * diffX;
    const shiftY = K * diffY;
    let x0 = x1;
    let y0 = y1;
    x1 = x22;
    y1 = y22;
    x22 += shiftX;
    y22 += shiftY;
    this.#points?.push(x2, y2);
    const nX = -shiftY / diffD;
    const nY = shiftX / diffD;
    const thX = nX * this.#thickness;
    const thY = nY * this.#thickness;
    this.#last.set(this.#last.subarray(2, 8), 0);
    this.#last.set([x22 + thX, y22 + thY], 4);
    this.#last.set(this.#last.subarray(14, 18), 12);
    this.#last.set([x22 - thX, y22 - thY], 16);
    if (isNaN(this.#last[6])) {
      if (this.#top.length === 0) {
        this.#last.set([x1 + thX, y1 + thY], 2);
        this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);
        this.#last.set([x1 - thX, y1 - thY], 14);
        this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);
      }
      this.#last.set([x0, y0, x1, y1, x22, y22], 6);
      return !this.isEmpty();
    }
    this.#last.set([x0, y0, x1, y1, x22, y22], 6);
    const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));
    if (angle < Math.PI / 2) {
      [x1, y1, x22, y22] = this.#last.subarray(2, 6);
      this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x22) / 2 - layerX) / layerWidth, ((y1 + y22) / 2 - layerY) / layerHeight);
      [x1, y1, x0, y0] = this.#last.subarray(14, 18);
      this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);
      return true;
    }
    [x0, y0, x1, y1, x22, y22] = this.#last.subarray(0, 6);
    this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x22) / 6 - layerX) / layerWidth, ((5 * y1 + y22) / 6 - layerY) / layerHeight, ((x1 + x22) / 2 - layerX) / layerWidth, ((y1 + y22) / 2 - layerY) / layerHeight);
    [x22, y22, x1, y1, x0, y0] = this.#last.subarray(12, 18);
    this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x22) / 6 - layerX) / layerWidth, ((5 * y1 + y22) / 6 - layerY) / layerHeight, ((x1 + x22) / 2 - layerX) / layerWidth, ((y1 + y22) / 2 - layerY) / layerHeight);
    return true;
  }
  toSVGPath() {
    if (this.isEmpty()) {
      return "";
    }
    const top = this.#top;
    const bottom = this.#bottom;
    const lastTop = this.#last.subarray(4, 6);
    const lastBottom = this.#last.subarray(16, 18);
    const [x2, y2, width, height] = this.#box;
    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
    if (isNaN(this.#last[6]) && !this.isEmpty()) {
      return `M${(this.#last[2] - x2) / width} ${(this.#last[3] - y2) / height} L${(this.#last[4] - x2) / width} ${(this.#last[5] - y2) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x2) / width} ${(this.#last[17] - y2) / height} L${(this.#last[14] - x2) / width} ${(this.#last[15] - y2) / height} Z`;
    }
    const buffer = [];
    buffer.push(`M${top[4]} ${top[5]}`);
    for (let i2 = 6; i2 < top.length; i2 += 6) {
      if (isNaN(top[i2])) {
        buffer.push(`L${top[i2 + 4]} ${top[i2 + 5]}`);
      } else {
        buffer.push(`C${top[i2]} ${top[i2 + 1]} ${top[i2 + 2]} ${top[i2 + 3]} ${top[i2 + 4]} ${top[i2 + 5]}`);
      }
    }
    buffer.push(`L${(lastTop[0] - x2) / width} ${(lastTop[1] - y2) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x2) / width} ${(lastBottom[1] - y2) / height}`);
    for (let i2 = bottom.length - 6; i2 >= 6; i2 -= 6) {
      if (isNaN(bottom[i2])) {
        buffer.push(`L${bottom[i2 + 4]} ${bottom[i2 + 5]}`);
      } else {
        buffer.push(`C${bottom[i2]} ${bottom[i2 + 1]} ${bottom[i2 + 2]} ${bottom[i2 + 3]} ${bottom[i2 + 4]} ${bottom[i2 + 5]}`);
      }
    }
    buffer.push(`L${bottom[4]} ${bottom[5]} Z`);
    return buffer.join(" ");
  }
  getOutlines() {
    const top = this.#top;
    const bottom = this.#bottom;
    const last2 = this.#last;
    const lastTop = last2.subarray(4, 6);
    const lastBottom = last2.subarray(16, 18);
    const [layerX, layerY, layerWidth, layerHeight] = this.#box;
    const points = new Float64Array((this.#points?.length ?? 0) + 2);
    for (let i2 = 0, ii = points.length - 2; i2 < ii; i2 += 2) {
      points[i2] = (this.#points[i2] - layerX) / layerWidth;
      points[i2 + 1] = (this.#points[i2 + 1] - layerY) / layerHeight;
    }
    points[points.length - 2] = (this.#lastX - layerX) / layerWidth;
    points[points.length - 1] = (this.#lastY - layerY) / layerHeight;
    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
    if (isNaN(last2[6]) && !this.isEmpty()) {
      const outline2 = new Float64Array(36);
      outline2.set([NaN, NaN, NaN, NaN, (last2[2] - layerX) / layerWidth, (last2[3] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last2[4] - layerX) / layerWidth, (last2[5] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (last2[16] - layerX) / layerWidth, (last2[17] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last2[14] - layerX) / layerWidth, (last2[15] - layerY) / layerHeight], 0);
      return new FreeHighlightOutline(outline2, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);
    }
    const outline = new Float64Array(this.#top.length + 24 + this.#bottom.length);
    let N = top.length;
    for (let i2 = 0; i2 < N; i2 += 2) {
      if (isNaN(top[i2])) {
        outline[i2] = outline[i2 + 1] = NaN;
        continue;
      }
      outline[i2] = top[i2];
      outline[i2 + 1] = top[i2 + 1];
    }
    outline.set([NaN, NaN, NaN, NaN, (lastTop[0] - layerX) / layerWidth, (lastTop[1] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (lastBottom[0] - layerX) / layerWidth, (lastBottom[1] - layerY) / layerHeight], N);
    N += 24;
    for (let i2 = bottom.length - 6; i2 >= 6; i2 -= 6) {
      for (let j = 0; j < 6; j += 2) {
        if (isNaN(bottom[i2 + j])) {
          outline[N] = outline[N + 1] = NaN;
          N += 2;
          continue;
        }
        outline[N] = bottom[i2 + j];
        outline[N + 1] = bottom[i2 + j + 1];
        N += 2;
      }
    }
    outline.set([NaN, NaN, NaN, NaN, bottom[4], bottom[5]], N);
    return new FreeHighlightOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);
  }
}
class FreeHighlightOutline extends Outline {
  #box;
  #bbox = null;
  #innerMargin;
  #isLTR;
  #points;
  #scaleFactor;
  #outline;
  constructor(outline, points, box, scaleFactor, innerMargin, isLTR) {
    super();
    this.#outline = outline;
    this.#points = points;
    this.#box = box;
    this.#scaleFactor = scaleFactor;
    this.#innerMargin = innerMargin;
    this.#isLTR = isLTR;
    this.#computeMinMax(isLTR);
    const {
      x: x2,
      y: y2,
      width,
      height
    } = this.#bbox;
    for (let i2 = 0, ii = outline.length; i2 < ii; i2 += 2) {
      outline[i2] = (outline[i2] - x2) / width;
      outline[i2 + 1] = (outline[i2 + 1] - y2) / height;
    }
    for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
      points[i2] = (points[i2] - x2) / width;
      points[i2 + 1] = (points[i2 + 1] - y2) / height;
    }
  }
  toSVGPath() {
    const buffer = [`M${this.#outline[4]} ${this.#outline[5]}`];
    for (let i2 = 6, ii = this.#outline.length; i2 < ii; i2 += 6) {
      if (isNaN(this.#outline[i2])) {
        buffer.push(`L${this.#outline[i2 + 4]} ${this.#outline[i2 + 5]}`);
        continue;
      }
      buffer.push(`C${this.#outline[i2]} ${this.#outline[i2 + 1]} ${this.#outline[i2 + 2]} ${this.#outline[i2 + 3]} ${this.#outline[i2 + 4]} ${this.#outline[i2 + 5]}`);
    }
    buffer.push("Z");
    return buffer.join(" ");
  }
  serialize([blX, blY, trX, trY], rotation) {
    const width = trX - blX;
    const height = trY - blY;
    let outline;
    let points;
    switch (rotation) {
      case 0:
        outline = this.#rescale(this.#outline, blX, trY, width, -height);
        points = this.#rescale(this.#points, blX, trY, width, -height);
        break;
      case 90:
        outline = this.#rescaleAndSwap(this.#outline, blX, blY, width, height);
        points = this.#rescaleAndSwap(this.#points, blX, blY, width, height);
        break;
      case 180:
        outline = this.#rescale(this.#outline, trX, blY, -width, height);
        points = this.#rescale(this.#points, trX, blY, -width, height);
        break;
      case 270:
        outline = this.#rescaleAndSwap(this.#outline, trX, trY, -width, -height);
        points = this.#rescaleAndSwap(this.#points, trX, trY, -width, -height);
        break;
    }
    return {
      outline: Array.from(outline),
      points: [Array.from(points)]
    };
  }
  #rescale(src, tx, ty, sx, sy) {
    const dest = new Float64Array(src.length);
    for (let i2 = 0, ii = src.length; i2 < ii; i2 += 2) {
      dest[i2] = tx + src[i2] * sx;
      dest[i2 + 1] = ty + src[i2 + 1] * sy;
    }
    return dest;
  }
  #rescaleAndSwap(src, tx, ty, sx, sy) {
    const dest = new Float64Array(src.length);
    for (let i2 = 0, ii = src.length; i2 < ii; i2 += 2) {
      dest[i2] = tx + src[i2 + 1] * sx;
      dest[i2 + 1] = ty + src[i2] * sy;
    }
    return dest;
  }
  #computeMinMax(isLTR) {
    const outline = this.#outline;
    let lastX = outline[4];
    let lastY = outline[5];
    let minX = lastX;
    let minY = lastY;
    let maxX = lastX;
    let maxY = lastY;
    let lastPointX = lastX;
    let lastPointY = lastY;
    const ltrCallback = isLTR ? Math.max : Math.min;
    for (let i2 = 6, ii = outline.length; i2 < ii; i2 += 6) {
      if (isNaN(outline[i2])) {
        minX = Math.min(minX, outline[i2 + 4]);
        minY = Math.min(minY, outline[i2 + 5]);
        maxX = Math.max(maxX, outline[i2 + 4]);
        maxY = Math.max(maxY, outline[i2 + 5]);
        if (lastPointY < outline[i2 + 5]) {
          lastPointX = outline[i2 + 4];
          lastPointY = outline[i2 + 5];
        } else if (lastPointY === outline[i2 + 5]) {
          lastPointX = ltrCallback(lastPointX, outline[i2 + 4]);
        }
      } else {
        const bbox = Util$1.bezierBoundingBox(lastX, lastY, ...outline.slice(i2, i2 + 6));
        minX = Math.min(minX, bbox[0]);
        minY = Math.min(minY, bbox[1]);
        maxX = Math.max(maxX, bbox[2]);
        maxY = Math.max(maxY, bbox[3]);
        if (lastPointY < bbox[3]) {
          lastPointX = bbox[2];
          lastPointY = bbox[3];
        } else if (lastPointY === bbox[3]) {
          lastPointX = ltrCallback(lastPointX, bbox[2]);
        }
      }
      lastX = outline[i2 + 4];
      lastY = outline[i2 + 5];
    }
    const x2 = minX - this.#innerMargin, y2 = minY - this.#innerMargin, width = maxX - minX + 2 * this.#innerMargin, height = maxY - minY + 2 * this.#innerMargin;
    this.#bbox = {
      x: x2,
      y: y2,
      width,
      height,
      lastPoint: [lastPointX, lastPointY]
    };
  }
  get box() {
    return this.#bbox;
  }
  getNewOutline(thickness, innerMargin) {
    const {
      x: x2,
      y: y2,
      width,
      height
    } = this.#bbox;
    const [layerX, layerY, layerWidth, layerHeight] = this.#box;
    const sx = width * layerWidth;
    const sy = height * layerHeight;
    const tx = x2 * layerWidth + layerX;
    const ty = y2 * layerHeight + layerY;
    const outliner = new FreeOutliner({
      x: this.#points[0] * sx + tx,
      y: this.#points[1] * sy + ty
    }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);
    for (let i2 = 2; i2 < this.#points.length; i2 += 2) {
      outliner.add({
        x: this.#points[i2] * sx + tx,
        y: this.#points[i2 + 1] * sy + ty
      });
    }
    return outliner.getOutlines();
  }
}
let ColorPicker$1 = class ColorPicker {
  #boundKeyDown = this.#keyDown.bind(this);
  #boundPointerDown = this.#pointerDown.bind(this);
  #button = null;
  #buttonSwatch = null;
  #defaultColor;
  #dropdown = null;
  #dropdownWasFromKeyboard = false;
  #isMainColorPicker = false;
  #editor = null;
  #eventBus;
  #uiManager = null;
  #type;
  static get _keyboardManager() {
    return shadow$1(this, "_keyboardManager", new KeyboardManager([[["Escape", "mac+Escape"], ColorPicker.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], ColorPicker.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], ColorPicker.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], ColorPicker.prototype._moveToPrevious], [["Home", "mac+Home"], ColorPicker.prototype._moveToBeginning], [["End", "mac+End"], ColorPicker.prototype._moveToEnd]]));
  }
  constructor({
    editor = null,
    uiManager = null
  }) {
    if (editor) {
      this.#isMainColorPicker = false;
      this.#type = AnnotationEditorParamsType$1.HIGHLIGHT_COLOR;
      this.#editor = editor;
    } else {
      this.#isMainColorPicker = true;
      this.#type = AnnotationEditorParamsType$1.HIGHLIGHT_DEFAULT_COLOR;
    }
    this.#uiManager = editor?._uiManager || uiManager;
    this.#eventBus = this.#uiManager._eventBus;
    this.#defaultColor = editor?.color || this.#uiManager?.highlightColors.values().next().value || "#FFFF98";
  }
  renderButton() {
    const button = this.#button = document.createElement("button");
    button.className = "colorPicker";
    button.tabIndex = "0";
    button.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button");
    button.setAttribute("aria-haspopup", true);
    button.addEventListener("click", this.#openDropdown.bind(this));
    button.addEventListener("keydown", this.#boundKeyDown);
    const swatch = this.#buttonSwatch = document.createElement("span");
    swatch.className = "swatch";
    swatch.setAttribute("aria-hidden", true);
    swatch.style.backgroundColor = this.#defaultColor;
    button.append(swatch);
    return button;
  }
  renderMainDropdown() {
    const dropdown = this.#dropdown = this.#getDropdownRoot();
    dropdown.setAttribute("aria-orientation", "horizontal");
    dropdown.setAttribute("aria-labelledby", "highlightColorPickerLabel");
    return dropdown;
  }
  #getDropdownRoot() {
    const div = document.createElement("div");
    div.addEventListener("contextmenu", noContextMenu$1);
    div.className = "dropdown";
    div.role = "listbox";
    div.setAttribute("aria-multiselectable", false);
    div.setAttribute("aria-orientation", "vertical");
    div.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
    for (const [name, color] of this.#uiManager.highlightColors) {
      const button = document.createElement("button");
      button.tabIndex = "0";
      button.role = "option";
      button.setAttribute("data-color", color);
      button.title = name;
      button.setAttribute("data-l10n-id", `pdfjs-editor-colorpicker-${name}`);
      const swatch = document.createElement("span");
      button.append(swatch);
      swatch.className = "swatch";
      swatch.style.backgroundColor = color;
      button.setAttribute("aria-selected", color === this.#defaultColor);
      button.addEventListener("click", this.#colorSelect.bind(this, color));
      div.append(button);
    }
    div.addEventListener("keydown", this.#boundKeyDown);
    return div;
  }
  #colorSelect(color, event) {
    event.stopPropagation();
    this.#eventBus.dispatch("switchannotationeditorparams", {
      source: this,
      type: this.#type,
      value: color
    });
  }
  _colorSelectFromKeyboard(event) {
    if (event.target === this.#button) {
      this.#openDropdown(event);
      return;
    }
    const color = event.target.getAttribute("data-color");
    if (!color) {
      return;
    }
    this.#colorSelect(color, event);
  }
  _moveToNext(event) {
    if (!this.#isDropdownVisible) {
      this.#openDropdown(event);
      return;
    }
    if (event.target === this.#button) {
      this.#dropdown.firstChild?.focus();
      return;
    }
    event.target.nextSibling?.focus();
  }
  _moveToPrevious(event) {
    if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {
      if (this.#isDropdownVisible) {
        this._hideDropdownFromKeyboard();
      }
      return;
    }
    if (!this.#isDropdownVisible) {
      this.#openDropdown(event);
    }
    event.target.previousSibling?.focus();
  }
  _moveToBeginning(event) {
    if (!this.#isDropdownVisible) {
      this.#openDropdown(event);
      return;
    }
    this.#dropdown.firstChild?.focus();
  }
  _moveToEnd(event) {
    if (!this.#isDropdownVisible) {
      this.#openDropdown(event);
      return;
    }
    this.#dropdown.lastChild?.focus();
  }
  #keyDown(event) {
    ColorPicker._keyboardManager.exec(this, event);
  }
  #openDropdown(event) {
    if (this.#isDropdownVisible) {
      this.hideDropdown();
      return;
    }
    this.#dropdownWasFromKeyboard = event.detail === 0;
    window.addEventListener("pointerdown", this.#boundPointerDown);
    if (this.#dropdown) {
      this.#dropdown.classList.remove("hidden");
      return;
    }
    const root = this.#dropdown = this.#getDropdownRoot();
    this.#button.append(root);
  }
  #pointerDown(event) {
    if (this.#dropdown?.contains(event.target)) {
      return;
    }
    this.hideDropdown();
  }
  hideDropdown() {
    this.#dropdown?.classList.add("hidden");
    window.removeEventListener("pointerdown", this.#boundPointerDown);
  }
  get #isDropdownVisible() {
    return this.#dropdown && !this.#dropdown.classList.contains("hidden");
  }
  _hideDropdownFromKeyboard() {
    if (this.#isMainColorPicker) {
      return;
    }
    if (!this.#isDropdownVisible) {
      this.#editor?.unselect();
      return;
    }
    this.hideDropdown();
    this.#button.focus({
      preventScroll: true,
      focusVisible: this.#dropdownWasFromKeyboard
    });
  }
  updateColor(color) {
    if (this.#buttonSwatch) {
      this.#buttonSwatch.style.backgroundColor = color;
    }
    if (!this.#dropdown) {
      return;
    }
    const i2 = this.#uiManager.highlightColors.values();
    for (const child of this.#dropdown.children) {
      child.setAttribute("aria-selected", i2.next().value === color);
    }
  }
  destroy() {
    this.#button?.remove();
    this.#button = null;
    this.#buttonSwatch = null;
    this.#dropdown?.remove();
    this.#dropdown = null;
  }
};
class HighlightEditor extends AnnotationEditor {
  #anchorNode = null;
  #anchorOffset = 0;
  #boxes;
  #clipPathId = null;
  #colorPicker = null;
  #focusOutlines = null;
  #focusNode = null;
  #focusOffset = 0;
  #highlightDiv = null;
  #highlightOutlines = null;
  #id = null;
  #isFreeHighlight = false;
  #boundKeydown = this.#keydown.bind(this);
  #lastPoint = null;
  #opacity;
  #outlineId = null;
  #text = "";
  #thickness;
  #methodOfCreation = "";
  static _defaultColor = null;
  static _defaultOpacity = 1;
  static _defaultThickness = 12;
  static _l10nPromise;
  static _type = "highlight";
  static _editorType = AnnotationEditorType$1.HIGHLIGHT;
  static _freeHighlightId = -1;
  static _freeHighlight = null;
  static _freeHighlightClipId = "";
  static get _keyboardManager() {
    const proto = HighlightEditor.prototype;
    return shadow$1(this, "_keyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], proto._moveCaret, {
      args: [0]
    }], [["ArrowRight", "mac+ArrowRight"], proto._moveCaret, {
      args: [1]
    }], [["ArrowUp", "mac+ArrowUp"], proto._moveCaret, {
      args: [2]
    }], [["ArrowDown", "mac+ArrowDown"], proto._moveCaret, {
      args: [3]
    }]]));
  }
  constructor(params) {
    super({
      ...params,
      name: "highlightEditor"
    });
    this.color = params.color || HighlightEditor._defaultColor;
    this.#thickness = params.thickness || HighlightEditor._defaultThickness;
    this.#opacity = params.opacity || HighlightEditor._defaultOpacity;
    this.#boxes = params.boxes || null;
    this.#methodOfCreation = params.methodOfCreation || "";
    this.#text = params.text || "";
    this._isDraggable = false;
    if (params.highlightId > -1) {
      this.#isFreeHighlight = true;
      this.#createFreeOutlines(params);
      this.#addToDrawLayer();
    } else {
      this.#anchorNode = params.anchorNode;
      this.#anchorOffset = params.anchorOffset;
      this.#focusNode = params.focusNode;
      this.#focusOffset = params.focusOffset;
      this.#createOutlines();
      this.#addToDrawLayer();
      this.rotate(this.rotation);
    }
  }
  get telemetryInitialData() {
    return {
      action: "added",
      type: this.#isFreeHighlight ? "free_highlight" : "highlight",
      color: this._uiManager.highlightColorNames.get(this.color),
      thickness: this.#thickness,
      methodOfCreation: this.#methodOfCreation
    };
  }
  get telemetryFinalData() {
    return {
      type: "highlight",
      color: this._uiManager.highlightColorNames.get(this.color)
    };
  }
  static computeTelemetryFinalData(data2) {
    return {
      numberOfColors: data2.get("color").size
    };
  }
  #createOutlines() {
    const outliner = new Outliner$1(this.#boxes, 1e-3);
    this.#highlightOutlines = outliner.getOutlines();
    ({
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    } = this.#highlightOutlines.box);
    const outlinerForOutline = new Outliner$1(this.#boxes, 25e-4, 1e-3, this._uiManager.direction === "ltr");
    this.#focusOutlines = outlinerForOutline.getOutlines();
    const {
      lastPoint
    } = this.#focusOutlines.box;
    this.#lastPoint = [(lastPoint[0] - this.x) / this.width, (lastPoint[1] - this.y) / this.height];
  }
  #createFreeOutlines({
    highlightOutlines,
    highlightId,
    clipPathId
  }) {
    this.#highlightOutlines = highlightOutlines;
    const extraThickness = 1.5;
    this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 25e-4);
    if (highlightId >= 0) {
      this.#id = highlightId;
      this.#clipPathId = clipPathId;
      this.parent.drawLayer.finalizeLine(highlightId, highlightOutlines);
      this.#outlineId = this.parent.drawLayer.highlightOutline(this.#focusOutlines);
    } else if (this.parent) {
      const angle = this.parent.viewport.rotation;
      this.parent.drawLayer.updateLine(this.#id, highlightOutlines);
      this.parent.drawLayer.updateBox(this.#id, HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360));
      this.parent.drawLayer.updateLine(this.#outlineId, this.#focusOutlines);
      this.parent.drawLayer.updateBox(this.#outlineId, HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle));
    }
    const {
      x: x2,
      y: y2,
      width,
      height
    } = highlightOutlines.box;
    switch (this.rotation) {
      case 0:
        this.x = x2;
        this.y = y2;
        this.width = width;
        this.height = height;
        break;
      case 90: {
        const [pageWidth, pageHeight] = this.parentDimensions;
        this.x = y2;
        this.y = 1 - x2;
        this.width = width * pageHeight / pageWidth;
        this.height = height * pageWidth / pageHeight;
        break;
      }
      case 180:
        this.x = 1 - x2;
        this.y = 1 - y2;
        this.width = width;
        this.height = height;
        break;
      case 270: {
        const [pageWidth, pageHeight] = this.parentDimensions;
        this.x = 1 - y2;
        this.y = x2;
        this.width = width * pageHeight / pageWidth;
        this.height = height * pageWidth / pageHeight;
        break;
      }
    }
    const {
      lastPoint
    } = this.#focusOutlines.box;
    this.#lastPoint = [(lastPoint[0] - x2) / width, (lastPoint[1] - y2) / height];
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
    HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || "#fff066";
  }
  static updateDefaultParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType$1.HIGHLIGHT_DEFAULT_COLOR:
        HighlightEditor._defaultColor = value;
        break;
      case AnnotationEditorParamsType$1.HIGHLIGHT_THICKNESS:
        HighlightEditor._defaultThickness = value;
        break;
    }
  }
  translateInPage(x2, y2) {
  }
  get toolbarPosition() {
    return this.#lastPoint;
  }
  updateParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType$1.HIGHLIGHT_COLOR:
        this.#updateColor(value);
        break;
      case AnnotationEditorParamsType$1.HIGHLIGHT_THICKNESS:
        this.#updateThickness(value);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[AnnotationEditorParamsType$1.HIGHLIGHT_DEFAULT_COLOR, HighlightEditor._defaultColor], [AnnotationEditorParamsType$1.HIGHLIGHT_THICKNESS, HighlightEditor._defaultThickness]];
  }
  get propertiesToUpdate() {
    return [[AnnotationEditorParamsType$1.HIGHLIGHT_COLOR, this.color || HighlightEditor._defaultColor], [AnnotationEditorParamsType$1.HIGHLIGHT_THICKNESS, this.#thickness || HighlightEditor._defaultThickness], [AnnotationEditorParamsType$1.HIGHLIGHT_FREE, this.#isFreeHighlight]];
  }
  #updateColor(color) {
    const setColor = (col) => {
      this.color = col;
      this.parent?.drawLayer.changeColor(this.#id, col);
      this.#colorPicker?.updateColor(col);
    };
    const savedColor = this.color;
    this.addCommands({
      cmd: setColor.bind(this, color),
      undo: setColor.bind(this, savedColor),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType$1.HIGHLIGHT_COLOR,
      overwriteIfSameType: true,
      keepUndo: true
    });
    this._reportTelemetry({
      action: "color_changed",
      color: this._uiManager.highlightColorNames.get(color)
    }, true);
  }
  #updateThickness(thickness) {
    const savedThickness = this.#thickness;
    const setThickness = (th) => {
      this.#thickness = th;
      this.#changeThickness(th);
    };
    this.addCommands({
      cmd: setThickness.bind(this, thickness),
      undo: setThickness.bind(this, savedThickness),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType$1.INK_THICKNESS,
      overwriteIfSameType: true,
      keepUndo: true
    });
    this._reportTelemetry({
      action: "thickness_changed",
      thickness
    }, true);
  }
  async addEditToolbar() {
    const toolbar = await super.addEditToolbar();
    if (!toolbar) {
      return null;
    }
    if (this._uiManager.highlightColors) {
      this.#colorPicker = new ColorPicker$1({
        editor: this
      });
      toolbar.addColorPicker(this.#colorPicker);
    }
    return toolbar;
  }
  disableEditing() {
    super.disableEditing();
    this.div.classList.toggle("disabled", true);
  }
  enableEditing() {
    super.enableEditing();
    this.div.classList.toggle("disabled", false);
  }
  fixAndSetPosition() {
    return super.fixAndSetPosition(this.#getRotation());
  }
  getBaseTranslation() {
    return [0, 0];
  }
  getRect(tx, ty) {
    return super.getRect(tx, ty, this.#getRotation());
  }
  onceAdded() {
    this.parent.addUndoableEditor(this);
    this.div.focus();
  }
  remove() {
    this.#cleanDrawLayer();
    this._reportTelemetry({
      action: "deleted"
    });
    super.remove();
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    this.#addToDrawLayer();
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  setParent(parent) {
    let mustBeSelected = false;
    if (this.parent && !parent) {
      this.#cleanDrawLayer();
    } else if (parent) {
      this.#addToDrawLayer(parent);
      mustBeSelected = !this.parent && this.div?.classList.contains("selectedEditor");
    }
    super.setParent(parent);
    this.show(this._isVisible);
    if (mustBeSelected) {
      this.select();
    }
  }
  #changeThickness(thickness) {
    if (!this.#isFreeHighlight) {
      return;
    }
    this.#createFreeOutlines({
      highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)
    });
    this.fixAndSetPosition();
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.setDims(this.width * parentWidth, this.height * parentHeight);
  }
  #cleanDrawLayer() {
    if (this.#id === null || !this.parent) {
      return;
    }
    this.parent.drawLayer.remove(this.#id);
    this.#id = null;
    this.parent.drawLayer.remove(this.#outlineId);
    this.#outlineId = null;
  }
  #addToDrawLayer(parent = this.parent) {
    if (this.#id !== null) {
      return;
    }
    ({
      id: this.#id,
      clipPathId: this.#clipPathId
    } = parent.drawLayer.highlight(this.#highlightOutlines, this.color, this.#opacity));
    this.#outlineId = parent.drawLayer.highlightOutline(this.#focusOutlines);
    if (this.#highlightDiv) {
      this.#highlightDiv.style.clipPath = this.#clipPathId;
    }
  }
  static #rotateBbox({
    x: x2,
    y: y2,
    width,
    height
  }, angle) {
    switch (angle) {
      case 90:
        return {
          x: 1 - y2 - height,
          y: x2,
          width: height,
          height: width
        };
      case 180:
        return {
          x: 1 - x2 - width,
          y: 1 - y2 - height,
          width,
          height
        };
      case 270:
        return {
          x: y2,
          y: 1 - x2 - width,
          width: height,
          height: width
        };
    }
    return {
      x: x2,
      y: y2,
      width,
      height
    };
  }
  rotate(angle) {
    const {
      drawLayer
    } = this.parent;
    let box;
    if (this.#isFreeHighlight) {
      angle = (angle - this.rotation + 360) % 360;
      box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);
    } else {
      box = HighlightEditor.#rotateBbox(this, angle);
    }
    drawLayer.rotate(this.#id, angle);
    drawLayer.rotate(this.#outlineId, angle);
    drawLayer.updateBox(this.#id, box);
    drawLayer.updateBox(this.#outlineId, HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle));
  }
  render() {
    if (this.div) {
      return this.div;
    }
    const div = super.render();
    if (this.#text) {
      div.setAttribute("aria-label", this.#text);
      div.setAttribute("role", "mark");
    }
    if (this.#isFreeHighlight) {
      div.classList.add("free");
    } else {
      this.div.addEventListener("keydown", this.#boundKeydown);
    }
    const highlightDiv = this.#highlightDiv = document.createElement("div");
    div.append(highlightDiv);
    highlightDiv.setAttribute("aria-hidden", "true");
    highlightDiv.className = "internal";
    highlightDiv.style.clipPath = this.#clipPathId;
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.setDims(this.width * parentWidth, this.height * parentHeight);
    bindEvents(this, this.#highlightDiv, ["pointerover", "pointerleave"]);
    this.enableEditing();
    return div;
  }
  pointerover() {
    this.parent.drawLayer.addClass(this.#outlineId, "hovered");
  }
  pointerleave() {
    this.parent.drawLayer.removeClass(this.#outlineId, "hovered");
  }
  #keydown(event) {
    HighlightEditor._keyboardManager.exec(this, event);
  }
  _moveCaret(direction) {
    this.parent.unselect(this);
    switch (direction) {
      case 0:
      case 2:
        this.#setCaret(true);
        break;
      case 1:
      case 3:
        this.#setCaret(false);
        break;
    }
  }
  #setCaret(start) {
    if (!this.#anchorNode) {
      return;
    }
    const selection = window.getSelection();
    if (start) {
      selection.setPosition(this.#anchorNode, this.#anchorOffset);
    } else {
      selection.setPosition(this.#focusNode, this.#focusOffset);
    }
  }
  select() {
    super.select();
    if (!this.#outlineId) {
      return;
    }
    this.parent?.drawLayer.removeClass(this.#outlineId, "hovered");
    this.parent?.drawLayer.addClass(this.#outlineId, "selected");
  }
  unselect() {
    super.unselect();
    if (!this.#outlineId) {
      return;
    }
    this.parent?.drawLayer.removeClass(this.#outlineId, "selected");
    if (!this.#isFreeHighlight) {
      this.#setCaret(false);
    }
  }
  get _mustFixPosition() {
    return !this.#isFreeHighlight;
  }
  show(visible = this._isVisible) {
    super.show(visible);
    if (this.parent) {
      this.parent.drawLayer.show(this.#id, visible);
      this.parent.drawLayer.show(this.#outlineId, visible);
    }
  }
  #getRotation() {
    return this.#isFreeHighlight ? this.rotation : 0;
  }
  #serializeBoxes() {
    if (this.#isFreeHighlight) {
      return null;
    }
    const [pageWidth, pageHeight] = this.pageDimensions;
    const boxes = this.#boxes;
    const quadPoints = new Array(boxes.length * 8);
    let i2 = 0;
    for (const {
      x: x2,
      y: y2,
      width,
      height
    } of boxes) {
      const sx = x2 * pageWidth;
      const sy = (1 - y2 - height) * pageHeight;
      quadPoints[i2] = quadPoints[i2 + 4] = sx;
      quadPoints[i2 + 1] = quadPoints[i2 + 3] = sy;
      quadPoints[i2 + 2] = quadPoints[i2 + 6] = sx + width * pageWidth;
      quadPoints[i2 + 5] = quadPoints[i2 + 7] = sy + height * pageHeight;
      i2 += 8;
    }
    return quadPoints;
  }
  #serializeOutlines(rect) {
    return this.#highlightOutlines.serialize(rect, this.#getRotation());
  }
  static startHighlighting(parent, isLTR, {
    target: textLayer,
    x: x2,
    y: y2
  }) {
    const {
      x: layerX,
      y: layerY,
      width: parentWidth,
      height: parentHeight
    } = textLayer.getBoundingClientRect();
    const pointerMove = (e2) => {
      this.#highlightMove(parent, e2);
    };
    const pointerDownOptions = {
      capture: true,
      passive: false
    };
    const pointerDown = (e2) => {
      e2.preventDefault();
      e2.stopPropagation();
    };
    const pointerUpCallback = (e2) => {
      textLayer.removeEventListener("pointermove", pointerMove);
      window.removeEventListener("blur", pointerUpCallback);
      window.removeEventListener("pointerup", pointerUpCallback);
      window.removeEventListener("pointerdown", pointerDown, pointerDownOptions);
      window.removeEventListener("contextmenu", noContextMenu$1);
      this.#endHighlight(parent, e2);
    };
    window.addEventListener("blur", pointerUpCallback);
    window.addEventListener("pointerup", pointerUpCallback);
    window.addEventListener("pointerdown", pointerDown, pointerDownOptions);
    window.addEventListener("contextmenu", noContextMenu$1);
    textLayer.addEventListener("pointermove", pointerMove);
    this._freeHighlight = new FreeOutliner({
      x: x2,
      y: y2
    }, [layerX, layerY, parentWidth, parentHeight], parent.scale, this._defaultThickness / 2, isLTR, 1e-3);
    ({
      id: this._freeHighlightId,
      clipPathId: this._freeHighlightClipId
    } = parent.drawLayer.highlight(this._freeHighlight, this._defaultColor, this._defaultOpacity, true));
  }
  static #highlightMove(parent, event) {
    if (this._freeHighlight.add(event)) {
      parent.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
    }
  }
  static #endHighlight(parent, event) {
    if (!this._freeHighlight.isEmpty()) {
      parent.createAndAddNewEditor(event, false, {
        highlightId: this._freeHighlightId,
        highlightOutlines: this._freeHighlight.getOutlines(),
        clipPathId: this._freeHighlightClipId,
        methodOfCreation: "main_toolbar"
      });
    } else {
      parent.drawLayer.removeFreeHighlight(this._freeHighlightId);
    }
    this._freeHighlightId = -1;
    this._freeHighlight = null;
    this._freeHighlightClipId = "";
  }
  static deserialize(data2, parent, uiManager) {
    const editor = super.deserialize(data2, parent, uiManager);
    const {
      rect: [blX, blY, trX, trY],
      color,
      quadPoints
    } = data2;
    editor.color = Util$1.makeHexColor(...color);
    editor.#opacity = data2.opacity;
    const [pageWidth, pageHeight] = editor.pageDimensions;
    editor.width = (trX - blX) / pageWidth;
    editor.height = (trY - blY) / pageHeight;
    const boxes = editor.#boxes = [];
    for (let i2 = 0; i2 < quadPoints.length; i2 += 8) {
      boxes.push({
        x: (quadPoints[4] - trX) / pageWidth,
        y: (trY - (1 - quadPoints[i2 + 5])) / pageHeight,
        width: (quadPoints[i2 + 2] - quadPoints[i2]) / pageWidth,
        height: (quadPoints[i2 + 5] - quadPoints[i2 + 1]) / pageHeight
      });
    }
    editor.#createOutlines();
    return editor;
  }
  serialize(isForCopying = false) {
    if (this.isEmpty() || isForCopying) {
      return null;
    }
    const rect = this.getRect(0, 0);
    const color = AnnotationEditor._colorManager.convert(this.color);
    return {
      annotationType: AnnotationEditorType$1.HIGHLIGHT,
      color,
      opacity: this.#opacity,
      thickness: this.#thickness,
      quadPoints: this.#serializeBoxes(),
      outlines: this.#serializeOutlines(rect),
      pageIndex: this.pageIndex,
      rect,
      rotation: this.#getRotation(),
      structTreeParentId: this._structTreeParentId
    };
  }
  static canCreateNewEmptyEditor() {
    return false;
  }
}
class InkEditor extends AnnotationEditor {
  #baseHeight = 0;
  #baseWidth = 0;
  #boundCanvasPointermove = this.canvasPointermove.bind(this);
  #boundCanvasPointerleave = this.canvasPointerleave.bind(this);
  #boundCanvasPointerup = this.canvasPointerup.bind(this);
  #boundCanvasPointerdown = this.canvasPointerdown.bind(this);
  #canvasContextMenuTimeoutId = null;
  #currentPath2D = new Path2D();
  #disableEditing = false;
  #hasSomethingToDraw = false;
  #isCanvasInitialized = false;
  #observer = null;
  #realWidth = 0;
  #realHeight = 0;
  #requestFrameCallback = null;
  static _defaultColor = null;
  static _defaultOpacity = 1;
  static _defaultThickness = 1;
  static _type = "ink";
  static _editorType = AnnotationEditorType$1.INK;
  constructor(params) {
    super({
      ...params,
      name: "inkEditor"
    });
    this.color = params.color || null;
    this.thickness = params.thickness || null;
    this.opacity = params.opacity || null;
    this.paths = [];
    this.bezierPath2D = [];
    this.allRawPaths = [];
    this.currentPath = [];
    this.scaleFactor = 1;
    this.translationX = this.translationY = 0;
    this.x = 0;
    this.y = 0;
    this._willKeepAspectRatio = true;
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
  }
  static updateDefaultParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType$1.INK_THICKNESS:
        InkEditor._defaultThickness = value;
        break;
      case AnnotationEditorParamsType$1.INK_COLOR:
        InkEditor._defaultColor = value;
        break;
      case AnnotationEditorParamsType$1.INK_OPACITY:
        InkEditor._defaultOpacity = value / 100;
        break;
    }
  }
  updateParams(type, value) {
    switch (type) {
      case AnnotationEditorParamsType$1.INK_THICKNESS:
        this.#updateThickness(value);
        break;
      case AnnotationEditorParamsType$1.INK_COLOR:
        this.#updateColor(value);
        break;
      case AnnotationEditorParamsType$1.INK_OPACITY:
        this.#updateOpacity(value);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[AnnotationEditorParamsType$1.INK_THICKNESS, InkEditor._defaultThickness], [AnnotationEditorParamsType$1.INK_COLOR, InkEditor._defaultColor || AnnotationEditor._defaultLineColor], [AnnotationEditorParamsType$1.INK_OPACITY, Math.round(InkEditor._defaultOpacity * 100)]];
  }
  get propertiesToUpdate() {
    return [[AnnotationEditorParamsType$1.INK_THICKNESS, this.thickness || InkEditor._defaultThickness], [AnnotationEditorParamsType$1.INK_COLOR, this.color || InkEditor._defaultColor || AnnotationEditor._defaultLineColor], [AnnotationEditorParamsType$1.INK_OPACITY, Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity))]];
  }
  #updateThickness(thickness) {
    const setThickness = (th) => {
      this.thickness = th;
      this.#fitToContent();
    };
    const savedThickness = this.thickness;
    this.addCommands({
      cmd: setThickness.bind(this, thickness),
      undo: setThickness.bind(this, savedThickness),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType$1.INK_THICKNESS,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  #updateColor(color) {
    const setColor = (col) => {
      this.color = col;
      this.#redraw();
    };
    const savedColor = this.color;
    this.addCommands({
      cmd: setColor.bind(this, color),
      undo: setColor.bind(this, savedColor),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType$1.INK_COLOR,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  #updateOpacity(opacity) {
    const setOpacity = (op) => {
      this.opacity = op;
      this.#redraw();
    };
    opacity /= 100;
    const savedOpacity = this.opacity;
    this.addCommands({
      cmd: setOpacity.bind(this, opacity),
      undo: setOpacity.bind(this, savedOpacity),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: AnnotationEditorParamsType$1.INK_OPACITY,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }
  rebuild() {
    if (!this.parent) {
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    if (!this.canvas) {
      this.#createCanvas();
      this.#createObserver();
    }
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
      this.#setCanvasDims();
    }
    this.#fitToContent();
  }
  remove() {
    if (this.canvas === null) {
      return;
    }
    if (!this.isEmpty()) {
      this.commit();
    }
    this.canvas.width = this.canvas.height = 0;
    this.canvas.remove();
    this.canvas = null;
    if (this.#canvasContextMenuTimeoutId) {
      clearTimeout(this.#canvasContextMenuTimeoutId);
      this.#canvasContextMenuTimeoutId = null;
    }
    this.#observer.disconnect();
    this.#observer = null;
    super.remove();
  }
  setParent(parent) {
    if (!this.parent && parent) {
      this._uiManager.removeShouldRescale(this);
    } else if (this.parent && parent === null) {
      this._uiManager.addShouldRescale(this);
    }
    super.setParent(parent);
  }
  onScaleChanging() {
    const [parentWidth, parentHeight] = this.parentDimensions;
    const width = this.width * parentWidth;
    const height = this.height * parentHeight;
    this.setDimensions(width, height);
  }
  enableEditMode() {
    if (this.#disableEditing || this.canvas === null) {
      return;
    }
    super.enableEditMode();
    this._isDraggable = false;
    this.canvas.addEventListener("pointerdown", this.#boundCanvasPointerdown);
  }
  disableEditMode() {
    if (!this.isInEditMode() || this.canvas === null) {
      return;
    }
    super.disableEditMode();
    this._isDraggable = !this.isEmpty();
    this.div.classList.remove("editing");
    this.canvas.removeEventListener("pointerdown", this.#boundCanvasPointerdown);
  }
  onceAdded() {
    this._isDraggable = !this.isEmpty();
  }
  isEmpty() {
    return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
  }
  #getInitialBBox() {
    const {
      parentRotation,
      parentDimensions: [width, height]
    } = this;
    switch (parentRotation) {
      case 90:
        return [0, height, height, width];
      case 180:
        return [width, height, width, height];
      case 270:
        return [width, 0, height, width];
      default:
        return [0, 0, width, height];
    }
  }
  #setStroke() {
    const {
      ctx,
      color,
      opacity,
      thickness,
      parentScale,
      scaleFactor
    } = this;
    ctx.lineWidth = thickness * parentScale / scaleFactor;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.miterLimit = 10;
    ctx.strokeStyle = `${color}${opacityToHex(opacity)}`;
  }
  #startDrawing(x2, y2) {
    this.canvas.addEventListener("contextmenu", noContextMenu$1);
    this.canvas.addEventListener("pointerleave", this.#boundCanvasPointerleave);
    this.canvas.addEventListener("pointermove", this.#boundCanvasPointermove);
    this.canvas.addEventListener("pointerup", this.#boundCanvasPointerup);
    this.canvas.removeEventListener("pointerdown", this.#boundCanvasPointerdown);
    this.isEditing = true;
    if (!this.#isCanvasInitialized) {
      this.#isCanvasInitialized = true;
      this.#setCanvasDims();
      this.thickness ||= InkEditor._defaultThickness;
      this.color ||= InkEditor._defaultColor || AnnotationEditor._defaultLineColor;
      this.opacity ??= InkEditor._defaultOpacity;
    }
    this.currentPath.push([x2, y2]);
    this.#hasSomethingToDraw = false;
    this.#setStroke();
    this.#requestFrameCallback = () => {
      this.#drawPoints();
      if (this.#requestFrameCallback) {
        window.requestAnimationFrame(this.#requestFrameCallback);
      }
    };
    window.requestAnimationFrame(this.#requestFrameCallback);
  }
  #draw(x2, y2) {
    const [lastX, lastY] = this.currentPath.at(-1);
    if (this.currentPath.length > 1 && x2 === lastX && y2 === lastY) {
      return;
    }
    const currentPath = this.currentPath;
    let path2D = this.#currentPath2D;
    currentPath.push([x2, y2]);
    this.#hasSomethingToDraw = true;
    if (currentPath.length <= 2) {
      path2D.moveTo(...currentPath[0]);
      path2D.lineTo(x2, y2);
      return;
    }
    if (currentPath.length === 3) {
      this.#currentPath2D = path2D = new Path2D();
      path2D.moveTo(...currentPath[0]);
    }
    this.#makeBezierCurve(path2D, ...currentPath.at(-3), ...currentPath.at(-2), x2, y2);
  }
  #endPath() {
    if (this.currentPath.length === 0) {
      return;
    }
    const lastPoint = this.currentPath.at(-1);
    this.#currentPath2D.lineTo(...lastPoint);
  }
  #stopDrawing(x2, y2) {
    this.#requestFrameCallback = null;
    x2 = Math.min(Math.max(x2, 0), this.canvas.width);
    y2 = Math.min(Math.max(y2, 0), this.canvas.height);
    this.#draw(x2, y2);
    this.#endPath();
    let bezier;
    if (this.currentPath.length !== 1) {
      bezier = this.#generateBezierPoints();
    } else {
      const xy = [x2, y2];
      bezier = [[xy, xy.slice(), xy.slice(), xy]];
    }
    const path2D = this.#currentPath2D;
    const currentPath = this.currentPath;
    this.currentPath = [];
    this.#currentPath2D = new Path2D();
    const cmd = () => {
      this.allRawPaths.push(currentPath);
      this.paths.push(bezier);
      this.bezierPath2D.push(path2D);
      this._uiManager.rebuild(this);
    };
    const undo = () => {
      this.allRawPaths.pop();
      this.paths.pop();
      this.bezierPath2D.pop();
      if (this.paths.length === 0) {
        this.remove();
      } else {
        if (!this.canvas) {
          this.#createCanvas();
          this.#createObserver();
        }
        this.#fitToContent();
      }
    };
    this.addCommands({
      cmd,
      undo,
      mustExec: true
    });
  }
  #drawPoints() {
    if (!this.#hasSomethingToDraw) {
      return;
    }
    this.#hasSomethingToDraw = false;
    const thickness = Math.ceil(this.thickness * this.parentScale);
    const lastPoints = this.currentPath.slice(-3);
    const x2 = lastPoints.map((xy) => xy[0]);
    const y2 = lastPoints.map((xy) => xy[1]);
    Math.min(...x2) - thickness;
    Math.max(...x2) + thickness;
    Math.min(...y2) - thickness;
    Math.max(...y2) + thickness;
    const {
      ctx
    } = this;
    ctx.save();
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    for (const path of this.bezierPath2D) {
      ctx.stroke(path);
    }
    ctx.stroke(this.#currentPath2D);
    ctx.restore();
  }
  #makeBezierCurve(path2D, x0, y0, x1, y1, x2, y2) {
    const prevX = (x0 + x1) / 2;
    const prevY = (y0 + y1) / 2;
    const x3 = (x1 + x2) / 2;
    const y3 = (y1 + y2) / 2;
    path2D.bezierCurveTo(prevX + 2 * (x1 - prevX) / 3, prevY + 2 * (y1 - prevY) / 3, x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3, x3, y3);
  }
  #generateBezierPoints() {
    const path = this.currentPath;
    if (path.length <= 2) {
      return [[path[0], path[0], path.at(-1), path.at(-1)]];
    }
    const bezierPoints = [];
    let i2;
    let [x0, y0] = path[0];
    for (i2 = 1; i2 < path.length - 2; i2++) {
      const [x12, y12] = path[i2];
      const [x22, y22] = path[i2 + 1];
      const x3 = (x12 + x22) / 2;
      const y3 = (y12 + y22) / 2;
      const control12 = [x0 + 2 * (x12 - x0) / 3, y0 + 2 * (y12 - y0) / 3];
      const control22 = [x3 + 2 * (x12 - x3) / 3, y3 + 2 * (y12 - y3) / 3];
      bezierPoints.push([[x0, y0], control12, control22, [x3, y3]]);
      [x0, y0] = [x3, y3];
    }
    const [x1, y1] = path[i2];
    const [x2, y2] = path[i2 + 1];
    const control1 = [x0 + 2 * (x1 - x0) / 3, y0 + 2 * (y1 - y0) / 3];
    const control2 = [x2 + 2 * (x1 - x2) / 3, y2 + 2 * (y1 - y2) / 3];
    bezierPoints.push([[x0, y0], control1, control2, [x2, y2]]);
    return bezierPoints;
  }
  #redraw() {
    if (this.isEmpty()) {
      this.#updateTransform();
      return;
    }
    this.#setStroke();
    const {
      canvas,
      ctx
    } = this;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    this.#updateTransform();
    for (const path of this.bezierPath2D) {
      ctx.stroke(path);
    }
  }
  commit() {
    if (this.#disableEditing) {
      return;
    }
    super.commit();
    this.isEditing = false;
    this.disableEditMode();
    this.setInForeground();
    this.#disableEditing = true;
    this.div.classList.add("disabled");
    this.#fitToContent(true);
    this.select();
    this.parent.addInkEditorIfNeeded(true);
    this.moveInDOM();
    this.div.focus({
      preventScroll: true
    });
  }
  focusin(event) {
    if (!this._focusEventsAllowed) {
      return;
    }
    super.focusin(event);
    this.enableEditMode();
  }
  canvasPointerdown(event) {
    if (event.button !== 0 || !this.isInEditMode() || this.#disableEditing) {
      return;
    }
    this.setInForeground();
    event.preventDefault();
    if (!this.div.contains(document.activeElement)) {
      this.div.focus({
        preventScroll: true
      });
    }
    this.#startDrawing(event.offsetX, event.offsetY);
  }
  canvasPointermove(event) {
    event.preventDefault();
    this.#draw(event.offsetX, event.offsetY);
  }
  canvasPointerup(event) {
    event.preventDefault();
    this.#endDrawing(event);
  }
  canvasPointerleave(event) {
    this.#endDrawing(event);
  }
  #endDrawing(event) {
    this.canvas.removeEventListener("pointerleave", this.#boundCanvasPointerleave);
    this.canvas.removeEventListener("pointermove", this.#boundCanvasPointermove);
    this.canvas.removeEventListener("pointerup", this.#boundCanvasPointerup);
    this.canvas.addEventListener("pointerdown", this.#boundCanvasPointerdown);
    if (this.#canvasContextMenuTimeoutId) {
      clearTimeout(this.#canvasContextMenuTimeoutId);
    }
    this.#canvasContextMenuTimeoutId = setTimeout(() => {
      this.#canvasContextMenuTimeoutId = null;
      this.canvas.removeEventListener("contextmenu", noContextMenu$1);
    }, 10);
    this.#stopDrawing(event.offsetX, event.offsetY);
    this.addToAnnotationStorage();
    this.setInBackground();
  }
  #createCanvas() {
    this.canvas = document.createElement("canvas");
    this.canvas.width = this.canvas.height = 0;
    this.canvas.className = "inkEditorCanvas";
    this.canvas.setAttribute("data-l10n-id", "pdfjs-ink-canvas");
    this.div.append(this.canvas);
    this.ctx = this.canvas.getContext("2d");
  }
  #createObserver() {
    this.#observer = new ResizeObserver((entries) => {
      const rect = entries[0].contentRect;
      if (rect.width && rect.height) {
        this.setDimensions(rect.width, rect.height);
      }
    });
    this.#observer.observe(this.div);
  }
  get isResizable() {
    return !this.isEmpty() && this.#disableEditing;
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this.width) {
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    this.div.setAttribute("data-l10n-id", "pdfjs-ink");
    const [x2, y2, w2, h2] = this.#getInitialBBox();
    this.setAt(x2, y2, 0, 0);
    this.setDims(w2, h2);
    this.#createCanvas();
    if (this.width) {
      const [parentWidth, parentHeight] = this.parentDimensions;
      this.setAspectRatio(this.width * parentWidth, this.height * parentHeight);
      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
      this.#isCanvasInitialized = true;
      this.#setCanvasDims();
      this.setDims(this.width * parentWidth, this.height * parentHeight);
      this.#redraw();
      this.div.classList.add("disabled");
    } else {
      this.div.classList.add("editing");
      this.enableEditMode();
    }
    this.#createObserver();
    return this.div;
  }
  #setCanvasDims() {
    if (!this.#isCanvasInitialized) {
      return;
    }
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.canvas.width = Math.ceil(this.width * parentWidth);
    this.canvas.height = Math.ceil(this.height * parentHeight);
    this.#updateTransform();
  }
  setDimensions(width, height) {
    const roundedWidth = Math.round(width);
    const roundedHeight = Math.round(height);
    if (this.#realWidth === roundedWidth && this.#realHeight === roundedHeight) {
      return;
    }
    this.#realWidth = roundedWidth;
    this.#realHeight = roundedHeight;
    this.canvas.style.visibility = "hidden";
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.width = width / parentWidth;
    this.height = height / parentHeight;
    this.fixAndSetPosition();
    if (this.#disableEditing) {
      this.#setScaleFactor(width, height);
    }
    this.#setCanvasDims();
    this.#redraw();
    this.canvas.style.visibility = "visible";
    this.fixDims();
  }
  #setScaleFactor(width, height) {
    const padding = this.#getPadding();
    const scaleFactorW = (width - padding) / this.#baseWidth;
    const scaleFactorH = (height - padding) / this.#baseHeight;
    this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);
  }
  #updateTransform() {
    const padding = this.#getPadding() / 2;
    this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);
  }
  static #buildPath2D(bezier) {
    const path2D = new Path2D();
    for (let i2 = 0, ii = bezier.length; i2 < ii; i2++) {
      const [first, control1, control2, second] = bezier[i2];
      if (i2 === 0) {
        path2D.moveTo(...first);
      }
      path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);
    }
    return path2D;
  }
  static #toPDFCoordinates(points, rect, rotation) {
    const [blX, blY, trX, trY] = rect;
    switch (rotation) {
      case 0:
        for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
          points[i2] += blX;
          points[i2 + 1] = trY - points[i2 + 1];
        }
        break;
      case 90:
        for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
          const x2 = points[i2];
          points[i2] = points[i2 + 1] + blX;
          points[i2 + 1] = x2 + blY;
        }
        break;
      case 180:
        for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
          points[i2] = trX - points[i2];
          points[i2 + 1] += blY;
        }
        break;
      case 270:
        for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
          const x2 = points[i2];
          points[i2] = trX - points[i2 + 1];
          points[i2 + 1] = trY - x2;
        }
        break;
      default:
        throw new Error("Invalid rotation");
    }
    return points;
  }
  static #fromPDFCoordinates(points, rect, rotation) {
    const [blX, blY, trX, trY] = rect;
    switch (rotation) {
      case 0:
        for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
          points[i2] -= blX;
          points[i2 + 1] = trY - points[i2 + 1];
        }
        break;
      case 90:
        for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
          const x2 = points[i2];
          points[i2] = points[i2 + 1] - blY;
          points[i2 + 1] = x2 - blX;
        }
        break;
      case 180:
        for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
          points[i2] = trX - points[i2];
          points[i2 + 1] -= blY;
        }
        break;
      case 270:
        for (let i2 = 0, ii = points.length; i2 < ii; i2 += 2) {
          const x2 = points[i2];
          points[i2] = trY - points[i2 + 1];
          points[i2 + 1] = trX - x2;
        }
        break;
      default:
        throw new Error("Invalid rotation");
    }
    return points;
  }
  #serializePaths(s, tx, ty, rect) {
    const paths = [];
    const padding = this.thickness / 2;
    const shiftX = s * tx + padding;
    const shiftY = s * ty + padding;
    for (const bezier of this.paths) {
      const buffer = [];
      const points = [];
      for (let j = 0, jj = bezier.length; j < jj; j++) {
        const [first, control1, control2, second] = bezier[j];
        if (first[0] === second[0] && first[1] === second[1] && jj === 1) {
          const p0 = s * first[0] + shiftX;
          const p1 = s * first[1] + shiftY;
          buffer.push(p0, p1);
          points.push(p0, p1);
          break;
        }
        const p10 = s * first[0] + shiftX;
        const p11 = s * first[1] + shiftY;
        const p20 = s * control1[0] + shiftX;
        const p21 = s * control1[1] + shiftY;
        const p30 = s * control2[0] + shiftX;
        const p31 = s * control2[1] + shiftY;
        const p40 = s * second[0] + shiftX;
        const p41 = s * second[1] + shiftY;
        if (j === 0) {
          buffer.push(p10, p11);
          points.push(p10, p11);
        }
        buffer.push(p20, p21, p30, p31, p40, p41);
        points.push(p20, p21);
        if (j === jj - 1) {
          points.push(p40, p41);
        }
      }
      paths.push({
        bezier: InkEditor.#toPDFCoordinates(buffer, rect, this.rotation),
        points: InkEditor.#toPDFCoordinates(points, rect, this.rotation)
      });
    }
    return paths;
  }
  #getBbox() {
    let xMin = Infinity;
    let xMax = -Infinity;
    let yMin = Infinity;
    let yMax = -Infinity;
    for (const path of this.paths) {
      for (const [first, control1, control2, second] of path) {
        const bbox = Util$1.bezierBoundingBox(...first, ...control1, ...control2, ...second);
        xMin = Math.min(xMin, bbox[0]);
        yMin = Math.min(yMin, bbox[1]);
        xMax = Math.max(xMax, bbox[2]);
        yMax = Math.max(yMax, bbox[3]);
      }
    }
    return [xMin, yMin, xMax, yMax];
  }
  #getPadding() {
    return this.#disableEditing ? Math.ceil(this.thickness * this.parentScale) : 0;
  }
  #fitToContent(firstTime = false) {
    if (this.isEmpty()) {
      return;
    }
    if (!this.#disableEditing) {
      this.#redraw();
      return;
    }
    const bbox = this.#getBbox();
    const padding = this.#getPadding();
    this.#baseWidth = Math.max(AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);
    this.#baseHeight = Math.max(AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);
    const width = Math.ceil(padding + this.#baseWidth * this.scaleFactor);
    const height = Math.ceil(padding + this.#baseHeight * this.scaleFactor);
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.width = width / parentWidth;
    this.height = height / parentHeight;
    this.setAspectRatio(width, height);
    const prevTranslationX = this.translationX;
    const prevTranslationY = this.translationY;
    this.translationX = -bbox[0];
    this.translationY = -bbox[1];
    this.#setCanvasDims();
    this.#redraw();
    this.#realWidth = width;
    this.#realHeight = height;
    this.setDims(width, height);
    const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;
    this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);
  }
  static deserialize(data2, parent, uiManager) {
    if (data2 instanceof InkAnnotationElement) {
      return null;
    }
    const editor = super.deserialize(data2, parent, uiManager);
    editor.thickness = data2.thickness;
    editor.color = Util$1.makeHexColor(...data2.color);
    editor.opacity = data2.opacity;
    const [pageWidth, pageHeight] = editor.pageDimensions;
    const width = editor.width * pageWidth;
    const height = editor.height * pageHeight;
    const scaleFactor = editor.parentScale;
    const padding = data2.thickness / 2;
    editor.#disableEditing = true;
    editor.#realWidth = Math.round(width);
    editor.#realHeight = Math.round(height);
    const {
      paths,
      rect,
      rotation
    } = data2;
    for (let {
      bezier
    } of paths) {
      bezier = InkEditor.#fromPDFCoordinates(bezier, rect, rotation);
      const path = [];
      editor.paths.push(path);
      let p0 = scaleFactor * (bezier[0] - padding);
      let p1 = scaleFactor * (bezier[1] - padding);
      for (let i2 = 2, ii = bezier.length; i2 < ii; i2 += 6) {
        const p10 = scaleFactor * (bezier[i2] - padding);
        const p11 = scaleFactor * (bezier[i2 + 1] - padding);
        const p20 = scaleFactor * (bezier[i2 + 2] - padding);
        const p21 = scaleFactor * (bezier[i2 + 3] - padding);
        const p30 = scaleFactor * (bezier[i2 + 4] - padding);
        const p31 = scaleFactor * (bezier[i2 + 5] - padding);
        path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);
        p0 = p30;
        p1 = p31;
      }
      const path2D = this.#buildPath2D(path);
      editor.bezierPath2D.push(path2D);
    }
    const bbox = editor.#getBbox();
    editor.#baseWidth = Math.max(AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);
    editor.#baseHeight = Math.max(AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);
    editor.#setScaleFactor(width, height);
    return editor;
  }
  serialize() {
    if (this.isEmpty()) {
      return null;
    }
    const rect = this.getRect(0, 0);
    const color = AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
    return {
      annotationType: AnnotationEditorType$1.INK,
      color,
      thickness: this.thickness,
      opacity: this.opacity,
      paths: this.#serializePaths(this.scaleFactor / this.parentScale, this.translationX, this.translationY, rect),
      pageIndex: this.pageIndex,
      rect,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
  }
}
class StampEditor extends AnnotationEditor {
  #bitmap = null;
  #bitmapId = null;
  #bitmapPromise = null;
  #bitmapUrl = null;
  #bitmapFile = null;
  #bitmapFileName = "";
  #canvas = null;
  #observer = null;
  #resizeTimeoutId = null;
  #isSvg = false;
  #hasBeenAddedInUndoStack = false;
  static _type = "stamp";
  static _editorType = AnnotationEditorType$1.STAMP;
  constructor(params) {
    super({
      ...params,
      name: "stampEditor"
    });
    this.#bitmapUrl = params.bitmapUrl;
    this.#bitmapFile = params.bitmapFile;
  }
  static initialize(l10n, uiManager) {
    AnnotationEditor.initialize(l10n, uiManager);
  }
  static get supportedTypes() {
    const types = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"];
    return shadow$1(this, "supportedTypes", types.map((type) => `image/${type}`));
  }
  static get supportedTypesStr() {
    return shadow$1(this, "supportedTypesStr", this.supportedTypes.join(","));
  }
  static isHandlingMimeForPasting(mime) {
    return this.supportedTypes.includes(mime);
  }
  static paste(item, parent) {
    parent.pasteEditor(AnnotationEditorType$1.STAMP, {
      bitmapFile: item.getAsFile()
    });
  }
  #getBitmapFetched(data2, fromId = false) {
    if (!data2) {
      this.remove();
      return;
    }
    this.#bitmap = data2.bitmap;
    if (!fromId) {
      this.#bitmapId = data2.id;
      this.#isSvg = data2.isSvg;
    }
    if (data2.file) {
      this.#bitmapFileName = data2.file.name;
    }
    this.#createCanvas();
  }
  #getBitmapDone() {
    this.#bitmapPromise = null;
    this._uiManager.enableWaiting(false);
    if (this.#canvas) {
      this.div.focus();
    }
  }
  #getBitmap() {
    if (this.#bitmapId) {
      this._uiManager.enableWaiting(true);
      this._uiManager.imageManager.getFromId(this.#bitmapId).then((data2) => this.#getBitmapFetched(data2, true)).finally(() => this.#getBitmapDone());
      return;
    }
    if (this.#bitmapUrl) {
      const url = this.#bitmapUrl;
      this.#bitmapUrl = null;
      this._uiManager.enableWaiting(true);
      this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then((data2) => this.#getBitmapFetched(data2)).finally(() => this.#getBitmapDone());
      return;
    }
    if (this.#bitmapFile) {
      const file2 = this.#bitmapFile;
      this.#bitmapFile = null;
      this._uiManager.enableWaiting(true);
      this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file2).then((data2) => this.#getBitmapFetched(data2)).finally(() => this.#getBitmapDone());
      return;
    }
    const input = document.createElement("input");
    input.type = "file";
    input.accept = StampEditor.supportedTypesStr;
    this.#bitmapPromise = new Promise((resolve2) => {
      input.addEventListener("change", async () => {
        if (!input.files || input.files.length === 0) {
          this.remove();
        } else {
          this._uiManager.enableWaiting(true);
          const data2 = await this._uiManager.imageManager.getFromFile(input.files[0]);
          this.#getBitmapFetched(data2);
        }
        resolve2();
      });
      input.addEventListener("cancel", () => {
        this.remove();
        resolve2();
      });
    }).finally(() => this.#getBitmapDone());
    input.click();
  }
  remove() {
    if (this.#bitmapId) {
      this.#bitmap = null;
      this._uiManager.imageManager.deleteId(this.#bitmapId);
      this.#canvas?.remove();
      this.#canvas = null;
      this.#observer?.disconnect();
      this.#observer = null;
      if (this.#resizeTimeoutId) {
        clearTimeout(this.#resizeTimeoutId);
        this.#resizeTimeoutId = null;
      }
    }
    super.remove();
  }
  rebuild() {
    if (!this.parent) {
      if (this.#bitmapId) {
        this.#getBitmap();
      }
      return;
    }
    super.rebuild();
    if (this.div === null) {
      return;
    }
    if (this.#bitmapId && this.#canvas === null) {
      this.#getBitmap();
    }
    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }
  onceAdded() {
    this._isDraggable = true;
    this.div.focus();
  }
  isEmpty() {
    return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId);
  }
  get isResizable() {
    return true;
  }
  render() {
    if (this.div) {
      return this.div;
    }
    let baseX, baseY;
    if (this.width) {
      baseX = this.x;
      baseY = this.y;
    }
    super.render();
    this.div.hidden = true;
    this.addAltTextButton();
    if (this.#bitmap) {
      this.#createCanvas();
    } else {
      this.#getBitmap();
    }
    if (this.width) {
      const [parentWidth, parentHeight] = this.parentDimensions;
      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
    }
    return this.div;
  }
  #createCanvas() {
    const {
      div
    } = this;
    let {
      width,
      height
    } = this.#bitmap;
    const [pageWidth, pageHeight] = this.pageDimensions;
    const MAX_RATIO = 0.75;
    if (this.width) {
      width = this.width * pageWidth;
      height = this.height * pageHeight;
    } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {
      const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);
      width *= factor;
      height *= factor;
    }
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);
    this._uiManager.enableWaiting(false);
    const canvas = this.#canvas = document.createElement("canvas");
    div.append(canvas);
    div.hidden = false;
    this.#drawBitmap(width, height);
    this.#createObserver();
    if (!this.#hasBeenAddedInUndoStack) {
      this.parent.addUndoableEditor(this);
      this.#hasBeenAddedInUndoStack = true;
    }
    this._reportTelemetry({
      action: "inserted_image"
    });
    if (this.#bitmapFileName) {
      canvas.setAttribute("aria-label", this.#bitmapFileName);
    }
  }
  #setDimensions(width, height) {
    const [parentWidth, parentHeight] = this.parentDimensions;
    this.width = width / parentWidth;
    this.height = height / parentHeight;
    this.setDims(width, height);
    if (this._initialOptions?.isCentered) {
      this.center();
    } else {
      this.fixAndSetPosition();
    }
    this._initialOptions = null;
    if (this.#resizeTimeoutId !== null) {
      clearTimeout(this.#resizeTimeoutId);
    }
    const TIME_TO_WAIT = 200;
    this.#resizeTimeoutId = setTimeout(() => {
      this.#resizeTimeoutId = null;
      this.#drawBitmap(width, height);
    }, TIME_TO_WAIT);
  }
  #scaleBitmap(width, height) {
    const {
      width: bitmapWidth,
      height: bitmapHeight
    } = this.#bitmap;
    let newWidth = bitmapWidth;
    let newHeight = bitmapHeight;
    let bitmap = this.#bitmap;
    while (newWidth > 2 * width || newHeight > 2 * height) {
      const prevWidth = newWidth;
      const prevHeight = newHeight;
      if (newWidth > 2 * width) {
        newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);
      }
      if (newHeight > 2 * height) {
        newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);
      }
      const offscreen = new OffscreenCanvas(newWidth, newHeight);
      const ctx = offscreen.getContext("2d");
      ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
      bitmap = offscreen.transferToImageBitmap();
    }
    return bitmap;
  }
  #drawBitmap(width, height) {
    width = Math.ceil(width);
    height = Math.ceil(height);
    const canvas = this.#canvas;
    if (!canvas || canvas.width === width && canvas.height === height) {
      return;
    }
    canvas.width = width;
    canvas.height = height;
    const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(width, height);
    if (this._uiManager.hasMLManager && !this.hasAltText()) {
      const offscreen = new OffscreenCanvas(width, height);
      const ctx2 = offscreen.getContext("2d");
      ctx2.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, width, height);
      this._uiManager.mlGuess({
        service: "image-to-text",
        request: {
          data: ctx2.getImageData(0, 0, width, height).data,
          width,
          height,
          channels: 4
        }
      }).then((response) => {
        const altText = response?.output || "";
        if (this.parent && altText && !this.hasAltText()) {
          this.altTextData = {
            altText,
            decorative: false
          };
        }
      });
    }
    const ctx = canvas.getContext("2d");
    ctx.filter = this._uiManager.hcmFilter;
    ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, width, height);
  }
  getImageForAltText() {
    return this.#canvas;
  }
  #serializeBitmap(toUrl) {
    if (toUrl) {
      if (this.#isSvg) {
        const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);
        if (url) {
          return url;
        }
      }
      const canvas = document.createElement("canvas");
      ({
        width: canvas.width,
        height: canvas.height
      } = this.#bitmap);
      const ctx = canvas.getContext("2d");
      ctx.drawImage(this.#bitmap, 0, 0);
      return canvas.toDataURL();
    }
    if (this.#isSvg) {
      const [pageWidth, pageHeight] = this.pageDimensions;
      const width = Math.round(this.width * pageWidth * PixelsPerInch$1.PDF_TO_CSS_UNITS);
      const height = Math.round(this.height * pageHeight * PixelsPerInch$1.PDF_TO_CSS_UNITS);
      const offscreen = new OffscreenCanvas(width, height);
      const ctx = offscreen.getContext("2d");
      ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);
      return offscreen.transferToImageBitmap();
    }
    return structuredClone(this.#bitmap);
  }
  #createObserver() {
    this.#observer = new ResizeObserver((entries) => {
      const rect = entries[0].contentRect;
      if (rect.width && rect.height) {
        this.#setDimensions(rect.width, rect.height);
      }
    });
    this.#observer.observe(this.div);
  }
  static deserialize(data2, parent, uiManager) {
    if (data2 instanceof StampAnnotationElement) {
      return null;
    }
    const editor = super.deserialize(data2, parent, uiManager);
    const {
      rect,
      bitmapUrl,
      bitmapId,
      isSvg,
      accessibilityData
    } = data2;
    if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {
      editor.#bitmapId = bitmapId;
    } else {
      editor.#bitmapUrl = bitmapUrl;
    }
    editor.#isSvg = isSvg;
    const [parentWidth, parentHeight] = editor.pageDimensions;
    editor.width = (rect[2] - rect[0]) / parentWidth;
    editor.height = (rect[3] - rect[1]) / parentHeight;
    if (accessibilityData) {
      editor.altTextData = accessibilityData;
    }
    return editor;
  }
  serialize(isForCopying = false, context = null) {
    if (this.isEmpty()) {
      return null;
    }
    const serialized = {
      annotationType: AnnotationEditorType$1.STAMP,
      bitmapId: this.#bitmapId,
      pageIndex: this.pageIndex,
      rect: this.getRect(0, 0),
      rotation: this.rotation,
      isSvg: this.#isSvg,
      structTreeParentId: this._structTreeParentId
    };
    if (isForCopying) {
      serialized.bitmapUrl = this.#serializeBitmap(true);
      serialized.accessibilityData = this.altTextData;
      return serialized;
    }
    const {
      decorative,
      altText
    } = this.altTextData;
    if (!decorative && altText) {
      serialized.accessibilityData = {
        type: "Figure",
        alt: altText
      };
    }
    if (context === null) {
      return serialized;
    }
    context.stamps ||= /* @__PURE__ */ new Map();
    const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;
    if (!context.stamps.has(this.#bitmapId)) {
      context.stamps.set(this.#bitmapId, {
        area,
        serialized
      });
      serialized.bitmap = this.#serializeBitmap(false);
    } else if (this.#isSvg) {
      const prevData = context.stamps.get(this.#bitmapId);
      if (area > prevData.area) {
        prevData.area = area;
        prevData.serialized.bitmap.close();
        prevData.serialized.bitmap = this.#serializeBitmap(false);
      }
    }
    return serialized;
  }
}
let AnnotationEditorLayer$1 = class AnnotationEditorLayer {
  #accessibilityManager;
  #allowClick = false;
  #annotationLayer = null;
  #boundPointerup = null;
  #boundPointerdown = null;
  #boundTextLayerPointerDown = null;
  #editorFocusTimeoutId = null;
  #editors = /* @__PURE__ */ new Map();
  #hadPointerDown = false;
  #isCleaningUp = false;
  #isDisabling = false;
  #textLayer = null;
  #uiManager;
  static _initialized = false;
  static #editorTypes = new Map([FreeTextEditor, InkEditor, StampEditor, HighlightEditor].map((type) => [type._editorType, type]));
  constructor({
    uiManager,
    pageIndex,
    div,
    accessibilityManager,
    annotationLayer,
    drawLayer,
    textLayer,
    viewport,
    l10n
  }) {
    const editorTypes = [...AnnotationEditorLayer.#editorTypes.values()];
    if (!AnnotationEditorLayer._initialized) {
      AnnotationEditorLayer._initialized = true;
      for (const editorType of editorTypes) {
        editorType.initialize(l10n, uiManager);
      }
    }
    uiManager.registerEditorTypes(editorTypes);
    this.#uiManager = uiManager;
    this.pageIndex = pageIndex;
    this.div = div;
    this.#accessibilityManager = accessibilityManager;
    this.#annotationLayer = annotationLayer;
    this.viewport = viewport;
    this.#textLayer = textLayer;
    this.drawLayer = drawLayer;
    this.#uiManager.addLayer(this);
  }
  get isEmpty() {
    return this.#editors.size === 0;
  }
  get isInvisible() {
    return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType$1.NONE;
  }
  updateToolbar(mode) {
    this.#uiManager.updateToolbar(mode);
  }
  updateMode(mode = this.#uiManager.getMode()) {
    this.#cleanup();
    switch (mode) {
      case AnnotationEditorType$1.NONE:
        this.disableTextSelection();
        this.togglePointerEvents(false);
        this.toggleAnnotationLayerPointerEvents(true);
        this.disableClick();
        return;
      case AnnotationEditorType$1.INK:
        this.addInkEditorIfNeeded(false);
        this.disableTextSelection();
        this.togglePointerEvents(true);
        this.disableClick();
        break;
      case AnnotationEditorType$1.HIGHLIGHT:
        this.enableTextSelection();
        this.togglePointerEvents(false);
        this.disableClick();
        break;
      default:
        this.disableTextSelection();
        this.togglePointerEvents(true);
        this.enableClick();
    }
    this.toggleAnnotationLayerPointerEvents(false);
    const {
      classList
    } = this.div;
    for (const editorType of AnnotationEditorLayer.#editorTypes.values()) {
      classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);
    }
    this.div.hidden = false;
  }
  hasTextLayer(textLayer) {
    return textLayer === this.#textLayer?.div;
  }
  addInkEditorIfNeeded(isCommitting) {
    if (this.#uiManager.getMode() !== AnnotationEditorType$1.INK) {
      return;
    }
    if (!isCommitting) {
      for (const editor2 of this.#editors.values()) {
        if (editor2.isEmpty()) {
          editor2.setInBackground();
          return;
        }
      }
    }
    const editor = this.createAndAddNewEditor({
      offsetX: 0,
      offsetY: 0
    }, false);
    editor.setInBackground();
  }
  setEditingState(isEditing) {
    this.#uiManager.setEditingState(isEditing);
  }
  addCommands(params) {
    this.#uiManager.addCommands(params);
  }
  togglePointerEvents(enabled = false) {
    this.div.classList.toggle("disabled", !enabled);
  }
  toggleAnnotationLayerPointerEvents(enabled = false) {
    this.#annotationLayer?.div.classList.toggle("disabled", !enabled);
  }
  enable() {
    this.div.tabIndex = 0;
    this.togglePointerEvents(true);
    const annotationElementIds = /* @__PURE__ */ new Set();
    for (const editor of this.#editors.values()) {
      editor.enableEditing();
      editor.show(true);
      if (editor.annotationElementId) {
        this.#uiManager.removeChangedExistingAnnotation(editor);
        annotationElementIds.add(editor.annotationElementId);
      }
    }
    if (!this.#annotationLayer) {
      return;
    }
    const editables = this.#annotationLayer.getEditableAnnotations();
    for (const editable of editables) {
      editable.hide();
      if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {
        continue;
      }
      if (annotationElementIds.has(editable.data.id)) {
        continue;
      }
      const editor = this.deserialize(editable);
      if (!editor) {
        continue;
      }
      this.addOrRebuild(editor);
      editor.enableEditing();
    }
  }
  disable() {
    this.#isDisabling = true;
    this.div.tabIndex = -1;
    this.togglePointerEvents(false);
    const changedAnnotations = /* @__PURE__ */ new Map();
    const resetAnnotations = /* @__PURE__ */ new Map();
    for (const editor of this.#editors.values()) {
      editor.disableEditing();
      if (!editor.annotationElementId) {
        continue;
      }
      if (editor.serialize() !== null) {
        changedAnnotations.set(editor.annotationElementId, editor);
        continue;
      } else {
        resetAnnotations.set(editor.annotationElementId, editor);
      }
      this.getEditableAnnotation(editor.annotationElementId)?.show();
      editor.remove();
    }
    if (this.#annotationLayer) {
      const editables = this.#annotationLayer.getEditableAnnotations();
      for (const editable of editables) {
        const {
          id: id2
        } = editable.data;
        if (this.#uiManager.isDeletedAnnotationElement(id2)) {
          continue;
        }
        let editor = resetAnnotations.get(id2);
        if (editor) {
          editor.resetAnnotationElement(editable);
          editor.show(false);
          editable.show();
          continue;
        }
        editor = changedAnnotations.get(id2);
        if (editor) {
          this.#uiManager.addChangedExistingAnnotation(editor);
          editor.renderAnnotationElement(editable);
          editor.show(false);
        }
        editable.show();
      }
    }
    this.#cleanup();
    if (this.isEmpty) {
      this.div.hidden = true;
    }
    const {
      classList
    } = this.div;
    for (const editorType of AnnotationEditorLayer.#editorTypes.values()) {
      classList.remove(`${editorType._type}Editing`);
    }
    this.disableTextSelection();
    this.toggleAnnotationLayerPointerEvents(true);
    this.#isDisabling = false;
  }
  getEditableAnnotation(id2) {
    return this.#annotationLayer?.getEditableAnnotation(id2) || null;
  }
  setActiveEditor(editor) {
    const currentActive = this.#uiManager.getActive();
    if (currentActive === editor) {
      return;
    }
    this.#uiManager.setActiveEditor(editor);
  }
  enableTextSelection() {
    this.div.tabIndex = -1;
    if (this.#textLayer?.div && !this.#boundTextLayerPointerDown) {
      this.#boundTextLayerPointerDown = this.#textLayerPointerDown.bind(this);
      this.#textLayer.div.addEventListener("pointerdown", this.#boundTextLayerPointerDown);
      this.#textLayer.div.classList.add("highlighting");
    }
  }
  disableTextSelection() {
    this.div.tabIndex = 0;
    if (this.#textLayer?.div && this.#boundTextLayerPointerDown) {
      this.#textLayer.div.removeEventListener("pointerdown", this.#boundTextLayerPointerDown);
      this.#boundTextLayerPointerDown = null;
      this.#textLayer.div.classList.remove("highlighting");
    }
  }
  #textLayerPointerDown(event) {
    this.#uiManager.unselectAll();
    if (event.target === this.#textLayer.div) {
      const {
        isMac
      } = util_FeatureTest.platform;
      if (event.button !== 0 || event.ctrlKey && isMac) {
        return;
      }
      this.#uiManager.showAllEditors("highlight", true, true);
      this.#textLayer.div.classList.add("free");
      HighlightEditor.startHighlighting(this, this.#uiManager.direction === "ltr", event);
      this.#textLayer.div.addEventListener("pointerup", () => {
        this.#textLayer.div.classList.remove("free");
      }, {
        once: true
      });
      event.preventDefault();
    }
  }
  enableClick() {
    if (this.#boundPointerdown) {
      return;
    }
    this.#boundPointerdown = this.pointerdown.bind(this);
    this.#boundPointerup = this.pointerup.bind(this);
    this.div.addEventListener("pointerdown", this.#boundPointerdown);
    this.div.addEventListener("pointerup", this.#boundPointerup);
  }
  disableClick() {
    if (!this.#boundPointerdown) {
      return;
    }
    this.div.removeEventListener("pointerdown", this.#boundPointerdown);
    this.div.removeEventListener("pointerup", this.#boundPointerup);
    this.#boundPointerdown = null;
    this.#boundPointerup = null;
  }
  attach(editor) {
    this.#editors.set(editor.id, editor);
    const {
      annotationElementId
    } = editor;
    if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {
      this.#uiManager.removeDeletedAnnotationElement(editor);
    }
  }
  detach(editor) {
    this.#editors.delete(editor.id);
    this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
    if (!this.#isDisabling && editor.annotationElementId) {
      this.#uiManager.addDeletedAnnotationElement(editor);
    }
  }
  remove(editor) {
    this.detach(editor);
    this.#uiManager.removeEditor(editor);
    editor.div.remove();
    editor.isAttachedToDOM = false;
    if (!this.#isCleaningUp) {
      this.addInkEditorIfNeeded(false);
    }
  }
  changeParent(editor) {
    if (editor.parent === this) {
      return;
    }
    if (editor.parent && editor.annotationElementId) {
      this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);
      AnnotationEditor.deleteAnnotationElement(editor);
      editor.annotationElementId = null;
    }
    this.attach(editor);
    editor.parent?.detach(editor);
    editor.setParent(this);
    if (editor.div && editor.isAttachedToDOM) {
      editor.div.remove();
      this.div.append(editor.div);
    }
  }
  add(editor) {
    if (editor.parent === this && editor.isAttachedToDOM) {
      return;
    }
    this.changeParent(editor);
    this.#uiManager.addEditor(editor);
    this.attach(editor);
    if (!editor.isAttachedToDOM) {
      const div = editor.render();
      this.div.append(div);
      editor.isAttachedToDOM = true;
    }
    editor.fixAndSetPosition();
    editor.onceAdded();
    this.#uiManager.addToAnnotationStorage(editor);
    editor._reportTelemetry(editor.telemetryInitialData);
  }
  moveEditorInDOM(editor) {
    if (!editor.isAttachedToDOM) {
      return;
    }
    const {
      activeElement
    } = document;
    if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {
      editor._focusEventsAllowed = false;
      this.#editorFocusTimeoutId = setTimeout(() => {
        this.#editorFocusTimeoutId = null;
        if (!editor.div.contains(document.activeElement)) {
          editor.div.addEventListener("focusin", () => {
            editor._focusEventsAllowed = true;
          }, {
            once: true
          });
          activeElement.focus();
        } else {
          editor._focusEventsAllowed = true;
        }
      }, 0);
    }
    editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
  }
  addOrRebuild(editor) {
    if (editor.needsToBeRebuilt()) {
      editor.parent ||= this;
      editor.rebuild();
      editor.show();
    } else {
      this.add(editor);
    }
  }
  addUndoableEditor(editor) {
    const cmd = () => editor._uiManager.rebuild(editor);
    const undo = () => {
      editor.remove();
    };
    this.addCommands({
      cmd,
      undo,
      mustExec: false
    });
  }
  getNextId() {
    return this.#uiManager.getId();
  }
  get #currentEditorType() {
    return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());
  }
  #createNewEditor(params) {
    const editorType = this.#currentEditorType;
    return editorType ? new editorType.prototype.constructor(params) : null;
  }
  canCreateNewEmptyEditor() {
    return this.#currentEditorType?.canCreateNewEmptyEditor();
  }
  pasteEditor(mode, params) {
    this.#uiManager.updateToolbar(mode);
    this.#uiManager.updateMode(mode);
    const {
      offsetX,
      offsetY
    } = this.#getCenterPoint();
    const id2 = this.getNextId();
    const editor = this.#createNewEditor({
      parent: this,
      id: id2,
      x: offsetX,
      y: offsetY,
      uiManager: this.#uiManager,
      isCentered: true,
      ...params
    });
    if (editor) {
      this.add(editor);
    }
  }
  deserialize(data2) {
    return AnnotationEditorLayer.#editorTypes.get(data2.annotationType ?? data2.annotationEditorType)?.deserialize(data2, this, this.#uiManager) || null;
  }
  createAndAddNewEditor(event, isCentered, data2 = {}) {
    const id2 = this.getNextId();
    const editor = this.#createNewEditor({
      parent: this,
      id: id2,
      x: event.offsetX,
      y: event.offsetY,
      uiManager: this.#uiManager,
      isCentered,
      ...data2
    });
    if (editor) {
      this.add(editor);
    }
    return editor;
  }
  #getCenterPoint() {
    const {
      x: x2,
      y: y2,
      width,
      height
    } = this.div.getBoundingClientRect();
    const tlX = Math.max(0, x2);
    const tlY = Math.max(0, y2);
    const brX = Math.min(window.innerWidth, x2 + width);
    const brY = Math.min(window.innerHeight, y2 + height);
    const centerX = (tlX + brX) / 2 - x2;
    const centerY = (tlY + brY) / 2 - y2;
    const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX];
    return {
      offsetX,
      offsetY
    };
  }
  addNewEditor() {
    this.createAndAddNewEditor(this.#getCenterPoint(), true);
  }
  setSelected(editor) {
    this.#uiManager.setSelected(editor);
  }
  toggleSelected(editor) {
    this.#uiManager.toggleSelected(editor);
  }
  isSelected(editor) {
    return this.#uiManager.isSelected(editor);
  }
  unselect(editor) {
    this.#uiManager.unselect(editor);
  }
  pointerup(event) {
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    if (event.target !== this.div) {
      return;
    }
    if (!this.#hadPointerDown) {
      return;
    }
    this.#hadPointerDown = false;
    if (!this.#allowClick) {
      this.#allowClick = true;
      return;
    }
    if (this.#uiManager.getMode() === AnnotationEditorType$1.STAMP) {
      this.#uiManager.unselectAll();
      return;
    }
    this.createAndAddNewEditor(event, false);
  }
  pointerdown(event) {
    if (this.#uiManager.getMode() === AnnotationEditorType$1.HIGHLIGHT) {
      this.enableTextSelection();
    }
    if (this.#hadPointerDown) {
      this.#hadPointerDown = false;
      return;
    }
    const {
      isMac
    } = util_FeatureTest.platform;
    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }
    if (event.target !== this.div) {
      return;
    }
    this.#hadPointerDown = true;
    const editor = this.#uiManager.getActive();
    this.#allowClick = !editor || editor.isEmpty();
  }
  findNewParent(editor, x2, y2) {
    const layer = this.#uiManager.findParent(x2, y2);
    if (layer === null || layer === this) {
      return false;
    }
    layer.changeParent(editor);
    return true;
  }
  destroy() {
    if (this.#uiManager.getActive()?.parent === this) {
      this.#uiManager.commitOrRemove();
      this.#uiManager.setActiveEditor(null);
    }
    if (this.#editorFocusTimeoutId) {
      clearTimeout(this.#editorFocusTimeoutId);
      this.#editorFocusTimeoutId = null;
    }
    for (const editor of this.#editors.values()) {
      this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
      editor.setParent(null);
      editor.isAttachedToDOM = false;
      editor.div.remove();
    }
    this.div = null;
    this.#editors.clear();
    this.#uiManager.removeLayer(this);
  }
  #cleanup() {
    this.#isCleaningUp = true;
    for (const editor of this.#editors.values()) {
      if (editor.isEmpty()) {
        editor.remove();
      }
    }
    this.#isCleaningUp = false;
  }
  render({
    viewport
  }) {
    this.viewport = viewport;
    setLayerDimensions$1(this.div, viewport);
    for (const editor of this.#uiManager.getEditors(this.pageIndex)) {
      this.add(editor);
      editor.rebuild();
    }
    this.updateMode();
  }
  update({
    viewport
  }) {
    this.#uiManager.commitOrRemove();
    this.#cleanup();
    const oldRotation = this.viewport.rotation;
    const rotation = viewport.rotation;
    this.viewport = viewport;
    setLayerDimensions$1(this.div, {
      rotation
    });
    if (oldRotation !== rotation) {
      for (const editor of this.#editors.values()) {
        editor.rotate(rotation);
      }
    }
    this.addInkEditorIfNeeded(false);
  }
  get pageDimensions() {
    const {
      pageWidth,
      pageHeight
    } = this.viewport.rawDims;
    return [pageWidth, pageHeight];
  }
  get scale() {
    return this.#uiManager.viewParameters.realScale;
  }
};
let DrawLayer$1 = class DrawLayer {
  #parent = null;
  #id = 0;
  #mapping = /* @__PURE__ */ new Map();
  #toUpdate = /* @__PURE__ */ new Map();
  constructor({
    pageIndex
  }) {
    this.pageIndex = pageIndex;
  }
  setParent(parent) {
    if (!this.#parent) {
      this.#parent = parent;
      return;
    }
    if (this.#parent !== parent) {
      if (this.#mapping.size > 0) {
        for (const root of this.#mapping.values()) {
          root.remove();
          parent.append(root);
        }
      }
      this.#parent = parent;
    }
  }
  static get _svgFactory() {
    return shadow$1(this, "_svgFactory", new DOMSVGFactory$1());
  }
  static #setBox(element, {
    x: x2 = 0,
    y: y2 = 0,
    width = 1,
    height = 1
  } = {}) {
    const {
      style: style2
    } = element;
    style2.top = `${100 * y2}%`;
    style2.left = `${100 * x2}%`;
    style2.width = `${100 * width}%`;
    style2.height = `${100 * height}%`;
  }
  #createSVG(box) {
    const svg = DrawLayer._svgFactory.create(1, 1, true);
    this.#parent.append(svg);
    svg.setAttribute("aria-hidden", true);
    DrawLayer.#setBox(svg, box);
    return svg;
  }
  #createClipPath(defs, pathId) {
    const clipPath = DrawLayer._svgFactory.createElement("clipPath");
    defs.append(clipPath);
    const clipPathId = `clip_${pathId}`;
    clipPath.setAttribute("id", clipPathId);
    clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
    const clipPathUse = DrawLayer._svgFactory.createElement("use");
    clipPath.append(clipPathUse);
    clipPathUse.setAttribute("href", `#${pathId}`);
    clipPathUse.classList.add("clip");
    return clipPathId;
  }
  highlight(outlines, color, opacity, isPathUpdatable = false) {
    const id2 = this.#id++;
    const root = this.#createSVG(outlines.box);
    root.classList.add("highlight");
    if (outlines.free) {
      root.classList.add("free");
    }
    const defs = DrawLayer._svgFactory.createElement("defs");
    root.append(defs);
    const path = DrawLayer._svgFactory.createElement("path");
    defs.append(path);
    const pathId = `path_p${this.pageIndex}_${id2}`;
    path.setAttribute("id", pathId);
    path.setAttribute("d", outlines.toSVGPath());
    if (isPathUpdatable) {
      this.#toUpdate.set(id2, path);
    }
    const clipPathId = this.#createClipPath(defs, pathId);
    const use = DrawLayer._svgFactory.createElement("use");
    root.append(use);
    root.setAttribute("fill", color);
    root.setAttribute("fill-opacity", opacity);
    use.setAttribute("href", `#${pathId}`);
    this.#mapping.set(id2, root);
    return {
      id: id2,
      clipPathId: `url(#${clipPathId})`
    };
  }
  highlightOutline(outlines) {
    const id2 = this.#id++;
    const root = this.#createSVG(outlines.box);
    root.classList.add("highlightOutline");
    const defs = DrawLayer._svgFactory.createElement("defs");
    root.append(defs);
    const path = DrawLayer._svgFactory.createElement("path");
    defs.append(path);
    const pathId = `path_p${this.pageIndex}_${id2}`;
    path.setAttribute("id", pathId);
    path.setAttribute("d", outlines.toSVGPath());
    path.setAttribute("vector-effect", "non-scaling-stroke");
    let maskId;
    if (outlines.free) {
      root.classList.add("free");
      const mask = DrawLayer._svgFactory.createElement("mask");
      defs.append(mask);
      maskId = `mask_p${this.pageIndex}_${id2}`;
      mask.setAttribute("id", maskId);
      mask.setAttribute("maskUnits", "objectBoundingBox");
      const rect = DrawLayer._svgFactory.createElement("rect");
      mask.append(rect);
      rect.setAttribute("width", "1");
      rect.setAttribute("height", "1");
      rect.setAttribute("fill", "white");
      const use = DrawLayer._svgFactory.createElement("use");
      mask.append(use);
      use.setAttribute("href", `#${pathId}`);
      use.setAttribute("stroke", "none");
      use.setAttribute("fill", "black");
      use.setAttribute("fill-rule", "nonzero");
      use.classList.add("mask");
    }
    const use1 = DrawLayer._svgFactory.createElement("use");
    root.append(use1);
    use1.setAttribute("href", `#${pathId}`);
    if (maskId) {
      use1.setAttribute("mask", `url(#${maskId})`);
    }
    const use2 = use1.cloneNode();
    root.append(use2);
    use1.classList.add("mainOutline");
    use2.classList.add("secondaryOutline");
    this.#mapping.set(id2, root);
    return id2;
  }
  finalizeLine(id2, line2) {
    const path = this.#toUpdate.get(id2);
    this.#toUpdate.delete(id2);
    this.updateBox(id2, line2.box);
    path.setAttribute("d", line2.toSVGPath());
  }
  updateLine(id2, line2) {
    const root = this.#mapping.get(id2);
    const defs = root.firstChild;
    const path = defs.firstChild;
    path.setAttribute("d", line2.toSVGPath());
  }
  removeFreeHighlight(id2) {
    this.remove(id2);
    this.#toUpdate.delete(id2);
  }
  updatePath(id2, line2) {
    this.#toUpdate.get(id2).setAttribute("d", line2.toSVGPath());
  }
  updateBox(id2, box) {
    DrawLayer.#setBox(this.#mapping.get(id2), box);
  }
  show(id2, visible) {
    this.#mapping.get(id2).classList.toggle("hidden", !visible);
  }
  rotate(id2, angle) {
    this.#mapping.get(id2).setAttribute("data-main-rotation", angle);
  }
  changeColor(id2, color) {
    this.#mapping.get(id2).setAttribute("fill", color);
  }
  changeOpacity(id2, opacity) {
    this.#mapping.get(id2).setAttribute("fill-opacity", opacity);
  }
  addClass(id2, className) {
    this.#mapping.get(id2).classList.add(className);
  }
  removeClass(id2, className) {
    this.#mapping.get(id2).classList.remove(className);
  }
  remove(id2) {
    if (this.#parent === null) {
      return;
    }
    this.#mapping.get(id2).remove();
    this.#mapping.delete(id2);
  }
  destroy() {
    this.#parent = null;
    for (const root of this.#mapping.values()) {
      root.remove();
    }
    this.#mapping.clear();
  }
};
__webpack_exports__$1.AbortException;
__webpack_exports__$1.AnnotationEditorLayer;
__webpack_exports__$1.AnnotationEditorParamsType;
__webpack_exports__$1.AnnotationEditorType;
__webpack_exports__$1.AnnotationEditorUIManager;
__webpack_exports__$1.AnnotationLayer;
__webpack_exports__$1.AnnotationMode;
__webpack_exports__$1.CMapCompressionType;
__webpack_exports__$1.ColorPicker;
__webpack_exports__$1.DOMSVGFactory;
__webpack_exports__$1.DrawLayer;
__webpack_exports__$1.FeatureTest;
var __webpack_exports__GlobalWorkerOptions = __webpack_exports__$1.GlobalWorkerOptions;
__webpack_exports__$1.ImageKind;
__webpack_exports__$1.InvalidPDFException;
__webpack_exports__$1.MissingPDFException;
__webpack_exports__$1.OPS;
__webpack_exports__$1.Outliner;
__webpack_exports__$1.PDFDataRangeTransport;
__webpack_exports__$1.PDFDateString;
__webpack_exports__$1.PDFWorker;
__webpack_exports__$1.PasswordResponses;
__webpack_exports__$1.PermissionFlag;
__webpack_exports__$1.PixelsPerInch;
__webpack_exports__$1.RenderingCancelledException;
__webpack_exports__$1.TextLayer;
__webpack_exports__$1.UnexpectedResponseException;
__webpack_exports__$1.Util;
__webpack_exports__$1.VerbosityLevel;
__webpack_exports__$1.XfaLayer;
__webpack_exports__$1.build;
__webpack_exports__$1.createValidAbsoluteUrl;
__webpack_exports__$1.fetchData;
var __webpack_exports__getDocument = __webpack_exports__$1.getDocument;
__webpack_exports__$1.getFilenameFromUrl;
__webpack_exports__$1.getPdfFilenameFromUrl;
__webpack_exports__$1.getXfaPageViewport;
__webpack_exports__$1.isDataScheme;
__webpack_exports__$1.isPdfFile;
__webpack_exports__$1.noContextMenu;
__webpack_exports__$1.normalizeUnicode;
__webpack_exports__$1.renderTextLayer;
__webpack_exports__$1.setLayerDimensions;
__webpack_exports__$1.shadow;
__webpack_exports__$1.updateTextLayer;
__webpack_exports__$1.version;
var BookType = /* @__PURE__ */ ((BookType2) => {
  BookType2["pdf"] = "pdf";
  BookType2["epub"] = "epub";
  BookType2["mobi"] = "mobi";
  BookType2["azw3"] = "azw3";
  BookType2["fb2"] = "fb2";
  BookType2["cbz"] = "cbz";
  return BookType2;
})(BookType || {});
var sparkMd5 = { exports: {} };
(function(module, exports) {
  (function(factory) {
    {
      module.exports = factory();
    }
  })(function(undefined$1) {
    var hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    function md5cycle(x2, k2) {
      var a2 = x2[0], b2 = x2[1], c = x2[2], d = x2[3];
      a2 += (b2 & c | ~b2 & d) + k2[0] - 680876936 | 0;
      a2 = (a2 << 7 | a2 >>> 25) + b2 | 0;
      d += (a2 & b2 | ~a2 & c) + k2[1] - 389564586 | 0;
      d = (d << 12 | d >>> 20) + a2 | 0;
      c += (d & a2 | ~d & b2) + k2[2] + 606105819 | 0;
      c = (c << 17 | c >>> 15) + d | 0;
      b2 += (c & d | ~c & a2) + k2[3] - 1044525330 | 0;
      b2 = (b2 << 22 | b2 >>> 10) + c | 0;
      a2 += (b2 & c | ~b2 & d) + k2[4] - 176418897 | 0;
      a2 = (a2 << 7 | a2 >>> 25) + b2 | 0;
      d += (a2 & b2 | ~a2 & c) + k2[5] + 1200080426 | 0;
      d = (d << 12 | d >>> 20) + a2 | 0;
      c += (d & a2 | ~d & b2) + k2[6] - 1473231341 | 0;
      c = (c << 17 | c >>> 15) + d | 0;
      b2 += (c & d | ~c & a2) + k2[7] - 45705983 | 0;
      b2 = (b2 << 22 | b2 >>> 10) + c | 0;
      a2 += (b2 & c | ~b2 & d) + k2[8] + 1770035416 | 0;
      a2 = (a2 << 7 | a2 >>> 25) + b2 | 0;
      d += (a2 & b2 | ~a2 & c) + k2[9] - 1958414417 | 0;
      d = (d << 12 | d >>> 20) + a2 | 0;
      c += (d & a2 | ~d & b2) + k2[10] - 42063 | 0;
      c = (c << 17 | c >>> 15) + d | 0;
      b2 += (c & d | ~c & a2) + k2[11] - 1990404162 | 0;
      b2 = (b2 << 22 | b2 >>> 10) + c | 0;
      a2 += (b2 & c | ~b2 & d) + k2[12] + 1804603682 | 0;
      a2 = (a2 << 7 | a2 >>> 25) + b2 | 0;
      d += (a2 & b2 | ~a2 & c) + k2[13] - 40341101 | 0;
      d = (d << 12 | d >>> 20) + a2 | 0;
      c += (d & a2 | ~d & b2) + k2[14] - 1502002290 | 0;
      c = (c << 17 | c >>> 15) + d | 0;
      b2 += (c & d | ~c & a2) + k2[15] + 1236535329 | 0;
      b2 = (b2 << 22 | b2 >>> 10) + c | 0;
      a2 += (b2 & d | c & ~d) + k2[1] - 165796510 | 0;
      a2 = (a2 << 5 | a2 >>> 27) + b2 | 0;
      d += (a2 & c | b2 & ~c) + k2[6] - 1069501632 | 0;
      d = (d << 9 | d >>> 23) + a2 | 0;
      c += (d & b2 | a2 & ~b2) + k2[11] + 643717713 | 0;
      c = (c << 14 | c >>> 18) + d | 0;
      b2 += (c & a2 | d & ~a2) + k2[0] - 373897302 | 0;
      b2 = (b2 << 20 | b2 >>> 12) + c | 0;
      a2 += (b2 & d | c & ~d) + k2[5] - 701558691 | 0;
      a2 = (a2 << 5 | a2 >>> 27) + b2 | 0;
      d += (a2 & c | b2 & ~c) + k2[10] + 38016083 | 0;
      d = (d << 9 | d >>> 23) + a2 | 0;
      c += (d & b2 | a2 & ~b2) + k2[15] - 660478335 | 0;
      c = (c << 14 | c >>> 18) + d | 0;
      b2 += (c & a2 | d & ~a2) + k2[4] - 405537848 | 0;
      b2 = (b2 << 20 | b2 >>> 12) + c | 0;
      a2 += (b2 & d | c & ~d) + k2[9] + 568446438 | 0;
      a2 = (a2 << 5 | a2 >>> 27) + b2 | 0;
      d += (a2 & c | b2 & ~c) + k2[14] - 1019803690 | 0;
      d = (d << 9 | d >>> 23) + a2 | 0;
      c += (d & b2 | a2 & ~b2) + k2[3] - 187363961 | 0;
      c = (c << 14 | c >>> 18) + d | 0;
      b2 += (c & a2 | d & ~a2) + k2[8] + 1163531501 | 0;
      b2 = (b2 << 20 | b2 >>> 12) + c | 0;
      a2 += (b2 & d | c & ~d) + k2[13] - 1444681467 | 0;
      a2 = (a2 << 5 | a2 >>> 27) + b2 | 0;
      d += (a2 & c | b2 & ~c) + k2[2] - 51403784 | 0;
      d = (d << 9 | d >>> 23) + a2 | 0;
      c += (d & b2 | a2 & ~b2) + k2[7] + 1735328473 | 0;
      c = (c << 14 | c >>> 18) + d | 0;
      b2 += (c & a2 | d & ~a2) + k2[12] - 1926607734 | 0;
      b2 = (b2 << 20 | b2 >>> 12) + c | 0;
      a2 += (b2 ^ c ^ d) + k2[5] - 378558 | 0;
      a2 = (a2 << 4 | a2 >>> 28) + b2 | 0;
      d += (a2 ^ b2 ^ c) + k2[8] - 2022574463 | 0;
      d = (d << 11 | d >>> 21) + a2 | 0;
      c += (d ^ a2 ^ b2) + k2[11] + 1839030562 | 0;
      c = (c << 16 | c >>> 16) + d | 0;
      b2 += (c ^ d ^ a2) + k2[14] - 35309556 | 0;
      b2 = (b2 << 23 | b2 >>> 9) + c | 0;
      a2 += (b2 ^ c ^ d) + k2[1] - 1530992060 | 0;
      a2 = (a2 << 4 | a2 >>> 28) + b2 | 0;
      d += (a2 ^ b2 ^ c) + k2[4] + 1272893353 | 0;
      d = (d << 11 | d >>> 21) + a2 | 0;
      c += (d ^ a2 ^ b2) + k2[7] - 155497632 | 0;
      c = (c << 16 | c >>> 16) + d | 0;
      b2 += (c ^ d ^ a2) + k2[10] - 1094730640 | 0;
      b2 = (b2 << 23 | b2 >>> 9) + c | 0;
      a2 += (b2 ^ c ^ d) + k2[13] + 681279174 | 0;
      a2 = (a2 << 4 | a2 >>> 28) + b2 | 0;
      d += (a2 ^ b2 ^ c) + k2[0] - 358537222 | 0;
      d = (d << 11 | d >>> 21) + a2 | 0;
      c += (d ^ a2 ^ b2) + k2[3] - 722521979 | 0;
      c = (c << 16 | c >>> 16) + d | 0;
      b2 += (c ^ d ^ a2) + k2[6] + 76029189 | 0;
      b2 = (b2 << 23 | b2 >>> 9) + c | 0;
      a2 += (b2 ^ c ^ d) + k2[9] - 640364487 | 0;
      a2 = (a2 << 4 | a2 >>> 28) + b2 | 0;
      d += (a2 ^ b2 ^ c) + k2[12] - 421815835 | 0;
      d = (d << 11 | d >>> 21) + a2 | 0;
      c += (d ^ a2 ^ b2) + k2[15] + 530742520 | 0;
      c = (c << 16 | c >>> 16) + d | 0;
      b2 += (c ^ d ^ a2) + k2[2] - 995338651 | 0;
      b2 = (b2 << 23 | b2 >>> 9) + c | 0;
      a2 += (c ^ (b2 | ~d)) + k2[0] - 198630844 | 0;
      a2 = (a2 << 6 | a2 >>> 26) + b2 | 0;
      d += (b2 ^ (a2 | ~c)) + k2[7] + 1126891415 | 0;
      d = (d << 10 | d >>> 22) + a2 | 0;
      c += (a2 ^ (d | ~b2)) + k2[14] - 1416354905 | 0;
      c = (c << 15 | c >>> 17) + d | 0;
      b2 += (d ^ (c | ~a2)) + k2[5] - 57434055 | 0;
      b2 = (b2 << 21 | b2 >>> 11) + c | 0;
      a2 += (c ^ (b2 | ~d)) + k2[12] + 1700485571 | 0;
      a2 = (a2 << 6 | a2 >>> 26) + b2 | 0;
      d += (b2 ^ (a2 | ~c)) + k2[3] - 1894986606 | 0;
      d = (d << 10 | d >>> 22) + a2 | 0;
      c += (a2 ^ (d | ~b2)) + k2[10] - 1051523 | 0;
      c = (c << 15 | c >>> 17) + d | 0;
      b2 += (d ^ (c | ~a2)) + k2[1] - 2054922799 | 0;
      b2 = (b2 << 21 | b2 >>> 11) + c | 0;
      a2 += (c ^ (b2 | ~d)) + k2[8] + 1873313359 | 0;
      a2 = (a2 << 6 | a2 >>> 26) + b2 | 0;
      d += (b2 ^ (a2 | ~c)) + k2[15] - 30611744 | 0;
      d = (d << 10 | d >>> 22) + a2 | 0;
      c += (a2 ^ (d | ~b2)) + k2[6] - 1560198380 | 0;
      c = (c << 15 | c >>> 17) + d | 0;
      b2 += (d ^ (c | ~a2)) + k2[13] + 1309151649 | 0;
      b2 = (b2 << 21 | b2 >>> 11) + c | 0;
      a2 += (c ^ (b2 | ~d)) + k2[4] - 145523070 | 0;
      a2 = (a2 << 6 | a2 >>> 26) + b2 | 0;
      d += (b2 ^ (a2 | ~c)) + k2[11] - 1120210379 | 0;
      d = (d << 10 | d >>> 22) + a2 | 0;
      c += (a2 ^ (d | ~b2)) + k2[2] + 718787259 | 0;
      c = (c << 15 | c >>> 17) + d | 0;
      b2 += (d ^ (c | ~a2)) + k2[9] - 343485551 | 0;
      b2 = (b2 << 21 | b2 >>> 11) + c | 0;
      x2[0] = a2 + x2[0] | 0;
      x2[1] = b2 + x2[1] | 0;
      x2[2] = c + x2[2] | 0;
      x2[3] = d + x2[3] | 0;
    }
    function md5blk(s) {
      var md5blks = [], i2;
      for (i2 = 0; i2 < 64; i2 += 4) {
        md5blks[i2 >> 2] = s.charCodeAt(i2) + (s.charCodeAt(i2 + 1) << 8) + (s.charCodeAt(i2 + 2) << 16) + (s.charCodeAt(i2 + 3) << 24);
      }
      return md5blks;
    }
    function md5blk_array(a2) {
      var md5blks = [], i2;
      for (i2 = 0; i2 < 64; i2 += 4) {
        md5blks[i2 >> 2] = a2[i2] + (a2[i2 + 1] << 8) + (a2[i2 + 2] << 16) + (a2[i2 + 3] << 24);
      }
      return md5blks;
    }
    function md51(s) {
      var n2 = s.length, state = [1732584193, -271733879, -1732584194, 271733878], i2, length, tail, tmp, lo, hi;
      for (i2 = 64; i2 <= n2; i2 += 64) {
        md5cycle(state, md5blk(s.substring(i2 - 64, i2)));
      }
      s = s.substring(i2 - 64);
      length = s.length;
      tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (i2 = 0; i2 < length; i2 += 1) {
        tail[i2 >> 2] |= s.charCodeAt(i2) << (i2 % 4 << 3);
      }
      tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
      if (i2 > 55) {
        md5cycle(state, tail);
        for (i2 = 0; i2 < 16; i2 += 1) {
          tail[i2] = 0;
        }
      }
      tmp = n2 * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi;
      md5cycle(state, tail);
      return state;
    }
    function md51_array(a2) {
      var n2 = a2.length, state = [1732584193, -271733879, -1732584194, 271733878], i2, length, tail, tmp, lo, hi;
      for (i2 = 64; i2 <= n2; i2 += 64) {
        md5cycle(state, md5blk_array(a2.subarray(i2 - 64, i2)));
      }
      a2 = i2 - 64 < n2 ? a2.subarray(i2 - 64) : new Uint8Array(0);
      length = a2.length;
      tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (i2 = 0; i2 < length; i2 += 1) {
        tail[i2 >> 2] |= a2[i2] << (i2 % 4 << 3);
      }
      tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
      if (i2 > 55) {
        md5cycle(state, tail);
        for (i2 = 0; i2 < 16; i2 += 1) {
          tail[i2] = 0;
        }
      }
      tmp = n2 * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi;
      md5cycle(state, tail);
      return state;
    }
    function rhex(n2) {
      var s = "", j;
      for (j = 0; j < 4; j += 1) {
        s += hex_chr[n2 >> j * 8 + 4 & 15] + hex_chr[n2 >> j * 8 & 15];
      }
      return s;
    }
    function hex(x2) {
      var i2;
      for (i2 = 0; i2 < x2.length; i2 += 1) {
        x2[i2] = rhex(x2[i2]);
      }
      return x2.join("");
    }
    if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592")
      ;
    if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
      (function() {
        function clamp2(val, length) {
          val = val | 0 || 0;
          if (val < 0) {
            return Math.max(val + length, 0);
          }
          return Math.min(val, length);
        }
        ArrayBuffer.prototype.slice = function(from2, to) {
          var length = this.byteLength, begin = clamp2(from2, length), end = length, num, target, targetArray, sourceArray;
          if (to !== undefined$1) {
            end = clamp2(to, length);
          }
          if (begin > end) {
            return new ArrayBuffer(0);
          }
          num = end - begin;
          target = new ArrayBuffer(num);
          targetArray = new Uint8Array(target);
          sourceArray = new Uint8Array(this, begin, num);
          targetArray.set(sourceArray);
          return target;
        };
      })();
    }
    function toUtf8(str) {
      if (/[\u0080-\uFFFF]/.test(str)) {
        str = unescape(encodeURIComponent(str));
      }
      return str;
    }
    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
      var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i2;
      for (i2 = 0; i2 < length; i2 += 1) {
        arr[i2] = str.charCodeAt(i2);
      }
      return returnUInt8Array ? arr : buff;
    }
    function arrayBuffer2Utf8Str(buff) {
      return String.fromCharCode.apply(null, new Uint8Array(buff));
    }
    function concatenateArrayBuffers(first, second, returnUInt8Array) {
      var result = new Uint8Array(first.byteLength + second.byteLength);
      result.set(new Uint8Array(first));
      result.set(new Uint8Array(second), first.byteLength);
      return result;
    }
    function hexToBinaryString(hex2) {
      var bytes = [], length = hex2.length, x2;
      for (x2 = 0; x2 < length - 1; x2 += 2) {
        bytes.push(parseInt(hex2.substr(x2, 2), 16));
      }
      return String.fromCharCode.apply(String, bytes);
    }
    function SparkMD52() {
      this.reset();
    }
    SparkMD52.prototype.append = function(str) {
      this.appendBinary(toUtf8(str));
      return this;
    };
    SparkMD52.prototype.appendBinary = function(contents) {
      this._buff += contents;
      this._length += contents.length;
      var length = this._buff.length, i2;
      for (i2 = 64; i2 <= length; i2 += 64) {
        md5cycle(this._hash, md5blk(this._buff.substring(i2 - 64, i2)));
      }
      this._buff = this._buff.substring(i2 - 64);
      return this;
    };
    SparkMD52.prototype.end = function(raw) {
      var buff = this._buff, length = buff.length, i2, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
      for (i2 = 0; i2 < length; i2 += 1) {
        tail[i2 >> 2] |= buff.charCodeAt(i2) << (i2 % 4 << 3);
      }
      this._finish(tail, length);
      ret = hex(this._hash);
      if (raw) {
        ret = hexToBinaryString(ret);
      }
      this.reset();
      return ret;
    };
    SparkMD52.prototype.reset = function() {
      this._buff = "";
      this._length = 0;
      this._hash = [1732584193, -271733879, -1732584194, 271733878];
      return this;
    };
    SparkMD52.prototype.getState = function() {
      return {
        buff: this._buff,
        length: this._length,
        hash: this._hash.slice()
      };
    };
    SparkMD52.prototype.setState = function(state) {
      this._buff = state.buff;
      this._length = state.length;
      this._hash = state.hash;
      return this;
    };
    SparkMD52.prototype.destroy = function() {
      delete this._hash;
      delete this._buff;
      delete this._length;
    };
    SparkMD52.prototype._finish = function(tail, length) {
      var i2 = length, tmp, lo, hi;
      tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
      if (i2 > 55) {
        md5cycle(this._hash, tail);
        for (i2 = 0; i2 < 16; i2 += 1) {
          tail[i2] = 0;
        }
      }
      tmp = this._length * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi;
      md5cycle(this._hash, tail);
    };
    SparkMD52.hash = function(str, raw) {
      return SparkMD52.hashBinary(toUtf8(str), raw);
    };
    SparkMD52.hashBinary = function(content, raw) {
      var hash = md51(content), ret = hex(hash);
      return raw ? hexToBinaryString(ret) : ret;
    };
    SparkMD52.ArrayBuffer = function() {
      this.reset();
    };
    SparkMD52.ArrayBuffer.prototype.append = function(arr) {
      var buff = concatenateArrayBuffers(this._buff.buffer, arr), length = buff.length, i2;
      this._length += arr.byteLength;
      for (i2 = 64; i2 <= length; i2 += 64) {
        md5cycle(this._hash, md5blk_array(buff.subarray(i2 - 64, i2)));
      }
      this._buff = i2 - 64 < length ? new Uint8Array(buff.buffer.slice(i2 - 64)) : new Uint8Array(0);
      return this;
    };
    SparkMD52.ArrayBuffer.prototype.end = function(raw) {
      var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i2, ret;
      for (i2 = 0; i2 < length; i2 += 1) {
        tail[i2 >> 2] |= buff[i2] << (i2 % 4 << 3);
      }
      this._finish(tail, length);
      ret = hex(this._hash);
      if (raw) {
        ret = hexToBinaryString(ret);
      }
      this.reset();
      return ret;
    };
    SparkMD52.ArrayBuffer.prototype.reset = function() {
      this._buff = new Uint8Array(0);
      this._length = 0;
      this._hash = [1732584193, -271733879, -1732584194, 271733878];
      return this;
    };
    SparkMD52.ArrayBuffer.prototype.getState = function() {
      var state = SparkMD52.prototype.getState.call(this);
      state.buff = arrayBuffer2Utf8Str(state.buff);
      return state;
    };
    SparkMD52.ArrayBuffer.prototype.setState = function(state) {
      state.buff = utf8Str2ArrayBuffer(state.buff, true);
      return SparkMD52.prototype.setState.call(this, state);
    };
    SparkMD52.ArrayBuffer.prototype.destroy = SparkMD52.prototype.destroy;
    SparkMD52.ArrayBuffer.prototype._finish = SparkMD52.prototype._finish;
    SparkMD52.ArrayBuffer.hash = function(arr, raw) {
      var hash = md51_array(new Uint8Array(arr)), ret = hex(hash);
      return raw ? hexToBinaryString(ret) : ret;
    };
    return SparkMD52;
  });
})(sparkMd5);
var sparkMd5Exports = sparkMd5.exports;
const SparkMD5 = /* @__PURE__ */ getDefaultExportFromCjs(sparkMd5Exports);
const chunkSize = 1024 * 1024 * 10;
function readChunk(chunk) {
  return new Promise((resolve2, reject) => {
    const reader = new FileReader();
    reader.readAsArrayBuffer(chunk);
    reader.onload = function(event) {
      resolve2(event.target.result);
    };
    reader.onerror = function(event) {
      reject(event.target.error);
    };
  });
}
async function readFileInChunks(file2) {
  const size2 = file2.size;
  const spark = new SparkMD5.ArrayBuffer();
  let buffer = new ArrayBuffer(0);
  for (let start = 0; start < size2; start += chunkSize) {
    const end = Math.min(start + chunkSize, size2);
    const chunkBlob = file2.slice(start, end);
    const chunk = await readChunk(chunkBlob);
    buffer = concatArrayBuffers(buffer, chunk);
    spark.append(chunk);
  }
  const hash = spark.end();
  console.log("hash: ", hash);
  return { data: buffer, hash, file: file2 };
}
async function readFiles(files) {
  return await Promise.all(files.map(readFileInChunks));
}
const _hoisted_1$h = { class: "modal-box max-w-2xl" };
const _hoisted_2$e = { class: "font-bold text-lg flex justify-between mb-4" };
const _hoisted_3$b = { class: "h-full w-full text-center flex flex-col justify-center items-center" };
const _hoisted_4$b = { class: "p-5 bg-base-200 rounded-full mb-4" };
const _hoisted_5$8 = {
  key: 0,
  class: "pointer-none text-base-content text-lg"
};
const _hoisted_6$8 = {
  key: 1,
  class: "pointer-none text-base-content text-lg"
};
const _hoisted_7$6 = { class: "mx-1" };
const _hoisted_8$6 = { class: "text-info hover:underline" };
const _hoisted_9$5 = { class: "text-sm text-base-content/60 mt-2" };
const _hoisted_10$5 = { class: "mx-1" };
const _hoisted_11$5 = { key: 0 };
const _hoisted_12$4 = /* @__PURE__ */ createBaseVNode("form", {
  method: "dialog",
  class: "modal-backdrop"
}, [
  /* @__PURE__ */ createBaseVNode("button", null, "close")
], -1);
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "FileUpload",
  setup(__props, { expose: __expose }) {
    const { dialogRef, openDialog, closeDialog } = useDialog();
    const [isDragging, setDragging] = useToggle(false);
    __expose({ open: openDialog });
    const inputRef = ref(null);
    const getPDFCover = async (page) => {
      const naturalPdfSize = page.getViewport({ scale: 1 });
      const naturalPdfRatio = naturalPdfSize.width / naturalPdfSize.height;
      const appRatio = innerWidth / innerHeight;
      const pdfToAppResolutionRatio = appRatio / naturalPdfRatio;
      const scale = devicePixelRatio * pdfToAppResolutionRatio;
      const viewport = page.getViewport({ scale });
      const canvas = document.createElement("canvas");
      canvas.height = viewport.height;
      canvas.width = viewport.width;
      const canvasContext = canvas.getContext("2d");
      await page.render({ canvasContext, viewport }).promise;
      return await new Promise((resolve2) => canvas.toBlob(resolve2));
    };
    const handleFiles = async (files) => {
      try {
        const result = await readFiles(Array.from(files));
        if (result.length === 0)
          return;
        const books = await BookAction.getAll();
        const md5Set = new Set(books.map((book2) => book2.md5));
        const newBookData = result.filter(({ hash }) => {
          if (md5Set.has(hash)) {
            toastWarning(t$2("file.exist"));
            return false;
          } else {
            md5Set.add(hash);
            return true;
          }
        });
        const bookMetadata = await Promise.all(newBookData.map(async ({ data: data2, hash, file: file2 }) => {
          const reader = new Reader();
          await reader.open(file2);
          const size2 = file2.size;
          let path = "";
          if (isElectron) {
            path = await window.api.getFilePath(file2);
          }
          if (reader.book.type === "pdf") {
            const pdf2 = await __webpack_exports__getDocument({ data: cloneBuffer(data2) }).promise;
            const info2 = (await pdf2.getMetadata())?.info;
            const blob = await getPDFCover(await pdf2.getPage(1));
            const cover = await convertBlobToUint8Array(blob);
            const metadata = {
              title: info2?.Title || file2.name.replace(".pdf", ""),
              author: info2?.Author || "",
              language: info2?.Language || "",
              publishTime: info2?.CreationDate ? info2.CreationDate.replace("D:", "").split("+")[0] : "",
              publisher: info2?.Producer || "",
              description: info2?.Subject || ""
            };
            const pages = pdf2.numPages || 0;
            return {
              ...metadata,
              md5: hash,
              cover,
              path,
              data: data2,
              size: size2,
              pages
            };
          } else {
            const cover = await reader.getCover();
            const pages = reader.book.sections.length;
            return {
              ...reader.getMetadata(),
              md5: hash,
              cover: await convertBlobToUint8Array(cover),
              path,
              data: data2,
              size: size2,
              pages
            };
          }
        }));
        const newBook = bookMetadata.map((item) => {
          const { author, description, language, published, publisher, title, md5, cover, path, size: size2, pages } = item;
          return {
            id: v4(),
            md5,
            name: title,
            author: Reader.handleAuthor(author),
            description: description || "",
            language: Reader.handleAuthor(language),
            publishTime: published || "",
            publisher: publisher || "",
            cover,
            path,
            size: size2,
            pages,
            status: 0,
            category: 0,
            createTime: now(),
            updateTime: now(),
            isDelete: null,
            count: 0,
            lastReadPosition: "",
            score: -1,
            progress: 0,
            group: "",
            isLove: false,
            isReadDone: false,
            format: ""
          };
        });
        if (newBook.length) {
          await BookAction.bulkAdd(newBook);
          if (!isElectron) {
            const bookContents = bookMetadata.map((item) => {
              return {
                bookId: newBook.find((e2) => e2.md5 === item.md5).id,
                content: item.data,
                id: v4()
              };
            });
            await BookContentAction.bulkAdd(bookContents);
          }
          newBook.map((item) => toastSuccess(`${t$2("file.uploadSuccess")}: ${item.name}`));
        }
      } catch (error) {
        toastWarning(error);
        console.log(error);
      } finally {
        if (inputRef.value) {
          inputRef.value.value = "";
        }
      }
    };
    async function uploadFile(event) {
      const files = event.target.files;
      if (files === null)
        return;
      handleFiles(files);
    }
    const supportBookType = Object.values(BookType);
    const handleDrop = (e2) => {
      const files = e2.dataTransfer?.files;
      if (files) {
        handleFiles(files);
      }
      setDragging(false);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("dialog", {
        class: "modal",
        ref_key: "dialogRef",
        ref: dialogRef
      }, [
        createBaseVNode("div", _hoisted_1$h, [
          createBaseVNode("h3", _hoisted_2$e, [
            createBaseVNode("span", null, toDisplayString$1(_ctx.$t("file.upload")), 1),
            createBaseVNode("kbd", {
              class: "kbd kbd-sm cursor-pointer",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(closeDialog)())
            }, "ESC")
          ]),
          createBaseVNode("div", {
            class: normalizeClass(["flex items-center justify-center w-full", { "bg-base-200/60": unref(isDragging) }]),
            onDrop: withModifiers(handleDrop, ["prevent"]),
            onDragover: _cache[1] || (_cache[1] = withModifiers(($event) => unref(setDragging)(true), ["prevent"])),
            onDragleave: _cache[2] || (_cache[2] = ($event) => unref(setDragging)(false))
          }, [
            createBaseVNode("label", {
              class: normalizeClass(["flex flex-col rounded-lg border-4 border-dashed cursor-pointer w-full h-60 p-10 group text-center", [unref(isDragging) ? "border-accent" : "border-info"]])
            }, [
              createBaseVNode("div", _hoisted_3$b, [
                createBaseVNode("div", _hoisted_4$b, [
                  createVNode(unref(Upload))
                ]),
                unref(isDragging) ? (openBlock(), createElementBlock("p", _hoisted_5$8, toDisplayString$1(_ctx.$t("file.releaseMouse")), 1)) : (openBlock(), createElementBlock("p", _hoisted_6$8, [
                  createBaseVNode("span", null, toDisplayString$1(_ctx.$t("file.dragFile")), 1),
                  createBaseVNode("span", _hoisted_7$6, toDisplayString$1(_ctx.$t("common.or")), 1),
                  createBaseVNode("a", _hoisted_8$6, toDisplayString$1(_ctx.$t("file.choose")), 1)
                ])),
                createBaseVNode("p", _hoisted_9$5, [
                  createBaseVNode("span", null, toDisplayString$1(_ctx.$t("file.supportFormat")), 1),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(supportBookType), (item, index) => {
                    return openBlock(), createElementBlock(Fragment, null, [
                      createBaseVNode("span", _hoisted_10$5, toDisplayString$1(item), 1),
                      index < unref(supportBookType).length - 1 ? (openBlock(), createElementBlock("span", _hoisted_11$5, "/")) : createCommentVNode("", true)
                    ], 64);
                  }), 256))
                ])
              ]),
              createBaseVNode("input", {
                type: "file",
                ref_key: "inputRef",
                ref: inputRef,
                multiple: "",
                class: "hidden",
                onChange: uploadFile
              }, null, 544)
            ], 2)
          ], 34)
        ]),
        _hoisted_12$4
      ], 512);
    };
  }
});
const useToggleDrawer = () => {
  const isLG = ref(false);
  function toggleDrawer() {
    const { width } = useWindowSize();
    if (width.value >= 1024) {
      isLG.value = !isLG.value;
    }
  }
  return { isLG, toggleDrawer };
};
let id$1 = 0;
function createToastConatiner(position) {
  const className = (position.length > 0 ? ".toast." : ".toast") + position.join(".");
  const conatiner = $(className);
  if (conatiner) {
    return conatiner;
  }
  const div = createElement("div");
  div.className = "toast text-[16px] " + position.join(" ");
  div.style.zIndex = "1000";
  document.body.appendChild(div);
  return div;
}
function createAlert(type, id2) {
  const alert = createElement("div");
  alert.className = "alert " + type + " rounded-md px-[0.5rem] py-[0.75rem]";
  alert.style.boxShadow = "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)";
  alert.id = id2;
  return alert;
}
function createMessage(message) {
  const span = createElement("span");
  span.innerText = message;
  return span;
}
function createCloseButton(id2) {
  const button = createElement("button");
  button.className = "btn btn-circle btn-xs";
  button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-xicon "><path d="M18 6 6 18"></path><path d="m6 6 12 12"></path></svg>';
  button.addEventListener("click", () => {
    remove(id2);
  });
  return button;
}
function remove(id2) {
  const toast = $(`#${id2}`);
  if (toast) {
    toast.remove();
  }
}
function Toast({ position, type, message, duration }) {
  id$1 += 1;
  const toastId = `toast-${id$1}`;
  const conatiner = createToastConatiner(position || []);
  const alert = createAlert(type || "alert-info", toastId);
  const messageElement = createMessage(message || "");
  const closeButton = createCloseButton(toastId);
  alert.appendChild(messageElement);
  alert.appendChild(closeButton);
  conatiner.appendChild(alert);
  const removeAction = () => remove(toastId);
  if (duration !== null) {
    const time = duration || 3e3;
    setTimeout(removeAction, time);
  }
  return removeAction;
}
const _withScopeId$1 = (n2) => (pushScopeId("data-v-3e30c94e"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$g = { class: "leftmenu-wrapper bg-base-100" };
const _hoisted_2$d = {
  "data-simplebar": "init",
  class: "h-[calc(100vh-64px)] lg:h-[calc(100vh-230px)]"
};
const _hoisted_3$a = { class: "menu mb-6" };
const _hoisted_4$a = { class: "mb-0.5" };
const _hoisted_5$7 = { class: "flex items-center gap-2" };
const _hoisted_6$7 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "mx-4 hidden rounded bg-base-200 px-3 py-4 lg:hidden" }, "  ", -1));
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "Menu",
  setup(__props) {
    const router2 = useRouter();
    const menus = [
      { name: "menu.book", path: RouterName.Book, icon: Book },
      { name: "menu.note", path: RouterName.Note, icon: PencilLine },
      { name: "menu.recycleBin", path: RouterName.RecycleBin, icon: Trash2 },
      { name: "menu.setting", path: RouterName.Setting, icon: Settings }
    ];
    const activeIndex = ref(-1);
    watchEffect(() => {
      const path = router2.currentRoute.value.path;
      let has2 = false;
      menus.forEach((item, index) => {
        if (path === `/${item.path}`) {
          activeIndex.value = index;
          has2 = true;
        }
      });
      if (!has2) {
        activeIndex.value = -1;
      }
    });
    return (_ctx, _cache) => {
      const _component_RouterLink = resolveComponent("RouterLink");
      return openBlock(), createElementBlock("div", _hoisted_1$g, [
        createVNode(_component_RouterLink, {
          to: unref(RouterName).Home,
          class: "flex h-16 items-center justify-center"
        }, {
          default: withCtx(() => [
            createTextVNode("BookWise")
          ]),
          _: 1
        }, 8, ["to"]),
        createBaseVNode("div", _hoisted_2$d, [
          createBaseVNode("ul", _hoisted_3$a, [
            (openBlock(), createElementBlock(Fragment, null, renderList(menus, (item, index) => {
              return createBaseVNode("li", _hoisted_4$a, [
                createVNode(_component_RouterLink, {
                  to: item.path,
                  class: normalizeClass(["hover:bg-base-content/15", { "active": index === activeIndex.value }])
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_5$7, [
                      (openBlock(), createBlock(resolveDynamicComponent(item.icon), { class: "w-4 h-4" })),
                      createTextVNode(" " + toDisplayString$1(_ctx.$t(item.name)), 1)
                    ])
                  ]),
                  _: 2
                }, 1032, ["to", "class"])
              ]);
            }), 64))
          ])
        ]),
        _hoisted_6$7
      ]);
    };
  }
});
const Menu = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__scopeId", "data-v-3e30c94e"]]);
const _hoisted_1$f = {
  role: "navigation",
  "aria-label": "Navbar",
  class: "navbar z-10 border-b border-base-200 px-3"
};
const _hoisted_2$c = { class: "gap-3 navbar-start" };
const _hoisted_3$9 = ["for"];
const _hoisted_4$9 = {
  "aria-label": "Search button",
  class: "btn hidden h-9 w-48 items-center justify-start gap-3 border-base-content/20 hover:border-transparent hover:bg-base-content/20 sm:flex btn-sm btn-outline"
};
const _hoisted_5$6 = /* @__PURE__ */ createBaseVNode("div", { class: "navbar-center" }, null, -1);
const _hoisted_6$6 = { class: "navbar-end gap-4" };
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "Navbar",
  emits: ["toggleSidebar"],
  setup(__props, { emit: __emit }) {
    const emit2 = __emit;
    const toggleSidebar = () => emit2("toggleSidebar", "");
    const { width } = useWindowSize();
    const isSM = computed(() => width.value < 1024);
    const dialogRef = ref(null);
    function uploadAction() {
      dialogRef.value?.open();
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$f, [
        createBaseVNode("div", _hoisted_2$c, [
          isSM.value ? (openBlock(), createElementBlock("label", {
            key: 0,
            for: unref(MENU_DRAWER),
            class: "cursor-pointer"
          }, [
            createVNode(unref(AlignJustify), { class: "w-5 h-5" })
          ], 8, _hoisted_3$9)) : (openBlock(), createElementBlock("button", {
            key: 1,
            "aria-label": "Leftmenu toggle",
            class: "btn btn-sm btn-square btn-ghost",
            onClick: toggleSidebar
          }, [
            createVNode(unref(AlignJustify), { class: "w-5 h-5" })
          ])),
          createBaseVNode("button", _hoisted_4$9, [
            createVNode(unref(Search), { class: "w-4 h-4" })
          ])
        ]),
        _hoisted_5$6,
        createBaseVNode("div", _hoisted_6$6, [
          createBaseVNode("button", {
            class: "btn btn-sm btn-primary",
            onClick: _cache[0] || (_cache[0] = ($event) => uploadAction())
          }, toDisplayString$1(_ctx.$t("file.upload")), 1),
          createVNode(unref(_sfc_main$m), {
            ref_key: "dialogRef",
            ref: dialogRef
          }, null, 512)
        ])
      ]);
    };
  }
});
const _hoisted_1$e = { class: "block lg:hidden" };
const _hoisted_2$b = { class: "hidden lg:block" };
const _hoisted_3$8 = { class: "w-full max-w-full h-screen" };
const _hoisted_4$8 = { class: "flex h-full flex-col" };
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "Layout",
  setup(__props) {
    const contentRef = ref(null);
    const { isLG, toggleDrawer } = useToggleDrawer();
    const store2 = useContentCantianerStore();
    const { width } = useElementSize(contentRef);
    const debouncedFn = useDebounceFn(async () => {
      store2.setWidth(width.value);
    }, 200);
    useResizeObserver(contentRef, debouncedFn);
    return (_ctx, _cache) => {
      const _component_router_view = resolveComponent("router-view");
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", _hoisted_1$e, [
          createVNode(unref(_sfc_main$B), { id: unref(MENU_DRAWER) }, {
            default: withCtx(() => [
              createVNode(Menu)
            ]),
            _: 1
          }, 8, ["id"])
        ]),
        createBaseVNode("div", _hoisted_2$b, [
          createVNode(Menu, {
            class: normalizeClass({ "hide": unref(isLG) })
          }, null, 8, ["class"])
        ]),
        createBaseVNode("div", _hoisted_3$8, [
          createBaseVNode("div", _hoisted_4$8, [
            createVNode(_sfc_main$k, { onToggleSidebar: unref(toggleDrawer) }, null, 8, ["onToggleSidebar"]),
            createBaseVNode("div", {
              ref_key: "contentRef",
              ref: contentRef,
              class: "flex-1 bg-base-200 overflow-hidden relative"
            }, [
              createVNode(_component_router_view)
            ], 512)
          ])
        ])
      ], 64);
    };
  }
});
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "Book",
  setup(__props) {
    const bookList = BookAction.observable();
    async function onClick({ id: id2 }) {
      bookJump(id2);
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(BookListView), {
        data: unref(bookList) || [],
        onClick
      }, null, 8, ["data"]);
    };
  }
});
const _hoisted_1$d = { class: "p-6 h-full overflow-auto absolute inset-0" };
const _hoisted_2$a = { class: "grid gap-5 lg:grid-cols-2 xl:grid-cols-4" };
const _hoisted_3$7 = { class: "skeleton h-40 w-full" };
const _hoisted_4$7 = { class: "card bg-base-100 shadow" };
const _hoisted_5$5 = { class: "card-body gap-2" };
const _hoisted_6$5 = { class: "flex items-start justify-between gap-2 text-sm" };
const _hoisted_7$5 = { class: "font-medium text-base-content/70" };
const _hoisted_8$5 = { class: "mt-4 flex items-center gap-2" };
const _hoisted_9$4 = { class: "inline text-2xl/none font-semibold" };
const _hoisted_10$4 = { class: "text-success mx-1" };
const _hoisted_11$4 = { class: "text-success" };
const _hoisted_12$3 = { class: "rounded bg-base-200 p-2" };
const _hoisted_13$3 = { class: "text-sm font-medium" };
const _hoisted_14$3 = { class: "text-base-content/60" };
const _hoisted_15$3 = { class: "text-success mx-[2px]" };
const _hoisted_16$3 = {
  key: 0,
  "aria-label": "Badge",
  class: "badge gap-1 border-0 bg-success/10 py-3 text-xs font-semibold text-success badge-sm ml-1.5"
};
const _hoisted_17$3 = {
  key: 1,
  "aria-label": "Badge",
  class: "badge gap-1 border-0 bg-error/10 py-3 text-xs font-semibold text-error badge-sm ml-1.5"
};
const _hoisted_18$3 = { class: "mt-6 card bg-base-100 card-bordered" };
const _hoisted_19$3 = { class: "card-body" };
const _hoisted_20$3 = { class: "card-title" };
const _hoisted_21$3 = { class: "w-full min-h-44 flex flex-row gap-6 overflow-hidden" };
const _hoisted_22$3 = {
  key: 0,
  class: "skeleton h-40 w-full mt-4"
};
const _hoisted_23$3 = ["onClick"];
const _hoisted_24$3 = ["src"];
const _hoisted_25$2 = {
  key: 1,
  class: "flex justify-center items-center w-full"
};
const _hoisted_26$2 = { class: "btn" };
const _hoisted_27$2 = { class: "badge" };
const _hoisted_28$2 = { class: "mt-6 card bg-base-100 card-bordered" };
const _hoisted_29$2 = { class: "card-body" };
const _hoisted_30$2 = { class: "card-title" };
const _hoisted_31$1 = { class: "w-full min-h-44 flex flex-row gap-6 overflow-hidden" };
const _hoisted_32$1 = {
  key: 0,
  class: "skeleton h-40 w-full mt-4"
};
const _hoisted_33$1 = ["onClick"];
const _hoisted_34$1 = ["src"];
const _hoisted_35$1 = {
  key: 1,
  class: "flex justify-center items-center w-full"
};
const _hoisted_36$1 = { class: "btn" };
const _hoisted_37 = { class: "badge" };
const bookshelfWidht = 120;
const bookshelfHeight = 100;
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "Home",
  setup(__props) {
    const statistical = ref([]);
    const store2 = useContentCantianerStore();
    const totalRecentBook = ref([]);
    const totalLoveBook = ref([]);
    const [loading, setLoading] = useToggle(false);
    function handlePercentage(num1, num2) {
      if (num1 === 0) {
        if (num2 === 0) {
          return 0;
        } else {
          return 1;
        }
      }
      if (num2 === 0) {
        return 0;
      }
      const percentage = +((num1 - num1) / num1 * 100).toFixed(4);
      return percentage;
    }
    const isThisMonth = (time) => dayjs(time).month() === dayjs().month();
    const isLastMonth = (time) => dayjs(time).month() === dayjs().month() - 1;
    const toStr = (val) => (val * 100).toFixed(2) + "%";
    async function init() {
      try {
        setLoading(true);
        const [allBook, allNotes, allime] = await Promise.all([
          BookAction.getAll(),
          NoteAction.getAll(),
          BookReadTimeAction.getAll()
        ]);
        allBook.sort((a2, b2) => b2.updateTime - a2.updateTime);
        const allReadingBook = allBook.filter((item) => item.count !== 0);
        const allReading = allReadingBook.length;
        const thisMouthReading = allReadingBook.filter((item) => isThisMonth(item.updateTime)).length;
        const lastMouthReading = allReadingBook.filter((item) => isLastMonth(item.updateTime)).length;
        const readPercentage = handlePercentage(lastMouthReading, thisMouthReading);
        const allReadedBook = allBook.filter((item) => item.isReadDone);
        const allReaded = allReadedBook.length;
        const thisMouthReaded = allReadedBook.filter((item) => isThisMonth(item.updateTime)).length;
        const lastMouthReaded = allReadedBook.filter((item) => isLastMonth(item.updateTime)).length;
        const readedPercentage = handlePercentage(lastMouthReaded, thisMouthReaded);
        const allNote = allNotes.length;
        const thisMouthNote = allNotes.filter((item) => isThisMonth(item.createTime)).length;
        const lastMouthNote = allNotes.filter((item) => isLastMonth(item.createTime)).length;
        const notePercentage = handlePercentage(lastMouthNote, thisMouthNote);
        const allReadTime = allime.reduce((pre, cur) => pre + getInterval(cur.startTime, cur.endTime), 0);
        const thisMouthReadTime = allime.filter((item) => isThisMonth(item.creatTime)).reduce((pre, cur) => pre + getInterval(cur.startTime, cur.endTime), 0);
        const lastMouthReadTime = allime.filter((item) => isLastMonth(item.creatTime)).reduce((pre, cur) => pre + getInterval(cur.startTime, cur.endTime), 0);
        const readTimePercentage = handlePercentage(lastMouthReadTime, thisMouthReadTime);
        set$1(statistical, [
          {
            title: "statistics.reading",
            desc: "statistics.total",
            total: allReading,
            percentage: toStr(readPercentage),
            detailTitle: "statistics.thisMouthReading",
            detailNum: thisMouthReading,
            detailUit: "statistics.bookUnit",
            icon: Annoyed,
            isUp: readPercentage > 0 ? true : false
          },
          {
            title: "statistics.readed",
            desc: "statistics.total",
            total: allReaded,
            percentage: toStr(readedPercentage),
            detailTitle: "statistics.thisMouthReaded",
            detailNum: thisMouthReaded,
            detailUit: "statistics.bookUnit",
            icon: CircleCheckBig,
            isUp: readedPercentage > 0 ? true : false
          },
          {
            title: "menu.note",
            desc: "statistics.total",
            total: allNote,
            percentage: toStr(notePercentage),
            detailTitle: "statistics.thisMouthNote",
            detailNum: thisMouthNote,
            detailUit: "statistics.noteUnit",
            icon: NotebookPen,
            isUp: notePercentage > 0 ? true : false
          },
          {
            title: "statistics.readTime",
            desc: "statistics.readTotalTime",
            total: allReadTime,
            percentage: toStr(readTimePercentage),
            detailTitle: "statistics.thisMouthReadTime",
            detailNum: thisMouthReadTime,
            detailUit: "statistics.readTimeUnit",
            icon: Clock,
            isUp: readTimePercentage > 0 ? true : false
          }
        ]);
        set$1(totalRecentBook, allReadingBook.slice(0, 100));
        set$1(totalLoveBook, allBook.filter((item) => item.isLove).slice(0, 100));
      } catch (err) {
      } finally {
        setLoading(false);
      }
    }
    const recentBook = computed(() => {
      const count = parseInt((store2.width / (bookshelfWidht + remToPx(2.5))).toString());
      return get(totalRecentBook).slice(0, count);
    });
    const loveBook = computed(() => {
      const count = parseInt((store2.width / (bookshelfWidht + remToPx(2.5))).toString());
      return get(totalLoveBook).slice(0, count);
    });
    init();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$d, [
        createBaseVNode("div", _hoisted_2$a, [
          unref(loading) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, renderList(4, (_2) => {
            return createBaseVNode("div", _hoisted_3$7);
          }), 64)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(statistical.value, (item) => {
            return openBlock(), createElementBlock("div", _hoisted_4$7, [
              createBaseVNode("div", _hoisted_5$5, [
                createBaseVNode("div", _hoisted_6$5, [
                  createBaseVNode("div", null, [
                    createBaseVNode("p", _hoisted_7$5, toDisplayString$1(unref(t$2)(item.title)), 1),
                    createBaseVNode("div", _hoisted_8$5, [
                      createBaseVNode("h5", _hoisted_9$4, [
                        createTextVNode(toDisplayString$1(unref(t$2)(item.desc)) + " ", 1),
                        createBaseVNode("span", _hoisted_10$4, toDisplayString$1(item.total), 1),
                        createBaseVNode("span", _hoisted_11$4, toDisplayString$1(unref(t$2)(item.detailUit)), 1)
                      ])
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_12$3, [
                    (openBlock(), createBlock(resolveDynamicComponent(item.icon), { class: "w-4 h-4" }))
                  ])
                ]),
                createBaseVNode("p", _hoisted_13$3, [
                  createBaseVNode("span", _hoisted_14$3, [
                    createTextVNode(toDisplayString$1(unref(t$2)(item.detailTitle)) + " ", 1),
                    createBaseVNode("span", _hoisted_15$3, toDisplayString$1(item.detailNum), 1),
                    createTextVNode(" " + toDisplayString$1(unref(t$2)(item.detailUit)), 1)
                  ]),
                  item.isUp ? (openBlock(), createElementBlock("div", _hoisted_16$3, [
                    createVNode(unref(MoveUp), { class: "w-2.5 h-2.5" }),
                    createTextVNode(toDisplayString$1(item.percentage), 1)
                  ])) : (openBlock(), createElementBlock("div", _hoisted_17$3, [
                    createVNode(unref(MoveUp), { class: "w-2.5 h-2.5" }),
                    createTextVNode(toDisplayString$1(item.percentage), 1)
                  ]))
                ])
              ])
            ]);
          }), 256))
        ]),
        createBaseVNode("div", _hoisted_18$3, [
          createBaseVNode("div", _hoisted_19$3, [
            createBaseVNode("h2", _hoisted_20$3, toDisplayString$1(unref(t$2)("statistics.currentReading")), 1),
            createBaseVNode("div", _hoisted_21$3, [
              unref(loading) ? (openBlock(), createElementBlock("div", _hoisted_22$3)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                recentBook.value.length > 0 ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(recentBook.value, (item) => {
                  return openBlock(), createElementBlock("div", {
                    class: "cursor-pointer",
                    onClick: ($event) => unref(bookJump)(item.id)
                  }, [
                    createBaseVNode("div", {
                      class: "rounded over-hidden",
                      style: normalizeStyle({ width: `${bookshelfWidht}px`, height: `${bookshelfHeight + unref(remToPx)(3.5)}px` })
                    }, [
                      createBaseVNode("img", {
                        src: unref(convertUint8ArrayToURL)(item.cover),
                        class: "w-full h-full rounded object-cover",
                        alt: ""
                      }, null, 8, _hoisted_24$3)
                    ], 4),
                    createBaseVNode("div", {
                      class: "line-clamp-2 mx-1 mb-1 text-sm",
                      style: normalizeStyle({ width: `${bookshelfWidht}px` })
                    }, toDisplayString$1(item.name), 5)
                  ], 8, _hoisted_23$3);
                }), 256)) : (openBlock(), createElementBlock("div", _hoisted_25$2, [
                  createBaseVNode("div", _hoisted_26$2, [
                    createBaseVNode("div", _hoisted_27$2, toDisplayString$1(unref(t$2)("common.empty")), 1)
                  ])
                ]))
              ], 64))
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_28$2, [
          createBaseVNode("div", _hoisted_29$2, [
            createBaseVNode("h2", _hoisted_30$2, toDisplayString$1(unref(t$2)("statistics.myLove")), 1),
            createBaseVNode("div", _hoisted_31$1, [
              unref(loading) ? (openBlock(), createElementBlock("div", _hoisted_32$1)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                loveBook.value.length > 0 ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(loveBook.value, (item) => {
                  return openBlock(), createElementBlock("div", {
                    class: "cursor-pointer",
                    onClick: ($event) => unref(bookJump)(item.id)
                  }, [
                    createBaseVNode("div", {
                      class: "rounded over-hidden",
                      style: normalizeStyle({ width: `${bookshelfWidht}px`, height: `${bookshelfHeight + unref(remToPx)(3.5)}px` })
                    }, [
                      createBaseVNode("img", {
                        src: unref(convertUint8ArrayToURL)(item.cover),
                        class: "w-full h-full rounded object-cover",
                        alt: ""
                      }, null, 8, _hoisted_34$1)
                    ], 4),
                    createBaseVNode("div", {
                      class: "line-clamp-2 mx-1 mb-1 text-sm",
                      style: normalizeStyle({ width: `${bookshelfWidht}px` })
                    }, toDisplayString$1(item.name), 5)
                  ], 8, _hoisted_33$1);
                }), 256)) : (openBlock(), createElementBlock("div", _hoisted_35$1, [
                  createBaseVNode("div", _hoisted_36$1, [
                    createBaseVNode("div", _hoisted_37, toDisplayString$1(unref(t$2)("common.empty")), 1)
                  ])
                ]))
              ], 64))
            ])
          ])
        ])
      ]);
    };
  }
});
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "Note",
  setup(__props) {
    const noteList = NoteAction.observable();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$t), {
        data: unref(noteList) || []
      }, null, 8, ["data"]);
    };
  }
});
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "RecycleBin",
  setup(__props) {
    const bookList = BookAction.observable(true);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(BookListView), {
        data: unref(bookList) || [],
        isRecycleBin: true
      }, null, 8, ["data"]);
    };
  }
});
function isReload() {
  let result = false;
  const oldAPI = window?.performance?.navigation?.type;
  if (oldAPI === void 0) {
    const entries = performance.getEntriesByType("navigation");
    entries.forEach((entry) => {
      if (entry.type === "reload") {
        result = true;
      }
    });
  } else {
    if (oldAPI === 1) {
      result = true;
    }
  }
  return result;
}
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "Catalog",
  props: {
    data: { default: () => [] }
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const emit2 = __emit;
    const handleClick = (e2) => {
      emit2("click", e2);
    };
    const container = ref(null);
    const bookPageStore = useBookPageStore();
    const scroll = useDebounceFn((_2) => {
      const dom = container.value;
      if (dom) {
        const acitveDom = dom.querySelector("a.active");
        if (acitveDom) {
          e$1(acitveDom, { behavior: "smooth", scrollMode: "if-needed" });
        }
      }
    }, 100);
    watchEffect(() => {
      scroll(bookPageStore.page);
    });
    return (_ctx, _cache) => {
      const _component_ExpandTreeView = resolveComponent("ExpandTreeView");
      return openBlock(), createElementBlock("div", {
        class: "catalog-wrapper bg-base-100 overflow-auto hover:scrollbar-thin scrollbar-none",
        ref_key: "container",
        ref: container
      }, [
        createVNode(_component_ExpandTreeView, {
          data: _ctx.data,
          active: unref(bookPageStore).page,
          onClick: handleClick
        }, null, 8, ["data", "active"])
      ], 512);
    };
  }
});
const CatalogView = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-eb5e86bb"]]);
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function toValue(r2) {
  return typeof r2 === "function" ? r2() : unref(r2);
}
typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
const _queue$1 = /* @__PURE__ */ new WeakMap();
function useRouteParams(name, defaultValue, options = {}) {
  const {
    mode = "replace",
    route = useRoute(),
    router: router2 = useRouter(),
    transform: transform2 = (value) => value
  } = options;
  if (!_queue$1.has(router2))
    _queue$1.set(router2, /* @__PURE__ */ new Map());
  const _paramsQueue = _queue$1.get(router2);
  let param = route.params[name];
  tryOnScopeDispose(() => {
    param = void 0;
  });
  let _trigger;
  const proxy = customRef((track2, trigger2) => {
    _trigger = trigger2;
    return {
      get() {
        track2();
        return transform2(param !== void 0 && param !== "" ? param : toValue(defaultValue));
      },
      set(v2) {
        if (param === v2)
          return;
        param = v2 === defaultValue || v2 === null ? void 0 : v2;
        _paramsQueue.set(name, v2 === defaultValue || v2 === null ? void 0 : v2);
        trigger2();
        nextTick(() => {
          if (_paramsQueue.size === 0)
            return;
          const newParams = Object.fromEntries(_paramsQueue.entries());
          _paramsQueue.clear();
          const { params, query, hash } = route;
          router2[toValue(mode)]({
            params: {
              ...params,
              ...newParams
            },
            query,
            hash
          });
        });
      }
    };
  });
  watch(
    () => route.params[name],
    (v2) => {
      param = v2;
      _trigger();
    },
    { flush: "sync" }
  );
  return proxy;
}
const _hoisted_1$c = { class: "flex flex-col select-none" };
const _hoisted_2$9 = { class: "flex flex-row gap-3" };
const _hoisted_3$6 = { class: "avatar" };
const _hoisted_4$6 = ["src"];
const _hoisted_5$4 = { class: "flex-1 flex flex-col gap-2 overflow-hidden" };
const _hoisted_6$4 = { class: "font-bold whitespace-normal" };
const _hoisted_7$4 = { class: "stat-title whitespace-normal" };
const _hoisted_8$4 = { class: "flex gap-4 ml-3 mt-5 mb-2" };
const _hoisted_9$3 = {
  key: 0,
  class: "stat-title whitespace-normal flex-1"
};
const _hoisted_10$3 = {
  key: 1,
  class: "stat-title whitespace-normal flex-1"
};
const _hoisted_11$3 = { class: "flex flex-nowrap gap-4 ml-3 mb-2 overflow-hidden" };
const _hoisted_12$2 = { class: "flex-none" };
const _hoisted_13$2 = { class: "stat-title shrink" };
const _hoisted_14$2 = { class: "flex gap-4 ml-3 mb-2" };
const _hoisted_15$2 = { class: "stat-title" };
const _hoisted_16$2 = { class: "flex gap-4 ml-3 mb-2" };
const _hoisted_17$2 = { class: "stat-title" };
const _hoisted_18$2 = { class: "flex gap-4 ml-3 mb-2" };
const _hoisted_19$2 = { class: "stat-title" };
const _hoisted_20$2 = { class: "flex gap-4 ml-3 mb-2" };
const _hoisted_21$2 = { class: "stat-title" };
const _hoisted_22$2 = { class: "link text-orange-400" };
const _hoisted_23$2 = { class: "flex gap-4 ml-3 mb-2" };
const _hoisted_24$2 = { class: "stat-title" };
const _hoisted_25$1 = { class: "flex gap-4 ml-3 mb-2" };
const _hoisted_26$1 = { class: "stat-title" };
const _hoisted_27$1 = { class: "flex gap-4 ml-3 mb-2" };
const _hoisted_28$1 = { class: "stat-title" };
const _hoisted_29$1 = { class: "flex gap-4 ml-3 mb-2" };
const _hoisted_30$1 = { class: "stat-title" };
const _hoisted_31 = { class: "flex gap-4 ml-3 mb-2" };
const _hoisted_32 = { class: "stat-title" };
const _hoisted_33 = { class: "flex gap-4 ml-3 mb-2" };
const _hoisted_34 = { class: "stat-title" };
const _hoisted_35 = {
  key: 0,
  class: "flex gap-4 ml-3 mb-2"
};
const _hoisted_36 = { class: "badge badge-accent" };
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "BookDetail",
  props: {
    book: {},
    notes: { default: () => [] },
    time: {}
  },
  setup(__props) {
    const props = __props;
    const { copy } = useClipboard();
    const copyAction = (val) => {
      if (val) {
        copy(val);
        toastSuccess(t$2("common.copySuccess"));
      }
    };
    const openBookScore = () => scroreDialog(props.book);
    const openBookEdite = () => editDialog(props.book);
    const highlightLen = computed(() => props.notes.filter((item) => item.notes === "").length);
    const notesLen = computed(() => props.notes.filter((item) => item.notes !== "").length);
    const readTimeList = BookReadTimeAction.observableOne(props.book.id);
    const totalReadTime = computed(() => {
      const list = readTimeList.value || [];
      const history2 = list.reduce((pre, cur) => pre + getInterval(cur.startTime, cur.endTime), 0);
      return (history2 + props.time).toFixed(0);
    });
    const getScore = (val) => isUndefined(val) || val === -1 ? t$2("common.unknown") : val;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$c, [
        createBaseVNode("div", _hoisted_2$9, [
          createBaseVNode("div", _hoisted_3$6, [
            createBaseVNode("div", {
              class: "w-28 min-h-36 rounded",
              onClick: _cache[0] || (_cache[0] = ($event) => openBookEdite())
            }, [
              createBaseVNode("img", {
                src: unref(convertUint8ArrayToURL)(_ctx.book.cover)
              }, null, 8, _hoisted_4$6)
            ])
          ]),
          createBaseVNode("div", _hoisted_5$4, [
            createBaseVNode("div", _hoisted_6$4, [
              createBaseVNode("span", {
                onClick: _cache[1] || (_cache[1] = ($event) => openBookEdite())
              }, toDisplayString$1(_ctx.book.name), 1),
              createBaseVNode("button", {
                class: "btn btn-xs btn-ghost",
                onClick: _cache[2] || (_cache[2] = ($event) => copyAction(_ctx.book.name))
              }, [
                createVNode(unref(Copy), { class: "w-4 h-4" })
              ])
            ]),
            createBaseVNode("div", _hoisted_7$4, [
              createBaseVNode("span", {
                onClick: _cache[3] || (_cache[3] = ($event) => openBookEdite())
              }, toDisplayString$1(_ctx.book.author), 1),
              createBaseVNode("button", {
                class: "btn btn-xs btn-ghost",
                onClick: _cache[4] || (_cache[4] = ($event) => copyAction(_ctx.book.author))
              }, [
                createVNode(unref(Copy), { class: "w-4 h-4" })
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_8$4, [
          createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.publisher")), 1),
          _ctx.book.publisher ? (openBlock(), createElementBlock("div", _hoisted_9$3, toDisplayString$1(_ctx.book.publisher), 1)) : (openBlock(), createElementBlock("div", _hoisted_10$3, toDisplayString$1(unref(t$2)("common.unknown")), 1))
        ]),
        createBaseVNode("div", _hoisted_11$3, [
          createBaseVNode("div", _hoisted_12$2, toDisplayString$1(unref(t$2)("book.publishTime")), 1),
          createBaseVNode("div", _hoisted_13$2, toDisplayString$1(_ctx.book.publishTime ? unref(dayjs)(_ctx.book.publishTime).format("L LT") : ""), 1)
        ]),
        createBaseVNode("div", _hoisted_14$2, [
          createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.createTime")), 1),
          createBaseVNode("div", _hoisted_15$2, toDisplayString$1(unref(dayjs)(_ctx.book.createTime).format("L LT")), 1)
        ]),
        createBaseVNode("div", _hoisted_16$2, [
          createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.updateTime")), 1),
          createBaseVNode("div", _hoisted_17$2, toDisplayString$1(unref(dayjs)(_ctx.book.updateTime).format("L LT")), 1)
        ]),
        createBaseVNode("div", _hoisted_18$2, [
          createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.size")), 1),
          createBaseVNode("div", _hoisted_19$2, toDisplayString$1(unref(formatFileSize)(_ctx.book.size)), 1)
        ]),
        createBaseVNode("div", _hoisted_20$2, [
          createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.page")), 1),
          createBaseVNode("div", _hoisted_21$2, toDisplayString$1(_ctx.book.pages), 1)
        ]),
        createBaseVNode("div", {
          class: "flex gap-4 ml-3 mb-2 cursor-pointer",
          onClick: _cache[6] || (_cache[6] = ($event) => openBookScore())
        }, [
          createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.score")), 1),
          createBaseVNode("div", {
            class: "rating rating-md rating-half",
            onClick: _cache[5] || (_cache[5] = ($event) => openBookScore())
          }, [
            createVNode(unref(_sfc_main$F), {
              value: _ctx.book.score,
              readonly: true
            }, null, 8, ["value"])
          ]),
          createBaseVNode("div", _hoisted_22$2, toDisplayString$1(getScore(_ctx.book.score)), 1)
        ]),
        createBaseVNode("div", _hoisted_23$2, [
          createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.openCount")), 1),
          createBaseVNode("div", _hoisted_24$2, toDisplayString$1(_ctx.book.count), 1)
        ]),
        createBaseVNode("div", _hoisted_25$1, [
          createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.readProgress")), 1),
          createBaseVNode("div", _hoisted_26$1, toDisplayString$1(unref(formatDecimal)(_ctx.book.progress * 100)) + "%", 1)
        ]),
        createBaseVNode("div", _hoisted_27$1, [
          createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.thisReadTime")), 1),
          createBaseVNode("div", _hoisted_28$1, toDisplayString$1(_ctx.time) + "", 1)
        ]),
        createBaseVNode("div", _hoisted_29$1, [
          createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.totalReadTime")), 1),
          createBaseVNode("div", _hoisted_30$1, toDisplayString$1(totalReadTime.value) + "", 1)
        ]),
        createBaseVNode("div", _hoisted_31, [
          createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.highlightLen")), 1),
          createBaseVNode("div", _hoisted_32, toDisplayString$1(highlightLen.value), 1)
        ]),
        createBaseVNode("div", _hoisted_33, [
          createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.notesLen")), 1),
          createBaseVNode("div", _hoisted_34, toDisplayString$1(notesLen.value), 1)
        ]),
        _ctx.book.group ? (openBlock(), createElementBlock("div", _hoisted_35, [
          createBaseVNode("div", null, toDisplayString$1(unref(t$2)("book.bookshelf")), 1),
          createBaseVNode("div", _hoisted_36, toDisplayString$1(unref(BookshelfAction).toBookshelf(_ctx.book.group).name), 1)
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
const _colorNames = ["red", "yellow", "emerald", "cyan", "violet"];
var HighlightType = /* @__PURE__ */ ((HighlightType2) => {
  HighlightType2["marker"] = "selection";
  HighlightType2["beeline"] = "beeline";
  HighlightType2["wavy"] = "wavy";
  return HighlightType2;
})(HighlightType || {});
class HighlightColor {
  color = "yellow";
  type = "selection";
  changeColor = (value) => {
    this.color = value;
  };
  changeType = (val) => {
    this.type = val;
  };
  getClassName = () => {
    return `${this.type}-${this.color}`;
  };
  getColors = () => {
    return _colorNames;
  };
  getBadgeColor(colorName) {
    return `bg-${colorName}-300 border-${colorName}-300 `;
  }
}
const highlightColor = new HighlightColor();
const _hoisted_1$b = { class: "flex flex-row justify-between items-center mb-1" };
const _hoisted_2$8 = { class: "stat-desc" };
const _hoisted_3$5 = { key: 0 };
const _hoisted_4$5 = ["onClick"];
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "NoteList",
  props: {
    data: { default: () => [] },
    opacity: { default: 0.5 },
    className: { default: "" },
    show: { type: Boolean, default: true }
  },
  emits: ["remove"],
  setup(__props, { emit: __emit }) {
    const emit2 = __emit;
    return (_ctx, _cache) => {
      return openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.data, (item, index) => {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(["bg-base-200 text-base-content select-none p-3 hover:bg-info hover:text-info-content", _ctx.className]),
          style: normalizeStyle({ "--tw-bg-opacity": _ctx.opacity })
        }, [
          createBaseVNode("div", _hoisted_1$b, [
            createBaseVNode("div", _hoisted_2$8, toDisplayString$1(unref(dayjs)(item.time).format("L LT")), 1),
            _ctx.show ? (openBlock(), createElementBlock("div", _hoisted_3$5, [
              createBaseVNode("button", {
                class: "btn btn-outline btn-error btn-xs",
                onClick: ($event) => emit2("remove", item, index)
              }, "", 8, _hoisted_4$5)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("p", null, toDisplayString$1(item.value), 1)
        ], 6);
      }), 256);
    };
  }
});
const _hoisted_1$a = { class: "flex flex-row gap-4" };
const _hoisted_2$7 = /* @__PURE__ */ createBaseVNode("div", { class: "flex" }, [
  /* @__PURE__ */ createBaseVNode("div", { class: "divider divider-primary h-full w-[3px] flex-col m-0 py-1" })
], -1);
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "SourceList",
  props: {
    data: { default: () => [] },
    opacity: { default: 1 },
    auto: { type: Boolean, default: true },
    className: { default: "rounded-md" }
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const porps = __props;
    const emit2 = __emit;
    const _className = ref("");
    const setName = () => set$1(_className, porps.data[0].className);
    const removeName = () => set$1(_className, "");
    const onMouseEnter = () => {
      const show = get(settingStore).isNoteShowClass;
      if (show) {
        setName();
        return;
      }
      setName();
    };
    const onMouseLeave = () => {
      const show = get(settingStore).isNoteShowClass;
      if (show) {
        setName();
        return;
      }
      if (porps.auto) {
        removeName();
      }
    };
    watchEffect(() => {
      const show = get(settingStore).isNoteShowClass;
      if (show) {
        setName();
      } else {
        if (!porps.auto) {
          if (porps.opacity === 1) {
            removeName();
          } else {
            setName();
          }
        }
      }
    });
    return (_ctx, _cache) => {
      return _ctx.data.length > 0 ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["bg-base-200 text-base-content p-3 select-none", [_className.value, _ctx.className]]),
        onClick: _cache[0] || (_cache[0] = ($event) => emit2("click")),
        onMouseover: onMouseEnter,
        onMouseleave: onMouseLeave,
        style: normalizeStyle({ "--tw-bg-opacity": _ctx.opacity })
      }, [
        createBaseVNode("div", _hoisted_1$a, [
          _hoisted_2$7,
          createBaseVNode("blockquote", null, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.data, (item) => {
              return openBlock(), createElementBlock("p", null, toDisplayString$1(item.text), 1);
            }), 256))
          ])
        ])
      ], 38)) : createCommentVNode("", true);
    };
  }
});
const DATA_WEB_HIGHLIGHT = "data-web-highlight_id";
const DATA_WEB_HIGHLIGHT_EXTRA = "data-web-highlight-extra_id";
const ROOT_INDEX = -2;
const UNKNOWN_INDEX = -1;
const ID_DIVIDION = ";";
const indexOf = (arr, val) => {
  return arr.indexOf(val);
};
const isIndexOf = (arr, val) => {
  const index = indexOf(arr, val);
  return index !== -1;
};
const isLen = (value) => value.length > 0;
const from = Array.from;
const isArray = Array.isArray;
const last = (arr) => arr[arr.length - 1];
function selector(selector2, doc2) {
  const $root = doc2 || document;
  return $root.querySelector(selector2);
}
function selctorAll(selector2, doc2) {
  const $root = doc2 || document;
  return from($root.querySelectorAll(selector2));
}
function queryDomIndex(node, root) {
  const nodeList = selctorAll(node.tagName, root);
  return indexOf(nodeList, node);
}
function unListener(el, type, fn) {
  return el?.removeEventListener(type, fn);
}
function listener(el, type, fn) {
  el.addEventListener(type, fn, { capture: false });
  return () => unListener(el, type, fn);
}
function addClass(el, className) {
  const name = className.split(",");
  el.classList.add(...name);
}
function removeClass(el, className) {
  el.classList.remove(className);
}
function replaceClass(el, newClassName, oldClassName) {
  return el.classList.replace(oldClassName, newClassName);
}
function setAttr(el, key, value) {
  el.setAttribute(key, value);
}
function getAttr(el, key) {
  return el.getAttribute(key) || "";
}
function hasAttr(el, key) {
  return el.hasAttribute(key);
}
function createFragment() {
  return document.createDocumentFragment();
}
function appendChild(el, child) {
  el.appendChild(child.cloneNode(false));
}
const regMobile = /Android|iPhone|BlackBerry|BB10|Opera Mini|Phone|Mobile|Silk|Windows Phone|Mobile(?:.+)Firefox\b/i;
const isMobile = (userAgent) => regMobile.test(userAgent);
const isNull = (val) => val === null;
const isString = (val) => typeof val === "string";
const isTextNode = (node) => node.nodeType === Node.TEXT_NODE;
const isHighlightWrapNode = (node) => node && hasAttr(node, DATA_WEB_HIGHLIGHT);
var UserInputEvent = /* @__PURE__ */ ((UserInputEvent2) => {
  UserInputEvent2["touchend"] = "touchend";
  UserInputEvent2["mouseup"] = "mouseup";
  UserInputEvent2["touchstart"] = "touchstart";
  UserInputEvent2["click"] = "click";
  UserInputEvent2["dbclick"] = "dblclick";
  UserInputEvent2["mouseover"] = "mouseover";
  return UserInputEvent2;
})(UserInputEvent || {});
var EventTypeEnum = /* @__PURE__ */ ((EventTypeEnum2) => {
  EventTypeEnum2["SOURCE"] = "selection:source";
  EventTypeEnum2["CREATE"] = "selection:create";
  EventTypeEnum2["REMOVE"] = "selection:remove";
  EventTypeEnum2["MODIFY"] = "selection:modify";
  EventTypeEnum2["HOVER"] = "selection:hover";
  EventTypeEnum2["HOVER_OUT"] = "selection:hover-out";
  EventTypeEnum2["CLICK"] = "selection:click";
  return EventTypeEnum2;
})(EventTypeEnum || {});
var CreateFrom = /* @__PURE__ */ ((CreateFrom2) => {
  CreateFrom2["source"] = "source";
  CreateFrom2["rang"] = "rang";
  return CreateFrom2;
})(CreateFrom || {});
class EventEmitter {
  constructor() {
    this._events = /* @__PURE__ */ Object.create(null);
  }
  on(type, handler) {
    if (!this._events[type]) {
      this._events[type] = [];
    }
    const has2 = this._events[type].find((item) => item === handler);
    if (!has2) {
      this._events[type].push(handler);
    }
    return this;
  }
  off(type, handler) {
    if (this._events[type]) {
      this._events[type].splice(this._events[type].indexOf(handler) >>> 0, 1);
    }
    return this;
  }
  offAll() {
    this._events = /* @__PURE__ */ Object.create(null);
  }
  emit(type, ...data2) {
    if (this._events[type]) {
      this._events[type].forEach((handler) => {
        handler(...data2);
      });
    }
    return this;
  }
}
class ErrorEventEmitter extends EventEmitter {
}
const errorEventEimtter = new ErrorEventEmitter();
const INTERNAL_ERROR_EVENT = "error";
function getInteraction() {
  const isMobile$1 = isMobile(window.navigator.userAgent);
  return {
    PointerEnd: isMobile$1 ? UserInputEvent.touchend : UserInputEvent.mouseup,
    PointerTap: isMobile$1 ? UserInputEvent.touchstart : UserInputEvent.click,
    // hover and click will be the same event in mobile
    PointerOver: isMobile$1 ? UserInputEvent.touchstart : UserInputEvent.mouseover,
    PinterDb: isMobile$1 ? UserInputEvent.touchstart : UserInputEvent.dbclick
  };
}
var ERROR = /* @__PURE__ */ ((ERROR2) => {
  ERROR2["HIGHLIGHT_SOURCE_DOM_META_INDEX"] = "[HIGHLIGHT_SOURCE_DOM_META] This highlight source dom meta index is invalid";
  ERROR2["HIGHLIGHT_ID_INDVALID"] = "[HIGHLIGHT_ID_INDVALID] This highlight id is invalid";
  ERROR2["HIGHLIGHT_SOURCE_SELECTION_NOTE"] = `[HIGHLIGHT_SOURCE_SELECTION_NOTE] This highlight source cant't get selection note.`;
  ERROR2["HOOKS_TYPE_ERROR"] = `[HOOKS_TYPE_ERROR] The Hooks callback method is wrong.`;
  ERROR2["HOOKS_CALLBACK_REURN_VALUE"] = `[HOOKS_CALLBACK_REURN_VALUE] The hooks callback return value is invalid.`;
  ERROR2["DOM_SELECTION_EMPTY"] = "[DOM] The selection contains no dom node, may be you except them.";
  ERROR2["HIGHLIGHT_SOURCE_STORE_NOT_FOUND"] = `[HIGHLIGHT_SOURCE_SOTRE_NOT_FOUND] The highlight source store not found`;
  ERROR2["HIGHLIGHT_DOM_NOT_FOUND"] = `[HIGHLIGHT_DOM_NOT_FOUND] The highlight dom not found`;
  ERROR2["PAINT_HIGHLIGHT_FAIL"] = `[PAINT_HIGHLIGHT_FAIL] Paint highlight source dom is failed`;
  ERROR2["DARA_DOM_REPEATEDLY"] = `[DARA_DOM_REPEATEDLY] draw dom repeatedly`;
  return ERROR2;
})(ERROR || {});
class Hook {
  constructor(name) {
    this.name = "";
    this.cbs = [];
    if (name) {
      this.name = name;
    }
  }
  tap(cb) {
    if (!isIndexOf(this.cbs, cb)) {
      this.cbs.push(cb);
    }
    return () => this.remove(cb);
  }
  remove(cb) {
    if (!isIndexOf(this.cbs, cb)) {
      return;
    }
    this.cbs.splice(indexOf(this.cbs, cb), 1);
  }
  isEmpty() {
    return this.cbs.length === 0;
  }
  call(...args) {
    const res = [];
    try {
      this.cbs.forEach((cb) => {
        res.push(cb(...args));
      });
    } catch (err) {
      errorEventEimtter.emit(INTERNAL_ERROR_EVENT, {
        type: ERROR.HOOKS_TYPE_ERROR,
        error: `The ${this.name} hook callback is wrong when use it.`,
        hook: this
      });
    }
    return res;
  }
}
function getHooks() {
  return {
    render: {
      UUID: new Hook("Render.UUID"),
      selectNodes: new Hook("Render.selectNodes"),
      wrapNode: new Hook("Render.wrapNode")
    },
    record: {
      saveSource: new Hook("Source.save"),
      removeSource: new Hook("Source.remove")
    }
  };
}
function handleHookCall(value, hook, id2, wrongValue) {
  let result = value;
  if (!hook.isEmpty()) {
    const res = hook.call(id2, value);
    result = last(res) || wrongValue;
  }
  return result;
}
var Mode = /* @__PURE__ */ ((Mode2) => {
  Mode2[Mode2["single"] = 0] = "single";
  Mode2[Mode2["reserve"] = 1] = "reserve";
  return Mode2;
})(Mode || {});
function getDefaultOption() {
  return {
    context: window,
    root: document.body,
    tagName: "i",
    mode: Mode.single,
    className: "",
    showError: false,
    ignore: [],
    auto: true,
    pageAttribateName: "data-page-number",
    dynamic: false
    // 
  };
}
const _option = getDefaultOption();
function setOption(option) {
  Object.assign(_option, option);
}
function getOption() {
  return _option;
}
const getOrinalParent = (node) => {
  if (node instanceof HTMLElement && !isHighlightWrapNode(node)) {
    return node;
  }
  let parent = node.parentNode;
  while (isHighlightWrapNode(parent)) {
    parent = parent.parentNode;
  }
  return parent;
};
const getSingleOrinalParent = (node) => {
  while (!(node instanceof HTMLElement)) {
    node = node.parentNode;
  }
  return node;
};
const getTextLen$1 = (node) => node.textContent.length;
const getTextPreOffset = (orinalParent, textNode) => {
  const nodeStack = [orinalParent];
  let currentNode = void 0;
  let offset = 0;
  while (currentNode = nodeStack.pop()) {
    const children = currentNode.childNodes;
    for (let i2 = children.length - 1; i2 >= 0; i2--) {
      nodeStack.push(children[i2]);
    }
    if (isTextNode(currentNode)) {
      if (currentNode === textNode) {
        break;
      } else {
        offset += getTextLen$1(currentNode);
      }
    }
  }
  return offset;
};
const getSectionConatiner = (page) => {
  const { root, pageAttribateName } = getOption();
  return page === `${UNKNOWN_INDEX}` ? root : selector(`[${pageAttribateName}='${page}']`, root);
};
function getDomMeta(node, offset, page) {
  const { mode } = getOption();
  const root = getSectionConatiner(page);
  const orinalParent = mode === Mode.reserve ? getOrinalParent(node) : getSingleOrinalParent(node);
  const preOffset = getTextPreOffset(orinalParent, node);
  const index = orinalParent === root ? ROOT_INDEX : queryDomIndex(orinalParent, root);
  return { tagName: orinalParent.tagName, index, offset: preOffset + offset };
}
const getTextLen = (node) => node.textContent.length;
const getDomByTagNameIndex = (tagName, index, page) => {
  const root = getSectionConatiner(page);
  if (!root) {
    errorEventEimtter.emit(INTERNAL_ERROR_EVENT, {
      type: ERROR.HIGHLIGHT_SOURCE_DOM_META_INDEX,
      error: `cann't find element by  tagName: ${tagName}  and   index: ${index} , because can't the page: ${page} conatiner`
    });
    return null;
  }
  const doms = selctorAll(tagName, root);
  if (index < 0 || index > doms.length) {
    errorEventEimtter.emit(INTERNAL_ERROR_EVENT, {
      type: ERROR.HIGHLIGHT_SOURCE_DOM_META_INDEX,
      error: `cann't find element by  tagName: ${tagName}  and   index: ${index} `
    });
    return null;
  }
  return doms[index];
};
const getTextNodeByOffset = (parent, offset, isStart = true) => {
  const nodeStack = [parent];
  let currentNode = void 0;
  let curOffset = 0;
  let startOffset = 0;
  while (currentNode = nodeStack.pop()) {
    const children = currentNode.childNodes;
    for (let i2 = children.length - 1; i2 >= 0; i2--) {
      nodeStack.push(children[i2]);
    }
    if (isTextNode(currentNode)) {
      startOffset = offset - curOffset;
      curOffset += getTextLen(currentNode);
      const handler = isStart ? curOffset > offset : curOffset >= offset;
      if (handler) {
        break;
      }
    }
  }
  if (!currentNode) {
    currentNode = parent;
  }
  return { node: currentNode, offset: startOffset };
};
const getDomNode = ({ tagName, index, offset }, page, isStart = true) => {
  const dom = getDomByTagNameIndex(tagName, index, page);
  if (isNull(dom)) {
    return dom;
  }
  const node = getTextNodeByOffset(dom, offset, isStart);
  return { parent: dom, parentOffset: offset, ...node };
};
const sameTextNode = (text, startOffset, endOffset) => {
  text.splitText(startOffset);
  const node = text.nextSibling;
  node.splitText(endOffset - startOffset);
  return [{ node }];
};
const findFirstSameParentNode = (start, end) => {
  if (start.contains(end))
    return start;
  if (end.contains(start))
    return end;
  let result = start.parentElement;
  while (result) {
    if (result.contains(end)) {
      break;
    }
    result = result.parentElement;
  }
  return result;
};
const spaceTextNode = (node, start, end) => {
  const stack2 = [node];
  const result = [];
  let currentNode = void 0;
  let withinSelectedRange = false;
  while (currentNode = stack2.pop()) {
    const children = currentNode.childNodes;
    for (let i2 = children.length - 1; i2 >= 0; i2--) {
      stack2.push(children[i2]);
    }
    if (currentNode === start.node) {
      if (isTextNode(currentNode)) {
        currentNode.splitText(start.offset);
        const node2 = currentNode.nextSibling;
        result.push({ node: node2 });
      }
      withinSelectedRange = true;
    } else if (currentNode === end.node) {
      if (isTextNode(currentNode)) {
        const node2 = currentNode;
        node2.splitText(end.offset);
        result.push({ node: node2 });
      }
      break;
    } else if (withinSelectedRange && isTextNode(currentNode)) {
      result.push({ node: currentNode });
    }
  }
  return result;
};
const getAllSelectDom = (start, end) => {
  const { node: startNode, offset: startOffset } = start;
  const { node: endNode, offset: endOffset } = end;
  if (!startNode) {
    errorEventEimtter.emit(INTERNAL_ERROR_EVENT, {
      type: ERROR.HIGHLIGHT_SOURCE_SELECTION_NOTE,
      error: `Can't get start note in getAllSelectDom method action.The startNode is: ${startNode}`,
      startNode: start
    });
    return [];
  }
  if (!endNode) {
    errorEventEimtter.emit(INTERNAL_ERROR_EVENT, {
      type: ERROR.HIGHLIGHT_SOURCE_SELECTION_NOTE,
      error: `Can't get start note in getAllSelectDom method action.The startNode is: ${endNode}`,
      endNode: end
    });
    return [];
  }
  if (startNode === endNode && isTextNode(startNode)) {
    return sameTextNode(startNode, startOffset, endOffset);
  }
  const parentNode = findFirstSameParentNode(start.parent, end.parent);
  return spaceTextNode(parentNode, start, end);
};
function getSelectNodes(source) {
  const { startDomMeta, endDomMeta, page } = source;
  const startNode = getDomNode(startDomMeta, page);
  if (!startNode) {
    return startNode;
  }
  const endNode = getDomNode(endDomMeta, page, false);
  if (!endNode) {
    return endNode;
  }
  return getAllSelectDom(startNode, endNode);
}
const getParentNode = (node) => node.node.parentNode;
const getAllDom = (tagName, dataId, root = getOption().root) => {
  const data2 = `${tagName}[${DATA_WEB_HIGHLIGHT}='${dataId}']`;
  return selctorAll(data2, root);
};
const getsectionDom = (tagName, dataId, page) => {
  const root = getSectionConatiner(page);
  if (root) {
    return selector(`${tagName}[${DATA_WEB_HIGHLIGHT}='${dataId}']`, root);
  }
  return null;
};
const getPaintedIds = (selectNodes) => {
  const result = /* @__PURE__ */ new Set();
  selectNodes.forEach((selectNode) => {
    const node = getParentNode(selectNode);
    if (isHighlightWrapNode(node)) {
      const id2 = getAttr(node, DATA_WEB_HIGHLIGHT);
      if (id2) {
        result.add(id2);
      }
    }
  });
  return result;
};
const getWrapId = (selectNode) => {
  let result = "";
  const node = getParentNode(selectNode);
  if (isHighlightWrapNode(node)) {
    result = getAttr(node, DATA_WEB_HIGHLIGHT);
  }
  return result;
};
const createEleByTagName = (tagName, id2, className, extraInfo) => {
  const wrap2 = document.createElement(tagName);
  setAttr(wrap2, DATA_WEB_HIGHLIGHT, id2);
  addClass(wrap2, className);
  return wrap2;
};
const createWrap = ({ node, id: id2, className, tagName }) => {
  const wrap2 = createEleByTagName(tagName, id2, className);
  appendChild(wrap2, node);
  node.parentNode?.replaceChild(wrap2, node);
  return wrap2;
};
const paintItemNode = (wrapNode) => {
  const result = createWrap(wrapNode);
  result.normalize();
  return result;
};
const warpToRemove = (nodes) => {
  nodes.forEach((node) => {
    const parent = node.parentNode;
    const fragment = createFragment();
    node.childNodes.forEach((child) => appendChild(fragment, child));
    parent.replaceChild(fragment, node);
    parent.normalize();
  });
};
const wrapToUpdate = (nodes) => {
  nodes.forEach((node) => {
    const ids = getAttr(node, DATA_WEB_HIGHLIGHT_EXTRA).split(ID_DIVIDION);
    const newId = ids.pop();
    setAttr(node, DATA_WEB_HIGHLIGHT, newId);
    if (isLen(ids)) {
      setAttr(node, DATA_WEB_HIGHLIGHT_EXTRA, ids.join(ID_DIVIDION));
    }
  });
};
class PaintUntil {
  constructor(store2) {
    this.store = store2;
  }
  create(source) {
    const { id: id2, tagName, page } = source;
    const paintedDoms = getsectionDom(tagName, id2, page);
    if (!isNull(paintedDoms)) {
      errorEventEimtter.emit(INTERNAL_ERROR_EVENT, {
        type: ERROR.DARA_DOM_REPEATEDLY,
        error: `The highlight source has painted.`,
        detail: source
      });
      return null;
    }
    const selectNodes = getSelectNodes(source);
    if (isNull(selectNodes)) {
      return selectNodes;
    }
    if (!isLen(selectNodes)) {
      errorEventEimtter.emit(INTERNAL_ERROR_EVENT, {
        type: ERROR.DOM_SELECTION_EMPTY,
        error: `The selection contains select nodes is empty.`,
        detail: source
      });
      return null;
    }
    const mode = getOption().mode;
    if (mode === Mode.single) {
      return this.paintSingle(selectNodes, source);
    } else if (mode === Mode.reserve) {
      return null;
    } else {
      return null;
    }
  }
  remove(source) {
    const { id: id2, tagName } = source;
    const mode = getOption().mode;
    const paintedDoms = getAllDom(tagName, id2);
    const toRemove = [];
    const toUpdate = [];
    paintedDoms.forEach((dom) => {
      const extraId = mode === Mode.reserve && getAttr(dom, DATA_WEB_HIGHLIGHT_EXTRA);
      extraId ? toUpdate.push(dom) : toRemove.push(dom);
    });
    warpToRemove(toRemove);
    wrapToUpdate(toUpdate);
  }
  removeAll() {
    const { root, tagName } = getOption();
    const doms = selctorAll(`${tagName}[${DATA_WEB_HIGHLIGHT}]`, root);
    warpToRemove(doms);
  }
  getRemoveIds(source) {
    const result = [];
    const selectNodes = getSelectNodes(source);
    if (selectNodes) {
      const oldIds = getPaintedIds(selectNodes);
      result.push(...oldIds);
    }
    return result;
  }
  replaceExtraOldWrap(oldId, newId) {
    const source = this.store.get(oldId);
    if (source && isLen(source)) {
      source.forEach((item) => {
        const oldDoms = getAllDom(item.tagName, oldId);
        oldDoms.forEach((note2) => setAttr(note2, DATA_WEB_HIGHLIGHT, newId));
      });
    }
  }
  handleSelectNotes(selectNodes, source) {
    const nodes = selectNodes.map((node) => this.getOldWrapSource(node, source.page));
    const result = /* @__PURE__ */ new Set();
    let startDomMeta = source.startDomMeta;
    let endDomMeta = source.endDomMeta;
    let startId = "";
    let endId = "";
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const item = nodes[i2];
      if (isNull(item)) {
        continue;
      } else if (isString(item)) {
        result.add(item);
      } else {
        if (i2 === 0) {
          startDomMeta = item.startDomMeta;
          startId = item.id;
        }
        if (i2 === nodes.length - 1) {
          endDomMeta = item.endDomMeta;
          endId = item.id;
        }
        result.add(item.id);
      }
    }
    if (startId && endId && startId === endId) {
      return null;
    } else {
      source.startDomMeta = startDomMeta;
      source.endDomMeta = endDomMeta;
      return result;
    }
  }
  paintSingle(selectNodes, source) {
    const oldIds = this.handleSelectNotes(selectNodes, source);
    if (!oldIds) {
      return null;
    }
    const { page, id: id2 } = source;
    this.removeOldWrap(oldIds, page);
    selectNodes = getSelectNodes(source) || selectNodes;
    const res = this.paintAction(selectNodes, source);
    const root = getSectionConatiner(page);
    const doms = getAllDom(source.tagName, id2, root);
    if (isLen(doms)) {
      const _doms = doms.filter((dom) => !["IMG, IMAGE"].includes(dom.tagName.toLocaleUpperCase()));
      source.text = _doms.reduce((acc, cur) => acc += cur.innerText, "");
    } else {
      errorEventEimtter.emit(INTERNAL_ERROR_EVENT, {
        type: ERROR.HIGHLIGHT_DOM_NOT_FOUND,
        error: `Can't find the highlight dom by the id ${id2}`,
        detail: source
      });
    }
    return { wrap: res, ids: [...oldIds] };
  }
  getOldWrapSource(selectNode, page) {
    const id2 = getWrapId(selectNode);
    if (!id2)
      return null;
    const sources = this.store.get(id2);
    if (!sources) {
      errorEventEimtter.emit(INTERNAL_ERROR_EVENT, {
        type: ERROR.HIGHLIGHT_SOURCE_DOM_META_INDEX,
        error: `Can't find the source in the cache store by the id ${id2}.it happened at the getOldWrapSource function execute.`
      });
      return id2;
    }
    const source = sources.find((source2) => source2.page === page);
    if (!source) {
      errorEventEimtter.emit(INTERNAL_ERROR_EVENT, {
        type: ERROR.HIGHLIGHT_SOURCE_DOM_META_INDEX,
        error: `Can't find the source in the cache store by the id ${id2} and the page ${page}.it happened at the getOldWrapSource function execute.`
      });
      return null;
    }
    return source;
  }
  removeOldWrap(ids, page) {
    const removeDoms = [];
    const root = getSectionConatiner(page);
    ids.forEach((id2) => {
      const source = this.store.get(id2);
      if (source && isLen(source)) {
        const data2 = `${source[0].tagName}[${DATA_WEB_HIGHLIGHT}='${id2}']`;
        const doms = selctorAll(data2, root);
        if (doms) {
          removeDoms.push(...doms);
          this.store.removeOneSource(id2, page);
        }
      } else {
        errorEventEimtter.emit(INTERNAL_ERROR_EVENT, {
          type: ERROR.HIGHLIGHT_SOURCE_STORE_NOT_FOUND,
          error: `Can't find the source in the cache store by the id ${id2}.it happened at the removeOldWrap function execute.`
        });
      }
    });
    warpToRemove(removeDoms);
  }
  paintAction(selectNodes, source) {
    const { id: id2, tagName, className } = source;
    return selectNodes.map((select) => {
      return paintItemNode({ node: select.node, id: id2, className, tagName });
    });
  }
}
class RangeUtil {
  constructor() {
    this.prev = null;
  }
  getRange() {
    let result = null;
    const selection = getOption().context.getSelection();
    if (selection && !selection.isCollapsed) {
      result = selection.getRangeAt(0);
    }
    if (this.prev && this.prev === result) {
      result = null;
    }
    this.prev = result;
    return result;
  }
  removeAll() {
    const selection = getOption().context.getSelection();
    if (selection && selection.rangeCount > 0) {
      selection.removeAllRanges();
    }
    this.prev = null;
  }
}
const rangeUtil = new RangeUtil();
function createUUID(a2) {
  return a2 ? (a2 ^ Math.random() * 16 >> a2 / 4).toString(16) : ("10000000-1000-4000-8000" + -1e11).replace(
    /[018]/g,
    createUUID
  );
}
const findPageIndexNode = (node) => {
  const { pageAttribateName, root } = getOption();
  let result = null;
  if (pageAttribateName === "")
    return result;
  while (node) {
    if (node instanceof HTMLElement && node.hasAttribute(pageAttribateName)) {
      result = node;
      break;
    }
    if (node === root) {
      break;
    }
    node = node.parentNode;
  }
  return result;
};
const findPageIndex = (node) => {
  const { pageAttribateName } = getOption();
  return node.getAttribute(pageAttribateName) || `${UNKNOWN_INDEX}`;
};
const getfirstElementChild = (node) => {
  let result = node.firstElementChild;
  while (result?.firstElementChild) {
    result = result.firstElementChild;
  }
  return result;
};
const getRangeDoms = (startDom, endDom) => {
  const result = [];
  let start = startDom;
  while (start !== endDom) {
    result.push(start);
    start = start.nextSibling;
  }
  result.push(start);
  return result;
};
const getlastElementChild = (node) => {
  let result = node.lastElementChild;
  while (result?.lastElementChild) {
    result = result.lastElementChild;
  }
  return result;
};
const setRange = ({
  startDom,
  endDom,
  startOffset,
  endOffset
}) => {
  const range = document.createRange();
  if (startOffset === void 0) {
    range.setStartBefore(startDom);
  } else {
    range.setStart(startDom, startOffset);
  }
  if (endOffset === void 0) {
    range.setEndAfter(endDom);
  } else {
    range.setEnd(endDom, endOffset);
  }
  return range;
};
const oneRangeToSource = (range, id2, page) => {
  const { className, tagName } = getOption();
  const { startContainer, startOffset, endContainer, endOffset } = range;
  const startDomMeta = getDomMeta(startContainer, startOffset, page);
  const endDomMeta = getDomMeta(endContainer, endOffset, page);
  const text = range.toString();
  return { startDomMeta, endDomMeta, className, tagName, text, id: id2, page };
};
const handleSectionSource = (startSection, endSection, range) => {
  const result = [];
  if (startSection.parentNode !== endSection.parentNode)
    return { id: "", source: [] };
  const id2 = createUUID();
  if (startSection === endSection) {
    const page = findPageIndex(startSection);
    result.push(oneRangeToSource(range, id2, page));
  } else {
    const doms = getRangeDoms(startSection, endSection);
    const { startContainer, endContainer, startOffset, endOffset } = range;
    for (let i2 = 0; i2 < doms.length; i2++) {
      const dom = doms[i2];
      const page = findPageIndex(dom);
      let range2;
      if (i2 === 0) {
        const endDom = getlastElementChild(dom);
        range2 = setRange({
          startDom: startContainer,
          startOffset,
          endDom: endDom.lastChild,
          endOffset: endDom.textContent?.length || 0
        });
      } else if (i2 === doms.length - 1) {
        const startDom = getfirstElementChild(dom);
        range2 = setRange({
          startDom: startDom.lastChild,
          startOffset: 0,
          endDom: endContainer,
          endOffset
        });
      } else {
        const startDom = getfirstElementChild(dom);
        const endDom = getlastElementChild(dom);
        range2 = setRange({
          startDom: startDom.lastChild,
          startOffset: 0,
          endDom: endDom.lastChild,
          endOffset: endDom.textContent?.length || 0
        });
      }
      result.push(oneRangeToSource(range2, id2, page));
    }
  }
  return { id: id2, source: result };
};
function rangeToSource(range) {
  const { startContainer, endContainer } = range;
  const startSection = findPageIndexNode(startContainer);
  const endSection = findPageIndexNode(endContainer);
  if (startSection && endSection) {
    return handleSectionSource(startSection, endSection, range);
  } else {
    const id2 = createUUID();
    const source = oneRangeToSource(range, id2, `${UNKNOWN_INDEX}`);
    return { id: id2, source: [source] };
  }
}
class Store {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  save(id2, source) {
    const list = this.get(id2) || [];
    const newList = source.filter((item) => !list.find((sub) => sub.id === item.id));
    list.push(...newList);
    this._data.set(id2, list);
  }
  get(id2) {
    return this._data.get(id2);
  }
  getAll() {
    const result = [];
    this._data.forEach((item) => result.push(item));
    return result;
  }
  findByPage(id2, page) {
    const data2 = this._data.get(id2);
    if (data2) {
      return data2.find((item) => item.page === page);
    }
    return void 0;
  }
  remove(ids) {
    if (!isArray(ids)) {
      ids = [ids];
    }
    ids.forEach((id2) => this._data.delete(id2));
  }
  removeOneSource(id2, page) {
    const data2 = this._data.get(id2);
    if (data2) {
      const res = data2.filter((item) => item.page !== page);
      this._data.set(id2, res);
    }
  }
  removeAll() {
    const result = [];
    this._data.forEach((_2, key) => result.push(key));
    this._data.clear();
    return result;
  }
}
class WebHighlight extends EventEmitter {
  constructor(option) {
    super();
    this._hoverId = null;
    this._event = getInteraction();
    this.setOption = (option2) => {
      if (option2.root) {
        this.removeListener();
      }
      setOption(option2);
      if (option2.root) {
        this.addListener();
      }
    };
    this.fromRange = (range) => {
      const res = rangeToSource(range);
      if (!res)
        return;
      const removeIds = /* @__PURE__ */ new Set();
      const { id: id2, source } = res;
      let isPainted = false;
      if (getOption().auto) {
        const sources = source.filter((item) => {
          const [painted, ids] = this._handlePaintWrap(item);
          if (painted) {
            isPainted = true;
            ids.forEach((id22) => removeIds.add(id22));
          }
          return painted;
        });
        if (removeIds.size) {
          removeIds.forEach((id22) => {
            this._paint.replaceExtraOldWrap(id22, source[0].id);
            this._store.remove(id22);
          });
        }
        if (isPainted) {
          this._store.save(id2, sources);
          this.emit(
            EventTypeEnum.CREATE,
            { id: id2, sources, type: CreateFrom.rang, removeIds: [...removeIds] },
            this
          );
          rangeUtil.removeAll();
        }
      } else {
        source.forEach((item) => {
          const ids = this._paint.getRemoveIds(item);
          ids.forEach((id22) => removeIds.add(id22));
        });
      }
      return { source, isPainted, removeIds: [...removeIds] };
    };
    this.fromSource = (source) => {
      const data2 = /* @__PURE__ */ new Map();
      source.forEach((item) => {
        const id2 = item.id;
        const list = data2.get(id2) || [];
        list.push(item);
        data2.set(id2, list);
      });
      data2.forEach((sourceList, id2) => {
        const removeIds = /* @__PURE__ */ new Set();
        const sources = sourceList.filter((item) => {
          const [painted, ids] = this._handlePaintWrap(item);
          if (painted) {
            ids.forEach((id22) => removeIds.add(id22));
          }
          return painted;
        });
        if (isLen(sources)) {
          this._store.save(id2, sources);
          this.emit(
            EventTypeEnum.CREATE,
            { id: id2, sources, type: CreateFrom.source, removeIds: [...removeIds] },
            this
          );
          sources.map((item) => handleHookCall(item, this._hooks.record.saveSource, item.id, item));
        }
      });
    };
    this.getDomsById = (id2) => {
      return selctorAll(`[${DATA_WEB_HIGHLIGHT}='${id2}']`, getOption().root);
    };
    this.getSourceById = (id2) => {
      return this._store.get(id2);
    };
    this.remove = (id2) => {
      const source = this.getSourceById(id2);
      if (!source) {
        return;
      }
      this._store.remove(id2);
      if (isLen(source)) {
        this._paint.remove(source[0]);
        this.emit(EventTypeEnum.REMOVE, { ids: [id2] }, this);
      }
    };
    this.removeAll = () => {
      this._paint.removeAll();
      const ids = this._store.removeAll();
      this.emit(EventTypeEnum.REMOVE, { ids }, this);
    };
    this.dispose = () => {
      this.removeListener();
      this.offAll();
      this._store.removeAll();
    };
    this.addClass = (id2, className) => {
      this._handleClass(id2, (note2) => addClass(note2, className));
    };
    this.removeClass = (id2, className) => {
      this._handleClass(id2, (note2) => removeClass(note2, className));
    };
    this.click = (event) => {
      const target = event.target;
      if (isHighlightWrapNode(target)) {
        const id2 = getAttr(target, DATA_WEB_HIGHLIGHT);
        const source = this.getSourceById(id2) || [];
        const { page, container } = this._findSectionContainer(target);
        const data2 = source.find((item) => item.page === page);
        if (data2) {
          let _target = target;
          if (page) {
            _target = selctorAll(`[${DATA_WEB_HIGHLIGHT}='${id2}']`, container)[0];
          }
          this.emit(EventTypeEnum.CLICK, { id: id2, target: _target, source }, this, event);
          return;
        }
      }
      this.emit(EventTypeEnum.CLICK, { target }, this, event);
    };
    this.dbclick = (event) => {
      const target = event.target;
      if (target && !isHighlightWrapNode(target)) {
        if (target.firstChild && target.lastChild && target.lastChild.textContent) {
          const range = document.createRange();
          range.setStart(target.firstChild, 0);
          range.setEnd(target.lastChild, target.lastChild.textContent.length);
          this.fromRange(range);
        }
      }
    };
    this.hover = (event) => {
      const target = event.target;
      if (!isHighlightWrapNode(target)) {
        this._hoverId && this.emit(EventTypeEnum.HOVER_OUT, { id: this._hoverId }, this, event);
        this._hoverId = null;
        return;
      }
      const id2 = getAttr(target, DATA_WEB_HIGHLIGHT);
      if (id2 === this._hoverId) {
        return;
      }
      if (this._hoverId) {
        this.emit(EventTypeEnum.HOVER_OUT, { id: this._hoverId }, this, event);
      }
      this._hoverId = id2;
      this.emit(EventTypeEnum.HOVER_OUT, { id: this._hoverId }, this, event);
    };
    this.addListener = () => {
      const { root, dynamic } = getOption();
      if (!dynamic) {
        listener(root, this._event.PointerOver, this.hover);
        listener(root, this._event.PointerTap, this.click);
        listener(root, this._event.PointerEnd, this._handleSelection);
        listener(root, this._event.PinterDb, this.dbclick);
      }
    };
    this.removeListener = () => {
      const root = getOption().root;
      unListener(root, this._event.PointerOver, this.hover);
      unListener(root, this._event.PointerTap, this.click);
      unListener(root, this._event.PinterDb, this.dbclick);
      unListener(root, this._event.PointerEnd, this._handleSelection);
    };
    this._handleSelection = () => {
      const range = rangeUtil.getRange();
      if (range) {
        const res = this.fromRange(range);
        if (res) {
          const { source, isPainted, removeIds } = res;
          this.emit(EventTypeEnum.SOURCE, { source, isPainted, range, removeIds }, this);
        }
      }
    };
    this.__handleError = (data2) => {
      if (getOption().showError) {
        console.warn(data2);
      }
    };
    this._findSectionContainer = (target) => {
      const { root, pageAttribateName } = getOption();
      let node = target;
      while (node !== root && !hasAttr(node, pageAttribateName)) {
        node = node.parentNode;
      }
      const page = getAttr(node, pageAttribateName) || "";
      return { page, container: node };
    };
    if (option) {
      setOption(option);
    }
    this._store = new Store();
    this._hooks = getHooks();
    this._paint = new PaintUntil(this._store);
    this.addListener();
    errorEventEimtter.on(INTERNAL_ERROR_EVENT, this.__handleError);
  }
  replaceClass(id2, newClassName, oldClassName) {
    this._handleClass(id2, (note2) => replaceClass(note2, newClassName, oldClassName));
  }
  _handleClass(id2, cb) {
    const source = this.getSourceById(id2);
    if (!source || !isLen(source)) {
      errorEventEimtter.emit(INTERNAL_ERROR_EVENT, {
        type: ERROR.HIGHLIGHT_ID_INDVALID,
        error: `Can't find the highlight source by the id ${id2}`
      });
      return;
    }
    const doms = selctorAll(
      `${source[0].tagName}[${DATA_WEB_HIGHLIGHT}='${source[0].id}']`,
      getOption().root
    );
    if (isLen(doms)) {
      doms.forEach((dom) => cb(dom));
    } else {
      errorEventEimtter.emit(INTERNAL_ERROR_EVENT, {
        type: ERROR.HIGHLIGHT_DOM_NOT_FOUND,
        error: `Can't find the highlight dom by the id ${source[0].id}`,
        detail: source[0]
      });
    }
  }
  _handlePaintWrap(source) {
    let result = false;
    const removeIds = /* @__PURE__ */ new Set();
    const res = this._paint.create(source);
    if (!isNull(res)) {
      const { wrap: wrap2, ids } = res;
      if (isLen(wrap2)) {
        handleHookCall(source, this._hooks.record.saveSource, source.id, source);
        result = true;
        ids.forEach((id2) => removeIds.add(id2));
      } else {
        errorEventEimtter.emit(INTERNAL_ERROR_EVENT, {
          type: ERROR.PAINT_HIGHLIGHT_FAIL,
          error: `Failed to draw highlighted note content.`,
          detail: source
        });
      }
    }
    return [result, [...removeIds]];
  }
}
let highlighter;
const CONTINAER_ID = "reader-container";
const getRoot = () => $("#" + CONTINAER_ID);
function initHighlight(book2) {
  highlighter = new WebHighlight({
    tagName: "span",
    className: highlightColor.getClassName(),
    root: getRoot() || Document,
    showError: true,
    auto: settingStore.value.isAutoHighlight
  });
  watchEffect(() => {
    const auto = settingStore.value.isAutoHighlight;
    highlighter?.setOption({ auto });
  });
  let isNotPaintedFromSource = false;
  highlighter.on(EventTypeEnum.SOURCE, ({ isPainted, range, source }) => {
    if (!isPainted && !get(NoteBarStyle.show)) {
      const { top, left } = getNoteOffset(range);
      ToolbarStyle.open(top, left, source, false);
      isNotPaintedFromSource = true;
    }
  });
  highlighter.on(EventTypeEnum.CREATE, async ({ sources, type, removeIds }) => {
    if (type === CreateFrom.rang) {
      let notes = "";
      if (removeIds && removeIds.length > 0) {
        const willDeleteNote = await NoteAction.findBySourceIds(removeIds);
        const cacheNote = [];
        willDeleteNote.forEach((item) => {
          const val = NoteAction.getNoteText(item.notes);
          cacheNote.push(...val);
        });
        if (cacheNote.length > 0) {
          notes = JSON.stringify(cacheNote);
        }
        await NoteAction.removeBySoureIds(removeIds);
      }
      await NoteAction.add({ sources, eBookId: book2.id, chapterName: "", notes, tag: "" });
    }
  });
  highlighter.on(EventTypeEnum.CLICK, ({ id: id2, target, source }) => {
    if (id2 && source) {
      const { top, left } = getNoteOffset(target);
      ToolbarStyle.open(top, left, source, true);
    } else {
      if (!isNotPaintedFromSource)
        ToolbarStyle.close();
    }
    isNotPaintedFromSource = false;
  });
}
class ToolbarStyle {
  static style = shallowReactive({ top: 0, left: 0 });
  static show = ref(false);
  static isEdite = ref(true);
  static source = [];
  static open(top, left, source, isEdite) {
    set$1(this.show, true);
    set$1(this.isEdite, isEdite);
    Object.assign(this.style, { top, left });
    this.source = source;
  }
  static close() {
    set$1(this.show, false);
    Object.assign(this.style, { top: 0, left: 0 });
    this.source = [];
  }
}
class NoteBarStyle {
  static show = ref(false);
  static isPainted = true;
  static source = ref([]);
  static open(source, isPainted) {
    set$1(this.show, true);
    set$1(this.source, source);
    this.isPainted = isPainted;
  }
  static close() {
    set$1(this.show, false);
    set$1(this.source, []);
  }
}
class NoteToolBarAction {
  //   
  constructor(source, isEdite, bookParam) {
    this.source = source;
    this.isEdite = isEdite;
    this.bookParam = bookParam;
    this.init();
  }
  color = ref(highlightColor.color);
  // 
  decoration = ref("");
  updateSource(source) {
    this.source = source;
    this.init();
  }
  // 
  changeColor(color) {
    const source = this.source;
    if (source.length === 0)
      return;
    const { className } = source[0];
    if (className.includes(get(color)))
      return;
    set$1(this.color, color);
    if (get(this.decoration)) {
      highlightColor.changeColor(color);
      this.updateNote();
    }
  }
  changeDecoration(decoration) {
    const source = this.source;
    if (source.length === 0)
      return;
    if (get(this.decoration) === decoration)
      return;
    highlightColor.changeType(decoration);
    set$1(this.decoration, decoration);
    this.updateNote();
  }
  /**
   * 
   */
  async updateNote(tags = []) {
    const source = this.source;
    if (source.length === 0)
      return;
    const { id: id2, className } = source[0];
    const newClassName = `${get(this.decoration)}-${get(this.color)}`;
    source.forEach((item) => item.className = newClassName);
    if (get(this.isEdite)) {
      highlighter.replaceClass(id2, newClassName, className);
      NoteAction.updateBySourceId(id2, { domSource: JSON.stringify(source) });
    } else {
      highlighter.fromSource(source);
      const tag2 = TagAction.toJSON(tags);
      await NoteAction.add({
        sources: source,
        eBookId: get(this.bookParam),
        chapterName: "",
        notes: "",
        tag: tag2
      });
      set$1(this.isEdite, true);
    }
    highlighter.setOption({ className: newClassName });
  }
  /**
   * 
   * @returns
   */
  remove() {
    const source = this.source;
    if (source.length === 0)
      return null;
    const { id: id2 } = source[0];
    highlighter.remove(id2);
    NoteAction.removeBySoureIds([id2]);
    return true;
  }
  /**
   * 
   */
  copySource() {
    const source = this.source;
    if (source.length === 0)
      return null;
    const { copy } = useClipboard();
    const val = source.reduce((acc, cur) => acc += cur.text, "");
    copy(val);
    toastSuccess("");
    return true;
  }
  /**
   * 
   */
  marker() {
    this.changeDecoration(HighlightType.marker);
  }
  /**
   * 
   */
  beeline() {
    this.changeDecoration(HighlightType.beeline);
  }
  /**
   * 
   */
  wavy() {
    this.changeDecoration(HighlightType.wavy);
  }
  init() {
    const source = this.source;
    if (source.length === 0)
      return;
    const { className } = source[0];
    const [_textType, color] = className.split("-");
    let textType = "";
    if (_textType === HighlightType.marker) {
      textType = HighlightType.marker;
    } else if (_textType === HighlightType.beeline) {
      textType = HighlightType.beeline;
    } else if (_textType === HighlightType.wavy) {
      textType = HighlightType.wavy;
    }
    if (!get(this.isEdite)) {
      textType = "";
    }
    set$1(this.decoration, textType);
    if (color) {
      set$1(this.color, color);
    }
  }
}
class NoteRichAction {
  constructor(bookParam, value) {
    this.bookParam = bookParam;
    this.value = value;
  }
  notes = ref([]);
  noteDetail = null;
  setNotes(_note) {
    set$1(this.notes, NoteAction.getNoteText(_note.notes));
    this.noteDetail = _note;
  }
  /**
   * 
   * @param value
   * @param source
   * @returns
   */
  async firstAdd(source, tags = []) {
    const value = get(this.value);
    if (!value) {
      toastWarning("");
      return;
    }
    if (source.length === 0)
      return;
    const tag2 = TagAction.toJSON(tags);
    this.notes.value.push({ value, time: now() });
    const sources = source.map((item) => {
      return { ...item, className: highlightColor.getClassName() };
    });
    await NoteAction.add({ sources, eBookId: get(this.bookParam), chapterName: "", notes: "", tag: tag2 });
    highlighter.remove(sources[0].id);
    highlighter.fromSource(sources);
    toastSuccess("");
  }
  /**
   * 
   * @param id
   * @param value
   */
  async addInNoNotes(tags = []) {
    const value = get(this.value);
    const id2 = this.noteDetail?.id;
    if (!id2)
      return;
    const tag2 = TagAction.toJSON(tags);
    if (value) {
      this.notes.value.push({ value, time: now() });
    }
    await NoteAction.update(id2, {
      notes: JSON.stringify(get(this.notes)),
      tag: tag2
    });
    toastSuccess("");
  }
  async remove(index) {
    const id2 = this.noteDetail?.id;
    if (!id2)
      return;
    await NoteAction.update(id2, { notes: JSON.stringify(get(this.notes)) });
    this.notes.value.splice(index, 1);
    toastSuccess("");
  }
}
const _hoisted_1$9 = { class: "left-note-wrapper bg-base-100 flex flex-col" };
const _hoisted_2$6 = {
  role: "tablist",
  class: "tabs tabs-boxed rounded-none py-2"
};
const _hoisted_3$4 = { class: "indicator w-full justify-center" };
const _hoisted_4$4 = { class: "indicator-item indicator-bottom badge badge-secondary right-[5px]" };
const _hoisted_5$3 = { class: "flex-1 transition ease-in-out p-3 relative" };
const _hoisted_6$3 = {
  key: 1,
  class: "absolute inset-0"
};
const _hoisted_7$3 = ["data-index"];
const _hoisted_8$3 = ["onMouseenter"];
const _hoisted_9$2 = { class: "card-body p-2" };
const _hoisted_10$2 = { class: "grid grid-cols-1 divide-y divide-neutral" };
const _hoisted_11$2 = {
  key: 0,
  class: "pt-2 flex flex-wrap flex-row gap-2"
};
const _hoisted_12$1 = { class: "flex flex-row-reverse" };
const _hoisted_13$1 = ["onClick"];
const _hoisted_14$1 = {
  key: 1,
  class: "flex justify-center mt-20 w-full"
};
const _hoisted_15$1 = { class: "btn" };
const _hoisted_16$1 = { class: "badge" };
const _hoisted_17$1 = {
  key: 0,
  class: "fixed inset-0"
};
const _hoisted_18$1 = { class: "card-body p-4" };
const _hoisted_19$1 = {
  class: "grid grid-cols-1 bg-base-200 rounded-lg p-2 divide-y divide-neutral",
  style: { "--tw-bg-opacity": 0.5 }
};
const _hoisted_20$1 = { class: "menu menu-horizontal p-1 m-0 justify-between" };
const _hoisted_21$1 = ["onClick", "data-tip"];
const _hoisted_22$1 = { class: "grid grid-cols-2 divide-x py-3 divide-neutral" };
const _hoisted_23$1 = { class: "menu menu-horizontal py-0 px-2 m-0 justify-between" };
const _hoisted_24$1 = ["onClick", "data-tip"];
const _hoisted_25 = { class: "flex items-center px-2" };
const _hoisted_26 = { class: "flex flex-row gap-3 cursor-pointer" };
const _hoisted_27 = ["onClick"];
const _hoisted_28 = ["placeholder"];
const _hoisted_29 = { class: "card-actions justify-end" };
const _hoisted_30 = {
  key: 0,
  class: "loading loading-spinner"
};
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "NoteContainer",
  props: {
    book: {},
    readTime: {}
  },
  emits: ["jump"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const bookParam = useRouteParams("id");
    const [loading, setLoading] = useToggle(false);
    const activeTab = ref("book");
    const changeTab = (tab) => {
      activeTab.value = tab;
    };
    const notes = NoteAction.observableByEBookId(props.book.id);
    const containerRef = ref(null);
    const rowVirtualizerOptions = computed(() => {
      return {
        count: notes.value?.length || 0,
        estimateSize: () => 400,
        overscan: 10,
        getScrollElement: () => containerRef.value
      };
    });
    const rowVirtualizer = useVirtualizer(rowVirtualizerOptions);
    const virtualRows = computed(() => rowVirtualizer.value.getVirtualItems());
    const totalSize = computed(() => rowVirtualizer.value.getTotalSize());
    const measureElement2 = (el) => {
      if (!el) {
        return;
      }
      setTimeout(() => {
        rowVirtualizer.value.measureElement(el);
      });
      return void 0;
    };
    const { hoverIndex, indexBgOpacity, hoverAction } = useBgOpacity();
    const closeHover = () => {
      if (!get(selectNote)) {
        hoverAction(1, -1);
      }
    };
    const tags = ref([]);
    const selectNote = ref();
    const noteTop = ref(0);
    const toolbarRef = ref(null);
    const noteToolBar = new NoteToolBarAction([], ref(true), bookParam);
    const activeTextDecoration = noteToolBar.decoration;
    const activeColor = noteToolBar.color;
    const textareaValue = ref("");
    const noteRichAction = new NoteRichAction(bookParam, textareaValue);
    const noteList = noteRichAction.notes;
    const openEidteBar = async (index) => {
      const dom = $(`.note-item[data-index='${index}']`);
      if (dom) {
        const note2 = get(notes)[index];
        set$1(tags, TagAction.toTag(note2.tag));
        set$1(selectNote, note2);
        hoverAction(0.3, index);
        const { top } = dom.getBoundingClientRect();
        set$1(noteTop, top);
        noteToolBar.updateSource(NoteAction.getDomSource(note2.domSource));
        noteRichAction.setNotes(note2);
      }
    };
    const closeEditrBar = () => {
      set$1(selectNote, void 0);
      hoverAction(1, -1);
    };
    const { height: barHeight } = useElementSize(toolbarRef);
    const { height: winHeight } = useWindowSize();
    const barTop = computed(() => {
      const n2 = get(noteTop);
      const w2 = get(winHeight);
      const h2 = get(barHeight);
      if (n2 < 0) {
        return 0;
      }
      if (n2 + h2 > w2) {
        return w2 - h2 - 2;
      }
      return n2;
    });
    onClickOutside$1(toolbarRef, closeEditrBar);
    onKeyStroke("Escape", () => {
      if (get(selectNote)) {
        closeEditrBar();
      }
    });
    const removeOneNote = () => {
      noteToolBar.remove();
      closeEditrBar();
    };
    const barList = computed(() => {
      return [
        { name: t$2("common.copy"), icon: Copy, click: () => noteToolBar.copySource(), active: "copy" },
        { name: t$2("common.remove"), icon: Trash, click: () => removeOneNote(), active: "remove" }
      ];
    });
    const lineList = [
      { name: t$2("line.marker"), icon: Highlighter, click: () => noteToolBar.marker(), active: HighlightType.marker },
      { name: t$2("line.beeline"), icon: Baseline, click: () => noteToolBar.beeline(), active: HighlightType.beeline },
      { name: t$2("line.wavy"), icon: SpellCheck2, click: () => noteToolBar.wavy(), active: HighlightType.wavy }
    ];
    const addNote = async () => {
      try {
        if (get(loading))
          return;
        setLoading(true);
        const note2 = get(selectNote);
        if (!note2)
          return;
        await noteRichAction.addInNoNotes(get(tags));
      } catch (err) {
        toastError(`${t$2("note.addNoteFail")}${err}`);
      } finally {
        setLoading(false);
        set$1(selectNote, void 0);
      }
    };
    const removeNote = (_2, index) => {
      noteRichAction.remove(index);
    };
    const throttleClick = useThrottleFn((val) => {
      emit2("jump", val);
    }, 800);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$9, [
        createBaseVNode("div", _hoisted_2$6, [
          createBaseVNode("a", {
            role: "tab",
            class: normalizeClass(["tab transition ease-in-out", { "tab-active": activeTab.value === "book" }]),
            onClick: _cache[0] || (_cache[0] = ($event) => changeTab("book"))
          }, toDisplayString$1(unref(t$2)("common.detail")), 3),
          unref(notes)?.length ? (openBlock(), createElementBlock("a", {
            key: 0,
            role: "tab",
            class: normalizeClass(["tab transition ease-in-out", { "tab-active": activeTab.value === "note" }]),
            onClick: _cache[1] || (_cache[1] = ($event) => changeTab("note"))
          }, [
            createBaseVNode("div", _hoisted_3$4, [
              createBaseVNode("span", _hoisted_4$4, toDisplayString$1(unref(notes).length >= 100 ? "99+" : unref(notes).length), 1),
              createBaseVNode("div", null, toDisplayString$1(unref(t$2)("menu.note")), 1)
            ])
          ], 2)) : (openBlock(), createElementBlock("a", {
            key: 1,
            role: "tab",
            class: normalizeClass(["tab transition ease-in-out", { "tab-active": activeTab.value === "note" }]),
            onClick: _cache[2] || (_cache[2] = ($event) => changeTab("note"))
          }, toDisplayString$1(unref(t$2)("menu.note")), 3))
        ]),
        createBaseVNode("div", _hoisted_5$3, [
          activeTab.value === "book" ? (openBlock(), createBlock(_sfc_main$d, {
            key: 0,
            book: _ctx.book,
            notes: unref(notes),
            time: _ctx.readTime
          }, null, 8, ["book", "notes", "time"])) : (openBlock(), createElementBlock("div", _hoisted_6$3, [
            createBaseVNode("div", {
              class: "h-full p-3 bg-base-100 overflow-y-auto scrollbar-none hover:scrollbar-thin",
              ref_key: "containerRef",
              ref: containerRef
            }, [
              unref(notes).length ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "relative w-full",
                style: normalizeStyle({ height: `${totalSize.value}px` })
              }, [
                createBaseVNode("div", {
                  class: "absolute top-0 left-0 w-full",
                  style: normalizeStyle({ transform: `translateY(${virtualRows.value[0]?.start ?? 0}px)` })
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(virtualRows.value, (virtualRow) => {
                    return openBlock(), createElementBlock("div", {
                      key: virtualRow.key,
                      class: "note-item",
                      "data-index": virtualRow.index,
                      ref_for: true,
                      ref: measureElement2
                    }, [
                      createBaseVNode("div", {
                        class: normalizeClass(["card bg-base-200 rounded-md cursor-pointer mb-3", [unref(hoverIndex) === virtualRow.index ? "bg-info text-info-content" : ""]]),
                        style: normalizeStyle({ "--tw-bg-opacity": unref(indexBgOpacity)(virtualRow.index) }),
                        onMouseenter: ($event) => unref(hoverAction)(0.3, virtualRow.index),
                        onMouseleave: _cache[3] || (_cache[3] = ($event) => closeHover())
                      }, [
                        createBaseVNode("div", _hoisted_9$2, [
                          createVNode(_sfc_main$b, {
                            onClick: ($event) => unref(throttleClick)(unref(notes)[virtualRow.index]),
                            data: unref(NoteAction).getDomSource(unref(notes)[virtualRow.index].domSource),
                            opacity: unref(indexBgOpacity)(virtualRow.index),
                            auto: false
                          }, null, 8, ["onClick", "data", "opacity"]),
                          createBaseVNode("div", _hoisted_10$2, [
                            createVNode(_sfc_main$c, {
                              show: false,
                              data: unref(NoteAction).getNoteText(unref(notes)[virtualRow.index].notes),
                              opacity: unref(indexBgOpacity)(virtualRow.index)
                            }, null, 8, ["data", "opacity"]),
                            unref(TagAction).toTag(unref(notes)[virtualRow.index].tag).length ? (openBlock(), createElementBlock("div", _hoisted_11$2, [
                              createVNode(unref(_sfc_main$q), {
                                tag: unref(TagAction).toTag(unref(notes)[virtualRow.index].tag),
                                show: false
                              }, null, 8, ["tag"])
                            ])) : createCommentVNode("", true)
                          ]),
                          createBaseVNode("div", _hoisted_12$1, [
                            createBaseVNode("button", {
                              class: "btn btn-sm btn-outline btn-primary",
                              onClick: ($event) => openEidteBar(virtualRow.index)
                            }, toDisplayString$1(unref(t$2)("common.edit")), 9, _hoisted_13$1)
                          ])
                        ])
                      ], 46, _hoisted_8$3)
                    ], 8, _hoisted_7$3);
                  }), 128))
                ], 4)
              ], 4)) : (openBlock(), createElementBlock("div", _hoisted_14$1, [
                createBaseVNode("div", _hoisted_15$1, [
                  createBaseVNode("div", _hoisted_16$1, toDisplayString$1(unref(t$2)("common.empty")), 1)
                ])
              ]))
            ], 512),
            selectNote.value ? (openBlock(), createElementBlock("div", _hoisted_17$1, [
              createBaseVNode("div", {
                class: "card bg-base-100 absolute transition ease-in-out right-[26rem] border border-primary z-50 select-none cursor-pointer max-w-md bar-shadow",
                style: normalizeStyle({ top: `${barTop.value}px` }),
                ref_key: "toolbarRef",
                ref: toolbarRef
              }, [
                createBaseVNode("div", _hoisted_18$1, [
                  createBaseVNode("div", _hoisted_19$1, [
                    createBaseVNode("ul", _hoisted_20$1, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(barList.value, (item) => {
                        return openBlock(), createElementBlock("li", {
                          onClick: withModifiers(item.click, ["stop"]),
                          key: item.name,
                          class: "tooltip",
                          "data-tip": item.name
                        }, [
                          createBaseVNode("a", null, [
                            (openBlock(), createBlock(resolveDynamicComponent(item.icon)))
                          ])
                        ], 8, _hoisted_21$1);
                      }), 128))
                    ]),
                    createBaseVNode("div", _hoisted_22$1, [
                      createBaseVNode("ul", _hoisted_23$1, [
                        (openBlock(), createElementBlock(Fragment, null, renderList(lineList, (item) => {
                          return createBaseVNode("li", {
                            onClick: withModifiers(item.click, ["stop"]),
                            key: item.name,
                            class: "tooltip",
                            "data-tip": item.name
                          }, [
                            createBaseVNode("a", {
                              class: normalizeClass({ active: item.active === unref(activeTextDecoration) })
                            }, [
                              (openBlock(), createBlock(resolveDynamicComponent(item.icon)))
                            ], 2)
                          ], 8, _hoisted_24$1);
                        }), 64))
                      ]),
                      createBaseVNode("div", _hoisted_25, [
                        createBaseVNode("div", _hoisted_26, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(highlightColor).getColors(), (item) => {
                            return openBlock(), createElementBlock("div", {
                              class: normalizeClass(["badge badge-lg", unref(highlightColor).getBadgeColor(item)]),
                              onClick: ($event) => unref(noteToolBar).changeColor(item),
                              key: item
                            }, toDisplayString$1(item === unref(activeColor) ? "" : ""), 11, _hoisted_27);
                          }), 128))
                        ])
                      ])
                    ])
                  ]),
                  createVNode(_sfc_main$c, {
                    "class-name": "rounded-lg",
                    data: unref(noteList),
                    onRemove: removeNote
                  }, null, 8, ["data"]),
                  withDirectives(createBaseVNode("textarea", {
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => textareaValue.value = $event),
                    rows: "4",
                    class: "textarea textarea-accent w-full bg-base-200 rounded-lg my-3",
                    placeholder: unref(t$2)("note.placeholder")
                  }, null, 8, _hoisted_28), [
                    [vModelText, textareaValue.value]
                  ]),
                  createVNode(unref(_sfc_main$p), {
                    modelValue: tags.value,
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => tags.value = $event)
                  }, null, 8, ["modelValue"]),
                  createBaseVNode("div", _hoisted_29, [
                    createBaseVNode("button", {
                      class: "btn btn-sm btn-success",
                      onClick: _cache[6] || (_cache[6] = ($event) => addNote())
                    }, [
                      unref(loading) ? (openBlock(), createElementBlock("span", _hoisted_30)) : createCommentVNode("", true),
                      createTextVNode(" " + toDisplayString$1(unref(t$2)("common.add")), 1)
                    ])
                  ])
                ])
              ], 4)
            ])) : createCommentVNode("", true)
          ]))
        ])
      ]);
    };
  }
});
const NoteView = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-499d46b8"]]);
let bookRender = null;
class DPFUtil {
  static isPDF = ref(false);
  static size = shallowReactive({ width: 0, height: 0 });
  static total = ref(0);
  static sections = [];
}
const render = async (file2) => {
  bookRender = new Reader();
  await bookRender.open(file2);
  const sections = await bookRender.getSections();
  const toc = bookRender.book.toc || [];
  handleToc(toc);
  const _isPDG = bookRender.book.type === "pdf";
  set$1(DPFUtil.isPDF, _isPDG);
  return { sections, toc };
};
function handleToc(toc) {
  const list = [];
  const eachToc = (data2) => {
    data2.forEach((item) => {
      list.push(item);
      if (Array.isArray(item.subitems)) {
        eachToc(item.subitems);
      }
    });
  };
  eachToc(toc);
  list.forEach((item) => {
    item.page = bookRender.resolveNavigation(item.href).index;
  });
  for (let i2 = 0; i2 < list.length; i2++) {
    const currunt = list[i2];
    const next = list[i2 + 1];
    if (next) {
      currunt.nextPage = next.page;
    } else {
      currunt.nextPage = currunt.page * 2;
    }
  }
}
function getBookHref(href) {
  return bookRender?.resolveNavigation(href);
}
function isExternal(href) {
  return bookRender.isExternal(href);
}
function getImgBlob(href) {
  return bookRender?.getImgBlob(href) || null;
}
function openExternal(href) {
  if (isElectron)
    ;
  else {
    window.open(href, "_blank");
  }
}
function unMountedBookRender() {
  bookRender?.destroy();
}
function getSectionContainer(page) {
  return $(`div[data-page-number='${page}']`);
}
function getSourceTarget(page, id2) {
  const dom = getSectionContainer(page);
  if (!dom)
    return null;
  return dom.querySelector(`span[data-web-highlight_id='${id2}']`);
}
function toPrewView(node, top, height) {
  let val = top - height;
  if (val < 0)
    val = 0;
  node.scrollTo({ top: val, behavior: "smooth" });
}
function toNextView(node, top, height, total) {
  let val = top + height;
  if (val > total)
    val = total;
  node.scrollTo({ top: val, behavior: "smooth" });
}
function isFirstInView(node, offsetTop = 0) {
  const { top, bottom } = node.getBoundingClientRect();
  return top - offsetTop <= 0 && bottom > 0;
}
function getDomPosition(contianer, target, page) {
  const index = findDomIndex(contianer, target);
  if (index === -1)
    return null;
  return { page, index, tagName: target.tagName };
}
function getNavbarRect() {
  const navBar = $(`#book-view_nav_bar`);
  if (!navBar)
    return null;
  return navBar.getBoundingClientRect();
}
function findPositionDom(page, position) {
  const sectionContainer = getSectionContainer(page);
  const { tagName, index } = position;
  if (tagName && index !== -1) {
    return (sectionContainer?.querySelectorAll(tagName) || [])[index];
  }
  return null;
}
function getSectionFirstChild(page) {
  const contianer = getSectionContainer(page);
  if (!contianer)
    return null;
  const navBarRect = getNavbarRect();
  let offsetTop = 0;
  if (navBarRect) {
    offsetTop = navBarRect.height;
  }
  let firstElement = getFirstLastElementChild(contianer);
  if (!firstElement)
    return null;
  const { top } = firstElement.getBoundingClientRect();
  const n2 = top - offsetTop;
  if (n2 > 0) {
    return getSectionFirstChild(page - 1);
  } else if (n2 === 0) {
    return getDomPosition(contianer, firstElement, page);
  } else {
    const doms = lastElementsToArray(contianer);
    for (const dom of doms) {
      if (isFirstInView(dom, offsetTop)) {
        return getDomPosition(contianer, dom, page);
      }
    }
    return null;
  }
}
function getSectionLeftFfirstChild(contianer, page) {
  const rect = contianer.getBoundingClientRect();
  const doms = lastElementsToArray(contianer);
  const firstElement = doms.find((item) => {
    const { left, width } = item.getBoundingClientRect();
    return left > rect.left && left < rect.left + width;
  });
  if (firstElement) {
    return getDomPosition(contianer, firstElement, page);
  } else {
    return null;
  }
}
const cache$1 = [];
function getSectionSize(page) {
  if (cache$1.length) {
    return cache$1[page];
  } else {
    if (!bookRender)
      return null;
    const sections = bookRender.book.sections;
    const total = sections.reduce((p2, c) => p2 + c.size, 0);
    let reduce = 0;
    for (let i2 = 0; i2 < sections.length; i2++) {
      const size2 = sections[i2].size;
      reduce += size2;
      cache$1.push({
        progress: formatDecimal(reduce / total, 4),
        current: formatDecimal(size2 / total, 4)
      });
    }
    return cache$1[page];
  }
}
const _hoisted_1$8 = ["innerHTML"];
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "Section",
  props: {
    data: { default: "" },
    index: { default: 0 }
  },
  emits: ["linkClick"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const contianer = ref(null);
    const bookParam = useRouteParams("id");
    const bookPageStore = useBookPageStore();
    function mountBlobToImg() {
      const imgs = contianer.value?.querySelectorAll("img[src]") || [];
      for (const img of imgs) {
        const blob = getImgBlob(img.getAttribute("src") || "");
        if (blob) {
          img.setAttribute("src", URL.createObjectURL(blob));
        }
      }
    }
    function handleLink() {
      const links = contianer.value?.querySelectorAll("a[href]") || [];
      for (const link of links) {
        link.addEventListener("click", (e2) => {
          e2.preventDefault();
          const href_ = link.getAttribute("href");
          emit2("linkClick", href_);
        });
      }
    }
    async function drawHighlight() {
      const notes = await NoteAction.findBookPageNotes(get(bookParam), props.index.toString());
      const domSource = notes.map((note2) => NoteAction.noteToDomSource(note2));
      highlighter?.fromSource(domSource);
    }
    onMounted(() => {
      mountBlobToImg();
      handleLink();
      drawHighlight();
    });
    useIntersectionObserver(contianer, ([{ isIntersecting }]) => {
      if (isIntersecting) {
        bookPageStore.setPage(props.index);
        console.log(props.index, "");
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "contianer",
        ref: contianer,
        innerHTML: _ctx.data
      }, null, 8, _hoisted_1$8);
    };
  }
});
const _hoisted_1$7 = { class: "bg-base-300 h-full cursor-pointer p-10 overflow-hidden" };
const _hoisted_2$5 = { class: "prose prose-width mx-auto my-0 bg-base-100 rounded-3xl h-full relative" };
const _hoisted_3$3 = { class: "absolute inset-0" };
const _hoisted_4$3 = ["data-page-number"];
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "DoubleReader",
  props: {
    section: { default: () => [] },
    isScrollLocked: { type: Boolean, default: false }
  },
  emits: ["progress"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    __expose({ jump });
    let currentIndex = 0;
    const [isLoading, setLoading] = useToggle(false);
    const bookPageStore = useBookPageStore();
    const containerRef = ref(null);
    const remendyRef = ref(null);
    const resize = useThrottleFn(async () => {
      setHeight();
      await nextTick();
      resetScrollLeft();
    }, 400);
    useResizeObserver(containerRef, resize);
    const index = ref(0);
    const section = ref(props.section[0]?.html || "");
    const { x: x2 } = useScroll(containerRef);
    const calculateProgress = useDebounceFn((progress) => {
      emit2("progress", progress);
    }, 200);
    watchEffect(async () => {
      let dom = get(containerRef);
      const page = get(index);
      bookPageStore.setPage(page);
      const left = get(x2);
      await nextTick();
      dom = get(containerRef);
      if (dom) {
        const size2 = getSectionSize(page);
        if (size2) {
          const { offsetWidth, scrollWidth, firstElementChild } = dom;
          if (firstElementChild.clientHeight > offsetWidth) {
            const progress = formatDecimal((left + offsetWidth) / scrollWidth, 4);
            const res = formatDecimal(size2.progress - size2.current + Math.min(progress, 1) * size2.current, 4);
            calculateProgress(res);
          } else {
            emit2("progress", size2.progress);
          }
        }
      }
    });
    async function updateSection() {
      setLoading(true);
      currentIndex = 0;
      section.value = props.section[index.value].html || "";
      await wait(200);
      setLoading(false);
    }
    const style2 = ref({ height: "0px" });
    function setHeight() {
      const dom = containerRef.value;
      if (dom) {
        let result = 0;
        const { scrollWidth, offsetWidth } = dom;
        if (scrollWidth > offsetWidth) {
          const remainder = scrollWidth % offsetWidth;
          if (remainder > 0) {
            result = offsetWidth - remainder;
          }
        }
        set$1(style2, { height: `${result}px` });
      }
    }
    onMounted(() => {
      setHeight();
    });
    function resetScrollLeft() {
      if (currentIndex > 0) {
        const dom = containerRef.value;
        if (!dom)
          return;
        const { scrollWidth, offsetWidth, scrollLeft } = dom;
        if (scrollLeft === 0)
          return;
        if (scrollWidth <= offsetWidth) {
          dom.scrollLeft = 0;
        } else {
          dom.scrollLeft = currentIndex * offsetWidth;
        }
      }
    }
    function domToView(target) {
      const dom = containerRef.value;
      const { left } = target.getBoundingClientRect();
      const container = $(`#${CONTINAER_ID}`);
      const content = container.querySelector(".prose");
      const { left: cLeft } = content.getBoundingClientRect();
      const { offsetWidth } = dom;
      const l2 = left - cLeft;
      const remainder = +(l2 / offsetWidth).toFixed(0);
      if (dom.scrollLeft !== remainder * offsetWidth) {
        containerRef.value.scrollLeft = remainder * offsetWidth;
      }
    }
    async function jump(i2, id2, position) {
      index.value = i2;
      await updateSection();
      if (id2) {
        await nextTick();
        const dom = containerRef.value;
        const target = dom?.querySelector(`span[data-web-highlight_id='${id2}']`);
        if (target) {
          domToView(target);
        }
      }
      if (position) {
        await nextTick();
        const target = findPositionDom(i2, position);
        if (target) {
          domToView(target);
        }
      }
    }
    async function prev() {
      if (index.value > 0) {
        index.value -= 1;
        await updateSection();
        await wait(20);
        const dom = containerRef.value;
        dom.scrollTo({ left: dom.scrollWidth });
      } else {
        toastWarning("");
      }
    }
    async function next() {
      if (index.value < props.section.length - 1) {
        index.value += 1;
        await updateSection();
      } else {
        toastWarning("");
      }
    }
    const prewView = useThrottleFn(() => {
      if (props.isScrollLocked)
        return;
      const dom = containerRef.value;
      if (dom) {
        const { scrollWidth, offsetWidth, scrollLeft } = dom;
        if (scrollWidth <= offsetWidth) {
          prev();
        } else if (scrollLeft + offsetWidth >= scrollWidth) {
          currentIndex -= 1;
          dom.scrollLeft -= offsetWidth;
        } else if (scrollLeft === 0) {
          prev();
        } else {
          currentIndex -= 1;
          dom.scrollLeft -= offsetWidth;
        }
      } else {
        console.warn("dom is null");
        prev();
      }
    }, 300);
    const nextView = useThrottleFn(() => {
      if (props.isScrollLocked)
        return;
      const dom = containerRef.value;
      if (dom) {
        const { scrollWidth, offsetWidth, scrollLeft } = dom;
        if (scrollWidth <= offsetWidth) {
          next();
        } else if (scrollLeft + offsetWidth >= scrollWidth) {
          next();
        } else {
          currentIndex += 1;
          dom.scrollLeft += offsetWidth;
        }
      } else {
        console.warn("dom is null");
        next();
      }
    }, 300);
    onKeyStroke(["ArrowDown", "ArrowRight"], nextView);
    onKeyStroke(["ArrowUp", "ArrowLeft"], prewView);
    function linkClick(href) {
      if (isExternal(href)) {
        openExternal(href);
      } else {
        const value = getBookHref(href);
        if (value) {
          jump(value.index);
        }
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$7, [
        createBaseVNode("div", _hoisted_2$5, [
          createBaseVNode("div", _hoisted_3$3, [
            unref(isLoading) ? (openBlock(), createBlock(unref(RingLoadingView), {
              key: 0,
              class: "rounded-3xl"
            })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createBaseVNode("div", {
                ref_key: "containerRef",
                ref: containerRef,
                "data-page-number": index.value,
                class: "columns-1 scroll-smooth transition ease-in-out lg:columns-2 gap-x-16 h-full overflow-auto scrollbar-none p-8 pb-12 double-container relative"
              }, [
                (openBlock(), createBlock(_sfc_main$9, {
                  key: index.value,
                  index: index.value,
                  data: section.value,
                  onLinkClick: linkClick
                }, null, 8, ["index", "data"])),
                createBaseVNode("div", {
                  ref_key: "remendyRef",
                  ref: remendyRef,
                  style: normalizeStyle(style2.value)
                }, null, 4)
              ], 8, _hoisted_4$3),
              createBaseVNode("button", {
                class: "btn btn-outline absolute bottom-5 left-10 btn-sm",
                onClick: _cache[0] || (_cache[0] = //@ts-ignore
                (...args) => unref(prewView) && unref(prewView)(...args))
              }, ""),
              createBaseVNode("button", {
                class: "btn btn-outline absolute bottom-5 right-10 btn-sm",
                onClick: _cache[1] || (_cache[1] = //@ts-ignore
                (...args) => unref(nextView) && unref(nextView)(...args))
              }, "")
            ], 64))
          ])
        ])
      ]);
    };
  }
});
const DoubleReaderView = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-7aad53bf"]]);
const _hoisted_1$6 = ["data-index", "data-page-number"];
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "ScrollReader",
  props: {
    section: { default: () => [] },
    isScrollLocked: { type: Boolean, default: false }
  },
  emits: ["progress"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const debouncedFn = useDebounceFn(() => {
    }, 1e3);
    window.addEventListener("resize", debouncedFn);
    const props = __props;
    __expose({ jump });
    const emit2 = __emit;
    const containerRef = ref(null);
    let isJump = false;
    let highlightId = void 0;
    let lastReadPosition = void 0;
    let jumpPage = -1;
    async function jump(index, id2, position) {
      rowVirtualizer.value.scrollToIndex(index, { align: "start", behavior: "smooth" });
      jumpPage = index;
      highlightId = id2;
      lastReadPosition = position;
      isJump = true;
    }
    function jumpToHighlight() {
      if (highlightId && jumpPage !== -1) {
        const target = getSourceTarget(jumpPage, highlightId);
        if (!target)
          return;
        const rect = target.getBoundingClientRect();
        const scrollTop = get(containerRef)?.scrollTop || 0;
        if (scrollTop) {
          rowVirtualizer.value.scrollToOffset(scrollTop + rect.top, { align: "center", behavior: "smooth" });
        }
      }
    }
    function jumpToPosition() {
      if (lastReadPosition && jumpPage !== -1) {
        const scrollTop = get(containerRef)?.scrollTop || 0;
        const target = findPositionDom(jumpPage, lastReadPosition);
        if (!target)
          return;
        const navBarRect = getNavbarRect()?.height || 0;
        const { top } = target.getBoundingClientRect();
        rowVirtualizer.value.scrollToOffset(scrollTop + top - navBarRect, { align: "start", behavior: "smooth" });
      }
    }
    function resetJump() {
      highlightId = void 0;
      jumpPage = -1;
      lastReadPosition = void 0;
    }
    const calculateProgress = useDebounceFn((offset) => {
      const total = get(totalSize);
      if (total) {
        const height = getNavbarRect()?.height || 0;
        const current = Math.min(offset + window.innerHeight - height, total);
        emit2("progress", formatDecimal(current / total, 4));
      }
    }, 200);
    const rowVirtualizerOptions = computed(() => {
      return {
        count: props.section.length,
        overscan: 5,
        getScrollElement: () => containerRef.value,
        estimateSize: (i2) => props.section[i2].height,
        observeElementOffset: (instance, cb) => observeElementOffset(instance, (offset, isScrolling) => {
          cb(offset, isScrolling);
          calculateProgress(offset);
          if (!isScrolling && isJump) {
            jumpToHighlight();
            jumpToPosition();
            resetJump();
          }
        })
      };
    });
    const rowVirtualizer = useVirtualizer(rowVirtualizerOptions);
    const virtualRows = computed(() => rowVirtualizer.value.getVirtualItems());
    const totalSize = computed(() => rowVirtualizer.value.getTotalSize());
    const measureElement2 = (element) => {
      if (!element) {
        return;
      }
      setTimeout(() => {
        rowVirtualizer.value.measureElement(element);
      });
      return void 0;
    };
    function linkClick(href) {
      if (isExternal(href)) {
        openExternal(href);
      } else {
        const value = getBookHref(href);
        if (value) {
          jump(value.index);
        }
      }
    }
    const getHeight = (h2) => {
      const dom = containerRef.value;
      let result = 0;
      if (h2) {
        result = h2;
      } else {
        const { height } = dom.getBoundingClientRect();
        result = height;
      }
      return { height: result, dom, scrollTop: dom.scrollTop };
    };
    const prewViewAction = (h2) => {
      if (!props.isScrollLocked) {
        if (!get(containerRef))
          return;
        const { height, dom, scrollTop } = getHeight(h2);
        toPrewView(dom, scrollTop, height);
      }
    };
    const prewView = useThrottleFn(() => prewViewAction(), 300);
    onKeyStroke(["ArrowLeft"], prewView);
    const littlePrewView = useThrottleFn(() => {
      if (!props.isScrollLocked) {
        prewViewAction(10);
      }
    }, 100);
    onKeyStroke(["ArrowUp"], littlePrewView);
    const nextViewAction = (h2) => {
      if (!props.isScrollLocked) {
        if (!get(containerRef))
          return;
        const { height, dom, scrollTop } = getHeight(h2);
        toNextView(dom, scrollTop, height, get(totalSize));
      }
    };
    const nextView = useThrottleFn(() => nextViewAction(), 300);
    onKeyStroke(["ArrowRight"], nextView);
    const littleNextView = useThrottleFn(() => {
      if (!props.isScrollLocked) {
        nextViewAction(10);
      }
    }, 100);
    onKeyStroke(["ArrowDown"], littleNextView);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-base-100 h-full cursor-pointer overflow-auto scrollbar-thin",
        ref_key: "containerRef",
        ref: containerRef
      }, [
        createBaseVNode("div", {
          class: "relative w-full",
          style: normalizeStyle({ height: `${totalSize.value}px` })
        }, [
          createBaseVNode("div", {
            class: "absolute top-0 left-0 w-full",
            style: normalizeStyle({ transform: `translateY(${virtualRows.value[0]?.start ?? 0}px)` })
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(virtualRows.value, (virtualRow) => {
              return openBlock(), createElementBlock("div", {
                key: virtualRow.key,
                "data-index": virtualRow.index,
                "data-page-number": virtualRow.index,
                ref_for: true,
                ref: measureElement2,
                class: "prose mx-auto my-0 mb-12 prose-width"
              }, [
                createVNode(_sfc_main$9, {
                  data: _ctx.section[virtualRow.index].html,
                  index: virtualRow.index,
                  onLinkClick: linkClick
                }, null, 8, ["data", "index"])
              ], 8, _hoisted_1$6);
            }), 128))
          ], 4)
        ], 4)
      ], 512);
    };
  }
});
const _hoisted_1$5 = ["id"];
const _hoisted_2$4 = ["data-page-number"];
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "SectionReader",
  props: {
    section: { default: () => [] },
    isScrollLocked: { type: Boolean, default: false }
  },
  emits: ["progress"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    __expose({ jump });
    const emit2 = __emit;
    const containerRef = ref(null);
    const index = ref(0);
    const bookPageStore = useBookPageStore();
    const section = computed(() => props.section[index.value].html);
    const { y: y2 } = useScroll(containerRef);
    const calculateProgress = useDebounceFn((progress) => {
      emit2("progress", progress);
    }, 200);
    watchEffect(async () => {
      let dom = get(containerRef);
      const page = get(index);
      bookPageStore.setPage(page);
      const top = get(y2);
      await nextTick();
      dom = get(containerRef);
      if (dom) {
        const size2 = getSectionSize(page);
        if (size2) {
          const { offsetHeight, scrollHeight, firstElementChild } = dom;
          if (firstElementChild.clientHeight > offsetHeight) {
            const progress = formatDecimal((top + offsetHeight) / scrollHeight, 4);
            const res = formatDecimal(size2.progress - size2.current + progress * size2.current, 4);
            calculateProgress(res);
          } else {
            emit2("progress", size2.progress);
          }
        }
      }
    });
    async function jump(i2, id2, position) {
      if (containerRef.value && !id2) {
        containerRef.value.scrollTop = 0;
      }
      index.value = i2;
      if (id2) {
        await wait(100);
        getSourceTarget(i2, id2)?.scrollIntoView({ behavior: "smooth", block: "center" });
      }
      if (position) {
        await wait(100);
        const target = findPositionDom(i2, position);
        if (!target)
          return;
        const { top } = target.getBoundingClientRect();
        containerRef.value?.scrollTo({ top, behavior: "smooth" });
      }
    }
    function prevSection() {
      if (index.value > 0) {
        index.value -= 1;
      }
    }
    function nextSection() {
      if (containerRef.value) {
        containerRef.value.scroll({
          top: 0,
          behavior: "smooth"
        });
        containerRef.value.scrollTop = 0;
      }
      if (index.value < props.section.length - 1) {
        index.value += 1;
      }
    }
    function linkClick(href) {
      if (isExternal(href)) {
        openExternal(href);
      } else {
        const value = getBookHref(href);
        if (value) {
          jump(value.index);
        }
      }
    }
    const jumpToPrewView = async () => {
      if (get(index) === 0)
        return;
      set$1(index, get(index) - 1);
      await wait(100);
      containerRef.value.scrollTo({ top: containerRef.value.scrollHeight });
    };
    const getScrollData = () => {
      const dom = containerRef.value;
      const { height } = dom.getBoundingClientRect();
      const { scrollHeight, scrollTop } = dom;
      return { height, scrollHeight, scrollTop, dom };
    };
    const prewView = useThrottleFn(async () => {
      if (props.isScrollLocked)
        return;
      if (!get(containerRef))
        return;
      const { height, scrollHeight, scrollTop, dom } = getScrollData();
      if (scrollHeight <= height) {
        await jumpToPrewView();
      } else {
        if (scrollTop === 0) {
          await jumpToPrewView();
        } else {
          toPrewView(dom, scrollTop, height);
        }
      }
    }, 300);
    onKeyStroke(["ArrowLeft"], prewView);
    const jumpToNextView = async () => {
      if (get(index) === props.section.length - 1)
        return;
      set$1(index, get(index) + 1);
      await wait(100);
      containerRef.value.scrollTo({ top: 0 });
    };
    const nextView = useThrottleFn(() => {
      if (props.isScrollLocked)
        return;
      if (!get(containerRef))
        return;
      const { height, scrollHeight, scrollTop, dom } = getScrollData();
      if (scrollHeight <= height) {
        jumpToNextView();
      } else {
        if (scrollTop + height >= scrollHeight) {
          jumpToNextView();
        } else {
          toNextView(dom, scrollTop, height, scrollHeight - height);
        }
      }
    }, 300);
    onKeyStroke(["ArrowRight"], nextView);
    const littlePrevView = () => {
      if (props.isScrollLocked)
        return;
      if (!get(containerRef))
        return;
      const { height, scrollHeight, scrollTop, dom } = getScrollData();
      if (scrollHeight > height) {
        if (scrollTop !== 0) {
          toPrewView(dom, scrollTop, 10);
        }
      }
    };
    onKeyStroke(["ArrowUp"], littlePrevView);
    const littleNextView = () => {
      if (props.isScrollLocked)
        return;
      if (!get(containerRef))
        return;
      const { height, scrollHeight, scrollTop, dom } = getScrollData();
      if (scrollHeight > height) {
        if (scrollTop + height < scrollHeight) {
          toNextView(dom, scrollTop, 10, scrollHeight - height);
        }
      }
    };
    onKeyStroke(["ArrowDown"], littleNextView);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "bg-base-100 h-full cursor-pointer overflow-auto scrollbar-thin",
        ref_key: "containerRef",
        ref: containerRef,
        id: unref(CONTINAER_ID)
      }, [
        createBaseVNode("div", {
          class: "prose mx-auto my-0 prose-width",
          "data-page-number": index.value
        }, [
          createBaseVNode("div", { class: "py-8" }, [
            createBaseVNode("button", {
              class: "btn btn-active btn-neutral",
              onClick: prevSection
            }, "")
          ]),
          (openBlock(), createBlock(_sfc_main$9, {
            key: index.value,
            index: index.value,
            data: section.value,
            onLinkClick: linkClick
          }, null, 8, ["index", "data"])),
          createBaseVNode("div", { class: "text-center py-10" }, [
            createBaseVNode("button", {
              class: "btn btn-active btn-primary btn-wide",
              onClick: nextSection
            }, "")
          ])
        ], 8, _hoisted_2$4)
      ], 8, _hoisted_1$5);
    };
  }
});
var __webpack_require__ = {};
(() => {
  __webpack_require__.d = (exports, definition) => {
    for (var key in definition) {
      if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
        Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
      }
    }
  };
})();
(() => {
  __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
})();
var __webpack_exports__ = globalThis.pdfjsViewer = {};
__webpack_require__.d(__webpack_exports__, {
  AnnotationLayerBuilder: () => (
    /* reexport */
    AnnotationLayerBuilder
  ),
  DownloadManager: () => (
    /* reexport */
    DownloadManager
  ),
  EventBus: () => (
    /* reexport */
    EventBus
  ),
  FindState: () => (
    /* reexport */
    FindState
  ),
  GenericL10n: () => (
    /* reexport */
    genericl10n_GenericL10n
  ),
  LinkTarget: () => (
    /* reexport */
    LinkTarget
  ),
  PDFFindController: () => (
    /* reexport */
    PDFFindController
  ),
  PDFHistory: () => (
    /* reexport */
    PDFHistory
  ),
  PDFLinkService: () => (
    /* reexport */
    PDFLinkService
  ),
  PDFPageView: () => (
    /* reexport */
    PDFPageView
  ),
  PDFScriptingManager: () => (
    /* reexport */
    PDFScriptingManagerComponents
  ),
  PDFSinglePageViewer: () => (
    /* reexport */
    PDFSinglePageViewer
  ),
  PDFViewer: () => (
    /* reexport */
    PDFViewer
  ),
  ProgressBar: () => (
    /* reexport */
    ProgressBar
  ),
  RenderingStates: () => (
    /* reexport */
    RenderingStates
  ),
  ScrollMode: () => (
    /* reexport */
    ScrollMode
  ),
  SimpleLinkService: () => (
    /* reexport */
    SimpleLinkService
  ),
  SpreadMode: () => (
    /* reexport */
    SpreadMode
  ),
  StructTreeLayerBuilder: () => (
    /* reexport */
    StructTreeLayerBuilder
  ),
  TextLayerBuilder: () => (
    /* reexport */
    TextLayerBuilder
  ),
  XfaLayerBuilder: () => (
    /* reexport */
    XfaLayerBuilder
  ),
  parseQueryString: () => (
    /* reexport */
    parseQueryString
  )
});
const DEFAULT_SCALE_VALUE = "auto";
const DEFAULT_SCALE = 1;
const DEFAULT_SCALE_DELTA = 1.1;
const MIN_SCALE = 0.1;
const MAX_SCALE = 10;
const UNKNOWN_SCALE = 0;
const MAX_AUTO_SCALE = 1.25;
const SCROLLBAR_PADDING = 40;
const VERTICAL_PADDING = 5;
const RenderingStates = {
  INITIAL: 0,
  RUNNING: 1,
  PAUSED: 2,
  FINISHED: 3
};
const PresentationModeState = {
  UNKNOWN: 0,
  NORMAL: 1,
  CHANGING: 2,
  FULLSCREEN: 3
};
const TextLayerMode = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_PERMISSIONS: 2
};
const ScrollMode = {
  UNKNOWN: -1,
  VERTICAL: 0,
  HORIZONTAL: 1,
  WRAPPED: 2,
  PAGE: 3
};
const SpreadMode = {
  UNKNOWN: -1,
  NONE: 0,
  ODD: 1,
  EVEN: 2
};
class OutputScale {
  constructor() {
    const pixelRatio = window.devicePixelRatio || 1;
    this.sx = pixelRatio;
    this.sy = pixelRatio;
  }
  get scaled() {
    return this.sx !== 1 || this.sy !== 1;
  }
}
function scrollIntoView(element, spot, scrollMatches = false) {
  let parent = element.offsetParent;
  if (!parent) {
    console.error("offsetParent is not set -- cannot scroll");
    return;
  }
  let offsetY = element.offsetTop + element.clientTop;
  let offsetX = element.offsetLeft + element.clientLeft;
  while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || scrollMatches && (parent.classList.contains("markedContent") || getComputedStyle(parent).overflow === "hidden")) {
    offsetY += parent.offsetTop;
    offsetX += parent.offsetLeft;
    parent = parent.offsetParent;
    if (!parent) {
      return;
    }
  }
  if (spot) {
    if (spot.top !== void 0) {
      offsetY += spot.top;
    }
    if (spot.left !== void 0) {
      offsetX += spot.left;
      parent.scrollLeft = offsetX;
    }
  }
  parent.scrollTop = offsetY;
}
function watchScroll(viewAreaElement, callback) {
  const debounceScroll = function(evt) {
    if (rAF) {
      return;
    }
    rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
      rAF = null;
      const currentX = viewAreaElement.scrollLeft;
      const lastX = state.lastX;
      if (currentX !== lastX) {
        state.right = currentX > lastX;
      }
      state.lastX = currentX;
      const currentY = viewAreaElement.scrollTop;
      const lastY = state.lastY;
      if (currentY !== lastY) {
        state.down = currentY > lastY;
      }
      state.lastY = currentY;
      callback(state);
    });
  };
  const state = {
    right: true,
    down: true,
    lastX: viewAreaElement.scrollLeft,
    lastY: viewAreaElement.scrollTop,
    _eventHandler: debounceScroll
  };
  let rAF = null;
  viewAreaElement.addEventListener("scroll", debounceScroll, true);
  return state;
}
function parseQueryString(query) {
  const params = /* @__PURE__ */ new Map();
  for (const [key, value] of new URLSearchParams(query)) {
    params.set(key.toLowerCase(), value);
  }
  return params;
}
const InvisibleCharsRegExp = /[\x00-\x1F]/g;
function removeNullCharacters(str, replaceInvisible = false) {
  if (!InvisibleCharsRegExp.test(str)) {
    return str;
  }
  if (replaceInvisible) {
    return str.replaceAll(InvisibleCharsRegExp, (m2) => m2 === "\0" ? "" : " ");
  }
  return str.replaceAll("\0", "");
}
function binarySearchFirstItem(items, condition, start = 0) {
  let minIndex = start;
  let maxIndex = items.length - 1;
  if (maxIndex < 0 || !condition(items[maxIndex])) {
    return items.length;
  }
  if (condition(items[minIndex])) {
    return minIndex;
  }
  while (minIndex < maxIndex) {
    const currentIndex = minIndex + maxIndex >> 1;
    const currentItem = items[currentIndex];
    if (condition(currentItem)) {
      maxIndex = currentIndex;
    } else {
      minIndex = currentIndex + 1;
    }
  }
  return minIndex;
}
function approximateFraction(x2) {
  if (Math.floor(x2) === x2) {
    return [x2, 1];
  }
  const xinv = 1 / x2;
  const limit = 8;
  if (xinv > limit) {
    return [1, limit];
  } else if (Math.floor(xinv) === xinv) {
    return [1, xinv];
  }
  const x_ = x2 > 1 ? xinv : x2;
  let a2 = 0, b2 = 1, c = 1, d = 1;
  while (true) {
    const p2 = a2 + c, q = b2 + d;
    if (q > limit) {
      break;
    }
    if (x_ <= p2 / q) {
      c = p2;
      d = q;
    } else {
      a2 = p2;
      b2 = q;
    }
  }
  let result;
  if (x_ - a2 / b2 < c / d - x_) {
    result = x_ === x2 ? [a2, b2] : [b2, a2];
  } else {
    result = x_ === x2 ? [c, d] : [d, c];
  }
  return result;
}
function roundToDivide(x2, div) {
  const r2 = x2 % div;
  return r2 === 0 ? x2 : Math.round(x2 - r2 + div);
}
function backtrackBeforeAllVisibleElements(index, views, top) {
  if (index < 2) {
    return index;
  }
  let elt = views[index].div;
  let pageTop = elt.offsetTop + elt.clientTop;
  if (pageTop >= top) {
    elt = views[index - 1].div;
    pageTop = elt.offsetTop + elt.clientTop;
  }
  for (let i2 = index - 2; i2 >= 0; --i2) {
    elt = views[i2].div;
    if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {
      break;
    }
    index = i2;
  }
  return index;
}
function getVisibleElements({
  scrollEl,
  views,
  sortByVisibility = false,
  horizontal = false,
  rtl = false
}) {
  const top = scrollEl.scrollTop, bottom = top + scrollEl.clientHeight;
  const left = scrollEl.scrollLeft, right = left + scrollEl.clientWidth;
  function isElementBottomAfterViewTop(view) {
    const element = view.div;
    const elementBottom = element.offsetTop + element.clientTop + element.clientHeight;
    return elementBottom > top;
  }
  function isElementNextAfterViewHorizontally(view) {
    const element = view.div;
    const elementLeft = element.offsetLeft + element.clientLeft;
    const elementRight = elementLeft + element.clientWidth;
    return rtl ? elementLeft < right : elementRight > left;
  }
  const visible = [], ids = /* @__PURE__ */ new Set(), numViews = views.length;
  let firstVisibleElementInd = binarySearchFirstItem(views, horizontal ? isElementNextAfterViewHorizontally : isElementBottomAfterViewTop);
  if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) {
    firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top);
  }
  let lastEdge = horizontal ? right : -1;
  for (let i2 = firstVisibleElementInd; i2 < numViews; i2++) {
    const view = views[i2], element = view.div;
    const currentWidth = element.offsetLeft + element.clientLeft;
    const currentHeight = element.offsetTop + element.clientTop;
    const viewWidth = element.clientWidth, viewHeight = element.clientHeight;
    const viewRight = currentWidth + viewWidth;
    const viewBottom = currentHeight + viewHeight;
    if (lastEdge === -1) {
      if (viewBottom >= bottom) {
        lastEdge = viewBottom;
      }
    } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {
      break;
    }
    if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) {
      continue;
    }
    const hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);
    const hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);
    const fractionHeight = (viewHeight - hiddenHeight) / viewHeight, fractionWidth = (viewWidth - hiddenWidth) / viewWidth;
    const percent = fractionHeight * fractionWidth * 100 | 0;
    visible.push({
      id: view.id,
      x: currentWidth,
      y: currentHeight,
      view,
      percent,
      widthPercent: fractionWidth * 100 | 0
    });
    ids.add(view.id);
  }
  const first = visible[0], last2 = visible.at(-1);
  if (sortByVisibility) {
    visible.sort(function(a2, b2) {
      const pc = a2.percent - b2.percent;
      if (Math.abs(pc) > 1e-3) {
        return -pc;
      }
      return a2.id - b2.id;
    });
  }
  return {
    first,
    last: last2,
    views: visible,
    ids
  };
}
function isValidRotation(angle) {
  return Number.isInteger(angle) && angle % 90 === 0;
}
function isValidScrollMode(mode) {
  return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN;
}
function isValidSpreadMode(mode) {
  return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN;
}
function isPortraitOrientation(size2) {
  return size2.width <= size2.height;
}
new Promise(function(resolve2) {
  window.requestAnimationFrame(resolve2);
});
const docStyle = document.documentElement.style;
function clamp(v2, min, max) {
  return Math.min(Math.max(v2, min), max);
}
class ProgressBar {
  #classList = null;
  #disableAutoFetchTimeout = null;
  #percent = 0;
  #style = null;
  #visible = true;
  constructor(bar) {
    this.#classList = bar.classList;
    this.#style = bar.style;
  }
  get percent() {
    return this.#percent;
  }
  set percent(val) {
    this.#percent = clamp(val, 0, 100);
    if (isNaN(val)) {
      this.#classList.add("indeterminate");
      return;
    }
    this.#classList.remove("indeterminate");
    this.#style.setProperty("--progressBar-percent", `${this.#percent}%`);
  }
  setWidth(viewer) {
    if (!viewer) {
      return;
    }
    const container = viewer.parentNode;
    const scrollbarWidth = container.offsetWidth - viewer.offsetWidth;
    if (scrollbarWidth > 0) {
      this.#style.setProperty("--progressBar-end-offset", `${scrollbarWidth}px`);
    }
  }
  setDisableAutoFetch(delay = 5e3) {
    if (isNaN(this.#percent)) {
      return;
    }
    if (this.#disableAutoFetchTimeout) {
      clearTimeout(this.#disableAutoFetchTimeout);
    }
    this.show();
    this.#disableAutoFetchTimeout = setTimeout(() => {
      this.#disableAutoFetchTimeout = null;
      this.hide();
    }, delay);
  }
  hide() {
    if (!this.#visible) {
      return;
    }
    this.#visible = false;
    this.#classList.add("hidden");
  }
  show() {
    if (this.#visible) {
      return;
    }
    this.#visible = true;
    this.#classList.remove("hidden");
  }
}
function apiPageLayoutToViewerModes(layout) {
  let scrollMode = ScrollMode.VERTICAL, spreadMode = SpreadMode.NONE;
  switch (layout) {
    case "SinglePage":
      scrollMode = ScrollMode.PAGE;
      break;
    case "OneColumn":
      break;
    case "TwoPageLeft":
      scrollMode = ScrollMode.PAGE;
    case "TwoColumnLeft":
      spreadMode = SpreadMode.ODD;
      break;
    case "TwoPageRight":
      scrollMode = ScrollMode.PAGE;
    case "TwoColumnRight":
      spreadMode = SpreadMode.EVEN;
      break;
  }
  return {
    scrollMode,
    spreadMode
  };
}
const CharacterType = {
  SPACE: 0,
  ALPHA_LETTER: 1,
  PUNCT: 2,
  HAN_LETTER: 3,
  KATAKANA_LETTER: 4,
  HIRAGANA_LETTER: 5,
  HALFWIDTH_KATAKANA_LETTER: 6,
  THAI_LETTER: 7
};
function isAlphabeticalScript(charCode) {
  return charCode < 11904;
}
function isAscii(charCode) {
  return (charCode & 65408) === 0;
}
function isAsciiAlpha(charCode) {
  return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90;
}
function isAsciiDigit(charCode) {
  return charCode >= 48 && charCode <= 57;
}
function isAsciiSpace(charCode) {
  return charCode === 32 || charCode === 9 || charCode === 13 || charCode === 10;
}
function isHan(charCode) {
  return charCode >= 13312 && charCode <= 40959 || charCode >= 63744 && charCode <= 64255;
}
function isKatakana(charCode) {
  return charCode >= 12448 && charCode <= 12543;
}
function isHiragana(charCode) {
  return charCode >= 12352 && charCode <= 12447;
}
function isHalfwidthKatakana(charCode) {
  return charCode >= 65376 && charCode <= 65439;
}
function isThai(charCode) {
  return (charCode & 65408) === 3584;
}
function getCharacterType(charCode) {
  if (isAlphabeticalScript(charCode)) {
    if (isAscii(charCode)) {
      if (isAsciiSpace(charCode)) {
        return CharacterType.SPACE;
      } else if (isAsciiAlpha(charCode) || isAsciiDigit(charCode) || charCode === 95) {
        return CharacterType.ALPHA_LETTER;
      }
      return CharacterType.PUNCT;
    } else if (isThai(charCode)) {
      return CharacterType.THAI_LETTER;
    } else if (charCode === 160) {
      return CharacterType.SPACE;
    }
    return CharacterType.ALPHA_LETTER;
  }
  if (isHan(charCode)) {
    return CharacterType.HAN_LETTER;
  } else if (isKatakana(charCode)) {
    return CharacterType.KATAKANA_LETTER;
  } else if (isHiragana(charCode)) {
    return CharacterType.HIRAGANA_LETTER;
  } else if (isHalfwidthKatakana(charCode)) {
    return CharacterType.HALFWIDTH_KATAKANA_LETTER;
  }
  return CharacterType.ALPHA_LETTER;
}
let NormalizeWithNFKC;
function getNormalizeWithNFKC() {
  NormalizeWithNFKC ||= `---------------------------------------------------------------------------------------------------`;
  return NormalizeWithNFKC;
}
const FindState = {
  FOUND: 0,
  NOT_FOUND: 1,
  WRAPPED: 2,
  PENDING: 3
};
const FIND_TIMEOUT = 250;
const MATCH_SCROLL_OFFSET_TOP = -50;
const MATCH_SCROLL_OFFSET_LEFT = -400;
const CHARACTERS_TO_NORMALIZE = {
  "": "-",
  "": "'",
  "": "'",
  "": "'",
  "": "'",
  "": '"',
  "": '"',
  "": '"',
  "": '"',
  "": "1/4",
  "": "1/2",
  "": "3/4"
};
const DIACRITICS_EXCEPTION = /* @__PURE__ */ new Set([12441, 12442, 2381, 2509, 2637, 2765, 2893, 3021, 3149, 3277, 3387, 3388, 3405, 3530, 3642, 3770, 3972, 4153, 4154, 5908, 5940, 6098, 6752, 6980, 7082, 7083, 7154, 7155, 11647, 43014, 43052, 43204, 43347, 43456, 43766, 44013, 3158, 3953, 3954, 3962, 3963, 3964, 3965, 3968, 3956]);
let DIACRITICS_EXCEPTION_STR;
const DIACRITICS_REG_EXP = new RegExp("\\p{M}+", "gu");
const SPECIAL_CHARS_REG_EXP = new RegExp("([.*+?^${}()|[\\]\\\\])|(\\p{P})|(\\s+)|(\\p{M})|(\\p{L})", "gu");
const NOT_DIACRITIC_FROM_END_REG_EXP = new RegExp("([^\\p{M}])\\p{M}*$", "u");
const NOT_DIACRITIC_FROM_START_REG_EXP = new RegExp("^\\p{M}*([^\\p{M}])", "u");
const SYLLABLES_REG_EXP = /[\uAC00-\uD7AF\uFA6C\uFACF-\uFAD1\uFAD5-\uFAD7]+/g;
const SYLLABLES_LENGTHS = /* @__PURE__ */ new Map();
const FIRST_CHAR_SYLLABLES_REG_EXP = "[\\u1100-\\u1112\\ud7a4-\\ud7af\\ud84a\\ud84c\\ud850\\ud854\\ud857\\ud85f]";
const NFKC_CHARS_TO_NORMALIZE = /* @__PURE__ */ new Map();
let noSyllablesRegExp = null;
let withSyllablesRegExp = null;
function normalize(text) {
  const syllablePositions = [];
  let m2;
  while ((m2 = SYLLABLES_REG_EXP.exec(text)) !== null) {
    let {
      index
    } = m2;
    for (const char of m2[0]) {
      let len = SYLLABLES_LENGTHS.get(char);
      if (!len) {
        len = char.normalize("NFD").length;
        SYLLABLES_LENGTHS.set(char, len);
      }
      syllablePositions.push([len, index++]);
    }
  }
  let normalizationRegex;
  if (syllablePositions.length === 0 && noSyllablesRegExp) {
    normalizationRegex = noSyllablesRegExp;
  } else if (syllablePositions.length > 0 && withSyllablesRegExp) {
    normalizationRegex = withSyllablesRegExp;
  } else {
    const replace = Object.keys(CHARACTERS_TO_NORMALIZE).join("");
    const toNormalizeWithNFKC = getNormalizeWithNFKC();
    const CJK = "(?:\\p{Ideographic}|[-])";
    const HKDiacritics = "(?:|)";
    const regexp = `([${replace}])|([${toNormalizeWithNFKC}])|(${HKDiacritics}\\n)|(\\p{M}+(?:-\\n)?)|(\\S-\\n)|(${CJK}\\n)|(\\n)`;
    if (syllablePositions.length === 0) {
      normalizationRegex = noSyllablesRegExp = new RegExp(regexp + "|(\\u0000)", "gum");
    } else {
      normalizationRegex = withSyllablesRegExp = new RegExp(regexp + `|(${FIRST_CHAR_SYLLABLES_REG_EXP})`, "gum");
    }
  }
  const rawDiacriticsPositions = [];
  while ((m2 = DIACRITICS_REG_EXP.exec(text)) !== null) {
    rawDiacriticsPositions.push([m2[0].length, m2.index]);
  }
  let normalized = text.normalize("NFD");
  const positions = [[0, 0]];
  let rawDiacriticsIndex = 0;
  let syllableIndex = 0;
  let shift = 0;
  let shiftOrigin = 0;
  let eol = 0;
  let hasDiacritics = false;
  normalized = normalized.replace(normalizationRegex, (match2, p1, p2, p3, p4, p5, p6, p7, p8, i2) => {
    i2 -= shiftOrigin;
    if (p1) {
      const replacement = CHARACTERS_TO_NORMALIZE[p1];
      const jj = replacement.length;
      for (let j = 1; j < jj; j++) {
        positions.push([i2 - shift + j, shift - j]);
      }
      shift -= jj - 1;
      return replacement;
    }
    if (p2) {
      let replacement = NFKC_CHARS_TO_NORMALIZE.get(p2);
      if (!replacement) {
        replacement = p2.normalize("NFKC");
        NFKC_CHARS_TO_NORMALIZE.set(p2, replacement);
      }
      const jj = replacement.length;
      for (let j = 1; j < jj; j++) {
        positions.push([i2 - shift + j, shift - j]);
      }
      shift -= jj - 1;
      return replacement;
    }
    if (p3) {
      hasDiacritics = true;
      if (i2 + eol === rawDiacriticsPositions[rawDiacriticsIndex]?.[1]) {
        ++rawDiacriticsIndex;
      } else {
        positions.push([i2 - 1 - shift + 1, shift - 1]);
        shift -= 1;
        shiftOrigin += 1;
      }
      positions.push([i2 - shift + 1, shift]);
      shiftOrigin += 1;
      eol += 1;
      return p3.charAt(0);
    }
    if (p4) {
      const hasTrailingDashEOL = p4.endsWith("\n");
      const len = hasTrailingDashEOL ? p4.length - 2 : p4.length;
      hasDiacritics = true;
      let jj = len;
      if (i2 + eol === rawDiacriticsPositions[rawDiacriticsIndex]?.[1]) {
        jj -= rawDiacriticsPositions[rawDiacriticsIndex][0];
        ++rawDiacriticsIndex;
      }
      for (let j = 1; j <= jj; j++) {
        positions.push([i2 - 1 - shift + j, shift - j]);
      }
      shift -= jj;
      shiftOrigin += jj;
      if (hasTrailingDashEOL) {
        i2 += len - 1;
        positions.push([i2 - shift + 1, 1 + shift]);
        shift += 1;
        shiftOrigin += 1;
        eol += 1;
        return p4.slice(0, len);
      }
      return p4;
    }
    if (p5) {
      const len = p5.length - 2;
      positions.push([i2 - shift + len, 1 + shift]);
      shift += 1;
      shiftOrigin += 1;
      eol += 1;
      return p5.slice(0, -2);
    }
    if (p6) {
      const len = p6.length - 1;
      positions.push([i2 - shift + len, shift]);
      shiftOrigin += 1;
      eol += 1;
      return p6.slice(0, -1);
    }
    if (p7) {
      positions.push([i2 - shift + 1, shift - 1]);
      shift -= 1;
      shiftOrigin += 1;
      eol += 1;
      return " ";
    }
    if (i2 + eol === syllablePositions[syllableIndex]?.[1]) {
      const newCharLen = syllablePositions[syllableIndex][0] - 1;
      ++syllableIndex;
      for (let j = 1; j <= newCharLen; j++) {
        positions.push([i2 - (shift - j), shift - j]);
      }
      shift -= newCharLen;
      shiftOrigin += newCharLen;
    }
    return p8;
  });
  positions.push([normalized.length, shift]);
  return [normalized, positions, hasDiacritics];
}
function getOriginalIndex(diffs, pos, len) {
  if (!diffs) {
    return [pos, len];
  }
  const start = pos;
  const end = pos + len - 1;
  let i2 = binarySearchFirstItem(diffs, (x2) => x2[0] >= start);
  if (diffs[i2][0] > start) {
    --i2;
  }
  let j = binarySearchFirstItem(diffs, (x2) => x2[0] >= end, i2);
  if (diffs[j][0] > end) {
    --j;
  }
  const oldStart = start + diffs[i2][1];
  const oldEnd = end + diffs[j][1];
  const oldLen = oldEnd + 1 - oldStart;
  return [oldStart, oldLen];
}
class PDFFindController {
  #state = null;
  #updateMatchesCountOnProgress = true;
  #visitedPagesCount = 0;
  constructor({
    linkService,
    eventBus,
    updateMatchesCountOnProgress = true
  }) {
    this._linkService = linkService;
    this._eventBus = eventBus;
    this.#updateMatchesCountOnProgress = updateMatchesCountOnProgress;
    this.onIsPageVisible = null;
    this.#reset();
    eventBus._on("find", this.#onFind.bind(this));
    eventBus._on("findbarclose", this.#onFindBarClose.bind(this));
  }
  get highlightMatches() {
    return this._highlightMatches;
  }
  get pageMatches() {
    return this._pageMatches;
  }
  get pageMatchesLength() {
    return this._pageMatchesLength;
  }
  get selected() {
    return this._selected;
  }
  get state() {
    return this.#state;
  }
  setDocument(pdfDocument) {
    if (this._pdfDocument) {
      this.#reset();
    }
    if (!pdfDocument) {
      return;
    }
    this._pdfDocument = pdfDocument;
    this._firstPageCapability.resolve();
  }
  #onFind(state) {
    if (!state) {
      return;
    }
    const pdfDocument = this._pdfDocument;
    const {
      type
    } = state;
    if (this.#state === null || this.#shouldDirtyMatch(state)) {
      this._dirtyMatch = true;
    }
    this.#state = state;
    if (type !== "highlightallchange") {
      this.#updateUIState(FindState.PENDING);
    }
    this._firstPageCapability.promise.then(() => {
      if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) {
        return;
      }
      this.#extractText();
      const findbarClosed = !this._highlightMatches;
      const pendingTimeout = !!this._findTimeout;
      if (this._findTimeout) {
        clearTimeout(this._findTimeout);
        this._findTimeout = null;
      }
      if (!type) {
        this._findTimeout = setTimeout(() => {
          this.#nextMatch();
          this._findTimeout = null;
        }, FIND_TIMEOUT);
      } else if (this._dirtyMatch) {
        this.#nextMatch();
      } else if (type === "again") {
        this.#nextMatch();
        if (findbarClosed && this.#state.highlightAll) {
          this.#updateAllPages();
        }
      } else if (type === "highlightallchange") {
        if (pendingTimeout) {
          this.#nextMatch();
        } else {
          this._highlightMatches = true;
        }
        this.#updateAllPages();
      } else {
        this.#nextMatch();
      }
    });
  }
  scrollMatchIntoView({
    element = null,
    selectedLeft = 0,
    pageIndex = -1,
    matchIndex = -1
  }) {
    if (!this._scrollMatches || !element) {
      return;
    } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) {
      return;
    } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) {
      return;
    }
    this._scrollMatches = false;
    const spot = {
      top: MATCH_SCROLL_OFFSET_TOP,
      left: selectedLeft + MATCH_SCROLL_OFFSET_LEFT
    };
    scrollIntoView(element, spot, true);
  }
  #reset() {
    this._highlightMatches = false;
    this._scrollMatches = false;
    this._pdfDocument = null;
    this._pageMatches = [];
    this._pageMatchesLength = [];
    this.#visitedPagesCount = 0;
    this.#state = null;
    this._selected = {
      pageIdx: -1,
      matchIdx: -1
    };
    this._offset = {
      pageIdx: null,
      matchIdx: null,
      wrapped: false
    };
    this._extractTextPromises = [];
    this._pageContents = [];
    this._pageDiffs = [];
    this._hasDiacritics = [];
    this._matchesCountTotal = 0;
    this._pagesToSearch = null;
    this._pendingFindMatches = /* @__PURE__ */ new Set();
    this._resumePageIdx = null;
    this._dirtyMatch = false;
    clearTimeout(this._findTimeout);
    this._findTimeout = null;
    this._firstPageCapability = Promise.withResolvers();
  }
  get #query() {
    const {
      query
    } = this.#state;
    if (typeof query === "string") {
      if (query !== this._rawQuery) {
        this._rawQuery = query;
        [this._normalizedQuery] = normalize(query);
      }
      return this._normalizedQuery;
    }
    return (query || []).filter((q) => !!q).map((q) => normalize(q)[0]);
  }
  #shouldDirtyMatch(state) {
    const newQuery = state.query, prevQuery = this.#state.query;
    const newType = typeof newQuery, prevType = typeof prevQuery;
    if (newType !== prevType) {
      return true;
    }
    if (newType === "string") {
      if (newQuery !== prevQuery) {
        return true;
      }
    } else if (JSON.stringify(newQuery) !== JSON.stringify(prevQuery)) {
      return true;
    }
    switch (state.type) {
      case "again":
        const pageNumber = this._selected.pageIdx + 1;
        const linkService = this._linkService;
        return pageNumber >= 1 && pageNumber <= linkService.pagesCount && pageNumber !== linkService.page && !(this.onIsPageVisible?.(pageNumber) ?? true);
      case "highlightallchange":
        return false;
    }
    return true;
  }
  #isEntireWord(content, startIdx, length) {
    let match2 = content.slice(0, startIdx).match(NOT_DIACRITIC_FROM_END_REG_EXP);
    if (match2) {
      const first = content.charCodeAt(startIdx);
      const limit = match2[1].charCodeAt(0);
      if (getCharacterType(first) === getCharacterType(limit)) {
        return false;
      }
    }
    match2 = content.slice(startIdx + length).match(NOT_DIACRITIC_FROM_START_REG_EXP);
    if (match2) {
      const last2 = content.charCodeAt(startIdx + length - 1);
      const limit = match2[1].charCodeAt(0);
      if (getCharacterType(last2) === getCharacterType(limit)) {
        return false;
      }
    }
    return true;
  }
  #calculateRegExpMatch(query, entireWord, pageIndex, pageContent) {
    const matches = this._pageMatches[pageIndex] = [];
    const matchesLength = this._pageMatchesLength[pageIndex] = [];
    if (!query) {
      return;
    }
    const diffs = this._pageDiffs[pageIndex];
    let match2;
    while ((match2 = query.exec(pageContent)) !== null) {
      if (entireWord && !this.#isEntireWord(pageContent, match2.index, match2[0].length)) {
        continue;
      }
      const [matchPos, matchLen] = getOriginalIndex(diffs, match2.index, match2[0].length);
      if (matchLen) {
        matches.push(matchPos);
        matchesLength.push(matchLen);
      }
    }
  }
  #convertToRegExpString(query, hasDiacritics) {
    const {
      matchDiacritics
    } = this.#state;
    let isUnicode = false;
    query = query.replaceAll(SPECIAL_CHARS_REG_EXP, (match2, p1, p2, p3, p4, p5) => {
      if (p1) {
        return `[ ]*\\${p1}[ ]*`;
      }
      if (p2) {
        return `[ ]*${p2}[ ]*`;
      }
      if (p3) {
        return "[ ]+";
      }
      if (matchDiacritics) {
        return p4 || p5;
      }
      if (p4) {
        return DIACRITICS_EXCEPTION.has(p4.charCodeAt(0)) ? p4 : "";
      }
      if (hasDiacritics) {
        isUnicode = true;
        return `${p5}\\p{M}*`;
      }
      return p5;
    });
    const trailingSpaces = "[ ]*";
    if (query.endsWith(trailingSpaces)) {
      query = query.slice(0, query.length - trailingSpaces.length);
    }
    if (matchDiacritics) {
      if (hasDiacritics) {
        DIACRITICS_EXCEPTION_STR ||= String.fromCharCode(...DIACRITICS_EXCEPTION);
        isUnicode = true;
        query = `${query}(?=[${DIACRITICS_EXCEPTION_STR}]|[^\\p{M}]|$)`;
      }
    }
    return [isUnicode, query];
  }
  #calculateMatch(pageIndex) {
    let query = this.#query;
    if (query.length === 0) {
      return;
    }
    const {
      caseSensitive,
      entireWord
    } = this.#state;
    const pageContent = this._pageContents[pageIndex];
    const hasDiacritics = this._hasDiacritics[pageIndex];
    let isUnicode = false;
    if (typeof query === "string") {
      [isUnicode, query] = this.#convertToRegExpString(query, hasDiacritics);
    } else {
      query = query.sort().reverse().map((q) => {
        const [isUnicodePart, queryPart] = this.#convertToRegExpString(q, hasDiacritics);
        isUnicode ||= isUnicodePart;
        return `(${queryPart})`;
      }).join("|");
    }
    const flags = `g${isUnicode ? "u" : ""}${caseSensitive ? "" : "i"}`;
    query = query ? new RegExp(query, flags) : null;
    this.#calculateRegExpMatch(query, entireWord, pageIndex, pageContent);
    if (this.#state.highlightAll) {
      this.#updatePage(pageIndex);
    }
    if (this._resumePageIdx === pageIndex) {
      this._resumePageIdx = null;
      this.#nextPageMatch();
    }
    const pageMatchesCount = this._pageMatches[pageIndex].length;
    this._matchesCountTotal += pageMatchesCount;
    if (this.#updateMatchesCountOnProgress) {
      if (pageMatchesCount > 0) {
        this.#updateUIResultsCount();
      }
    } else if (++this.#visitedPagesCount === this._linkService.pagesCount) {
      this.#updateUIResultsCount();
    }
  }
  #extractText() {
    if (this._extractTextPromises.length > 0) {
      return;
    }
    let deferred = Promise.resolve();
    const textOptions = {
      disableNormalization: true
    };
    for (let i2 = 0, ii = this._linkService.pagesCount; i2 < ii; i2++) {
      const {
        promise,
        resolve: resolve2
      } = Promise.withResolvers();
      this._extractTextPromises[i2] = promise;
      deferred = deferred.then(() => {
        return this._pdfDocument.getPage(i2 + 1).then((pdfPage) => pdfPage.getTextContent(textOptions)).then((textContent) => {
          const strBuf = [];
          for (const textItem of textContent.items) {
            strBuf.push(textItem.str);
            if (textItem.hasEOL) {
              strBuf.push("\n");
            }
          }
          [this._pageContents[i2], this._pageDiffs[i2], this._hasDiacritics[i2]] = normalize(strBuf.join(""));
          resolve2();
        }, (reason) => {
          console.error(`Unable to get text content for page ${i2 + 1}`, reason);
          this._pageContents[i2] = "";
          this._pageDiffs[i2] = null;
          this._hasDiacritics[i2] = false;
          resolve2();
        });
      });
    }
  }
  #updatePage(index) {
    if (this._scrollMatches && this._selected.pageIdx === index) {
      this._linkService.page = index + 1;
    }
    this._eventBus.dispatch("updatetextlayermatches", {
      source: this,
      pageIndex: index
    });
  }
  #updateAllPages() {
    this._eventBus.dispatch("updatetextlayermatches", {
      source: this,
      pageIndex: -1
    });
  }
  #nextMatch() {
    const previous = this.#state.findPrevious;
    const currentPageIndex = this._linkService.page - 1;
    const numPages = this._linkService.pagesCount;
    this._highlightMatches = true;
    if (this._dirtyMatch) {
      this._dirtyMatch = false;
      this._selected.pageIdx = this._selected.matchIdx = -1;
      this._offset.pageIdx = currentPageIndex;
      this._offset.matchIdx = null;
      this._offset.wrapped = false;
      this._resumePageIdx = null;
      this._pageMatches.length = 0;
      this._pageMatchesLength.length = 0;
      this.#visitedPagesCount = 0;
      this._matchesCountTotal = 0;
      this.#updateAllPages();
      for (let i2 = 0; i2 < numPages; i2++) {
        if (this._pendingFindMatches.has(i2)) {
          continue;
        }
        this._pendingFindMatches.add(i2);
        this._extractTextPromises[i2].then(() => {
          this._pendingFindMatches.delete(i2);
          this.#calculateMatch(i2);
        });
      }
    }
    const query = this.#query;
    if (query.length === 0) {
      this.#updateUIState(FindState.FOUND);
      return;
    }
    if (this._resumePageIdx) {
      return;
    }
    const offset = this._offset;
    this._pagesToSearch = numPages;
    if (offset.matchIdx !== null) {
      const numPageMatches = this._pageMatches[offset.pageIdx].length;
      if (!previous && offset.matchIdx + 1 < numPageMatches || previous && offset.matchIdx > 0) {
        offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1;
        this.#updateMatch(true);
        return;
      }
      this.#advanceOffsetPage(previous);
    }
    this.#nextPageMatch();
  }
  #matchesReady(matches) {
    const offset = this._offset;
    const numMatches = matches.length;
    const previous = this.#state.findPrevious;
    if (numMatches) {
      offset.matchIdx = previous ? numMatches - 1 : 0;
      this.#updateMatch(true);
      return true;
    }
    this.#advanceOffsetPage(previous);
    if (offset.wrapped) {
      offset.matchIdx = null;
      if (this._pagesToSearch < 0) {
        this.#updateMatch(false);
        return true;
      }
    }
    return false;
  }
  #nextPageMatch() {
    if (this._resumePageIdx !== null) {
      console.error("There can only be one pending page.");
    }
    let matches = null;
    do {
      const pageIdx = this._offset.pageIdx;
      matches = this._pageMatches[pageIdx];
      if (!matches) {
        this._resumePageIdx = pageIdx;
        break;
      }
    } while (!this.#matchesReady(matches));
  }
  #advanceOffsetPage(previous) {
    const offset = this._offset;
    const numPages = this._linkService.pagesCount;
    offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1;
    offset.matchIdx = null;
    this._pagesToSearch--;
    if (offset.pageIdx >= numPages || offset.pageIdx < 0) {
      offset.pageIdx = previous ? numPages - 1 : 0;
      offset.wrapped = true;
    }
  }
  #updateMatch(found = false) {
    let state = FindState.NOT_FOUND;
    const wrapped = this._offset.wrapped;
    this._offset.wrapped = false;
    if (found) {
      const previousPage = this._selected.pageIdx;
      this._selected.pageIdx = this._offset.pageIdx;
      this._selected.matchIdx = this._offset.matchIdx;
      state = wrapped ? FindState.WRAPPED : FindState.FOUND;
      if (previousPage !== -1 && previousPage !== this._selected.pageIdx) {
        this.#updatePage(previousPage);
      }
    }
    this.#updateUIState(state, this.#state.findPrevious);
    if (this._selected.pageIdx !== -1) {
      this._scrollMatches = true;
      this.#updatePage(this._selected.pageIdx);
    }
  }
  #onFindBarClose(evt) {
    const pdfDocument = this._pdfDocument;
    this._firstPageCapability.promise.then(() => {
      if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) {
        return;
      }
      if (this._findTimeout) {
        clearTimeout(this._findTimeout);
        this._findTimeout = null;
      }
      if (this._resumePageIdx) {
        this._resumePageIdx = null;
        this._dirtyMatch = true;
      }
      this.#updateUIState(FindState.FOUND);
      this._highlightMatches = false;
      this.#updateAllPages();
    });
  }
  #requestMatchesCount() {
    const {
      pageIdx,
      matchIdx
    } = this._selected;
    let current = 0, total = this._matchesCountTotal;
    if (matchIdx !== -1) {
      for (let i2 = 0; i2 < pageIdx; i2++) {
        current += this._pageMatches[i2]?.length || 0;
      }
      current += matchIdx + 1;
    }
    if (current < 1 || current > total) {
      current = total = 0;
    }
    return {
      current,
      total
    };
  }
  #updateUIResultsCount() {
    this._eventBus.dispatch("updatefindmatchescount", {
      source: this,
      matchesCount: this.#requestMatchesCount()
    });
  }
  #updateUIState(state, previous = false) {
    if (!this.#updateMatchesCountOnProgress && (this.#visitedPagesCount !== this._linkService.pagesCount || state === FindState.PENDING)) {
      return;
    }
    this._eventBus.dispatch("updatefindcontrolstate", {
      source: this,
      state,
      previous,
      matchesCount: this.#requestMatchesCount(),
      rawQuery: this.#state?.query ?? null
    });
  }
}
const DEFAULT_LINK_REL = "noopener noreferrer nofollow";
const LinkTarget = {
  NONE: 0,
  SELF: 1,
  BLANK: 2,
  PARENT: 3,
  TOP: 4
};
class PDFLinkService {
  externalLinkEnabled = true;
  constructor({
    eventBus,
    externalLinkTarget = null,
    externalLinkRel = null,
    ignoreDestinationZoom = false
  } = {}) {
    this.eventBus = eventBus;
    this.externalLinkTarget = externalLinkTarget;
    this.externalLinkRel = externalLinkRel;
    this._ignoreDestinationZoom = ignoreDestinationZoom;
    this.baseUrl = null;
    this.pdfDocument = null;
    this.pdfViewer = null;
    this.pdfHistory = null;
  }
  setDocument(pdfDocument, baseUrl = null) {
    this.baseUrl = baseUrl;
    this.pdfDocument = pdfDocument;
  }
  setViewer(pdfViewer) {
    this.pdfViewer = pdfViewer;
  }
  setHistory(pdfHistory) {
    this.pdfHistory = pdfHistory;
  }
  get pagesCount() {
    return this.pdfDocument ? this.pdfDocument.numPages : 0;
  }
  get page() {
    return this.pdfDocument ? this.pdfViewer.currentPageNumber : 1;
  }
  set page(value) {
    if (this.pdfDocument) {
      this.pdfViewer.currentPageNumber = value;
    }
  }
  get rotation() {
    return this.pdfDocument ? this.pdfViewer.pagesRotation : 0;
  }
  set rotation(value) {
    if (this.pdfDocument) {
      this.pdfViewer.pagesRotation = value;
    }
  }
  get isInPresentationMode() {
    return this.pdfDocument ? this.pdfViewer.isInPresentationMode : false;
  }
  async goToDestination(dest) {
    if (!this.pdfDocument) {
      return;
    }
    let namedDest, explicitDest, pageNumber;
    if (typeof dest === "string") {
      namedDest = dest;
      explicitDest = await this.pdfDocument.getDestination(dest);
    } else {
      namedDest = null;
      explicitDest = await dest;
    }
    if (!Array.isArray(explicitDest)) {
      console.error(`goToDestination: "${explicitDest}" is not a valid destination array, for dest="${dest}".`);
      return;
    }
    const [destRef] = explicitDest;
    if (destRef && typeof destRef === "object") {
      pageNumber = this.pdfDocument.cachedPageNumber(destRef);
      if (!pageNumber) {
        try {
          pageNumber = await this.pdfDocument.getPageIndex(destRef) + 1;
        } catch {
          console.error(`goToDestination: "${destRef}" is not a valid page reference, for dest="${dest}".`);
          return;
        }
      }
    } else if (Number.isInteger(destRef)) {
      pageNumber = destRef + 1;
    }
    if (!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount) {
      console.error(`goToDestination: "${pageNumber}" is not a valid page number, for dest="${dest}".`);
      return;
    }
    if (this.pdfHistory) {
      this.pdfHistory.pushCurrentPosition();
      this.pdfHistory.push({
        namedDest,
        explicitDest,
        pageNumber
      });
    }
    this.pdfViewer.scrollPageIntoView({
      pageNumber,
      destArray: explicitDest,
      ignoreDestinationZoom: this._ignoreDestinationZoom
    });
  }
  goToPage(val) {
    if (!this.pdfDocument) {
      return;
    }
    const pageNumber = typeof val === "string" && this.pdfViewer.pageLabelToPageNumber(val) || val | 0;
    if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
      console.error(`PDFLinkService.goToPage: "${val}" is not a valid page.`);
      return;
    }
    if (this.pdfHistory) {
      this.pdfHistory.pushCurrentPosition();
      this.pdfHistory.pushPage(pageNumber);
    }
    this.pdfViewer.scrollPageIntoView({
      pageNumber
    });
  }
  addLinkAttributes(link, url, newWindow = false) {
    if (!url || typeof url !== "string") {
      throw new Error('A valid "url" parameter must provided.');
    }
    const target = newWindow ? LinkTarget.BLANK : this.externalLinkTarget, rel = this.externalLinkRel;
    if (this.externalLinkEnabled) {
      link.href = link.title = url;
    } else {
      link.href = "";
      link.title = `Disabled: ${url}`;
      link.onclick = () => false;
    }
    let targetStr = "";
    switch (target) {
      case LinkTarget.NONE:
        break;
      case LinkTarget.SELF:
        targetStr = "_self";
        break;
      case LinkTarget.BLANK:
        targetStr = "_blank";
        break;
      case LinkTarget.PARENT:
        targetStr = "_parent";
        break;
      case LinkTarget.TOP:
        targetStr = "_top";
        break;
    }
    link.target = targetStr;
    link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
  }
  getDestinationHash(dest) {
    if (typeof dest === "string") {
      if (dest.length > 0) {
        return this.getAnchorUrl("#" + escape(dest));
      }
    } else if (Array.isArray(dest)) {
      const str = JSON.stringify(dest);
      if (str.length > 0) {
        return this.getAnchorUrl("#" + escape(str));
      }
    }
    return this.getAnchorUrl("");
  }
  getAnchorUrl(anchor) {
    return this.baseUrl ? this.baseUrl + anchor : anchor;
  }
  setHash(hash) {
    if (!this.pdfDocument) {
      return;
    }
    let pageNumber, dest;
    if (hash.includes("=")) {
      const params = parseQueryString(hash);
      if (params.has("search")) {
        const query = params.get("search").replaceAll('"', ""), phrase = params.get("phrase") === "true";
        this.eventBus.dispatch("findfromurlhash", {
          source: this,
          query: phrase ? query : query.match(/\S+/g)
        });
      }
      if (params.has("page")) {
        pageNumber = params.get("page") | 0 || 1;
      }
      if (params.has("zoom")) {
        const zoomArgs = params.get("zoom").split(",");
        const zoomArg = zoomArgs[0];
        const zoomArgNumber = parseFloat(zoomArg);
        if (!zoomArg.includes("Fit")) {
          dest = [null, {
            name: "XYZ"
          }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg];
        } else if (zoomArg === "Fit" || zoomArg === "FitB") {
          dest = [null, {
            name: zoomArg
          }];
        } else if (zoomArg === "FitH" || zoomArg === "FitBH" || zoomArg === "FitV" || zoomArg === "FitBV") {
          dest = [null, {
            name: zoomArg
          }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null];
        } else if (zoomArg === "FitR") {
          if (zoomArgs.length !== 5) {
            console.error('PDFLinkService.setHash: Not enough parameters for "FitR".');
          } else {
            dest = [null, {
              name: zoomArg
            }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0];
          }
        } else {
          console.error(`PDFLinkService.setHash: "${zoomArg}" is not a valid zoom value.`);
        }
      }
      if (dest) {
        this.pdfViewer.scrollPageIntoView({
          pageNumber: pageNumber || this.page,
          destArray: dest,
          allowNegativeOffset: true
        });
      } else if (pageNumber) {
        this.page = pageNumber;
      }
      if (params.has("pagemode")) {
        this.eventBus.dispatch("pagemode", {
          source: this,
          mode: params.get("pagemode")
        });
      }
      if (params.has("nameddest")) {
        this.goToDestination(params.get("nameddest"));
      }
      return;
    }
    dest = unescape(hash);
    try {
      dest = JSON.parse(dest);
      if (!Array.isArray(dest)) {
        dest = dest.toString();
      }
    } catch {
    }
    if (typeof dest === "string" || PDFLinkService.#isValidExplicitDest(dest)) {
      this.goToDestination(dest);
      return;
    }
    console.error(`PDFLinkService.setHash: "${unescape(hash)}" is not a valid destination.`);
  }
  executeNamedAction(action) {
    if (!this.pdfDocument) {
      return;
    }
    switch (action) {
      case "GoBack":
        this.pdfHistory?.back();
        break;
      case "GoForward":
        this.pdfHistory?.forward();
        break;
      case "NextPage":
        this.pdfViewer.nextPage();
        break;
      case "PrevPage":
        this.pdfViewer.previousPage();
        break;
      case "LastPage":
        this.page = this.pagesCount;
        break;
      case "FirstPage":
        this.page = 1;
        break;
    }
    this.eventBus.dispatch("namedaction", {
      source: this,
      action
    });
  }
  async executeSetOCGState(action) {
    if (!this.pdfDocument) {
      return;
    }
    const pdfDocument = this.pdfDocument, optionalContentConfig = await this.pdfViewer.optionalContentConfigPromise;
    if (pdfDocument !== this.pdfDocument) {
      return;
    }
    optionalContentConfig.setOCGState(action);
    this.pdfViewer.optionalContentConfigPromise = Promise.resolve(optionalContentConfig);
  }
  static #isValidExplicitDest(dest) {
    if (!Array.isArray(dest) || dest.length < 2) {
      return false;
    }
    const [page, zoom, ...args] = dest;
    if (!(typeof page === "object" && Number.isInteger(page?.num) && Number.isInteger(page?.gen)) && !Number.isInteger(page)) {
      return false;
    }
    if (!(typeof zoom === "object" && typeof zoom?.name === "string")) {
      return false;
    }
    let allowNull = true;
    switch (zoom.name) {
      case "XYZ":
        if (args.length !== 3) {
          return false;
        }
        break;
      case "Fit":
      case "FitB":
        return args.length === 0;
      case "FitH":
      case "FitBH":
      case "FitV":
      case "FitBV":
        if (args.length !== 1) {
          return false;
        }
        break;
      case "FitR":
        if (args.length !== 4) {
          return false;
        }
        allowNull = false;
        break;
      default:
        return false;
    }
    for (const arg of args) {
      if (!(typeof arg === "number" || allowNull && arg === null)) {
        return false;
      }
    }
    return true;
  }
}
class SimpleLinkService extends PDFLinkService {
  setDocument(pdfDocument, baseUrl = null) {
  }
}
const {
  AbortException: AbortException2,
  AnnotationEditorLayer: AnnotationEditorLayer2,
  AnnotationEditorParamsType,
  AnnotationEditorType,
  AnnotationEditorUIManager: AnnotationEditorUIManager2,
  AnnotationLayer: AnnotationLayer2,
  AnnotationMode,
  build,
  CMapCompressionType,
  ColorPicker: ColorPicker2,
  createValidAbsoluteUrl,
  DOMSVGFactory: DOMSVGFactory2,
  DrawLayer: DrawLayer2,
  FeatureTest,
  fetchData,
  getDocument,
  getFilenameFromUrl,
  getPdfFilenameFromUrl,
  getXfaPageViewport,
  GlobalWorkerOptions: GlobalWorkerOptions2,
  ImageKind,
  InvalidPDFException: InvalidPDFException2,
  isDataScheme,
  isPdfFile,
  MissingPDFException: MissingPDFException2,
  noContextMenu,
  normalizeUnicode,
  OPS,
  Outliner: Outliner2,
  PasswordResponses,
  PDFDataRangeTransport: PDFDataRangeTransport2,
  PDFDateString: PDFDateString2,
  PDFWorker: PDFWorker2,
  PermissionFlag,
  PixelsPerInch: PixelsPerInch2,
  RenderingCancelledException: RenderingCancelledException2,
  renderTextLayer,
  setLayerDimensions,
  shadow,
  TextLayer: TextLayer2,
  UnexpectedResponseException: UnexpectedResponseException2,
  updateTextLayer,
  Util: Util2,
  VerbosityLevel,
  version,
  XfaLayer: XfaLayer2
} = globalThis.pdfjsLib;
class AnnotationLayerBuilder {
  #onAppend = null;
  #eventAbortController = null;
  constructor({
    pdfPage,
    linkService,
    downloadManager,
    annotationStorage = null,
    imageResourcesPath = "",
    renderForms = true,
    enableScripting = false,
    hasJSActionsPromise = null,
    fieldObjectsPromise = null,
    annotationCanvasMap = null,
    accessibilityManager = null,
    annotationEditorUIManager = null,
    onAppend = null
  }) {
    this.pdfPage = pdfPage;
    this.linkService = linkService;
    this.downloadManager = downloadManager;
    this.imageResourcesPath = imageResourcesPath;
    this.renderForms = renderForms;
    this.annotationStorage = annotationStorage;
    this.enableScripting = enableScripting;
    this._hasJSActionsPromise = hasJSActionsPromise || Promise.resolve(false);
    this._fieldObjectsPromise = fieldObjectsPromise || Promise.resolve(null);
    this._annotationCanvasMap = annotationCanvasMap;
    this._accessibilityManager = accessibilityManager;
    this._annotationEditorUIManager = annotationEditorUIManager;
    this.#onAppend = onAppend;
    this.annotationLayer = null;
    this.div = null;
    this._cancelled = false;
    this._eventBus = linkService.eventBus;
  }
  async render(viewport, intent = "display") {
    if (this.div) {
      if (this._cancelled || !this.annotationLayer) {
        return;
      }
      this.annotationLayer.update({
        viewport: viewport.clone({
          dontFlip: true
        })
      });
      return;
    }
    const [annotations, hasJSActions, fieldObjects] = await Promise.all([this.pdfPage.getAnnotations({
      intent
    }), this._hasJSActionsPromise, this._fieldObjectsPromise]);
    if (this._cancelled) {
      return;
    }
    const div = this.div = document.createElement("div");
    div.className = "annotationLayer";
    this.#onAppend?.(div);
    if (annotations.length === 0) {
      this.hide();
      return;
    }
    this.annotationLayer = new AnnotationLayer2({
      div,
      accessibilityManager: this._accessibilityManager,
      annotationCanvasMap: this._annotationCanvasMap,
      annotationEditorUIManager: this._annotationEditorUIManager,
      page: this.pdfPage,
      viewport: viewport.clone({
        dontFlip: true
      })
    });
    await this.annotationLayer.render({
      annotations,
      imageResourcesPath: this.imageResourcesPath,
      renderForms: this.renderForms,
      linkService: this.linkService,
      downloadManager: this.downloadManager,
      annotationStorage: this.annotationStorage,
      enableScripting: this.enableScripting,
      hasJSActions,
      fieldObjects
    });
    if (this.linkService.isInPresentationMode) {
      this.#updatePresentationModeState(PresentationModeState.FULLSCREEN);
    }
    if (!this.#eventAbortController) {
      this.#eventAbortController = new AbortController();
      this._eventBus?._on("presentationmodechanged", (evt) => {
        this.#updatePresentationModeState(evt.state);
      }, {
        signal: this.#eventAbortController.signal
      });
    }
  }
  cancel() {
    this._cancelled = true;
    this.#eventAbortController?.abort();
    this.#eventAbortController = null;
  }
  hide() {
    if (!this.div) {
      return;
    }
    this.div.hidden = true;
  }
  #updatePresentationModeState(state) {
    if (!this.div) {
      return;
    }
    let disableFormElements = false;
    switch (state) {
      case PresentationModeState.FULLSCREEN:
        disableFormElements = true;
        break;
      case PresentationModeState.NORMAL:
        break;
      default:
        return;
    }
    for (const section of this.div.childNodes) {
      if (section.hasAttribute("data-internal-link")) {
        continue;
      }
      section.inert = disableFormElements;
    }
  }
}
function download(blobUrl, filename) {
  const a2 = document.createElement("a");
  if (!a2.click) {
    throw new Error('DownloadManager: "a.click()" is not supported.');
  }
  a2.href = blobUrl;
  a2.target = "_parent";
  if ("download" in a2) {
    a2.download = filename;
  }
  (document.body || document.documentElement).append(a2);
  a2.click();
  a2.remove();
}
class DownloadManager {
  #openBlobUrls = /* @__PURE__ */ new WeakMap();
  downloadUrl(url, filename, _options) {
    if (!createValidAbsoluteUrl(url, "http://example.com")) {
      console.error(`downloadUrl - not a valid URL: ${url}`);
      return;
    }
    download(url + "#pdfjs.action=download", filename);
  }
  downloadData(data2, filename, contentType) {
    const blobUrl = URL.createObjectURL(new Blob([data2], {
      type: contentType
    }));
    download(blobUrl, filename);
  }
  openOrDownloadData(data2, filename, dest = null) {
    const isPdfData = isPdfFile(filename);
    const contentType = isPdfData ? "application/pdf" : "";
    this.downloadData(data2, filename, contentType);
    return false;
  }
  download(blob, url, filename, _options) {
    const blobUrl = URL.createObjectURL(blob);
    download(blobUrl, filename);
  }
}
const WaitOnType = {
  EVENT: "event",
  TIMEOUT: "timeout"
};
async function waitOnEventOrTimeout({
  target,
  name,
  delay = 0
}) {
  if (typeof target !== "object" || !(name && typeof name === "string") || !(Number.isInteger(delay) && delay >= 0)) {
    throw new Error("waitOnEventOrTimeout - invalid parameters.");
  }
  const {
    promise,
    resolve: resolve2
  } = Promise.withResolvers();
  const ac = new AbortController();
  function handler(type) {
    ac.abort();
    clearTimeout(timeout);
    resolve2(type);
  }
  const evtMethod = target instanceof EventBus ? "_on" : "addEventListener";
  target[evtMethod](name, handler.bind(null, WaitOnType.EVENT), {
    signal: ac.signal
  });
  const timeout = setTimeout(handler.bind(null, WaitOnType.TIMEOUT), delay);
  return promise;
}
class EventBus {
  #listeners = /* @__PURE__ */ Object.create(null);
  on(eventName, listener2, options = null) {
    this._on(eventName, listener2, {
      external: true,
      once: options?.once,
      signal: options?.signal
    });
  }
  off(eventName, listener2, options = null) {
    this._off(eventName, listener2);
  }
  dispatch(eventName, data2) {
    const eventListeners = this.#listeners[eventName];
    if (!eventListeners || eventListeners.length === 0) {
      return;
    }
    let externalListeners;
    for (const {
      listener: listener2,
      external,
      once
    } of eventListeners.slice(0)) {
      if (once) {
        this._off(eventName, listener2);
      }
      if (external) {
        (externalListeners ||= []).push(listener2);
        continue;
      }
      listener2(data2);
    }
    if (externalListeners) {
      for (const listener2 of externalListeners) {
        listener2(data2);
      }
      externalListeners = null;
    }
  }
  _on(eventName, listener2, options = null) {
    let rmAbort = null;
    if (options?.signal instanceof AbortSignal) {
      const {
        signal
      } = options;
      if (signal.aborted) {
        console.error("Cannot use an `aborted` signal.");
        return;
      }
      const onAbort = () => this._off(eventName, listener2);
      rmAbort = () => signal.removeEventListener("abort", onAbort);
      signal.addEventListener("abort", onAbort);
    }
    const eventListeners = this.#listeners[eventName] ||= [];
    eventListeners.push({
      listener: listener2,
      external: options?.external === true,
      once: options?.once === true,
      rmAbort
    });
  }
  _off(eventName, listener2, options = null) {
    const eventListeners = this.#listeners[eventName];
    if (!eventListeners) {
      return;
    }
    for (let i2 = 0, ii = eventListeners.length; i2 < ii; i2++) {
      const evt = eventListeners[i2];
      if (evt.listener === listener2) {
        evt.rmAbort?.();
        eventListeners.splice(i2, 1);
        return;
      }
    }
  }
}
class FluentType {
  constructor(value) {
    this.value = value;
  }
  valueOf() {
    return this.value;
  }
}
class FluentNone extends FluentType {
  constructor(value = "???") {
    super(value);
  }
  toString(scope) {
    return `{${this.value}}`;
  }
}
class FluentNumber extends FluentType {
  constructor(value, opts = {}) {
    super(value);
    this.opts = opts;
  }
  toString(scope) {
    try {
      const nf = scope.memoizeIntlObject(Intl.NumberFormat, this.opts);
      return nf.format(this.value);
    } catch (err) {
      scope.reportError(err);
      return this.value.toString(10);
    }
  }
}
class FluentDateTime extends FluentType {
  constructor(value, opts = {}) {
    super(value);
    this.opts = opts;
  }
  toString(scope) {
    try {
      const dtf = scope.memoizeIntlObject(Intl.DateTimeFormat, this.opts);
      return dtf.format(this.value);
    } catch (err) {
      scope.reportError(err);
      return new Date(this.value).toISOString();
    }
  }
}
const MAX_PLACEABLES = 100;
const FSI = "";
const PDI = "";
function match(scope, selector2, key) {
  if (key === selector2) {
    return true;
  }
  if (key instanceof FluentNumber && selector2 instanceof FluentNumber && key.value === selector2.value) {
    return true;
  }
  if (selector2 instanceof FluentNumber && typeof key === "string") {
    let category = scope.memoizeIntlObject(Intl.PluralRules, selector2.opts).select(selector2.value);
    if (key === category) {
      return true;
    }
  }
  return false;
}
function getDefault(scope, variants, star) {
  if (variants[star]) {
    return resolvePattern(scope, variants[star].value);
  }
  scope.reportError(new RangeError("No default"));
  return new FluentNone();
}
function getArguments(scope, args) {
  const positional = [];
  const named = /* @__PURE__ */ Object.create(null);
  for (const arg of args) {
    if (arg.type === "narg") {
      named[arg.name] = resolveExpression(scope, arg.value);
    } else {
      positional.push(resolveExpression(scope, arg));
    }
  }
  return {
    positional,
    named
  };
}
function resolveExpression(scope, expr) {
  switch (expr.type) {
    case "str":
      return expr.value;
    case "num":
      return new FluentNumber(expr.value, {
        minimumFractionDigits: expr.precision
      });
    case "var":
      return resolveVariableReference(scope, expr);
    case "mesg":
      return resolveMessageReference(scope, expr);
    case "term":
      return resolveTermReference(scope, expr);
    case "func":
      return resolveFunctionReference(scope, expr);
    case "select":
      return resolveSelectExpression(scope, expr);
    default:
      return new FluentNone();
  }
}
function resolveVariableReference(scope, {
  name
}) {
  let arg;
  if (scope.params) {
    if (Object.prototype.hasOwnProperty.call(scope.params, name)) {
      arg = scope.params[name];
    } else {
      return new FluentNone(`$${name}`);
    }
  } else if (scope.args && Object.prototype.hasOwnProperty.call(scope.args, name)) {
    arg = scope.args[name];
  } else {
    scope.reportError(new ReferenceError(`Unknown variable: $${name}`));
    return new FluentNone(`$${name}`);
  }
  if (arg instanceof FluentType) {
    return arg;
  }
  switch (typeof arg) {
    case "string":
      return arg;
    case "number":
      return new FluentNumber(arg);
    case "object":
      if (arg instanceof Date) {
        return new FluentDateTime(arg.getTime());
      }
    default:
      scope.reportError(new TypeError(`Variable type not supported: $${name}, ${typeof arg}`));
      return new FluentNone(`$${name}`);
  }
}
function resolveMessageReference(scope, {
  name,
  attr
}) {
  const message = scope.bundle._messages.get(name);
  if (!message) {
    scope.reportError(new ReferenceError(`Unknown message: ${name}`));
    return new FluentNone(name);
  }
  if (attr) {
    const attribute = message.attributes[attr];
    if (attribute) {
      return resolvePattern(scope, attribute);
    }
    scope.reportError(new ReferenceError(`Unknown attribute: ${attr}`));
    return new FluentNone(`${name}.${attr}`);
  }
  if (message.value) {
    return resolvePattern(scope, message.value);
  }
  scope.reportError(new ReferenceError(`No value: ${name}`));
  return new FluentNone(name);
}
function resolveTermReference(scope, {
  name,
  attr,
  args
}) {
  const id2 = `-${name}`;
  const term = scope.bundle._terms.get(id2);
  if (!term) {
    scope.reportError(new ReferenceError(`Unknown term: ${id2}`));
    return new FluentNone(id2);
  }
  if (attr) {
    const attribute = term.attributes[attr];
    if (attribute) {
      scope.params = getArguments(scope, args).named;
      const resolved2 = resolvePattern(scope, attribute);
      scope.params = null;
      return resolved2;
    }
    scope.reportError(new ReferenceError(`Unknown attribute: ${attr}`));
    return new FluentNone(`${id2}.${attr}`);
  }
  scope.params = getArguments(scope, args).named;
  const resolved = resolvePattern(scope, term.value);
  scope.params = null;
  return resolved;
}
function resolveFunctionReference(scope, {
  name,
  args
}) {
  let func = scope.bundle._functions[name];
  if (!func) {
    scope.reportError(new ReferenceError(`Unknown function: ${name}()`));
    return new FluentNone(`${name}()`);
  }
  if (typeof func !== "function") {
    scope.reportError(new TypeError(`Function ${name}() is not callable`));
    return new FluentNone(`${name}()`);
  }
  try {
    let resolved = getArguments(scope, args);
    return func(resolved.positional, resolved.named);
  } catch (err) {
    scope.reportError(err);
    return new FluentNone(`${name}()`);
  }
}
function resolveSelectExpression(scope, {
  selector: selector2,
  variants,
  star
}) {
  let sel = resolveExpression(scope, selector2);
  if (sel instanceof FluentNone) {
    return getDefault(scope, variants, star);
  }
  for (const variant of variants) {
    const key = resolveExpression(scope, variant.key);
    if (match(scope, sel, key)) {
      return resolvePattern(scope, variant.value);
    }
  }
  return getDefault(scope, variants, star);
}
function resolveComplexPattern(scope, ptn) {
  if (scope.dirty.has(ptn)) {
    scope.reportError(new RangeError("Cyclic reference"));
    return new FluentNone();
  }
  scope.dirty.add(ptn);
  const result = [];
  const useIsolating = scope.bundle._useIsolating && ptn.length > 1;
  for (const elem of ptn) {
    if (typeof elem === "string") {
      result.push(scope.bundle._transform(elem));
      continue;
    }
    scope.placeables++;
    if (scope.placeables > MAX_PLACEABLES) {
      scope.dirty.delete(ptn);
      throw new RangeError(`Too many placeables expanded: ${scope.placeables}, max allowed is ${MAX_PLACEABLES}`);
    }
    if (useIsolating) {
      result.push(FSI);
    }
    result.push(resolveExpression(scope, elem).toString(scope));
    if (useIsolating) {
      result.push(PDI);
    }
  }
  scope.dirty.delete(ptn);
  return result.join("");
}
function resolvePattern(scope, value) {
  if (typeof value === "string") {
    return scope.bundle._transform(value);
  }
  return resolveComplexPattern(scope, value);
}
class Scope {
  constructor(bundle, errors, args) {
    this.dirty = /* @__PURE__ */ new WeakSet();
    this.params = null;
    this.placeables = 0;
    this.bundle = bundle;
    this.errors = errors;
    this.args = args;
  }
  reportError(error) {
    if (!this.errors || !(error instanceof Error)) {
      throw error;
    }
    this.errors.push(error);
  }
  memoizeIntlObject(ctor, opts) {
    let cache2 = this.bundle._intls.get(ctor);
    if (!cache2) {
      cache2 = {};
      this.bundle._intls.set(ctor, cache2);
    }
    let id2 = JSON.stringify(opts);
    if (!cache2[id2]) {
      cache2[id2] = new ctor(this.bundle.locales, opts);
    }
    return cache2[id2];
  }
}
function values(opts, allowed) {
  const unwrapped = /* @__PURE__ */ Object.create(null);
  for (const [name, opt] of Object.entries(opts)) {
    if (allowed.includes(name)) {
      unwrapped[name] = opt.valueOf();
    }
  }
  return unwrapped;
}
const NUMBER_ALLOWED = ["unitDisplay", "currencyDisplay", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits"];
function NUMBER(args, opts) {
  let arg = args[0];
  if (arg instanceof FluentNone) {
    return new FluentNone(`NUMBER(${arg.valueOf()})`);
  }
  if (arg instanceof FluentNumber) {
    return new FluentNumber(arg.valueOf(), {
      ...arg.opts,
      ...values(opts, NUMBER_ALLOWED)
    });
  }
  if (arg instanceof FluentDateTime) {
    return new FluentNumber(arg.valueOf(), {
      ...values(opts, NUMBER_ALLOWED)
    });
  }
  throw new TypeError("Invalid argument to NUMBER");
}
const DATETIME_ALLOWED = ["dateStyle", "timeStyle", "fractionalSecondDigits", "dayPeriod", "hour12", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName"];
function DATETIME(args, opts) {
  let arg = args[0];
  if (arg instanceof FluentNone) {
    return new FluentNone(`DATETIME(${arg.valueOf()})`);
  }
  if (arg instanceof FluentDateTime) {
    return new FluentDateTime(arg.valueOf(), {
      ...arg.opts,
      ...values(opts, DATETIME_ALLOWED)
    });
  }
  if (arg instanceof FluentNumber) {
    return new FluentDateTime(arg.valueOf(), {
      ...values(opts, DATETIME_ALLOWED)
    });
  }
  throw new TypeError("Invalid argument to DATETIME");
}
const cache = /* @__PURE__ */ new Map();
function getMemoizerForLocale(locales) {
  const stringLocale = Array.isArray(locales) ? locales.join(" ") : locales;
  let memoizer = cache.get(stringLocale);
  if (memoizer === void 0) {
    memoizer = /* @__PURE__ */ new Map();
    cache.set(stringLocale, memoizer);
  }
  return memoizer;
}
class FluentBundle {
  constructor(locales, {
    functions,
    useIsolating = true,
    transform: transform2 = (v2) => v2
  } = {}) {
    this._terms = /* @__PURE__ */ new Map();
    this._messages = /* @__PURE__ */ new Map();
    this.locales = Array.isArray(locales) ? locales : [locales];
    this._functions = {
      NUMBER,
      DATETIME,
      ...functions
    };
    this._useIsolating = useIsolating;
    this._transform = transform2;
    this._intls = getMemoizerForLocale(locales);
  }
  hasMessage(id2) {
    return this._messages.has(id2);
  }
  getMessage(id2) {
    return this._messages.get(id2);
  }
  addResource(res, {
    allowOverrides = false
  } = {}) {
    const errors = [];
    for (let i2 = 0; i2 < res.body.length; i2++) {
      let entry = res.body[i2];
      if (entry.id.startsWith("-")) {
        if (allowOverrides === false && this._terms.has(entry.id)) {
          errors.push(new Error(`Attempt to override an existing term: "${entry.id}"`));
          continue;
        }
        this._terms.set(entry.id, entry);
      } else {
        if (allowOverrides === false && this._messages.has(entry.id)) {
          errors.push(new Error(`Attempt to override an existing message: "${entry.id}"`));
          continue;
        }
        this._messages.set(entry.id, entry);
      }
    }
    return errors;
  }
  formatPattern(pattern, args = null, errors = null) {
    if (typeof pattern === "string") {
      return this._transform(pattern);
    }
    let scope = new Scope(this, errors, args);
    try {
      let value = resolveComplexPattern(scope, pattern);
      return value.toString(scope);
    } catch (err) {
      if (scope.errors && err instanceof Error) {
        scope.errors.push(err);
        return new FluentNone().toString(scope);
      }
      throw err;
    }
  }
}
const RE_MESSAGE_START = /^(-?[a-zA-Z][\w-]*) *= */gm;
const RE_ATTRIBUTE_START = /\.([a-zA-Z][\w-]*) *= */y;
const RE_VARIANT_START = /\*?\[/y;
const RE_NUMBER_LITERAL = /(-?[0-9]+(?:\.([0-9]+))?)/y;
const RE_IDENTIFIER = /([a-zA-Z][\w-]*)/y;
const RE_REFERENCE = /([$-])?([a-zA-Z][\w-]*)(?:\.([a-zA-Z][\w-]*))?/y;
const RE_FUNCTION_NAME = /^[A-Z][A-Z0-9_-]*$/;
const RE_TEXT_RUN = /([^{}\n\r]+)/y;
const RE_STRING_RUN = /([^\\"\n\r]*)/y;
const RE_STRING_ESCAPE = /\\([\\"])/y;
const RE_UNICODE_ESCAPE = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{6})/y;
const RE_LEADING_NEWLINES = /^\n+/;
const RE_TRAILING_SPACES = / +$/;
const RE_BLANK_LINES = / *\r?\n/g;
const RE_INDENT = /( *)$/;
const TOKEN_BRACE_OPEN = /{\s*/y;
const TOKEN_BRACE_CLOSE = /\s*}/y;
const TOKEN_BRACKET_OPEN = /\[\s*/y;
const TOKEN_BRACKET_CLOSE = /\s*] */y;
const TOKEN_PAREN_OPEN = /\s*\(\s*/y;
const TOKEN_ARROW = /\s*->\s*/y;
const TOKEN_COLON = /\s*:\s*/y;
const TOKEN_COMMA = /\s*,?\s*/y;
const TOKEN_BLANK = /\s+/y;
class FluentResource {
  constructor(source) {
    this.body = [];
    RE_MESSAGE_START.lastIndex = 0;
    let cursor = 0;
    while (true) {
      let next = RE_MESSAGE_START.exec(source);
      if (next === null) {
        break;
      }
      cursor = RE_MESSAGE_START.lastIndex;
      try {
        this.body.push(parseMessage(next[1]));
      } catch (err) {
        if (err instanceof SyntaxError) {
          continue;
        }
        throw err;
      }
    }
    function test(re) {
      re.lastIndex = cursor;
      return re.test(source);
    }
    function consumeChar(char, errorClass) {
      if (source[cursor] === char) {
        cursor++;
        return true;
      }
      if (errorClass) {
        throw new errorClass(`Expected ${char}`);
      }
      return false;
    }
    function consumeToken(re, errorClass) {
      if (test(re)) {
        cursor = re.lastIndex;
        return true;
      }
      if (errorClass) {
        throw new errorClass(`Expected ${re.toString()}`);
      }
      return false;
    }
    function match2(re) {
      re.lastIndex = cursor;
      let result = re.exec(source);
      if (result === null) {
        throw new SyntaxError(`Expected ${re.toString()}`);
      }
      cursor = re.lastIndex;
      return result;
    }
    function match1(re) {
      return match2(re)[1];
    }
    function parseMessage(id2) {
      let value = parsePattern();
      let attributes = parseAttributes();
      if (value === null && Object.keys(attributes).length === 0) {
        throw new SyntaxError("Expected message value or attributes");
      }
      return {
        id: id2,
        value,
        attributes
      };
    }
    function parseAttributes() {
      let attrs = /* @__PURE__ */ Object.create(null);
      while (test(RE_ATTRIBUTE_START)) {
        let name = match1(RE_ATTRIBUTE_START);
        let value = parsePattern();
        if (value === null) {
          throw new SyntaxError("Expected attribute value");
        }
        attrs[name] = value;
      }
      return attrs;
    }
    function parsePattern() {
      let first;
      if (test(RE_TEXT_RUN)) {
        first = match1(RE_TEXT_RUN);
      }
      if (source[cursor] === "{" || source[cursor] === "}") {
        return parsePatternElements(first ? [first] : [], Infinity);
      }
      let indent = parseIndent();
      if (indent) {
        if (first) {
          return parsePatternElements([first, indent], indent.length);
        }
        indent.value = trim(indent.value, RE_LEADING_NEWLINES);
        return parsePatternElements([indent], indent.length);
      }
      if (first) {
        return trim(first, RE_TRAILING_SPACES);
      }
      return null;
    }
    function parsePatternElements(elements = [], commonIndent) {
      while (true) {
        if (test(RE_TEXT_RUN)) {
          elements.push(match1(RE_TEXT_RUN));
          continue;
        }
        if (source[cursor] === "{") {
          elements.push(parsePlaceable());
          continue;
        }
        if (source[cursor] === "}") {
          throw new SyntaxError("Unbalanced closing brace");
        }
        let indent = parseIndent();
        if (indent) {
          elements.push(indent);
          commonIndent = Math.min(commonIndent, indent.length);
          continue;
        }
        break;
      }
      let lastIndex = elements.length - 1;
      let lastElement = elements[lastIndex];
      if (typeof lastElement === "string") {
        elements[lastIndex] = trim(lastElement, RE_TRAILING_SPACES);
      }
      let baked = [];
      for (let element of elements) {
        if (element instanceof Indent) {
          element = element.value.slice(0, element.value.length - commonIndent);
        }
        if (element) {
          baked.push(element);
        }
      }
      return baked;
    }
    function parsePlaceable() {
      consumeToken(TOKEN_BRACE_OPEN, SyntaxError);
      let selector2 = parseInlineExpression();
      if (consumeToken(TOKEN_BRACE_CLOSE)) {
        return selector2;
      }
      if (consumeToken(TOKEN_ARROW)) {
        let variants = parseVariants();
        consumeToken(TOKEN_BRACE_CLOSE, SyntaxError);
        return {
          type: "select",
          selector: selector2,
          ...variants
        };
      }
      throw new SyntaxError("Unclosed placeable");
    }
    function parseInlineExpression() {
      if (source[cursor] === "{") {
        return parsePlaceable();
      }
      if (test(RE_REFERENCE)) {
        let [, sigil, name, attr = null] = match2(RE_REFERENCE);
        if (sigil === "$") {
          return {
            type: "var",
            name
          };
        }
        if (consumeToken(TOKEN_PAREN_OPEN)) {
          let args = parseArguments();
          if (sigil === "-") {
            return {
              type: "term",
              name,
              attr,
              args
            };
          }
          if (RE_FUNCTION_NAME.test(name)) {
            return {
              type: "func",
              name,
              args
            };
          }
          throw new SyntaxError("Function names must be all upper-case");
        }
        if (sigil === "-") {
          return {
            type: "term",
            name,
            attr,
            args: []
          };
        }
        return {
          type: "mesg",
          name,
          attr
        };
      }
      return parseLiteral();
    }
    function parseArguments() {
      let args = [];
      while (true) {
        switch (source[cursor]) {
          case ")":
            cursor++;
            return args;
          case void 0:
            throw new SyntaxError("Unclosed argument list");
        }
        args.push(parseArgument());
        consumeToken(TOKEN_COMMA);
      }
    }
    function parseArgument() {
      let expr = parseInlineExpression();
      if (expr.type !== "mesg") {
        return expr;
      }
      if (consumeToken(TOKEN_COLON)) {
        return {
          type: "narg",
          name: expr.name,
          value: parseLiteral()
        };
      }
      return expr;
    }
    function parseVariants() {
      let variants = [];
      let count = 0;
      let star;
      while (test(RE_VARIANT_START)) {
        if (consumeChar("*")) {
          star = count;
        }
        let key = parseVariantKey();
        let value = parsePattern();
        if (value === null) {
          throw new SyntaxError("Expected variant value");
        }
        variants[count++] = {
          key,
          value
        };
      }
      if (count === 0) {
        return null;
      }
      if (star === void 0) {
        throw new SyntaxError("Expected default variant");
      }
      return {
        variants,
        star
      };
    }
    function parseVariantKey() {
      consumeToken(TOKEN_BRACKET_OPEN, SyntaxError);
      let key;
      if (test(RE_NUMBER_LITERAL)) {
        key = parseNumberLiteral();
      } else {
        key = {
          type: "str",
          value: match1(RE_IDENTIFIER)
        };
      }
      consumeToken(TOKEN_BRACKET_CLOSE, SyntaxError);
      return key;
    }
    function parseLiteral() {
      if (test(RE_NUMBER_LITERAL)) {
        return parseNumberLiteral();
      }
      if (source[cursor] === '"') {
        return parseStringLiteral();
      }
      throw new SyntaxError("Invalid expression");
    }
    function parseNumberLiteral() {
      let [, value, fraction = ""] = match2(RE_NUMBER_LITERAL);
      let precision = fraction.length;
      return {
        type: "num",
        value: parseFloat(value),
        precision
      };
    }
    function parseStringLiteral() {
      consumeChar('"', SyntaxError);
      let value = "";
      while (true) {
        value += match1(RE_STRING_RUN);
        if (source[cursor] === "\\") {
          value += parseEscapeSequence();
          continue;
        }
        if (consumeChar('"')) {
          return {
            type: "str",
            value
          };
        }
        throw new SyntaxError("Unclosed string literal");
      }
    }
    function parseEscapeSequence() {
      if (test(RE_STRING_ESCAPE)) {
        return match1(RE_STRING_ESCAPE);
      }
      if (test(RE_UNICODE_ESCAPE)) {
        let [, codepoint4, codepoint6] = match2(RE_UNICODE_ESCAPE);
        let codepoint = parseInt(codepoint4 || codepoint6, 16);
        return codepoint <= 55295 || 57344 <= codepoint ? String.fromCodePoint(codepoint) : "";
      }
      throw new SyntaxError("Unknown escape sequence");
    }
    function parseIndent() {
      let start = cursor;
      consumeToken(TOKEN_BLANK);
      switch (source[cursor]) {
        case ".":
        case "[":
        case "*":
        case "}":
        case void 0:
          return false;
        case "{":
          return makeIndent(source.slice(start, cursor));
      }
      if (source[cursor - 1] === " ") {
        return makeIndent(source.slice(start, cursor));
      }
      return false;
    }
    function trim(text, re) {
      return text.replace(re, "");
    }
    function makeIndent(blank) {
      let value = blank.replace(RE_BLANK_LINES, "\n");
      let length = RE_INDENT.exec(blank)[1].length;
      return new Indent(value, length);
    }
  }
}
class Indent {
  constructor(value, length) {
    this.value = value;
    this.length = length;
  }
}
const reOverlay = /<|&#?\w+;/;
const TEXT_LEVEL_ELEMENTS = {
  "http://www.w3.org/1999/xhtml": ["em", "strong", "small", "s", "cite", "q", "dfn", "abbr", "data", "time", "code", "var", "samp", "kbd", "sub", "sup", "i", "b", "u", "mark", "bdi", "bdo", "span", "br", "wbr"]
};
const LOCALIZABLE_ATTRIBUTES = {
  "http://www.w3.org/1999/xhtml": {
    global: ["title", "aria-label", "aria-valuetext"],
    a: ["download"],
    area: ["download", "alt"],
    input: ["alt", "placeholder"],
    menuitem: ["label"],
    menu: ["label"],
    optgroup: ["label"],
    option: ["label"],
    track: ["label"],
    img: ["alt"],
    textarea: ["placeholder"],
    th: ["abbr"]
  },
  "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul": {
    global: ["accesskey", "aria-label", "aria-valuetext", "label", "title", "tooltiptext"],
    description: ["value"],
    key: ["key", "keycode"],
    label: ["value"],
    textbox: ["placeholder", "value"]
  }
};
function translateElement(element, translation) {
  const {
    value
  } = translation;
  if (typeof value === "string") {
    if (element.localName === "title" && element.namespaceURI === "http://www.w3.org/1999/xhtml") {
      element.textContent = value;
    } else if (!reOverlay.test(value)) {
      element.textContent = value;
    } else {
      const templateElement = element.ownerDocument.createElementNS("http://www.w3.org/1999/xhtml", "template");
      templateElement.innerHTML = value;
      overlayChildNodes(templateElement.content, element);
    }
  }
  overlayAttributes(translation, element);
}
function overlayChildNodes(fromFragment, toElement2) {
  for (const childNode of fromFragment.childNodes) {
    if (childNode.nodeType === childNode.TEXT_NODE) {
      continue;
    }
    if (childNode.hasAttribute("data-l10n-name")) {
      const sanitized = getNodeForNamedElement(toElement2, childNode);
      fromFragment.replaceChild(sanitized, childNode);
      continue;
    }
    if (isElementAllowed(childNode)) {
      const sanitized = createSanitizedElement(childNode);
      fromFragment.replaceChild(sanitized, childNode);
      continue;
    }
    console.warn(`An element of forbidden type "${childNode.localName}" was found in the translation. Only safe text-level elements and elements with data-l10n-name are allowed.`);
    fromFragment.replaceChild(createTextNodeFromTextContent(childNode), childNode);
  }
  toElement2.textContent = "";
  toElement2.appendChild(fromFragment);
}
function hasAttribute(attributes, name) {
  if (!attributes) {
    return false;
  }
  for (let attr of attributes) {
    if (attr.name === name) {
      return true;
    }
  }
  return false;
}
function overlayAttributes(fromElement, toElement2) {
  const explicitlyAllowed = toElement2.hasAttribute("data-l10n-attrs") ? toElement2.getAttribute("data-l10n-attrs").split(",").map((i2) => i2.trim()) : null;
  for (const attr of Array.from(toElement2.attributes)) {
    if (isAttrNameLocalizable(attr.name, toElement2, explicitlyAllowed) && !hasAttribute(fromElement.attributes, attr.name)) {
      toElement2.removeAttribute(attr.name);
    }
  }
  if (!fromElement.attributes) {
    return;
  }
  for (const attr of Array.from(fromElement.attributes)) {
    if (isAttrNameLocalizable(attr.name, toElement2, explicitlyAllowed) && toElement2.getAttribute(attr.name) !== attr.value) {
      toElement2.setAttribute(attr.name, attr.value);
    }
  }
}
function getNodeForNamedElement(sourceElement, translatedChild) {
  const childName = translatedChild.getAttribute("data-l10n-name");
  const sourceChild = sourceElement.querySelector(`[data-l10n-name="${childName}"]`);
  if (!sourceChild) {
    console.warn(`An element named "${childName}" wasn't found in the source.`);
    return createTextNodeFromTextContent(translatedChild);
  }
  if (sourceChild.localName !== translatedChild.localName) {
    console.warn(`An element named "${childName}" was found in the translation but its type ${translatedChild.localName} didn't match the element found in the source (${sourceChild.localName}).`);
    return createTextNodeFromTextContent(translatedChild);
  }
  sourceElement.removeChild(sourceChild);
  const clone = sourceChild.cloneNode(false);
  return shallowPopulateUsing(translatedChild, clone);
}
function createSanitizedElement(element) {
  const clone = element.ownerDocument.createElement(element.localName);
  return shallowPopulateUsing(element, clone);
}
function createTextNodeFromTextContent(element) {
  return element.ownerDocument.createTextNode(element.textContent);
}
function isElementAllowed(element) {
  const allowed = TEXT_LEVEL_ELEMENTS[element.namespaceURI];
  return allowed && allowed.includes(element.localName);
}
function isAttrNameLocalizable(name, element, explicitlyAllowed = null) {
  if (explicitlyAllowed && explicitlyAllowed.includes(name)) {
    return true;
  }
  const allowed = LOCALIZABLE_ATTRIBUTES[element.namespaceURI];
  if (!allowed) {
    return false;
  }
  const attrName = name.toLowerCase();
  const elemName = element.localName;
  if (allowed.global.includes(attrName)) {
    return true;
  }
  if (!allowed[elemName]) {
    return false;
  }
  if (allowed[elemName].includes(attrName)) {
    return true;
  }
  if (element.namespaceURI === "http://www.w3.org/1999/xhtml" && elemName === "input" && attrName === "value") {
    const type = element.type.toLowerCase();
    if (type === "submit" || type === "button" || type === "reset") {
      return true;
    }
  }
  return false;
}
function shallowPopulateUsing(fromElement, toElement2) {
  toElement2.textContent = fromElement.textContent;
  overlayAttributes(fromElement, toElement2);
  return toElement2;
}
class CachedIterable extends Array {
  static from(iterable) {
    if (iterable instanceof this) {
      return iterable;
    }
    return new this(iterable);
  }
}
class CachedAsyncIterable extends CachedIterable {
  constructor(iterable) {
    super();
    if (Symbol.asyncIterator in Object(iterable)) {
      this.iterator = iterable[Symbol.asyncIterator]();
    } else if (Symbol.iterator in Object(iterable)) {
      this.iterator = iterable[Symbol.iterator]();
    } else {
      throw new TypeError("Argument must implement the iteration protocol.");
    }
  }
  [Symbol.asyncIterator]() {
    const cached = this;
    let cur = 0;
    return {
      async next() {
        if (cached.length <= cur) {
          cached.push(cached.iterator.next());
        }
        return cached[cur++];
      }
    };
  }
  async touchNext(count = 1) {
    let idx = 0;
    while (idx++ < count) {
      const last2 = this[this.length - 1];
      if (last2 && (await last2).done) {
        break;
      }
      this.push(this.iterator.next());
    }
    return this[this.length - 1];
  }
}
class Localization {
  constructor(resourceIds = [], generateBundles) {
    this.resourceIds = resourceIds;
    this.generateBundles = generateBundles;
    this.onChange(true);
  }
  addResourceIds(resourceIds, eager = false) {
    this.resourceIds.push(...resourceIds);
    this.onChange(eager);
    return this.resourceIds.length;
  }
  removeResourceIds(resourceIds) {
    this.resourceIds = this.resourceIds.filter((r2) => !resourceIds.includes(r2));
    this.onChange();
    return this.resourceIds.length;
  }
  async formatWithFallback(keys, method) {
    const translations = [];
    let hasAtLeastOneBundle = false;
    for await (const bundle of this.bundles) {
      hasAtLeastOneBundle = true;
      const missingIds = keysFromBundle(method, bundle, keys, translations);
      if (missingIds.size === 0) {
        break;
      }
      if (typeof console !== "undefined") {
        const locale = bundle.locales[0];
        const ids = Array.from(missingIds).join(", ");
        console.warn(`[fluent] Missing translations in ${locale}: ${ids}`);
      }
    }
    if (!hasAtLeastOneBundle && typeof console !== "undefined") {
      console.warn(`[fluent] Request for keys failed because no resource bundles got generated.
  keys: ${JSON.stringify(keys)}.
  resourceIds: ${JSON.stringify(this.resourceIds)}.`);
    }
    return translations;
  }
  formatMessages(keys) {
    return this.formatWithFallback(keys, messageFromBundle);
  }
  formatValues(keys) {
    return this.formatWithFallback(keys, valueFromBundle);
  }
  async formatValue(id2, args) {
    const [val] = await this.formatValues([{
      id: id2,
      args
    }]);
    return val;
  }
  handleEvent() {
    this.onChange();
  }
  onChange(eager = false) {
    this.bundles = CachedAsyncIterable.from(this.generateBundles(this.resourceIds));
    if (eager) {
      this.bundles.touchNext(2);
    }
  }
}
function valueFromBundle(bundle, errors, message, args) {
  if (message.value) {
    return bundle.formatPattern(message.value, args, errors);
  }
  return null;
}
function messageFromBundle(bundle, errors, message, args) {
  const formatted = {
    value: null,
    attributes: null
  };
  if (message.value) {
    formatted.value = bundle.formatPattern(message.value, args, errors);
  }
  let attrNames = Object.keys(message.attributes);
  if (attrNames.length > 0) {
    formatted.attributes = new Array(attrNames.length);
    for (let [i2, name] of attrNames.entries()) {
      let value = bundle.formatPattern(message.attributes[name], args, errors);
      formatted.attributes[i2] = {
        name,
        value
      };
    }
  }
  return formatted;
}
function keysFromBundle(method, bundle, keys, translations) {
  const messageErrors = [];
  const missingIds = /* @__PURE__ */ new Set();
  keys.forEach(({
    id: id2,
    args
  }, i2) => {
    if (translations[i2] !== void 0) {
      return;
    }
    let message = bundle.getMessage(id2);
    if (message) {
      messageErrors.length = 0;
      translations[i2] = method(bundle, messageErrors, message, args);
      if (messageErrors.length > 0 && typeof console !== "undefined") {
        const locale = bundle.locales[0];
        const errors = messageErrors.join(", ");
        console.warn(`[fluent][resolver] errors in ${locale}/${id2}: ${errors}.`);
      }
    } else {
      missingIds.add(id2);
    }
  });
  return missingIds;
}
const L10NID_ATTR_NAME = "data-l10n-id";
const L10NARGS_ATTR_NAME = "data-l10n-args";
const L10N_ELEMENT_QUERY = `[${L10NID_ATTR_NAME}]`;
class DOMLocalization extends Localization {
  constructor(resourceIds, generateBundles) {
    super(resourceIds, generateBundles);
    this.roots = /* @__PURE__ */ new Set();
    this.pendingrAF = null;
    this.pendingElements = /* @__PURE__ */ new Set();
    this.windowElement = null;
    this.mutationObserver = null;
    this.observerConfig = {
      attributes: true,
      characterData: false,
      childList: true,
      subtree: true,
      attributeFilter: [L10NID_ATTR_NAME, L10NARGS_ATTR_NAME]
    };
  }
  onChange(eager = false) {
    super.onChange(eager);
    if (this.roots) {
      this.translateRoots();
    }
  }
  setAttributes(element, id2, args) {
    element.setAttribute(L10NID_ATTR_NAME, id2);
    if (args) {
      element.setAttribute(L10NARGS_ATTR_NAME, JSON.stringify(args));
    } else {
      element.removeAttribute(L10NARGS_ATTR_NAME);
    }
    return element;
  }
  getAttributes(element) {
    return {
      id: element.getAttribute(L10NID_ATTR_NAME),
      args: JSON.parse(element.getAttribute(L10NARGS_ATTR_NAME) || null)
    };
  }
  connectRoot(newRoot) {
    for (const root of this.roots) {
      if (root === newRoot || root.contains(newRoot) || newRoot.contains(root)) {
        throw new Error("Cannot add a root that overlaps with existing root.");
      }
    }
    if (this.windowElement) {
      if (this.windowElement !== newRoot.ownerDocument.defaultView) {
        throw new Error(`Cannot connect a root:
          DOMLocalization already has a root from a different window.`);
      }
    } else {
      this.windowElement = newRoot.ownerDocument.defaultView;
      this.mutationObserver = new this.windowElement.MutationObserver((mutations) => this.translateMutations(mutations));
    }
    this.roots.add(newRoot);
    this.mutationObserver.observe(newRoot, this.observerConfig);
  }
  disconnectRoot(root) {
    this.roots.delete(root);
    this.pauseObserving();
    if (this.roots.size === 0) {
      this.mutationObserver = null;
      this.windowElement = null;
      this.pendingrAF = null;
      this.pendingElements.clear();
      return true;
    }
    this.resumeObserving();
    return false;
  }
  translateRoots() {
    const roots = Array.from(this.roots);
    return Promise.all(roots.map((root) => this.translateFragment(root)));
  }
  pauseObserving() {
    if (!this.mutationObserver) {
      return;
    }
    this.translateMutations(this.mutationObserver.takeRecords());
    this.mutationObserver.disconnect();
  }
  resumeObserving() {
    if (!this.mutationObserver) {
      return;
    }
    for (const root of this.roots) {
      this.mutationObserver.observe(root, this.observerConfig);
    }
  }
  translateMutations(mutations) {
    for (const mutation of mutations) {
      switch (mutation.type) {
        case "attributes":
          if (mutation.target.hasAttribute("data-l10n-id")) {
            this.pendingElements.add(mutation.target);
          }
          break;
        case "childList":
          for (const addedNode of mutation.addedNodes) {
            if (addedNode.nodeType === addedNode.ELEMENT_NODE) {
              if (addedNode.childElementCount) {
                for (const element of this.getTranslatables(addedNode)) {
                  this.pendingElements.add(element);
                }
              } else if (addedNode.hasAttribute(L10NID_ATTR_NAME)) {
                this.pendingElements.add(addedNode);
              }
            }
          }
          break;
      }
    }
    if (this.pendingElements.size > 0) {
      if (this.pendingrAF === null) {
        this.pendingrAF = this.windowElement.requestAnimationFrame(() => {
          this.translateElements(Array.from(this.pendingElements));
          this.pendingElements.clear();
          this.pendingrAF = null;
        });
      }
    }
  }
  translateFragment(frag) {
    return this.translateElements(this.getTranslatables(frag));
  }
  async translateElements(elements) {
    if (!elements.length) {
      return void 0;
    }
    const keys = elements.map(this.getKeysForElement);
    const translations = await this.formatMessages(keys);
    return this.applyTranslations(elements, translations);
  }
  applyTranslations(elements, translations) {
    this.pauseObserving();
    for (let i2 = 0; i2 < elements.length; i2++) {
      if (translations[i2] !== void 0) {
        translateElement(elements[i2], translations[i2]);
      }
    }
    this.resumeObserving();
  }
  getTranslatables(element) {
    const nodes = Array.from(element.querySelectorAll(L10N_ELEMENT_QUERY));
    if (typeof element.hasAttribute === "function" && element.hasAttribute(L10NID_ATTR_NAME)) {
      nodes.push(element);
    }
    return nodes;
  }
  getKeysForElement(element) {
    return {
      id: element.getAttribute(L10NID_ATTR_NAME),
      args: JSON.parse(element.getAttribute(L10NARGS_ATTR_NAME) || null)
    };
  }
}
class L10n {
  #dir;
  #lang;
  #l10n;
  constructor({
    lang,
    isRTL
  }, l10n = null) {
    this.#lang = L10n.#fixupLangCode(lang);
    this.#l10n = l10n;
    this.#dir = isRTL ?? L10n.#isRTL(this.#lang) ? "rtl" : "ltr";
  }
  _setL10n(l10n) {
    this.#l10n = l10n;
  }
  getLanguage() {
    return this.#lang;
  }
  getDirection() {
    return this.#dir;
  }
  async get(ids, args = null, fallback) {
    if (Array.isArray(ids)) {
      ids = ids.map((id2) => ({
        id: id2
      }));
      const messages2 = await this.#l10n.formatMessages(ids);
      return messages2.map((message) => message.value);
    }
    const messages = await this.#l10n.formatMessages([{
      id: ids,
      args
    }]);
    return messages?.[0].value || fallback;
  }
  async translate(element) {
    try {
      this.#l10n.connectRoot(element);
      await this.#l10n.translateRoots();
    } catch {
    }
  }
  pause() {
    this.#l10n.pauseObserving();
  }
  resume() {
    this.#l10n.resumeObserving();
  }
  static #fixupLangCode(langCode) {
    langCode = langCode?.toLowerCase() || "en-us";
    const PARTIAL_LANG_CODES = {
      en: "en-us",
      es: "es-es",
      fy: "fy-nl",
      ga: "ga-ie",
      gu: "gu-in",
      hi: "hi-in",
      hy: "hy-am",
      nb: "nb-no",
      ne: "ne-np",
      nn: "nn-no",
      pa: "pa-in",
      pt: "pt-pt",
      sv: "sv-se",
      zh: "zh-cn"
    };
    return PARTIAL_LANG_CODES[langCode] || langCode;
  }
  static #isRTL(lang) {
    const shortCode = lang.split("-", 1)[0];
    return ["ar", "he", "fa", "ps", "ur"].includes(shortCode);
  }
}
function createBundle(lang, text) {
  const resource = new FluentResource(text);
  const bundle = new FluentBundle(lang);
  const errors = bundle.addResource(resource);
  if (errors.length) {
    console.error("L10n errors", errors);
  }
  return bundle;
}
class genericl10n_GenericL10n extends L10n {
  constructor(lang) {
    super({
      lang
    });
    const generateBundles = !lang ? genericl10n_GenericL10n.#generateBundlesFallback.bind(genericl10n_GenericL10n, this.getLanguage()) : genericl10n_GenericL10n.#generateBundles.bind(genericl10n_GenericL10n, "en-us", this.getLanguage());
    this._setL10n(new DOMLocalization([], generateBundles));
  }
  static async *#generateBundles(defaultLang, baseLang) {
    const {
      baseURL,
      paths
    } = await this.#getPaths();
    const langs2 = [baseLang];
    if (defaultLang !== baseLang) {
      const shortLang = baseLang.split("-", 1)[0];
      if (shortLang !== baseLang) {
        langs2.push(shortLang);
      }
      langs2.push(defaultLang);
    }
    for (const lang of langs2) {
      const bundle = await this.#createBundle(lang, baseURL, paths);
      if (bundle) {
        yield bundle;
      }
      if (lang === "en-us") {
        yield this.#createBundleFallback(lang);
      }
    }
  }
  static async #createBundle(lang, baseURL, paths) {
    const path = paths[lang];
    if (!path) {
      return null;
    }
    const url = new URL(path, baseURL);
    const text = await fetchData(url, "text");
    return createBundle(lang, text);
  }
  static async #getPaths() {
    try {
      const {
        href
      } = document.querySelector(`link[type="application/l10n"]`);
      const paths = await fetchData(href, "json");
      return {
        baseURL: href.replace(/[^/]*$/, "") || "./",
        paths
      };
    } catch {
    }
    return {
      baseURL: "./",
      paths: /* @__PURE__ */ Object.create(null)
    };
  }
  static async *#generateBundlesFallback(lang) {
    yield this.#createBundleFallback(lang);
  }
  static async #createBundleFallback(lang) {
    const text = "pdfjs-previous-button =\n    .title = Previous Page\npdfjs-previous-button-label = Previous\npdfjs-next-button =\n    .title = Next Page\npdfjs-next-button-label = Next\npdfjs-page-input =\n    .title = Page\npdfjs-of-pages = of { $pagesCount }\npdfjs-page-of-pages = ({ $pageNumber } of { $pagesCount })\npdfjs-zoom-out-button =\n    .title = Zoom Out\npdfjs-zoom-out-button-label = Zoom Out\npdfjs-zoom-in-button =\n    .title = Zoom In\npdfjs-zoom-in-button-label = Zoom In\npdfjs-zoom-select =\n    .title = Zoom\npdfjs-presentation-mode-button =\n    .title = Switch to Presentation Mode\npdfjs-presentation-mode-button-label = Presentation Mode\npdfjs-open-file-button =\n    .title = Open File\npdfjs-open-file-button-label = Open\npdfjs-print-button =\n    .title = Print\npdfjs-print-button-label = Print\npdfjs-save-button =\n    .title = Save\npdfjs-save-button-label = Save\npdfjs-download-button =\n    .title = Download\npdfjs-download-button-label = Download\npdfjs-bookmark-button =\n    .title = Current Page (View URL from Current Page)\npdfjs-bookmark-button-label = Current Page\npdfjs-tools-button =\n    .title = Tools\npdfjs-tools-button-label = Tools\npdfjs-first-page-button =\n    .title = Go to First Page\npdfjs-first-page-button-label = Go to First Page\npdfjs-last-page-button =\n    .title = Go to Last Page\npdfjs-last-page-button-label = Go to Last Page\npdfjs-page-rotate-cw-button =\n    .title = Rotate Clockwise\npdfjs-page-rotate-cw-button-label = Rotate Clockwise\npdfjs-page-rotate-ccw-button =\n    .title = Rotate Counterclockwise\npdfjs-page-rotate-ccw-button-label = Rotate Counterclockwise\npdfjs-cursor-text-select-tool-button =\n    .title = Enable Text Selection Tool\npdfjs-cursor-text-select-tool-button-label = Text Selection Tool\npdfjs-cursor-hand-tool-button =\n    .title = Enable Hand Tool\npdfjs-cursor-hand-tool-button-label = Hand Tool\npdfjs-scroll-page-button =\n    .title = Use Page Scrolling\npdfjs-scroll-page-button-label = Page Scrolling\npdfjs-scroll-vertical-button =\n    .title = Use Vertical Scrolling\npdfjs-scroll-vertical-button-label = Vertical Scrolling\npdfjs-scroll-horizontal-button =\n    .title = Use Horizontal Scrolling\npdfjs-scroll-horizontal-button-label = Horizontal Scrolling\npdfjs-scroll-wrapped-button =\n    .title = Use Wrapped Scrolling\npdfjs-scroll-wrapped-button-label = Wrapped Scrolling\npdfjs-spread-none-button =\n    .title = Do not join page spreads\npdfjs-spread-none-button-label = No Spreads\npdfjs-spread-odd-button =\n    .title = Join page spreads starting with odd-numbered pages\npdfjs-spread-odd-button-label = Odd Spreads\npdfjs-spread-even-button =\n    .title = Join page spreads starting with even-numbered pages\npdfjs-spread-even-button-label = Even Spreads\npdfjs-document-properties-button =\n    .title = Document Properties\npdfjs-document-properties-button-label = Document Properties\npdfjs-document-properties-file-name = File name:\npdfjs-document-properties-file-size = File size:\npdfjs-document-properties-kb = { $size_kb } KB ({ $size_b } bytes)\npdfjs-document-properties-mb = { $size_mb } MB ({ $size_b } bytes)\npdfjs-document-properties-title = Title:\npdfjs-document-properties-author = Author:\npdfjs-document-properties-subject = Subject:\npdfjs-document-properties-keywords = Keywords:\npdfjs-document-properties-creation-date = Creation Date:\npdfjs-document-properties-modification-date = Modification Date:\npdfjs-document-properties-date-string = { $date }, { $time }\npdfjs-document-properties-creator = Creator:\npdfjs-document-properties-producer = PDF Producer:\npdfjs-document-properties-version = PDF Version:\npdfjs-document-properties-page-count = Page Count:\npdfjs-document-properties-page-size = Page Size:\npdfjs-document-properties-page-size-unit-inches = in\npdfjs-document-properties-page-size-unit-millimeters = mm\npdfjs-document-properties-page-size-orientation-portrait = portrait\npdfjs-document-properties-page-size-orientation-landscape = landscape\npdfjs-document-properties-page-size-name-a-three = A3\npdfjs-document-properties-page-size-name-a-four = A4\npdfjs-document-properties-page-size-name-letter = Letter\npdfjs-document-properties-page-size-name-legal = Legal\npdfjs-document-properties-page-size-dimension-string = { $width }  { $height } { $unit } ({ $orientation })\npdfjs-document-properties-page-size-dimension-name-string = { $width }  { $height } { $unit } ({ $name }, { $orientation })\npdfjs-document-properties-linearized = Fast Web View:\npdfjs-document-properties-linearized-yes = Yes\npdfjs-document-properties-linearized-no = No\npdfjs-document-properties-close-button = Close\npdfjs-print-progress-message = Preparing document for printing\npdfjs-print-progress-percent = { $progress }%\npdfjs-print-progress-close-button = Cancel\npdfjs-printing-not-supported = Warning: Printing is not fully supported by this browser.\npdfjs-printing-not-ready = Warning: The PDF is not fully loaded for printing.\npdfjs-toggle-sidebar-button =\n    .title = Toggle Sidebar\npdfjs-toggle-sidebar-notification-button =\n    .title = Toggle Sidebar (document contains outline/attachments/layers)\npdfjs-toggle-sidebar-button-label = Toggle Sidebar\npdfjs-document-outline-button =\n    .title = Show Document Outline (double-click to expand/collapse all items)\npdfjs-document-outline-button-label = Document Outline\npdfjs-attachments-button =\n    .title = Show Attachments\npdfjs-attachments-button-label = Attachments\npdfjs-layers-button =\n    .title = Show Layers (double-click to reset all layers to the default state)\npdfjs-layers-button-label = Layers\npdfjs-thumbs-button =\n    .title = Show Thumbnails\npdfjs-thumbs-button-label = Thumbnails\npdfjs-current-outline-item-button =\n    .title = Find Current Outline Item\npdfjs-current-outline-item-button-label = Current Outline Item\npdfjs-findbar-button =\n    .title = Find in Document\npdfjs-findbar-button-label = Find\npdfjs-additional-layers = Additional Layers\npdfjs-thumb-page-title =\n    .title = Page { $page }\npdfjs-thumb-page-canvas =\n    .aria-label = Thumbnail of Page { $page }\npdfjs-find-input =\n    .title = Find\n    .placeholder = Find in document\npdfjs-find-previous-button =\n    .title = Find the previous occurrence of the phrase\npdfjs-find-previous-button-label = Previous\npdfjs-find-next-button =\n    .title = Find the next occurrence of the phrase\npdfjs-find-next-button-label = Next\npdfjs-find-highlight-checkbox = Highlight All\npdfjs-find-match-case-checkbox-label = Match Case\npdfjs-find-match-diacritics-checkbox-label = Match Diacritics\npdfjs-find-entire-word-checkbox-label = Whole Words\npdfjs-find-reached-top = Reached top of document, continued from bottom\npdfjs-find-reached-bottom = Reached end of document, continued from top\npdfjs-find-match-count =\n    { $total ->\n        [one] { $current } of { $total } match\n       *[other] { $current } of { $total } matches\n    }\npdfjs-find-match-count-limit =\n    { $limit ->\n        [one] More than { $limit } match\n       *[other] More than { $limit } matches\n    }\npdfjs-find-not-found = Phrase not found\npdfjs-page-scale-width = Page Width\npdfjs-page-scale-fit = Page Fit\npdfjs-page-scale-auto = Automatic Zoom\npdfjs-page-scale-actual = Actual Size\npdfjs-page-scale-percent = { $scale }%\npdfjs-page-landmark =\n    .aria-label = Page { $page }\npdfjs-loading-error = An error occurred while loading the PDF.\npdfjs-invalid-file-error = Invalid or corrupted PDF file.\npdfjs-missing-file-error = Missing PDF file.\npdfjs-unexpected-response-error = Unexpected server response.\npdfjs-rendering-error = An error occurred while rendering the page.\npdfjs-annotation-date-string = { $date }, { $time }\npdfjs-text-annotation-type =\n    .alt = [{ $type } Annotation]\npdfjs-password-label = Enter the password to open this PDF file.\npdfjs-password-invalid = Invalid password. Please try again.\npdfjs-password-ok-button = OK\npdfjs-password-cancel-button = Cancel\npdfjs-web-fonts-disabled = Web fonts are disabled: unable to use embedded PDF fonts.\npdfjs-editor-free-text-button =\n    .title = Text\npdfjs-editor-free-text-button-label = Text\npdfjs-editor-ink-button =\n    .title = Draw\npdfjs-editor-ink-button-label = Draw\npdfjs-editor-stamp-button =\n    .title = Add or edit images\npdfjs-editor-stamp-button-label = Add or edit images\npdfjs-editor-highlight-button =\n    .title = Highlight\npdfjs-editor-highlight-button-label = Highlight\npdfjs-highlight-floating-button1 =\n    .title = Highlight\n    .aria-label = Highlight\npdfjs-highlight-floating-button-label = Highlight\npdfjs-editor-remove-ink-button =\n    .title = Remove drawing\npdfjs-editor-remove-freetext-button =\n    .title = Remove text\npdfjs-editor-remove-stamp-button =\n    .title = Remove image\npdfjs-editor-remove-highlight-button =\n    .title = Remove highlight\npdfjs-editor-free-text-color-input = Color\npdfjs-editor-free-text-size-input = Size\npdfjs-editor-ink-color-input = Color\npdfjs-editor-ink-thickness-input = Thickness\npdfjs-editor-ink-opacity-input = Opacity\npdfjs-editor-stamp-add-image-button =\n    .title = Add image\npdfjs-editor-stamp-add-image-button-label = Add image\npdfjs-editor-free-highlight-thickness-input = Thickness\npdfjs-editor-free-highlight-thickness-title =\n    .title = Change thickness when highlighting items other than text\npdfjs-free-text =\n    .aria-label = Text Editor\npdfjs-free-text-default-content = Start typing\npdfjs-ink =\n    .aria-label = Draw Editor\npdfjs-ink-canvas =\n    .aria-label = User-created image\npdfjs-editor-alt-text-button-label = Alt text\npdfjs-editor-alt-text-edit-button-label = Edit alt text\npdfjs-editor-alt-text-dialog-label = Choose an option\npdfjs-editor-alt-text-dialog-description = Alt text (alternative text) helps when people cant see the image or when it doesnt load.\npdfjs-editor-alt-text-add-description-label = Add a description\npdfjs-editor-alt-text-add-description-description = Aim for 1-2 sentences that describe the subject, setting, or actions.\npdfjs-editor-alt-text-mark-decorative-label = Mark as decorative\npdfjs-editor-alt-text-mark-decorative-description = This is used for ornamental images, like borders or watermarks.\npdfjs-editor-alt-text-cancel-button = Cancel\npdfjs-editor-alt-text-save-button = Save\npdfjs-editor-alt-text-decorative-tooltip = Marked as decorative\npdfjs-editor-alt-text-textarea =\n    .placeholder = For example, A young man sits down at a table to eat a meal\npdfjs-editor-resizer-label-top-left = Top left corner  resize\npdfjs-editor-resizer-label-top-middle = Top middle  resize\npdfjs-editor-resizer-label-top-right = Top right corner  resize\npdfjs-editor-resizer-label-middle-right = Middle right  resize\npdfjs-editor-resizer-label-bottom-right = Bottom right corner  resize\npdfjs-editor-resizer-label-bottom-middle = Bottom middle  resize\npdfjs-editor-resizer-label-bottom-left = Bottom left corner  resize\npdfjs-editor-resizer-label-middle-left = Middle left  resize\npdfjs-editor-highlight-colorpicker-label = Highlight color\npdfjs-editor-colorpicker-button =\n    .title = Change color\npdfjs-editor-colorpicker-dropdown =\n    .aria-label = Color choices\npdfjs-editor-colorpicker-yellow =\n    .title = Yellow\npdfjs-editor-colorpicker-green =\n    .title = Green\npdfjs-editor-colorpicker-blue =\n    .title = Blue\npdfjs-editor-colorpicker-pink =\n    .title = Pink\npdfjs-editor-colorpicker-red =\n    .title = Red\npdfjs-editor-highlight-show-all-button-label = Show all\npdfjs-editor-highlight-show-all-button =\n    .title = Show all";
    return createBundle(lang, text);
  }
}
const HASH_CHANGE_TIMEOUT = 1e3;
const POSITION_UPDATED_THRESHOLD = 50;
const UPDATE_VIEWAREA_TIMEOUT = 1e3;
function getCurrentHash() {
  return document.location.hash;
}
class PDFHistory {
  #eventAbortController = null;
  constructor({
    linkService,
    eventBus
  }) {
    this.linkService = linkService;
    this.eventBus = eventBus;
    this._initialized = false;
    this._fingerprint = "";
    this.reset();
    this.eventBus._on("pagesinit", () => {
      this._isPagesLoaded = false;
      this.eventBus._on("pagesloaded", (evt) => {
        this._isPagesLoaded = !!evt.pagesCount;
      }, {
        once: true
      });
    });
  }
  initialize({
    fingerprint,
    resetHistory = false,
    updateUrl = false
  }) {
    if (!fingerprint || typeof fingerprint !== "string") {
      console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
      return;
    }
    if (this._initialized) {
      this.reset();
    }
    const reInitialized = this._fingerprint !== "" && this._fingerprint !== fingerprint;
    this._fingerprint = fingerprint;
    this._updateUrl = updateUrl === true;
    this._initialized = true;
    this.#bindEvents();
    const state = window.history.state;
    this._popStateInProgress = false;
    this._blockHashChange = 0;
    this._currentHash = getCurrentHash();
    this._numPositionUpdates = 0;
    this._uid = this._maxUid = 0;
    this._destination = null;
    this._position = null;
    if (!this.#isValidState(state, true) || resetHistory) {
      const {
        hash,
        page,
        rotation
      } = this.#parseCurrentHash(true);
      if (!hash || reInitialized || resetHistory) {
        this.#pushOrReplaceState(null, true);
        return;
      }
      this.#pushOrReplaceState({
        hash,
        page,
        rotation
      }, true);
      return;
    }
    const destination = state.destination;
    this.#updateInternalState(destination, state.uid, true);
    if (destination.rotation !== void 0) {
      this._initialRotation = destination.rotation;
    }
    if (destination.dest) {
      this._initialBookmark = JSON.stringify(destination.dest);
      this._destination.page = null;
    } else if (destination.hash) {
      this._initialBookmark = destination.hash;
    } else if (destination.page) {
      this._initialBookmark = `page=${destination.page}`;
    }
  }
  reset() {
    if (this._initialized) {
      this.#pageHide();
      this._initialized = false;
      this.#unbindEvents();
    }
    if (this._updateViewareaTimeout) {
      clearTimeout(this._updateViewareaTimeout);
      this._updateViewareaTimeout = null;
    }
    this._initialBookmark = null;
    this._initialRotation = null;
  }
  push({
    namedDest = null,
    explicitDest,
    pageNumber
  }) {
    if (!this._initialized) {
      return;
    }
    if (namedDest && typeof namedDest !== "string") {
      console.error(`PDFHistory.push: "${namedDest}" is not a valid namedDest parameter.`);
      return;
    } else if (!Array.isArray(explicitDest)) {
      console.error(`PDFHistory.push: "${explicitDest}" is not a valid explicitDest parameter.`);
      return;
    } else if (!this.#isValidPage(pageNumber)) {
      if (pageNumber !== null || this._destination) {
        console.error(`PDFHistory.push: "${pageNumber}" is not a valid pageNumber parameter.`);
        return;
      }
    }
    const hash = namedDest || JSON.stringify(explicitDest);
    if (!hash) {
      return;
    }
    let forceReplace = false;
    if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) {
      if (this._destination.page) {
        return;
      }
      forceReplace = true;
    }
    if (this._popStateInProgress && !forceReplace) {
      return;
    }
    this.#pushOrReplaceState({
      dest: explicitDest,
      hash,
      page: pageNumber,
      rotation: this.linkService.rotation
    }, forceReplace);
    if (!this._popStateInProgress) {
      this._popStateInProgress = true;
      Promise.resolve().then(() => {
        this._popStateInProgress = false;
      });
    }
  }
  pushPage(pageNumber) {
    if (!this._initialized) {
      return;
    }
    if (!this.#isValidPage(pageNumber)) {
      console.error(`PDFHistory.pushPage: "${pageNumber}" is not a valid page number.`);
      return;
    }
    if (this._destination?.page === pageNumber) {
      return;
    }
    if (this._popStateInProgress) {
      return;
    }
    this.#pushOrReplaceState({
      dest: null,
      hash: `page=${pageNumber}`,
      page: pageNumber,
      rotation: this.linkService.rotation
    });
    if (!this._popStateInProgress) {
      this._popStateInProgress = true;
      Promise.resolve().then(() => {
        this._popStateInProgress = false;
      });
    }
  }
  pushCurrentPosition() {
    if (!this._initialized || this._popStateInProgress) {
      return;
    }
    this.#tryPushCurrentPosition();
  }
  back() {
    if (!this._initialized || this._popStateInProgress) {
      return;
    }
    const state = window.history.state;
    if (this.#isValidState(state) && state.uid > 0) {
      window.history.back();
    }
  }
  forward() {
    if (!this._initialized || this._popStateInProgress) {
      return;
    }
    const state = window.history.state;
    if (this.#isValidState(state) && state.uid < this._maxUid) {
      window.history.forward();
    }
  }
  get popStateInProgress() {
    return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);
  }
  get initialBookmark() {
    return this._initialized ? this._initialBookmark : null;
  }
  get initialRotation() {
    return this._initialized ? this._initialRotation : null;
  }
  #pushOrReplaceState(destination, forceReplace = false) {
    const shouldReplace = forceReplace || !this._destination;
    const newState = {
      fingerprint: this._fingerprint,
      uid: shouldReplace ? this._uid : this._uid + 1,
      destination
    };
    this.#updateInternalState(destination, newState.uid);
    let newUrl;
    if (this._updateUrl && destination?.hash) {
      const baseUrl = document.location.href.split("#", 1)[0];
      if (!baseUrl.startsWith("file://")) {
        newUrl = `${baseUrl}#${destination.hash}`;
      }
    }
    if (shouldReplace) {
      window.history.replaceState(newState, "", newUrl);
    } else {
      window.history.pushState(newState, "", newUrl);
    }
  }
  #tryPushCurrentPosition(temporary = false) {
    if (!this._position) {
      return;
    }
    let position = this._position;
    if (temporary) {
      position = Object.assign(/* @__PURE__ */ Object.create(null), this._position);
      position.temporary = true;
    }
    if (!this._destination) {
      this.#pushOrReplaceState(position);
      return;
    }
    if (this._destination.temporary) {
      this.#pushOrReplaceState(position, true);
      return;
    }
    if (this._destination.hash === position.hash) {
      return;
    }
    if (!this._destination.page && this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD) {
      return;
    }
    let forceReplace = false;
    if (this._destination.page >= position.first && this._destination.page <= position.page) {
      if (this._destination.dest !== void 0 || !this._destination.first) {
        return;
      }
      forceReplace = true;
    }
    this.#pushOrReplaceState(position, forceReplace);
  }
  #isValidPage(val) {
    return Number.isInteger(val) && val > 0 && val <= this.linkService.pagesCount;
  }
  #isValidState(state, checkReload = false) {
    if (!state) {
      return false;
    }
    if (state.fingerprint !== this._fingerprint) {
      if (checkReload) {
        if (typeof state.fingerprint !== "string" || state.fingerprint.length !== this._fingerprint.length) {
          return false;
        }
        const [perfEntry] = performance.getEntriesByType("navigation");
        if (perfEntry?.type !== "reload") {
          return false;
        }
      } else {
        return false;
      }
    }
    if (!Number.isInteger(state.uid) || state.uid < 0) {
      return false;
    }
    if (state.destination === null || typeof state.destination !== "object") {
      return false;
    }
    return true;
  }
  #updateInternalState(destination, uid2, removeTemporary = false) {
    if (this._updateViewareaTimeout) {
      clearTimeout(this._updateViewareaTimeout);
      this._updateViewareaTimeout = null;
    }
    if (removeTemporary && destination?.temporary) {
      delete destination.temporary;
    }
    this._destination = destination;
    this._uid = uid2;
    this._maxUid = Math.max(this._maxUid, uid2);
    this._numPositionUpdates = 0;
  }
  #parseCurrentHash(checkNameddest = false) {
    const hash = unescape(getCurrentHash()).substring(1);
    const params = parseQueryString(hash);
    const nameddest = params.get("nameddest") || "";
    let page = params.get("page") | 0;
    if (!this.#isValidPage(page) || checkNameddest && nameddest.length > 0) {
      page = null;
    }
    return {
      hash,
      page,
      rotation: this.linkService.rotation
    };
  }
  #updateViewarea({
    location: location2
  }) {
    if (this._updateViewareaTimeout) {
      clearTimeout(this._updateViewareaTimeout);
      this._updateViewareaTimeout = null;
    }
    this._position = {
      hash: location2.pdfOpenParams.substring(1),
      page: this.linkService.page,
      first: location2.pageNumber,
      rotation: location2.rotation
    };
    if (this._popStateInProgress) {
      return;
    }
    if (this._isPagesLoaded && this._destination && !this._destination.page) {
      this._numPositionUpdates++;
    }
    {
      this._updateViewareaTimeout = setTimeout(() => {
        if (!this._popStateInProgress) {
          this.#tryPushCurrentPosition(true);
        }
        this._updateViewareaTimeout = null;
      }, UPDATE_VIEWAREA_TIMEOUT);
    }
  }
  #popState({
    state
  }) {
    const newHash = getCurrentHash(), hashChanged = this._currentHash !== newHash;
    this._currentHash = newHash;
    if (!state) {
      this._uid++;
      const {
        hash,
        page,
        rotation
      } = this.#parseCurrentHash();
      this.#pushOrReplaceState({
        hash,
        page,
        rotation
      }, true);
      return;
    }
    if (!this.#isValidState(state)) {
      return;
    }
    this._popStateInProgress = true;
    if (hashChanged) {
      this._blockHashChange++;
      waitOnEventOrTimeout({
        target: window,
        name: "hashchange",
        delay: HASH_CHANGE_TIMEOUT
      }).then(() => {
        this._blockHashChange--;
      });
    }
    const destination = state.destination;
    this.#updateInternalState(destination, state.uid, true);
    if (isValidRotation(destination.rotation)) {
      this.linkService.rotation = destination.rotation;
    }
    if (destination.dest) {
      this.linkService.goToDestination(destination.dest);
    } else if (destination.hash) {
      this.linkService.setHash(destination.hash);
    } else if (destination.page) {
      this.linkService.page = destination.page;
    }
    Promise.resolve().then(() => {
      this._popStateInProgress = false;
    });
  }
  #pageHide() {
    if (!this._destination || this._destination.temporary) {
      this.#tryPushCurrentPosition();
    }
  }
  #bindEvents() {
    if (this.#eventAbortController) {
      return;
    }
    this.#eventAbortController = new AbortController();
    const {
      signal
    } = this.#eventAbortController;
    this.eventBus._on("updateviewarea", this.#updateViewarea.bind(this), {
      signal
    });
    window.addEventListener("popstate", this.#popState.bind(this), {
      signal
    });
    window.addEventListener("pagehide", this.#pageHide.bind(this), {
      signal
    });
  }
  #unbindEvents() {
    this.#eventAbortController?.abort();
    this.#eventAbortController = null;
  }
}
function isDestHashesEqual(destHash, pushHash) {
  if (typeof destHash !== "string" || typeof pushHash !== "string") {
    return false;
  }
  if (destHash === pushHash) {
    return true;
  }
  const nameddest = parseQueryString(destHash).get("nameddest");
  if (nameddest === pushHash) {
    return true;
  }
  return false;
}
function isDestArraysEqual(firstDest, secondDest) {
  function isEntryEqual(first, second) {
    if (typeof first !== typeof second) {
      return false;
    }
    if (Array.isArray(first) || Array.isArray(second)) {
      return false;
    }
    if (first !== null && typeof first === "object" && second !== null) {
      if (Object.keys(first).length !== Object.keys(second).length) {
        return false;
      }
      for (const key in first) {
        if (!isEntryEqual(first[key], second[key])) {
          return false;
        }
      }
      return true;
    }
    return first === second || Number.isNaN(first) && Number.isNaN(second);
  }
  if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) {
    return false;
  }
  if (firstDest.length !== secondDest.length) {
    return false;
  }
  for (let i2 = 0, ii = firstDest.length; i2 < ii; i2++) {
    if (!isEntryEqual(firstDest[i2], secondDest[i2])) {
      return false;
    }
  }
  return true;
}
class AnnotationEditorLayerBuilder {
  #annotationLayer = null;
  #drawLayer = null;
  #onAppend = null;
  #textLayer = null;
  #uiManager;
  constructor(options) {
    this.pdfPage = options.pdfPage;
    this.accessibilityManager = options.accessibilityManager;
    this.l10n = options.l10n;
    this.l10n ||= new genericl10n_GenericL10n();
    this.annotationEditorLayer = null;
    this.div = null;
    this._cancelled = false;
    this.#uiManager = options.uiManager;
    this.#annotationLayer = options.annotationLayer || null;
    this.#textLayer = options.textLayer || null;
    this.#drawLayer = options.drawLayer || null;
    this.#onAppend = options.onAppend || null;
  }
  async render(viewport, intent = "display") {
    if (intent !== "display") {
      return;
    }
    if (this._cancelled) {
      return;
    }
    const clonedViewport = viewport.clone({
      dontFlip: true
    });
    if (this.div) {
      this.annotationEditorLayer.update({
        viewport: clonedViewport
      });
      this.show();
      return;
    }
    const div = this.div = document.createElement("div");
    div.className = "annotationEditorLayer";
    div.hidden = true;
    div.dir = this.#uiManager.direction;
    this.#onAppend?.(div);
    this.annotationEditorLayer = new AnnotationEditorLayer2({
      uiManager: this.#uiManager,
      div,
      accessibilityManager: this.accessibilityManager,
      pageIndex: this.pdfPage.pageNumber - 1,
      l10n: this.l10n,
      viewport: clonedViewport,
      annotationLayer: this.#annotationLayer,
      textLayer: this.#textLayer,
      drawLayer: this.#drawLayer
    });
    const parameters = {
      viewport: clonedViewport,
      div,
      annotations: null,
      intent
    };
    this.annotationEditorLayer.render(parameters);
    this.show();
  }
  cancel() {
    this._cancelled = true;
    if (!this.div) {
      return;
    }
    this.annotationEditorLayer.destroy();
  }
  hide() {
    if (!this.div) {
      return;
    }
    this.div.hidden = true;
  }
  show() {
    if (!this.div || this.annotationEditorLayer.isInvisible) {
      return;
    }
    this.div.hidden = false;
  }
}
{
  var compatibilityParams = /* @__PURE__ */ Object.create(null);
  const userAgent = navigator.userAgent || "";
  const platform = navigator.platform || "";
  const maxTouchPoints = navigator.maxTouchPoints || 1;
  const isAndroid = /Android/.test(userAgent);
  const isIOS2 = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === "MacIntel" && maxTouchPoints > 1;
  (function checkCanvasSizeLimitation() {
    if (isIOS2 || isAndroid) {
      compatibilityParams.maxCanvasPixels = 5242880;
    }
  })();
}
const OptionKind = {
  BROWSER: 1,
  VIEWER: 2,
  API: 4,
  WORKER: 8,
  PREFERENCE: 128
};
const defaultOptions = {
  canvasMaxAreaInBytes: {
    value: -1,
    kind: OptionKind.BROWSER + OptionKind.API
  },
  isInAutomation: {
    value: false,
    kind: OptionKind.BROWSER
  },
  supportsCaretBrowsingMode: {
    value: false,
    kind: OptionKind.BROWSER
  },
  supportsDocumentFonts: {
    value: true,
    kind: OptionKind.BROWSER
  },
  supportsIntegratedFind: {
    value: false,
    kind: OptionKind.BROWSER
  },
  supportsMouseWheelZoomCtrlKey: {
    value: true,
    kind: OptionKind.BROWSER
  },
  supportsMouseWheelZoomMetaKey: {
    value: true,
    kind: OptionKind.BROWSER
  },
  supportsPinchToZoom: {
    value: true,
    kind: OptionKind.BROWSER
  },
  annotationEditorMode: {
    value: 0,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  annotationMode: {
    value: 2,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  cursorToolOnLoad: {
    value: 0,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  debuggerSrc: {
    value: "./debugger.mjs",
    kind: OptionKind.VIEWER
  },
  defaultZoomDelay: {
    value: 400,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  defaultZoomValue: {
    value: "",
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  disableHistory: {
    value: false,
    kind: OptionKind.VIEWER
  },
  disablePageLabels: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  enableHighlightEditor: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  enableHighlightFloatingButton: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  enableML: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  enablePermissions: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  enablePrintAutoRotate: {
    value: true,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  enableScripting: {
    value: true,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  enableStampEditor: {
    value: true,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  externalLinkRel: {
    value: "noopener noreferrer nofollow",
    kind: OptionKind.VIEWER
  },
  externalLinkTarget: {
    value: 0,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  highlightEditorColors: {
    value: "yellow=#FFFF98,green=#53FFBC,blue=#80EBFF,pink=#FFCBE6,red=#FF4F5F",
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  historyUpdateUrl: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  ignoreDestinationZoom: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  imageResourcesPath: {
    value: "./images/",
    kind: OptionKind.VIEWER
  },
  maxCanvasPixels: {
    value: 2 ** 25,
    kind: OptionKind.VIEWER
  },
  forcePageColors: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  pageColorsBackground: {
    value: "Canvas",
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  pageColorsForeground: {
    value: "CanvasText",
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  pdfBugEnabled: {
    value: false,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  printResolution: {
    value: 150,
    kind: OptionKind.VIEWER
  },
  sidebarViewOnLoad: {
    value: -1,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  scrollModeOnLoad: {
    value: -1,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  spreadModeOnLoad: {
    value: -1,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  textLayerMode: {
    value: 1,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  viewOnLoad: {
    value: 0,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  },
  cMapPacked: {
    value: true,
    kind: OptionKind.API
  },
  cMapUrl: {
    value: "../web/cmaps/",
    kind: OptionKind.API
  },
  disableAutoFetch: {
    value: false,
    kind: OptionKind.API + OptionKind.PREFERENCE
  },
  disableFontFace: {
    value: false,
    kind: OptionKind.API + OptionKind.PREFERENCE
  },
  disableRange: {
    value: false,
    kind: OptionKind.API + OptionKind.PREFERENCE
  },
  disableStream: {
    value: false,
    kind: OptionKind.API + OptionKind.PREFERENCE
  },
  docBaseUrl: {
    value: "",
    kind: OptionKind.API
  },
  enableXfa: {
    value: true,
    kind: OptionKind.API + OptionKind.PREFERENCE
  },
  fontExtraProperties: {
    value: false,
    kind: OptionKind.API
  },
  isEvalSupported: {
    value: true,
    kind: OptionKind.API
  },
  isOffscreenCanvasSupported: {
    value: true,
    kind: OptionKind.API
  },
  maxImageSize: {
    value: -1,
    kind: OptionKind.API
  },
  pdfBug: {
    value: false,
    kind: OptionKind.API
  },
  standardFontDataUrl: {
    value: "../web/standard_fonts/",
    kind: OptionKind.API
  },
  verbosity: {
    value: 1,
    kind: OptionKind.API
  },
  workerPort: {
    value: null,
    kind: OptionKind.WORKER
  },
  workerSrc: {
    value: "../build/pdf.worker.mjs",
    kind: OptionKind.WORKER
  }
};
{
  defaultOptions.defaultUrl = {
    value: "compressed.tracemonkey-pldi-09.pdf",
    kind: OptionKind.VIEWER
  };
  defaultOptions.sandboxBundleSrc = {
    value: "../build/pdf.sandbox.mjs",
    kind: OptionKind.VIEWER
  };
  defaultOptions.viewerCssTheme = {
    value: 0,
    kind: OptionKind.VIEWER + OptionKind.PREFERENCE
  };
}
{
  defaultOptions.disablePreferences = {
    value: false,
    kind: OptionKind.VIEWER
  };
  defaultOptions.locale = {
    value: navigator.language || "en-US",
    kind: OptionKind.VIEWER
  };
}
const userOptions = /* @__PURE__ */ Object.create(null);
{
  for (const name in compatibilityParams) {
    userOptions[name] = compatibilityParams[name];
  }
}
class AppOptions {
  constructor() {
    throw new Error("Cannot initialize AppOptions.");
  }
  static get(name) {
    return userOptions[name] ?? defaultOptions[name]?.value ?? void 0;
  }
  static getAll(kind = null, defaultOnly = false) {
    const options = /* @__PURE__ */ Object.create(null);
    for (const name in defaultOptions) {
      const defaultOption = defaultOptions[name];
      if (kind && !(kind & defaultOption.kind)) {
        continue;
      }
      options[name] = defaultOnly ? defaultOption.value : userOptions[name] ?? defaultOption.value;
    }
    return options;
  }
  static set(name, value) {
    userOptions[name] = value;
  }
  static setAll(options, init = false) {
    if (init) {
      if (this.get("disablePreferences")) {
        return;
      }
      for (const name in userOptions) {
        if (compatibilityParams[name] !== void 0) {
          continue;
        }
        console.warn('setAll: The Preferences may override manually set AppOptions; please use the "disablePreferences"-option in order to prevent that.');
        break;
      }
    }
    for (const name in options) {
      userOptions[name] = options[name];
    }
  }
  static remove(name) {
    delete userOptions[name];
    const val = compatibilityParams[name];
    if (val !== void 0) {
      userOptions[name] = val;
    }
  }
}
class DrawLayerBuilder {
  #drawLayer = null;
  constructor(options) {
    this.pageIndex = options.pageIndex;
  }
  async render(intent = "display") {
    if (intent !== "display" || this.#drawLayer || this._cancelled) {
      return;
    }
    this.#drawLayer = new DrawLayer2({
      pageIndex: this.pageIndex
    });
  }
  cancel() {
    this._cancelled = true;
    if (!this.#drawLayer) {
      return;
    }
    this.#drawLayer.destroy();
    this.#drawLayer = null;
  }
  setParent(parent) {
    this.#drawLayer?.setParent(parent);
  }
  getDrawLayer() {
    return this.#drawLayer;
  }
}
const PDF_ROLE_TO_HTML_ROLE = {
  Document: null,
  DocumentFragment: null,
  Part: "group",
  Sect: "group",
  Div: "group",
  Aside: "note",
  NonStruct: "none",
  P: null,
  H: "heading",
  Title: null,
  FENote: "note",
  Sub: "group",
  Lbl: null,
  Span: null,
  Em: null,
  Strong: null,
  Link: "link",
  Annot: "note",
  Form: "form",
  Ruby: null,
  RB: null,
  RT: null,
  RP: null,
  Warichu: null,
  WT: null,
  WP: null,
  L: "list",
  LI: "listitem",
  LBody: null,
  Table: "table",
  TR: "row",
  TH: "columnheader",
  TD: "cell",
  THead: "columnheader",
  TBody: null,
  TFoot: null,
  Caption: null,
  Figure: "figure",
  Formula: null,
  Artifact: null
};
const HEADING_PATTERN = /^H(\d+)$/;
class StructTreeLayerBuilder {
  #treeDom = void 0;
  get renderingDone() {
    return this.#treeDom !== void 0;
  }
  render(structTree) {
    if (this.#treeDom !== void 0) {
      return this.#treeDom;
    }
    const treeDom = this.#walk(structTree);
    treeDom?.classList.add("structTree");
    return this.#treeDom = treeDom;
  }
  hide() {
    if (this.#treeDom && !this.#treeDom.hidden) {
      this.#treeDom.hidden = true;
    }
  }
  show() {
    if (this.#treeDom?.hidden) {
      this.#treeDom.hidden = false;
    }
  }
  #setAttributes(structElement, htmlElement) {
    const {
      alt,
      id: id2,
      lang
    } = structElement;
    if (alt !== void 0) {
      htmlElement.setAttribute("aria-label", removeNullCharacters(alt));
    }
    if (id2 !== void 0) {
      htmlElement.setAttribute("aria-owns", id2);
    }
    if (lang !== void 0) {
      htmlElement.setAttribute("lang", removeNullCharacters(lang, true));
    }
  }
  #walk(node) {
    if (!node) {
      return null;
    }
    const element = document.createElement("span");
    if ("role" in node) {
      const {
        role
      } = node;
      const match2 = role.match(HEADING_PATTERN);
      if (match2) {
        element.setAttribute("role", "heading");
        element.setAttribute("aria-level", match2[1]);
      } else if (PDF_ROLE_TO_HTML_ROLE[role]) {
        element.setAttribute("role", PDF_ROLE_TO_HTML_ROLE[role]);
      }
    }
    this.#setAttributes(node, element);
    if (node.children) {
      if (node.children.length === 1 && "id" in node.children[0]) {
        this.#setAttributes(node.children[0], element);
      } else {
        for (const kid of node.children) {
          element.append(this.#walk(kid));
        }
      }
    }
    return element;
  }
}
class TextAccessibilityManager {
  #enabled = false;
  #textChildren = null;
  #textNodes = /* @__PURE__ */ new Map();
  #waitingElements = /* @__PURE__ */ new Map();
  setTextMapping(textDivs) {
    this.#textChildren = textDivs;
  }
  static #compareElementPositions(e1, e2) {
    const rect1 = e1.getBoundingClientRect();
    const rect2 = e2.getBoundingClientRect();
    if (rect1.width === 0 && rect1.height === 0) {
      return 1;
    }
    if (rect2.width === 0 && rect2.height === 0) {
      return -1;
    }
    const top1 = rect1.y;
    const bot1 = rect1.y + rect1.height;
    const mid1 = rect1.y + rect1.height / 2;
    const top2 = rect2.y;
    const bot2 = rect2.y + rect2.height;
    const mid2 = rect2.y + rect2.height / 2;
    if (mid1 <= top2 && mid2 >= bot1) {
      return -1;
    }
    if (mid2 <= top1 && mid1 >= bot2) {
      return 1;
    }
    const centerX1 = rect1.x + rect1.width / 2;
    const centerX2 = rect2.x + rect2.width / 2;
    return centerX1 - centerX2;
  }
  enable() {
    if (this.#enabled) {
      throw new Error("TextAccessibilityManager is already enabled.");
    }
    if (!this.#textChildren) {
      throw new Error("Text divs and strings have not been set.");
    }
    this.#enabled = true;
    this.#textChildren = this.#textChildren.slice();
    this.#textChildren.sort(TextAccessibilityManager.#compareElementPositions);
    if (this.#textNodes.size > 0) {
      const textChildren = this.#textChildren;
      for (const [id2, nodeIndex] of this.#textNodes) {
        const element = document.getElementById(id2);
        if (!element) {
          this.#textNodes.delete(id2);
          continue;
        }
        this.#addIdToAriaOwns(id2, textChildren[nodeIndex]);
      }
    }
    for (const [element, isRemovable] of this.#waitingElements) {
      this.addPointerInTextLayer(element, isRemovable);
    }
    this.#waitingElements.clear();
  }
  disable() {
    if (!this.#enabled) {
      return;
    }
    this.#waitingElements.clear();
    this.#textChildren = null;
    this.#enabled = false;
  }
  removePointerInTextLayer(element) {
    if (!this.#enabled) {
      this.#waitingElements.delete(element);
      return;
    }
    const children = this.#textChildren;
    if (!children || children.length === 0) {
      return;
    }
    const {
      id: id2
    } = element;
    const nodeIndex = this.#textNodes.get(id2);
    if (nodeIndex === void 0) {
      return;
    }
    const node = children[nodeIndex];
    this.#textNodes.delete(id2);
    let owns = node.getAttribute("aria-owns");
    if (owns?.includes(id2)) {
      owns = owns.split(" ").filter((x2) => x2 !== id2).join(" ");
      if (owns) {
        node.setAttribute("aria-owns", owns);
      } else {
        node.removeAttribute("aria-owns");
        node.setAttribute("role", "presentation");
      }
    }
  }
  #addIdToAriaOwns(id2, node) {
    const owns = node.getAttribute("aria-owns");
    if (!owns?.includes(id2)) {
      node.setAttribute("aria-owns", owns ? `${owns} ${id2}` : id2);
    }
    node.removeAttribute("role");
  }
  addPointerInTextLayer(element, isRemovable) {
    const {
      id: id2
    } = element;
    if (!id2) {
      return null;
    }
    if (!this.#enabled) {
      this.#waitingElements.set(element, isRemovable);
      return null;
    }
    if (isRemovable) {
      this.removePointerInTextLayer(element);
    }
    const children = this.#textChildren;
    if (!children || children.length === 0) {
      return null;
    }
    const index = binarySearchFirstItem(children, (node) => TextAccessibilityManager.#compareElementPositions(element, node) < 0);
    const nodeIndex = Math.max(0, index - 1);
    const child = children[nodeIndex];
    this.#addIdToAriaOwns(id2, child);
    this.#textNodes.set(id2, nodeIndex);
    const parent = child.parentNode;
    return parent?.classList.contains("markedContent") ? parent.id : null;
  }
  moveElementInDOM(container, element, contentElement, isRemovable) {
    const id2 = this.addPointerInTextLayer(contentElement, isRemovable);
    if (!container.hasChildNodes()) {
      container.append(element);
      return id2;
    }
    const children = Array.from(container.childNodes).filter((node) => node !== element);
    if (children.length === 0) {
      return id2;
    }
    const elementToCompare = contentElement || element;
    const index = binarySearchFirstItem(children, (node) => TextAccessibilityManager.#compareElementPositions(elementToCompare, node) < 0);
    if (index === 0) {
      children[0].before(element);
    } else {
      children[index - 1].after(element);
    }
    return id2;
  }
}
class TextHighlighter {
  #eventAbortController = null;
  constructor({
    findController,
    eventBus,
    pageIndex
  }) {
    this.findController = findController;
    this.matches = [];
    this.eventBus = eventBus;
    this.pageIdx = pageIndex;
    this.textDivs = null;
    this.textContentItemsStr = null;
    this.enabled = false;
  }
  setTextMapping(divs, texts) {
    this.textDivs = divs;
    this.textContentItemsStr = texts;
  }
  enable() {
    if (!this.textDivs || !this.textContentItemsStr) {
      throw new Error("Text divs and strings have not been set.");
    }
    if (this.enabled) {
      throw new Error("TextHighlighter is already enabled.");
    }
    this.enabled = true;
    if (!this.#eventAbortController) {
      this.#eventAbortController = new AbortController();
      this.eventBus._on("updatetextlayermatches", (evt) => {
        if (evt.pageIndex === this.pageIdx || evt.pageIndex === -1) {
          this._updateMatches();
        }
      }, {
        signal: this.#eventAbortController.signal
      });
    }
    this._updateMatches();
  }
  disable() {
    if (!this.enabled) {
      return;
    }
    this.enabled = false;
    this.#eventAbortController?.abort();
    this.#eventAbortController = null;
    this._updateMatches(true);
  }
  _convertMatches(matches, matchesLength) {
    if (!matches) {
      return [];
    }
    const {
      textContentItemsStr
    } = this;
    let i2 = 0, iIndex = 0;
    const end = textContentItemsStr.length - 1;
    const result = [];
    for (let m2 = 0, mm = matches.length; m2 < mm; m2++) {
      let matchIdx = matches[m2];
      while (i2 !== end && matchIdx >= iIndex + textContentItemsStr[i2].length) {
        iIndex += textContentItemsStr[i2].length;
        i2++;
      }
      if (i2 === textContentItemsStr.length) {
        console.error("Could not find a matching mapping");
      }
      const match2 = {
        begin: {
          divIdx: i2,
          offset: matchIdx - iIndex
        }
      };
      matchIdx += matchesLength[m2];
      while (i2 !== end && matchIdx > iIndex + textContentItemsStr[i2].length) {
        iIndex += textContentItemsStr[i2].length;
        i2++;
      }
      match2.end = {
        divIdx: i2,
        offset: matchIdx - iIndex
      };
      result.push(match2);
    }
    return result;
  }
  _renderMatches(matches) {
    if (matches.length === 0) {
      return;
    }
    const {
      findController,
      pageIdx
    } = this;
    const {
      textContentItemsStr,
      textDivs
    } = this;
    const isSelectedPage = pageIdx === findController.selected.pageIdx;
    const selectedMatchIdx = findController.selected.matchIdx;
    const highlightAll = findController.state.highlightAll;
    let prevEnd = null;
    const infinity = {
      divIdx: -1,
      offset: void 0
    };
    function beginText(begin, className) {
      const divIdx = begin.divIdx;
      textDivs[divIdx].textContent = "";
      return appendTextToDiv(divIdx, 0, begin.offset, className);
    }
    function appendTextToDiv(divIdx, fromOffset, toOffset, className) {
      let div = textDivs[divIdx];
      if (div.nodeType === Node.TEXT_NODE) {
        const span = document.createElement("span");
        div.before(span);
        span.append(div);
        textDivs[divIdx] = span;
        div = span;
      }
      const content = textContentItemsStr[divIdx].substring(fromOffset, toOffset);
      const node = document.createTextNode(content);
      if (className) {
        const span = document.createElement("span");
        span.className = `${className} appended`;
        span.append(node);
        div.append(span);
        return className.includes("selected") ? span.offsetLeft : 0;
      }
      div.append(node);
      return 0;
    }
    let i0 = selectedMatchIdx, i1 = i0 + 1;
    if (highlightAll) {
      i0 = 0;
      i1 = matches.length;
    } else if (!isSelectedPage) {
      return;
    }
    let lastDivIdx = -1;
    let lastOffset = -1;
    for (let i2 = i0; i2 < i1; i2++) {
      const match2 = matches[i2];
      const begin = match2.begin;
      if (begin.divIdx === lastDivIdx && begin.offset === lastOffset) {
        continue;
      }
      lastDivIdx = begin.divIdx;
      lastOffset = begin.offset;
      const end = match2.end;
      const isSelected = isSelectedPage && i2 === selectedMatchIdx;
      const highlightSuffix = isSelected ? " selected" : "";
      let selectedLeft = 0;
      if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {
        if (prevEnd !== null) {
          appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
        }
        beginText(begin);
      } else {
        appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);
      }
      if (begin.divIdx === end.divIdx) {
        selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, end.offset, "highlight" + highlightSuffix);
      } else {
        selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, "highlight begin" + highlightSuffix);
        for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {
          textDivs[n0].className = "highlight middle" + highlightSuffix;
        }
        beginText(end, "highlight end" + highlightSuffix);
      }
      prevEnd = end;
      if (isSelected) {
        findController.scrollMatchIntoView({
          element: textDivs[begin.divIdx],
          selectedLeft,
          pageIndex: pageIdx,
          matchIndex: selectedMatchIdx
        });
      }
    }
    if (prevEnd) {
      appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
    }
  }
  _updateMatches(reset = false) {
    if (!this.enabled && !reset) {
      return;
    }
    const {
      findController,
      matches,
      pageIdx
    } = this;
    const {
      textContentItemsStr,
      textDivs
    } = this;
    let clearedUntilDivIdx = -1;
    for (const match2 of matches) {
      const begin = Math.max(clearedUntilDivIdx, match2.begin.divIdx);
      for (let n2 = begin, end = match2.end.divIdx; n2 <= end; n2++) {
        const div = textDivs[n2];
        div.textContent = textContentItemsStr[n2];
        div.className = "";
      }
      clearedUntilDivIdx = match2.end.divIdx + 1;
    }
    if (!findController?.highlightMatches || reset) {
      return;
    }
    const pageMatches = findController.pageMatches[pageIdx] || null;
    const pageMatchesLength = findController.pageMatchesLength[pageIdx] || null;
    this.matches = this._convertMatches(pageMatches, pageMatchesLength);
    this._renderMatches(this.matches);
  }
}
class TextLayerBuilder {
  #enablePermissions = false;
  #onAppend = null;
  #renderingDone = false;
  #textLayer = null;
  static #textLayers = /* @__PURE__ */ new Map();
  static #selectionChangeAbortController = null;
  constructor({
    pdfPage,
    highlighter: highlighter2 = null,
    accessibilityManager = null,
    enablePermissions = false,
    onAppend = null
  }) {
    this.pdfPage = pdfPage;
    this.highlighter = highlighter2;
    this.accessibilityManager = accessibilityManager;
    this.#enablePermissions = enablePermissions === true;
    this.#onAppend = onAppend;
    this.div = document.createElement("div");
    this.div.tabIndex = 0;
    this.div.className = "textLayer";
  }
  #finishRendering() {
    this.#renderingDone = true;
    const endOfContent = document.createElement("div");
    endOfContent.className = "endOfContent";
    this.div.append(endOfContent);
    this.#bindMouse(endOfContent);
  }
  async render(viewport, textContentParams = null) {
    if (this.#renderingDone && this.#textLayer) {
      this.#textLayer.update({
        viewport,
        onBefore: this.hide.bind(this)
      });
      this.show();
      return;
    }
    this.cancel();
    this.#textLayer = new TextLayer2({
      textContentSource: this.pdfPage.streamTextContent(textContentParams || {
        includeMarkedContent: true,
        disableNormalization: true
      }),
      container: this.div,
      viewport
    });
    const {
      textDivs,
      textContentItemsStr
    } = this.#textLayer;
    this.highlighter?.setTextMapping(textDivs, textContentItemsStr);
    this.accessibilityManager?.setTextMapping(textDivs);
    await this.#textLayer.render();
    this.#finishRendering();
    this.#onAppend?.(this.div);
    this.highlighter?.enable();
    this.accessibilityManager?.enable();
  }
  hide() {
    if (!this.div.hidden && this.#renderingDone) {
      this.highlighter?.disable();
      this.div.hidden = true;
    }
  }
  show() {
    if (this.div.hidden && this.#renderingDone) {
      this.div.hidden = false;
      this.highlighter?.enable();
    }
  }
  cancel() {
    this.#textLayer?.cancel();
    this.#textLayer = null;
    this.highlighter?.disable();
    this.accessibilityManager?.disable();
    TextLayerBuilder.#removeGlobalSelectionListener(this.div);
  }
  #bindMouse(end) {
    const {
      div
    } = this;
    div.addEventListener("mousedown", (evt) => {
      end.classList.add("active");
    });
    div.addEventListener("copy", (event) => {
      if (!this.#enablePermissions) {
        const selection = document.getSelection();
        event.clipboardData.setData("text/plain", removeNullCharacters(normalizeUnicode(selection.toString())));
      }
      event.preventDefault();
      event.stopPropagation();
    });
    TextLayerBuilder.#textLayers.set(div, end);
    TextLayerBuilder.#enableGlobalSelectionListener();
  }
  static #removeGlobalSelectionListener(textLayerDiv) {
    this.#textLayers.delete(textLayerDiv);
    if (this.#textLayers.size === 0) {
      this.#selectionChangeAbortController?.abort();
      this.#selectionChangeAbortController = null;
    }
  }
  static #enableGlobalSelectionListener() {
    if (this.#selectionChangeAbortController) {
      return;
    }
    this.#selectionChangeAbortController = new AbortController();
    const {
      signal
    } = this.#selectionChangeAbortController;
    const reset = (end, textLayer) => {
      textLayer.append(end);
      end.style.width = "";
      end.style.height = "";
      end.classList.remove("active");
    };
    document.addEventListener("pointerup", () => {
      this.#textLayers.forEach(reset);
    }, {
      signal
    });
    var isFirefox, prevRange;
    document.addEventListener("selectionchange", () => {
      const selection = document.getSelection();
      if (selection.rangeCount === 0) {
        this.#textLayers.forEach(reset);
        return;
      }
      const activeTextLayers = /* @__PURE__ */ new Set();
      for (let i2 = 0; i2 < selection.rangeCount; i2++) {
        const range2 = selection.getRangeAt(i2);
        for (const textLayerDiv of this.#textLayers.keys()) {
          if (!activeTextLayers.has(textLayerDiv) && range2.intersectsNode(textLayerDiv)) {
            activeTextLayers.add(textLayerDiv);
          }
        }
      }
      for (const [textLayerDiv, endDiv2] of this.#textLayers) {
        if (activeTextLayers.has(textLayerDiv)) {
          endDiv2.classList.add("active");
        } else {
          reset(endDiv2, textLayerDiv);
        }
      }
      isFirefox ??= getComputedStyle(this.#textLayers.values().next().value).getPropertyValue("-moz-user-select") === "none";
      if (isFirefox) {
        return;
      }
      const range = selection.getRangeAt(0);
      const modifyStart = prevRange && (range.compareBoundaryPoints(Range.END_TO_END, prevRange) === 0 || range.compareBoundaryPoints(Range.START_TO_END, prevRange) === 0);
      let anchor = modifyStart ? range.startContainer : range.endContainer;
      if (anchor.nodeType === Node.TEXT_NODE) {
        anchor = anchor.parentNode;
      }
      const parentTextLayer = anchor.parentElement.closest(".textLayer");
      const endDiv = this.#textLayers.get(parentTextLayer);
      if (endDiv) {
        endDiv.style.width = parentTextLayer.style.width;
        endDiv.style.height = parentTextLayer.style.height;
        anchor.parentElement.insertBefore(endDiv, modifyStart ? anchor : anchor.nextSibling);
      }
      prevRange = range.cloneRange();
    }, {
      signal
    });
  }
}
class XfaLayerBuilder {
  constructor({
    pdfPage,
    annotationStorage = null,
    linkService,
    xfaHtml = null
  }) {
    this.pdfPage = pdfPage;
    this.annotationStorage = annotationStorage;
    this.linkService = linkService;
    this.xfaHtml = xfaHtml;
    this.div = null;
    this._cancelled = false;
  }
  async render(viewport, intent = "display") {
    if (intent === "print") {
      const parameters2 = {
        viewport: viewport.clone({
          dontFlip: true
        }),
        div: this.div,
        xfaHtml: this.xfaHtml,
        annotationStorage: this.annotationStorage,
        linkService: this.linkService,
        intent
      };
      this.div = document.createElement("div");
      parameters2.div = this.div;
      return XfaLayer2.render(parameters2);
    }
    const xfaHtml = await this.pdfPage.getXfa();
    if (this._cancelled || !xfaHtml) {
      return {
        textDivs: []
      };
    }
    const parameters = {
      viewport: viewport.clone({
        dontFlip: true
      }),
      div: this.div,
      xfaHtml,
      annotationStorage: this.annotationStorage,
      linkService: this.linkService,
      intent
    };
    if (this.div) {
      return XfaLayer2.update(parameters);
    }
    this.div = document.createElement("div");
    parameters.div = this.div;
    return XfaLayer2.render(parameters);
  }
  cancel() {
    this._cancelled = true;
  }
  hide() {
    if (!this.div) {
      return;
    }
    this.div.hidden = true;
  }
}
const DEFAULT_LAYER_PROPERTIES = {
  annotationEditorUIManager: null,
  annotationStorage: null,
  downloadManager: null,
  enableScripting: false,
  fieldObjectsPromise: null,
  findController: null,
  hasJSActionsPromise: null,
  get linkService() {
    return new SimpleLinkService();
  }
};
const LAYERS_ORDER = /* @__PURE__ */ new Map([["canvasWrapper", 0], ["textLayer", 1], ["annotationLayer", 2], ["annotationEditorLayer", 3], ["xfaLayer", 3]]);
class PDFPageView {
  #annotationMode = AnnotationMode.ENABLE_FORMS;
  #hasRestrictedScaling = false;
  #layerProperties = null;
  #loadingId = null;
  #previousRotation = null;
  #renderError = null;
  #renderingState = RenderingStates.INITIAL;
  #textLayerMode = TextLayerMode.ENABLE;
  #useThumbnailCanvas = {
    directDrawing: true,
    initialOptionalContent: true,
    regularAnnotations: true
  };
  #viewportMap = /* @__PURE__ */ new WeakMap();
  #layers = [null, null, null, null];
  constructor(options) {
    const container = options.container;
    const defaultViewport = options.defaultViewport;
    this.id = options.id;
    this.renderingId = "page" + this.id;
    this.#layerProperties = options.layerProperties || DEFAULT_LAYER_PROPERTIES;
    this.pdfPage = null;
    this.pageLabel = null;
    this.rotation = 0;
    this.scale = options.scale || DEFAULT_SCALE;
    this.viewport = defaultViewport;
    this.pdfPageRotate = defaultViewport.rotation;
    this._optionalContentConfigPromise = options.optionalContentConfigPromise || null;
    this.#textLayerMode = options.textLayerMode ?? TextLayerMode.ENABLE;
    this.#annotationMode = options.annotationMode ?? AnnotationMode.ENABLE_FORMS;
    this.imageResourcesPath = options.imageResourcesPath || "";
    this.maxCanvasPixels = options.maxCanvasPixels ?? AppOptions.get("maxCanvasPixels");
    this.pageColors = options.pageColors || null;
    this.eventBus = options.eventBus;
    this.renderingQueue = options.renderingQueue;
    this.l10n = options.l10n;
    this.l10n ||= new genericl10n_GenericL10n();
    this.renderTask = null;
    this.resume = null;
    this._isStandalone = !this.renderingQueue?.hasViewer();
    this._container = container;
    this._annotationCanvasMap = null;
    this.annotationLayer = null;
    this.annotationEditorLayer = null;
    this.textLayer = null;
    this.zoomLayer = null;
    this.xfaLayer = null;
    this.structTreeLayer = null;
    this.drawLayer = null;
    const div = document.createElement("div");
    div.className = "page";
    div.setAttribute("data-page-number", this.id);
    div.setAttribute("role", "region");
    div.setAttribute("data-l10n-id", "pdfjs-page-landmark");
    div.setAttribute("data-l10n-args", JSON.stringify({
      page: this.id
    }));
    this.div = div;
    this.#setDimensions();
    container?.append(div);
    if (this._isStandalone) {
      container?.style.setProperty("--scale-factor", this.scale * PixelsPerInch2.PDF_TO_CSS_UNITS);
      const {
        optionalContentConfigPromise
      } = options;
      if (optionalContentConfigPromise) {
        optionalContentConfigPromise.then((optionalContentConfig) => {
          if (optionalContentConfigPromise !== this._optionalContentConfigPromise) {
            return;
          }
          this.#useThumbnailCanvas.initialOptionalContent = optionalContentConfig.hasInitialVisibility;
        });
      }
      if (!options.l10n) {
        this.l10n.translate(this.div);
      }
    }
  }
  #addLayer(div, name) {
    const pos = LAYERS_ORDER.get(name);
    const oldDiv = this.#layers[pos];
    this.#layers[pos] = div;
    if (oldDiv) {
      oldDiv.replaceWith(div);
      return;
    }
    for (let i2 = pos - 1; i2 >= 0; i2--) {
      const layer = this.#layers[i2];
      if (layer) {
        layer.after(div);
        return;
      }
    }
    this.div.prepend(div);
  }
  get renderingState() {
    return this.#renderingState;
  }
  set renderingState(state) {
    if (state === this.#renderingState) {
      return;
    }
    this.#renderingState = state;
    if (this.#loadingId) {
      clearTimeout(this.#loadingId);
      this.#loadingId = null;
    }
    switch (state) {
      case RenderingStates.PAUSED:
        this.div.classList.remove("loading");
        break;
      case RenderingStates.RUNNING:
        this.div.classList.add("loadingIcon");
        this.#loadingId = setTimeout(() => {
          this.div.classList.add("loading");
          this.#loadingId = null;
        }, 0);
        break;
      case RenderingStates.INITIAL:
      case RenderingStates.FINISHED:
        this.div.classList.remove("loadingIcon", "loading");
        break;
    }
  }
  #setDimensions() {
    const {
      viewport
    } = this;
    if (this.pdfPage) {
      if (this.#previousRotation === viewport.rotation) {
        return;
      }
      this.#previousRotation = viewport.rotation;
    }
    setLayerDimensions(this.div, viewport, true, false);
  }
  setPdfPage(pdfPage) {
    if (this._isStandalone && (this.pageColors?.foreground === "CanvasText" || this.pageColors?.background === "Canvas")) {
      this._container?.style.setProperty("--hcm-highlight-filter", pdfPage.filterFactory.addHighlightHCMFilter("highlight", "CanvasText", "Canvas", "HighlightText", "Highlight"));
      this._container?.style.setProperty("--hcm-highlight-selected-filter", pdfPage.filterFactory.addHighlightHCMFilter("highlight_selected", "CanvasText", "Canvas", "HighlightText", "Highlight"));
    }
    this.pdfPage = pdfPage;
    this.pdfPageRotate = pdfPage.rotate;
    const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
    this.viewport = pdfPage.getViewport({
      scale: this.scale * PixelsPerInch2.PDF_TO_CSS_UNITS,
      rotation: totalRotation
    });
    this.#setDimensions();
    this.reset();
  }
  destroy() {
    this.reset();
    this.pdfPage?.cleanup();
  }
  get _textHighlighter() {
    return shadow(this, "_textHighlighter", new TextHighlighter({
      pageIndex: this.id - 1,
      eventBus: this.eventBus,
      findController: this.#layerProperties.findController
    }));
  }
  #dispatchLayerRendered(name, error) {
    this.eventBus.dispatch(name, {
      source: this,
      pageNumber: this.id,
      error
    });
  }
  async #renderAnnotationLayer() {
    let error = null;
    try {
      await this.annotationLayer.render(this.viewport, "display");
    } catch (ex) {
      console.error(`#renderAnnotationLayer: "${ex}".`);
      error = ex;
    } finally {
      this.#dispatchLayerRendered("annotationlayerrendered", error);
    }
  }
  async #renderAnnotationEditorLayer() {
    let error = null;
    try {
      await this.annotationEditorLayer.render(this.viewport, "display");
    } catch (ex) {
      console.error(`#renderAnnotationEditorLayer: "${ex}".`);
      error = ex;
    } finally {
      this.#dispatchLayerRendered("annotationeditorlayerrendered", error);
    }
  }
  async #renderDrawLayer() {
    try {
      await this.drawLayer.render("display");
    } catch (ex) {
      console.error(`#renderDrawLayer: "${ex}".`);
    }
  }
  async #renderXfaLayer() {
    let error = null;
    try {
      const result = await this.xfaLayer.render(this.viewport, "display");
      if (result?.textDivs && this._textHighlighter) {
        this.#buildXfaTextContentItems(result.textDivs);
      }
    } catch (ex) {
      console.error(`#renderXfaLayer: "${ex}".`);
      error = ex;
    } finally {
      if (this.xfaLayer?.div) {
        this.l10n.pause();
        this.#addLayer(this.xfaLayer.div, "xfaLayer");
        this.l10n.resume();
      }
      this.#dispatchLayerRendered("xfalayerrendered", error);
    }
  }
  async #renderTextLayer() {
    if (!this.textLayer) {
      return;
    }
    let error = null;
    try {
      await this.textLayer.render(this.viewport);
    } catch (ex) {
      if (ex instanceof AbortException2) {
        return;
      }
      console.error(`#renderTextLayer: "${ex}".`);
      error = ex;
    }
    this.#dispatchLayerRendered("textlayerrendered", error);
    this.#renderStructTreeLayer();
  }
  async #renderStructTreeLayer() {
    if (!this.textLayer) {
      return;
    }
    this.structTreeLayer ||= new StructTreeLayerBuilder();
    const tree = await (!this.structTreeLayer.renderingDone ? this.pdfPage.getStructTree() : null);
    const treeDom = this.structTreeLayer?.render(tree);
    if (treeDom) {
      this.l10n.pause();
      this.canvas?.append(treeDom);
      this.l10n.resume();
    }
    this.structTreeLayer?.show();
  }
  async #buildXfaTextContentItems(textDivs) {
    const text = await this.pdfPage.getTextContent();
    const items = [];
    for (const item of text.items) {
      items.push(item.str);
    }
    this._textHighlighter.setTextMapping(textDivs, items);
    this._textHighlighter.enable();
  }
  _resetZoomLayer(removeFromDOM = false) {
    if (!this.zoomLayer) {
      return;
    }
    const zoomLayerCanvas = this.zoomLayer.firstChild;
    this.#viewportMap.delete(zoomLayerCanvas);
    zoomLayerCanvas.width = 0;
    zoomLayerCanvas.height = 0;
    if (removeFromDOM) {
      this.zoomLayer.remove();
    }
    this.zoomLayer = null;
  }
  reset({
    keepZoomLayer = false,
    keepAnnotationLayer = false,
    keepAnnotationEditorLayer = false,
    keepXfaLayer = false,
    keepTextLayer = false
  } = {}) {
    this.cancelRendering({
      keepAnnotationLayer,
      keepAnnotationEditorLayer,
      keepXfaLayer,
      keepTextLayer
    });
    this.renderingState = RenderingStates.INITIAL;
    const div = this.div;
    const childNodes = div.childNodes, zoomLayerNode = keepZoomLayer && this.zoomLayer || null, annotationLayerNode = keepAnnotationLayer && this.annotationLayer?.div || null, annotationEditorLayerNode = keepAnnotationEditorLayer && this.annotationEditorLayer?.div || null, xfaLayerNode = keepXfaLayer && this.xfaLayer?.div || null, textLayerNode = keepTextLayer && this.textLayer?.div || null;
    for (let i2 = childNodes.length - 1; i2 >= 0; i2--) {
      const node = childNodes[i2];
      switch (node) {
        case zoomLayerNode:
        case annotationLayerNode:
        case annotationEditorLayerNode:
        case xfaLayerNode:
        case textLayerNode:
          continue;
      }
      node.remove();
      const layerIndex = this.#layers.indexOf(node);
      if (layerIndex >= 0) {
        this.#layers[layerIndex] = null;
      }
    }
    div.removeAttribute("data-loaded");
    if (annotationLayerNode) {
      this.annotationLayer.hide();
    }
    if (annotationEditorLayerNode) {
      this.annotationEditorLayer.hide();
    }
    if (xfaLayerNode) {
      this.xfaLayer.hide();
    }
    if (textLayerNode) {
      this.textLayer.hide();
    }
    this.structTreeLayer?.hide();
    if (!zoomLayerNode) {
      if (this.canvas) {
        this.#viewportMap.delete(this.canvas);
        this.canvas.width = 0;
        this.canvas.height = 0;
        delete this.canvas;
      }
      this._resetZoomLayer();
    }
  }
  update({
    scale = 0,
    rotation = null,
    optionalContentConfigPromise = null,
    drawingDelay = -1
  }) {
    this.scale = scale || this.scale;
    if (typeof rotation === "number") {
      this.rotation = rotation;
    }
    if (optionalContentConfigPromise instanceof Promise) {
      this._optionalContentConfigPromise = optionalContentConfigPromise;
      optionalContentConfigPromise.then((optionalContentConfig) => {
        if (optionalContentConfigPromise !== this._optionalContentConfigPromise) {
          return;
        }
        this.#useThumbnailCanvas.initialOptionalContent = optionalContentConfig.hasInitialVisibility;
      });
    }
    this.#useThumbnailCanvas.directDrawing = true;
    const totalRotation = (this.rotation + this.pdfPageRotate) % 360;
    this.viewport = this.viewport.clone({
      scale: this.scale * PixelsPerInch2.PDF_TO_CSS_UNITS,
      rotation: totalRotation
    });
    this.#setDimensions();
    if (this._isStandalone) {
      this._container?.style.setProperty("--scale-factor", this.viewport.scale);
    }
    if (this.canvas) {
      let onlyCssZoom = false;
      if (this.#hasRestrictedScaling) {
        if (this.maxCanvasPixels === 0) {
          onlyCssZoom = true;
        } else if (this.maxCanvasPixels > 0) {
          const {
            width,
            height
          } = this.viewport;
          const {
            sx,
            sy
          } = this.outputScale;
          onlyCssZoom = (Math.floor(width) * sx | 0) * (Math.floor(height) * sy | 0) > this.maxCanvasPixels;
        }
      }
      const postponeDrawing = drawingDelay >= 0 && drawingDelay < 1e3;
      if (postponeDrawing || onlyCssZoom) {
        if (postponeDrawing && !onlyCssZoom && this.renderingState !== RenderingStates.FINISHED) {
          this.cancelRendering({
            keepZoomLayer: true,
            keepAnnotationLayer: true,
            keepAnnotationEditorLayer: true,
            keepXfaLayer: true,
            keepTextLayer: true,
            cancelExtraDelay: drawingDelay
          });
          this.renderingState = RenderingStates.FINISHED;
          this.#useThumbnailCanvas.directDrawing = false;
        }
        this.cssTransform({
          target: this.canvas,
          redrawAnnotationLayer: true,
          redrawAnnotationEditorLayer: true,
          redrawXfaLayer: true,
          redrawTextLayer: !postponeDrawing,
          hideTextLayer: postponeDrawing
        });
        if (postponeDrawing) {
          return;
        }
        this.eventBus.dispatch("pagerendered", {
          source: this,
          pageNumber: this.id,
          cssTransform: true,
          timestamp: performance.now(),
          error: this.#renderError
        });
        return;
      }
      if (!this.zoomLayer && !this.canvas.hidden) {
        this.zoomLayer = this.canvas.parentNode;
        this.zoomLayer.style.position = "absolute";
      }
    }
    if (this.zoomLayer) {
      this.cssTransform({
        target: this.zoomLayer.firstChild
      });
    }
    this.reset({
      keepZoomLayer: true,
      keepAnnotationLayer: true,
      keepAnnotationEditorLayer: true,
      keepXfaLayer: true,
      keepTextLayer: true
    });
  }
  cancelRendering({
    keepAnnotationLayer = false,
    keepAnnotationEditorLayer = false,
    keepXfaLayer = false,
    keepTextLayer = false,
    cancelExtraDelay = 0
  } = {}) {
    if (this.renderTask) {
      this.renderTask.cancel(cancelExtraDelay);
      this.renderTask = null;
    }
    this.resume = null;
    if (this.textLayer && (!keepTextLayer || !this.textLayer.div)) {
      this.textLayer.cancel();
      this.textLayer = null;
    }
    if (this.structTreeLayer && !this.textLayer) {
      this.structTreeLayer = null;
    }
    if (this.annotationLayer && (!keepAnnotationLayer || !this.annotationLayer.div)) {
      this.annotationLayer.cancel();
      this.annotationLayer = null;
      this._annotationCanvasMap = null;
    }
    if (this.annotationEditorLayer && (!keepAnnotationEditorLayer || !this.annotationEditorLayer.div)) {
      if (this.drawLayer) {
        this.drawLayer.cancel();
        this.drawLayer = null;
      }
      this.annotationEditorLayer.cancel();
      this.annotationEditorLayer = null;
    }
    if (this.xfaLayer && (!keepXfaLayer || !this.xfaLayer.div)) {
      this.xfaLayer.cancel();
      this.xfaLayer = null;
      this._textHighlighter?.disable();
    }
  }
  cssTransform({
    target,
    redrawAnnotationLayer = false,
    redrawAnnotationEditorLayer = false,
    redrawXfaLayer = false,
    redrawTextLayer = false,
    hideTextLayer = false
  }) {
    if (!target.hasAttribute("zooming")) {
      target.setAttribute("zooming", true);
      const {
        style: style2
      } = target;
      style2.width = style2.height = "";
    }
    const originalViewport = this.#viewportMap.get(target);
    if (this.viewport !== originalViewport) {
      const relativeRotation = this.viewport.rotation - originalViewport.rotation;
      const absRotation = Math.abs(relativeRotation);
      let scaleX = 1, scaleY = 1;
      if (absRotation === 90 || absRotation === 270) {
        const {
          width,
          height
        } = this.viewport;
        scaleX = height / width;
        scaleY = width / height;
      }
      target.style.transform = `rotate(${relativeRotation}deg) scale(${scaleX}, ${scaleY})`;
    }
    if (redrawAnnotationLayer && this.annotationLayer) {
      this.#renderAnnotationLayer();
    }
    if (redrawAnnotationEditorLayer && this.annotationEditorLayer) {
      if (this.drawLayer) {
        this.#renderDrawLayer();
      }
      this.#renderAnnotationEditorLayer();
    }
    if (redrawXfaLayer && this.xfaLayer) {
      this.#renderXfaLayer();
    }
    if (this.textLayer) {
      if (hideTextLayer) {
        this.textLayer.hide();
        this.structTreeLayer?.hide();
      } else if (redrawTextLayer) {
        this.#renderTextLayer();
      }
    }
  }
  get width() {
    return this.viewport.width;
  }
  get height() {
    return this.viewport.height;
  }
  getPagePoint(x2, y2) {
    return this.viewport.convertToPdfPoint(x2, y2);
  }
  async #finishRenderTask(renderTask, error = null) {
    if (renderTask === this.renderTask) {
      this.renderTask = null;
    }
    if (error instanceof RenderingCancelledException2) {
      this.#renderError = null;
      return;
    }
    this.#renderError = error;
    this.renderingState = RenderingStates.FINISHED;
    this._resetZoomLayer(true);
    this.#useThumbnailCanvas.regularAnnotations = !renderTask.separateAnnots;
    this.eventBus.dispatch("pagerendered", {
      source: this,
      pageNumber: this.id,
      cssTransform: false,
      timestamp: performance.now(),
      error: this.#renderError
    });
    if (error) {
      throw error;
    }
  }
  async draw() {
    if (this.renderingState !== RenderingStates.INITIAL) {
      console.error("Must be in new state before drawing");
      this.reset();
    }
    const {
      div,
      l10n,
      pageColors,
      pdfPage,
      viewport
    } = this;
    if (!pdfPage) {
      this.renderingState = RenderingStates.FINISHED;
      throw new Error("pdfPage is not loaded");
    }
    this.renderingState = RenderingStates.RUNNING;
    const canvasWrapper = document.createElement("div");
    canvasWrapper.classList.add("canvasWrapper");
    this.#addLayer(canvasWrapper, "canvasWrapper");
    if (!this.textLayer && this.#textLayerMode !== TextLayerMode.DISABLE && !pdfPage.isPureXfa) {
      this._accessibilityManager ||= new TextAccessibilityManager();
      this.textLayer = new TextLayerBuilder({
        pdfPage,
        highlighter: this._textHighlighter,
        accessibilityManager: this._accessibilityManager,
        enablePermissions: this.#textLayerMode === TextLayerMode.ENABLE_PERMISSIONS,
        onAppend: (textLayerDiv) => {
          this.l10n.pause();
          this.#addLayer(textLayerDiv, "textLayer");
          this.l10n.resume();
        }
      });
    }
    if (!this.annotationLayer && this.#annotationMode !== AnnotationMode.DISABLE) {
      const {
        annotationStorage,
        annotationEditorUIManager,
        downloadManager,
        enableScripting,
        fieldObjectsPromise,
        hasJSActionsPromise,
        linkService
      } = this.#layerProperties;
      this._annotationCanvasMap ||= /* @__PURE__ */ new Map();
      this.annotationLayer = new AnnotationLayerBuilder({
        pdfPage,
        annotationStorage,
        imageResourcesPath: this.imageResourcesPath,
        renderForms: this.#annotationMode === AnnotationMode.ENABLE_FORMS,
        linkService,
        downloadManager,
        enableScripting,
        hasJSActionsPromise,
        fieldObjectsPromise,
        annotationCanvasMap: this._annotationCanvasMap,
        accessibilityManager: this._accessibilityManager,
        annotationEditorUIManager,
        onAppend: (annotationLayerDiv) => {
          this.#addLayer(annotationLayerDiv, "annotationLayer");
        }
      });
    }
    const renderContinueCallback = (cont) => {
      showCanvas?.(false);
      if (this.renderingQueue && !this.renderingQueue.isHighestPriority(this)) {
        this.renderingState = RenderingStates.PAUSED;
        this.resume = () => {
          this.renderingState = RenderingStates.RUNNING;
          cont();
        };
        return;
      }
      cont();
    };
    const {
      width,
      height
    } = viewport;
    const canvas = document.createElement("canvas");
    canvas.setAttribute("role", "presentation");
    canvas.hidden = true;
    const hasHCM = !!(pageColors?.background && pageColors?.foreground);
    let showCanvas = (isLastShow) => {
      if (!hasHCM || isLastShow) {
        canvas.hidden = false;
        showCanvas = null;
      }
    };
    canvasWrapper.append(canvas);
    this.canvas = canvas;
    const ctx = canvas.getContext("2d", {
      alpha: false
    });
    const outputScale = this.outputScale = new OutputScale();
    if (this.maxCanvasPixels === 0) {
      const invScale = 1 / this.scale;
      outputScale.sx *= invScale;
      outputScale.sy *= invScale;
      this.#hasRestrictedScaling = true;
    } else if (this.maxCanvasPixels > 0) {
      const pixelsInViewport = width * height;
      const maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport);
      if (outputScale.sx > maxScale || outputScale.sy > maxScale) {
        outputScale.sx = maxScale;
        outputScale.sy = maxScale;
        this.#hasRestrictedScaling = true;
      } else {
        this.#hasRestrictedScaling = false;
      }
    }
    const sfx = approximateFraction(outputScale.sx);
    const sfy = approximateFraction(outputScale.sy);
    canvas.width = roundToDivide(width * outputScale.sx, sfx[0]);
    canvas.height = roundToDivide(height * outputScale.sy, sfy[0]);
    const {
      style: style2
    } = canvas;
    style2.width = roundToDivide(width, sfx[1]) + "px";
    style2.height = roundToDivide(height, sfy[1]) + "px";
    this.#viewportMap.set(canvas, viewport);
    const transform2 = outputScale.scaled ? [outputScale.sx, 0, 0, outputScale.sy, 0, 0] : null;
    const renderContext = {
      canvasContext: ctx,
      transform: transform2,
      viewport,
      annotationMode: this.#annotationMode,
      optionalContentConfigPromise: this._optionalContentConfigPromise,
      annotationCanvasMap: this._annotationCanvasMap,
      pageColors
    };
    const renderTask = this.renderTask = pdfPage.render(renderContext);
    renderTask.onContinue = renderContinueCallback;
    const resultPromise = renderTask.promise.then(async () => {
      showCanvas?.(true);
      await this.#finishRenderTask(renderTask);
      this.#renderTextLayer();
      if (this.annotationLayer) {
        await this.#renderAnnotationLayer();
      }
      const {
        annotationEditorUIManager
      } = this.#layerProperties;
      if (!annotationEditorUIManager) {
        return;
      }
      this.drawLayer ||= new DrawLayerBuilder({
        pageIndex: this.id
      });
      await this.#renderDrawLayer();
      this.drawLayer.setParent(canvasWrapper);
      if (!this.annotationEditorLayer) {
        this.annotationEditorLayer = new AnnotationEditorLayerBuilder({
          uiManager: annotationEditorUIManager,
          pdfPage,
          l10n,
          accessibilityManager: this._accessibilityManager,
          annotationLayer: this.annotationLayer?.annotationLayer,
          textLayer: this.textLayer,
          drawLayer: this.drawLayer.getDrawLayer(),
          onAppend: (annotationEditorLayerDiv) => {
            this.#addLayer(annotationEditorLayerDiv, "annotationEditorLayer");
          }
        });
      }
      this.#renderAnnotationEditorLayer();
    }, (error) => {
      if (!(error instanceof RenderingCancelledException2)) {
        showCanvas?.(true);
      }
      return this.#finishRenderTask(renderTask, error);
    });
    if (pdfPage.isPureXfa) {
      if (!this.xfaLayer) {
        const {
          annotationStorage,
          linkService
        } = this.#layerProperties;
        this.xfaLayer = new XfaLayerBuilder({
          pdfPage,
          annotationStorage,
          linkService
        });
      }
      this.#renderXfaLayer();
    }
    div.setAttribute("data-loaded", true);
    this.eventBus.dispatch("pagerender", {
      source: this,
      pageNumber: this.id
    });
    return resultPromise;
  }
  setPageLabel(label) {
    this.pageLabel = typeof label === "string" ? label : null;
    this.div.setAttribute("data-l10n-args", JSON.stringify({
      page: this.pageLabel ?? this.id
    }));
    if (this.pageLabel !== null) {
      this.div.setAttribute("data-page-label", this.pageLabel);
    } else {
      this.div.removeAttribute("data-page-label");
    }
  }
  get thumbnailCanvas() {
    const {
      directDrawing,
      initialOptionalContent,
      regularAnnotations
    } = this.#useThumbnailCanvas;
    return directDrawing && initialOptionalContent && regularAnnotations ? this.canvas : null;
  }
}
async function docProperties(pdfDocument) {
  const url = "", baseUrl = url.split("#", 1)[0];
  let {
    info: info2,
    metadata,
    contentDispositionFilename,
    contentLength
  } = await pdfDocument.getMetadata();
  if (!contentLength) {
    const {
      length
    } = await pdfDocument.getDownloadInfo();
    contentLength = length;
  }
  return {
    ...info2,
    baseURL: baseUrl,
    filesize: contentLength,
    filename: contentDispositionFilename || getPdfFilenameFromUrl(url),
    metadata: metadata?.getRaw(),
    authors: metadata?.get("dc:creator"),
    numPages: pdfDocument.numPages,
    URL: url
  };
}
class GenericScripting {
  constructor(sandboxBundleSrc) {
    this._ready = new Promise((resolve2, reject) => {
      const sandbox = import(
        /*webpackIgnore: true*/
        sandboxBundleSrc
      );
      sandbox.then((pdfjsSandbox) => {
        resolve2(pdfjsSandbox.QuickJSSandbox());
      }).catch(reject);
    });
  }
  async createSandbox(data2) {
    const sandbox = await this._ready;
    sandbox.create(data2);
  }
  async dispatchEventInSandbox(event) {
    const sandbox = await this._ready;
    setTimeout(() => sandbox.dispatchEvent(event), 0);
  }
  async destroySandbox() {
    const sandbox = await this._ready;
    sandbox.nukeSandbox();
  }
}
class PDFScriptingManager {
  #closeCapability = null;
  #destroyCapability = null;
  #docProperties = null;
  #eventAbortController = null;
  #eventBus = null;
  #externalServices = null;
  #pdfDocument = null;
  #pdfViewer = null;
  #ready = false;
  #scripting = null;
  #willPrintCapability = null;
  constructor({
    eventBus,
    externalServices = null,
    docProperties: docProperties2 = null
  }) {
    this.#eventBus = eventBus;
    this.#externalServices = externalServices;
    this.#docProperties = docProperties2;
  }
  setViewer(pdfViewer) {
    this.#pdfViewer = pdfViewer;
  }
  async setDocument(pdfDocument) {
    if (this.#pdfDocument) {
      await this.#destroyScripting();
    }
    this.#pdfDocument = pdfDocument;
    if (!pdfDocument) {
      return;
    }
    const [objects, calculationOrder, docActions] = await Promise.all([pdfDocument.getFieldObjects(), pdfDocument.getCalculationOrderIds(), pdfDocument.getJSActions()]);
    if (!objects && !docActions) {
      await this.#destroyScripting();
      return;
    }
    if (pdfDocument !== this.#pdfDocument) {
      return;
    }
    try {
      this.#scripting = this.#initScripting();
    } catch (error) {
      console.error(`setDocument: "${error.message}".`);
      await this.#destroyScripting();
      return;
    }
    const eventBus = this.#eventBus;
    this.#eventAbortController = new AbortController();
    const {
      signal
    } = this.#eventAbortController;
    eventBus._on("updatefromsandbox", (event) => {
      if (event?.source === window) {
        this.#updateFromSandbox(event.detail);
      }
    }, {
      signal
    });
    eventBus._on("dispatcheventinsandbox", (event) => {
      this.#scripting?.dispatchEventInSandbox(event.detail);
    }, {
      signal
    });
    eventBus._on("pagechanging", ({
      pageNumber,
      previous
    }) => {
      if (pageNumber === previous) {
        return;
      }
      this.#dispatchPageClose(previous);
      this.#dispatchPageOpen(pageNumber);
    }, {
      signal
    });
    eventBus._on("pagerendered", ({
      pageNumber
    }) => {
      if (!this._pageOpenPending.has(pageNumber)) {
        return;
      }
      if (pageNumber !== this.#pdfViewer.currentPageNumber) {
        return;
      }
      this.#dispatchPageOpen(pageNumber);
    }, {
      signal
    });
    eventBus._on("pagesdestroy", async () => {
      await this.#dispatchPageClose(this.#pdfViewer.currentPageNumber);
      await this.#scripting?.dispatchEventInSandbox({
        id: "doc",
        name: "WillClose"
      });
      this.#closeCapability?.resolve();
    }, {
      signal
    });
    try {
      const docProperties2 = await this.#docProperties(pdfDocument);
      if (pdfDocument !== this.#pdfDocument) {
        return;
      }
      await this.#scripting.createSandbox({
        objects,
        calculationOrder,
        appInfo: {
          platform: navigator.platform,
          language: navigator.language
        },
        docInfo: {
          ...docProperties2,
          actions: docActions
        }
      });
      eventBus.dispatch("sandboxcreated", {
        source: this
      });
    } catch (error) {
      console.error(`setDocument: "${error.message}".`);
      await this.#destroyScripting();
      return;
    }
    await this.#scripting?.dispatchEventInSandbox({
      id: "doc",
      name: "Open"
    });
    await this.#dispatchPageOpen(this.#pdfViewer.currentPageNumber, true);
    Promise.resolve().then(() => {
      if (pdfDocument === this.#pdfDocument) {
        this.#ready = true;
      }
    });
  }
  async dispatchWillSave() {
    return this.#scripting?.dispatchEventInSandbox({
      id: "doc",
      name: "WillSave"
    });
  }
  async dispatchDidSave() {
    return this.#scripting?.dispatchEventInSandbox({
      id: "doc",
      name: "DidSave"
    });
  }
  async dispatchWillPrint() {
    if (!this.#scripting) {
      return;
    }
    await this.#willPrintCapability?.promise;
    this.#willPrintCapability = Promise.withResolvers();
    try {
      await this.#scripting.dispatchEventInSandbox({
        id: "doc",
        name: "WillPrint"
      });
    } catch (ex) {
      this.#willPrintCapability.resolve();
      this.#willPrintCapability = null;
      throw ex;
    }
    await this.#willPrintCapability.promise;
  }
  async dispatchDidPrint() {
    return this.#scripting?.dispatchEventInSandbox({
      id: "doc",
      name: "DidPrint"
    });
  }
  get destroyPromise() {
    return this.#destroyCapability?.promise || null;
  }
  get ready() {
    return this.#ready;
  }
  get _pageOpenPending() {
    return shadow(this, "_pageOpenPending", /* @__PURE__ */ new Set());
  }
  get _visitedPages() {
    return shadow(this, "_visitedPages", /* @__PURE__ */ new Map());
  }
  async #updateFromSandbox(detail) {
    const pdfViewer = this.#pdfViewer;
    const isInPresentationMode = pdfViewer.isInPresentationMode || pdfViewer.isChangingPresentationMode;
    const {
      id: id2,
      siblings,
      command,
      value
    } = detail;
    if (!id2) {
      switch (command) {
        case "clear":
          console.clear();
          break;
        case "error":
          console.error(value);
          break;
        case "layout":
          if (!isInPresentationMode) {
            const modes = apiPageLayoutToViewerModes(value);
            pdfViewer.spreadMode = modes.spreadMode;
          }
          break;
        case "page-num":
          pdfViewer.currentPageNumber = value + 1;
          break;
        case "print":
          await pdfViewer.pagesPromise;
          this.#eventBus.dispatch("print", {
            source: this
          });
          break;
        case "println":
          console.log(value);
          break;
        case "zoom":
          if (!isInPresentationMode) {
            pdfViewer.currentScaleValue = value;
          }
          break;
        case "SaveAs":
          this.#eventBus.dispatch("download", {
            source: this
          });
          break;
        case "FirstPage":
          pdfViewer.currentPageNumber = 1;
          break;
        case "LastPage":
          pdfViewer.currentPageNumber = pdfViewer.pagesCount;
          break;
        case "NextPage":
          pdfViewer.nextPage();
          break;
        case "PrevPage":
          pdfViewer.previousPage();
          break;
        case "ZoomViewIn":
          if (!isInPresentationMode) {
            pdfViewer.increaseScale();
          }
          break;
        case "ZoomViewOut":
          if (!isInPresentationMode) {
            pdfViewer.decreaseScale();
          }
          break;
        case "WillPrintFinished":
          this.#willPrintCapability?.resolve();
          this.#willPrintCapability = null;
          break;
      }
      return;
    }
    if (isInPresentationMode && detail.focus) {
      return;
    }
    delete detail.id;
    delete detail.siblings;
    const ids = siblings ? [id2, ...siblings] : [id2];
    for (const elementId of ids) {
      const element = document.querySelector(`[data-element-id="${elementId}"]`);
      if (element) {
        element.dispatchEvent(new CustomEvent("updatefromsandbox", {
          detail
        }));
      } else {
        this.#pdfDocument?.annotationStorage.setValue(elementId, detail);
      }
    }
  }
  async #dispatchPageOpen(pageNumber, initialize = false) {
    const pdfDocument = this.#pdfDocument, visitedPages = this._visitedPages;
    if (initialize) {
      this.#closeCapability = Promise.withResolvers();
    }
    if (!this.#closeCapability) {
      return;
    }
    const pageView = this.#pdfViewer.getPageView(pageNumber - 1);
    if (pageView?.renderingState !== RenderingStates.FINISHED) {
      this._pageOpenPending.add(pageNumber);
      return;
    }
    this._pageOpenPending.delete(pageNumber);
    const actionsPromise = (async () => {
      const actions = await (!visitedPages.has(pageNumber) ? pageView.pdfPage?.getJSActions() : null);
      if (pdfDocument !== this.#pdfDocument) {
        return;
      }
      await this.#scripting?.dispatchEventInSandbox({
        id: "page",
        name: "PageOpen",
        pageNumber,
        actions
      });
    })();
    visitedPages.set(pageNumber, actionsPromise);
  }
  async #dispatchPageClose(pageNumber) {
    const pdfDocument = this.#pdfDocument, visitedPages = this._visitedPages;
    if (!this.#closeCapability) {
      return;
    }
    if (this._pageOpenPending.has(pageNumber)) {
      return;
    }
    const actionsPromise = visitedPages.get(pageNumber);
    if (!actionsPromise) {
      return;
    }
    visitedPages.set(pageNumber, null);
    await actionsPromise;
    if (pdfDocument !== this.#pdfDocument) {
      return;
    }
    await this.#scripting?.dispatchEventInSandbox({
      id: "page",
      name: "PageClose",
      pageNumber
    });
  }
  #initScripting() {
    this.#destroyCapability = Promise.withResolvers();
    if (this.#scripting) {
      throw new Error("#initScripting: Scripting already exists.");
    }
    return this.#externalServices.createScripting();
  }
  async #destroyScripting() {
    if (!this.#scripting) {
      this.#pdfDocument = null;
      this.#destroyCapability?.resolve();
      return;
    }
    if (this.#closeCapability) {
      await Promise.race([this.#closeCapability.promise, new Promise((resolve2) => {
        setTimeout(resolve2, 1e3);
      })]).catch(() => {
      });
      this.#closeCapability = null;
    }
    this.#pdfDocument = null;
    try {
      await this.#scripting.destroySandbox();
    } catch {
    }
    this.#willPrintCapability?.reject(new Error("Scripting destroyed."));
    this.#willPrintCapability = null;
    this.#eventAbortController?.abort();
    this.#eventAbortController = null;
    this._pageOpenPending.clear();
    this._visitedPages.clear();
    this.#scripting = null;
    this.#ready = false;
    this.#destroyCapability?.resolve();
  }
}
class PDFScriptingManagerComponents extends PDFScriptingManager {
  constructor(options) {
    if (!options.externalServices) {
      window.addEventListener("updatefromsandbox", (event) => {
        options.eventBus.dispatch("updatefromsandbox", {
          source: window,
          detail: event.detail
        });
      });
    }
    options.externalServices ||= {
      createScripting: () => new GenericScripting(options.sandboxBundleSrc)
    };
    options.docProperties ||= (pdfDocument) => docProperties(pdfDocument);
    super(options);
  }
}
const CLEANUP_TIMEOUT = 3e4;
class PDFRenderingQueue {
  constructor() {
    this.pdfViewer = null;
    this.pdfThumbnailViewer = null;
    this.onIdle = null;
    this.highestPriorityPage = null;
    this.idleTimeout = null;
    this.printing = false;
    this.isThumbnailViewEnabled = false;
    Object.defineProperty(this, "hasViewer", {
      value: () => !!this.pdfViewer
    });
  }
  setViewer(pdfViewer) {
    this.pdfViewer = pdfViewer;
  }
  setThumbnailViewer(pdfThumbnailViewer) {
    this.pdfThumbnailViewer = pdfThumbnailViewer;
  }
  isHighestPriority(view) {
    return this.highestPriorityPage === view.renderingId;
  }
  renderHighestPriority(currentlyVisiblePages) {
    if (this.idleTimeout) {
      clearTimeout(this.idleTimeout);
      this.idleTimeout = null;
    }
    if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {
      return;
    }
    if (this.isThumbnailViewEnabled && this.pdfThumbnailViewer?.forceRendering()) {
      return;
    }
    if (this.printing) {
      return;
    }
    if (this.onIdle) {
      this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT);
    }
  }
  getHighestPriority(visible, views, scrolledDown, preRenderExtra = false) {
    const visibleViews = visible.views, numVisible = visibleViews.length;
    if (numVisible === 0) {
      return null;
    }
    for (let i2 = 0; i2 < numVisible; i2++) {
      const view = visibleViews[i2].view;
      if (!this.isViewFinished(view)) {
        return view;
      }
    }
    const firstId = visible.first.id, lastId = visible.last.id;
    if (lastId - firstId + 1 > numVisible) {
      const visibleIds = visible.ids;
      for (let i2 = 1, ii = lastId - firstId; i2 < ii; i2++) {
        const holeId = scrolledDown ? firstId + i2 : lastId - i2;
        if (visibleIds.has(holeId)) {
          continue;
        }
        const holeView = views[holeId - 1];
        if (!this.isViewFinished(holeView)) {
          return holeView;
        }
      }
    }
    let preRenderIndex = scrolledDown ? lastId : firstId - 2;
    let preRenderView = views[preRenderIndex];
    if (preRenderView && !this.isViewFinished(preRenderView)) {
      return preRenderView;
    }
    if (preRenderExtra) {
      preRenderIndex += scrolledDown ? 1 : -1;
      preRenderView = views[preRenderIndex];
      if (preRenderView && !this.isViewFinished(preRenderView)) {
        return preRenderView;
      }
    }
    return null;
  }
  isViewFinished(view) {
    return view.renderingState === RenderingStates.FINISHED;
  }
  renderView(view) {
    switch (view.renderingState) {
      case RenderingStates.FINISHED:
        return false;
      case RenderingStates.PAUSED:
        this.highestPriorityPage = view.renderingId;
        view.resume();
        break;
      case RenderingStates.RUNNING:
        this.highestPriorityPage = view.renderingId;
        break;
      case RenderingStates.INITIAL:
        this.highestPriorityPage = view.renderingId;
        view.draw().finally(() => {
          this.renderHighestPriority();
        }).catch((reason) => {
          if (reason instanceof RenderingCancelledException2) {
            return;
          }
          console.error(`renderView: "${reason}"`);
        });
        break;
    }
    return true;
  }
}
const DEFAULT_CACHE_SIZE = 10;
const PagesCountLimit = {
  FORCE_SCROLL_MODE_PAGE: 15e3,
  FORCE_LAZY_PAGE_INIT: 7500,
  PAUSE_EAGER_PAGE_INIT: 250
};
function isValidAnnotationEditorMode(mode) {
  return Object.values(AnnotationEditorType).includes(mode) && mode !== AnnotationEditorType.DISABLE;
}
class PDFPageViewBuffer {
  #buf = /* @__PURE__ */ new Set();
  #size = 0;
  constructor(size2) {
    this.#size = size2;
  }
  push(view) {
    const buf = this.#buf;
    if (buf.has(view)) {
      buf.delete(view);
    }
    buf.add(view);
    if (buf.size > this.#size) {
      this.#destroyFirstView();
    }
  }
  resize(newSize, idsToKeep = null) {
    this.#size = newSize;
    const buf = this.#buf;
    if (idsToKeep) {
      const ii = buf.size;
      let i2 = 1;
      for (const view of buf) {
        if (idsToKeep.has(view.id)) {
          buf.delete(view);
          buf.add(view);
        }
        if (++i2 > ii) {
          break;
        }
      }
    }
    while (buf.size > this.#size) {
      this.#destroyFirstView();
    }
  }
  has(view) {
    return this.#buf.has(view);
  }
  [Symbol.iterator]() {
    return this.#buf.keys();
  }
  #destroyFirstView() {
    const firstView = this.#buf.keys().next().value;
    firstView?.destroy();
    this.#buf.delete(firstView);
  }
}
class PDFViewer {
  #buffer = null;
  #altTextManager = null;
  #annotationEditorHighlightColors = null;
  #annotationEditorMode = AnnotationEditorType.NONE;
  #annotationEditorUIManager = null;
  #annotationMode = AnnotationMode.ENABLE_FORMS;
  #containerTopLeft = null;
  #enableHighlightFloatingButton = false;
  #enablePermissions = false;
  #eventAbortController = null;
  #mlManager = null;
  #getAllTextInProgress = false;
  #hiddenCopyElement = null;
  #interruptCopyCondition = false;
  #previousContainerHeight = 0;
  #resizeObserver = new ResizeObserver(this.#resizeObserverCallback.bind(this));
  #scrollModePageState = null;
  #scaleTimeoutId = null;
  #textLayerMode = TextLayerMode.ENABLE;
  constructor(options) {
    const viewerVersion = "4.3.136";
    if (version !== viewerVersion) {
      throw new Error(`The API version "${version}" does not match the Viewer version "${viewerVersion}".`);
    }
    this.container = options.container;
    this.viewer = options.viewer || options.container.firstElementChild;
    if (this.container?.tagName !== "DIV" || this.viewer?.tagName !== "DIV") {
      throw new Error("Invalid `container` and/or `viewer` option.");
    }
    if (this.container.offsetParent && getComputedStyle(this.container).position !== "absolute") {
      throw new Error("The `container` must be absolutely positioned.");
    }
    this.#resizeObserver.observe(this.container);
    this.eventBus = options.eventBus;
    this.linkService = options.linkService || new SimpleLinkService();
    this.downloadManager = options.downloadManager || null;
    this.findController = options.findController || null;
    this.#altTextManager = options.altTextManager || null;
    if (this.findController) {
      this.findController.onIsPageVisible = (pageNumber) => this._getVisiblePages().ids.has(pageNumber);
    }
    this._scriptingManager = options.scriptingManager || null;
    this.#textLayerMode = options.textLayerMode ?? TextLayerMode.ENABLE;
    this.#annotationMode = options.annotationMode ?? AnnotationMode.ENABLE_FORMS;
    this.#annotationEditorMode = options.annotationEditorMode ?? AnnotationEditorType.NONE;
    this.#annotationEditorHighlightColors = options.annotationEditorHighlightColors || null;
    this.#enableHighlightFloatingButton = options.enableHighlightFloatingButton === true;
    this.imageResourcesPath = options.imageResourcesPath || "";
    this.enablePrintAutoRotate = options.enablePrintAutoRotate || false;
    this.removePageBorders = options.removePageBorders || false;
    this.maxCanvasPixels = options.maxCanvasPixels;
    this.l10n = options.l10n;
    this.l10n ||= new genericl10n_GenericL10n();
    this.#enablePermissions = options.enablePermissions || false;
    this.pageColors = options.pageColors || null;
    this.#mlManager = options.mlManager || null;
    this.defaultRenderingQueue = !options.renderingQueue;
    if (this.defaultRenderingQueue) {
      this.renderingQueue = new PDFRenderingQueue();
      this.renderingQueue.setViewer(this);
    } else {
      this.renderingQueue = options.renderingQueue;
    }
    this.scroll = watchScroll(this.container, this._scrollUpdate.bind(this));
    this.presentationModeState = PresentationModeState.UNKNOWN;
    this._resetView();
    if (this.removePageBorders) {
      this.viewer.classList.add("removePageBorders");
    }
    this.#updateContainerHeightCss();
    this.eventBus._on("thumbnailrendered", ({
      pageNumber,
      pdfPage
    }) => {
      const pageView = this._pages[pageNumber - 1];
      if (!this.#buffer.has(pageView)) {
        pdfPage?.cleanup();
      }
    });
    if (!options.l10n) {
      this.l10n.translate(this.container);
    }
  }
  get pagesCount() {
    return this._pages.length;
  }
  getPageView(index) {
    return this._pages[index];
  }
  getCachedPageViews() {
    return new Set(this.#buffer);
  }
  get pageViewsReady() {
    return this._pages.every((pageView) => pageView?.pdfPage);
  }
  get renderForms() {
    return this.#annotationMode === AnnotationMode.ENABLE_FORMS;
  }
  get enableScripting() {
    return !!this._scriptingManager;
  }
  get currentPageNumber() {
    return this._currentPageNumber;
  }
  set currentPageNumber(val) {
    if (!Number.isInteger(val)) {
      throw new Error("Invalid page number.");
    }
    if (!this.pdfDocument) {
      return;
    }
    if (!this._setCurrentPageNumber(val, true)) {
      console.error(`currentPageNumber: "${val}" is not a valid page.`);
    }
  }
  _setCurrentPageNumber(val, resetCurrentPageView = false) {
    if (this._currentPageNumber === val) {
      if (resetCurrentPageView) {
        this.#resetCurrentPageView();
      }
      return true;
    }
    if (!(0 < val && val <= this.pagesCount)) {
      return false;
    }
    const previous = this._currentPageNumber;
    this._currentPageNumber = val;
    this.eventBus.dispatch("pagechanging", {
      source: this,
      pageNumber: val,
      pageLabel: this._pageLabels?.[val - 1] ?? null,
      previous
    });
    if (resetCurrentPageView) {
      this.#resetCurrentPageView();
    }
    return true;
  }
  get currentPageLabel() {
    return this._pageLabels?.[this._currentPageNumber - 1] ?? null;
  }
  set currentPageLabel(val) {
    if (!this.pdfDocument) {
      return;
    }
    let page = val | 0;
    if (this._pageLabels) {
      const i2 = this._pageLabels.indexOf(val);
      if (i2 >= 0) {
        page = i2 + 1;
      }
    }
    if (!this._setCurrentPageNumber(page, true)) {
      console.error(`currentPageLabel: "${val}" is not a valid page.`);
    }
  }
  get currentScale() {
    return this._currentScale !== UNKNOWN_SCALE ? this._currentScale : DEFAULT_SCALE;
  }
  set currentScale(val) {
    if (isNaN(val)) {
      throw new Error("Invalid numeric scale.");
    }
    if (!this.pdfDocument) {
      return;
    }
    this.#setScale(val, {
      noScroll: false
    });
  }
  get currentScaleValue() {
    return this._currentScaleValue;
  }
  set currentScaleValue(val) {
    if (!this.pdfDocument) {
      return;
    }
    this.#setScale(val, {
      noScroll: false
    });
  }
  get pagesRotation() {
    return this._pagesRotation;
  }
  set pagesRotation(rotation) {
    if (!isValidRotation(rotation)) {
      throw new Error("Invalid pages rotation angle.");
    }
    if (!this.pdfDocument) {
      return;
    }
    rotation %= 360;
    if (rotation < 0) {
      rotation += 360;
    }
    if (this._pagesRotation === rotation) {
      return;
    }
    this._pagesRotation = rotation;
    const pageNumber = this._currentPageNumber;
    this.refresh(true, {
      rotation
    });
    if (this._currentScaleValue) {
      this.#setScale(this._currentScaleValue, {
        noScroll: true
      });
    }
    this.eventBus.dispatch("rotationchanging", {
      source: this,
      pagesRotation: rotation,
      pageNumber
    });
    if (this.defaultRenderingQueue) {
      this.update();
    }
  }
  get firstPagePromise() {
    return this.pdfDocument ? this._firstPageCapability.promise : null;
  }
  get onePageRendered() {
    return this.pdfDocument ? this._onePageRenderedCapability.promise : null;
  }
  get pagesPromise() {
    return this.pdfDocument ? this._pagesCapability.promise : null;
  }
  get _layerProperties() {
    const self2 = this;
    return shadow(this, "_layerProperties", {
      get annotationEditorUIManager() {
        return self2.#annotationEditorUIManager;
      },
      get annotationStorage() {
        return self2.pdfDocument?.annotationStorage;
      },
      get downloadManager() {
        return self2.downloadManager;
      },
      get enableScripting() {
        return !!self2._scriptingManager;
      },
      get fieldObjectsPromise() {
        return self2.pdfDocument?.getFieldObjects();
      },
      get findController() {
        return self2.findController;
      },
      get hasJSActionsPromise() {
        return self2.pdfDocument?.hasJSActions();
      },
      get linkService() {
        return self2.linkService;
      }
    });
  }
  #initializePermissions(permissions) {
    const params = {
      annotationEditorMode: this.#annotationEditorMode,
      annotationMode: this.#annotationMode,
      textLayerMode: this.#textLayerMode
    };
    if (!permissions) {
      return params;
    }
    if (!permissions.includes(PermissionFlag.COPY) && this.#textLayerMode === TextLayerMode.ENABLE) {
      params.textLayerMode = TextLayerMode.ENABLE_PERMISSIONS;
    }
    if (!permissions.includes(PermissionFlag.MODIFY_CONTENTS)) {
      params.annotationEditorMode = AnnotationEditorType.DISABLE;
    }
    if (!permissions.includes(PermissionFlag.MODIFY_ANNOTATIONS) && !permissions.includes(PermissionFlag.FILL_INTERACTIVE_FORMS) && this.#annotationMode === AnnotationMode.ENABLE_FORMS) {
      params.annotationMode = AnnotationMode.ENABLE;
    }
    return params;
  }
  async #onePageRenderedOrForceFetch(signal) {
    if (document.visibilityState === "hidden" || !this.container.offsetParent || this._getVisiblePages().views.length === 0) {
      return;
    }
    const hiddenCapability = Promise.withResolvers();
    function onVisibilityChange() {
      if (document.visibilityState === "hidden") {
        hiddenCapability.resolve();
      }
    }
    document.addEventListener("visibilitychange", onVisibilityChange, {
      signal
    });
    await Promise.race([this._onePageRenderedCapability.promise, hiddenCapability.promise]);
    document.removeEventListener("visibilitychange", onVisibilityChange);
  }
  async getAllText() {
    const texts = [];
    const buffer = [];
    for (let pageNum = 1, pagesCount = this.pdfDocument.numPages; pageNum <= pagesCount; ++pageNum) {
      if (this.#interruptCopyCondition) {
        return null;
      }
      buffer.length = 0;
      const page = await this.pdfDocument.getPage(pageNum);
      const {
        items
      } = await page.getTextContent();
      for (const item of items) {
        if (item.str) {
          buffer.push(item.str);
        }
        if (item.hasEOL) {
          buffer.push("\n");
        }
      }
      texts.push(removeNullCharacters(buffer.join("")));
    }
    return texts.join("\n");
  }
  #copyCallback(textLayerMode, event) {
    const selection = document.getSelection();
    const {
      focusNode,
      anchorNode
    } = selection;
    if (anchorNode && focusNode && selection.containsNode(this.#hiddenCopyElement)) {
      if (this.#getAllTextInProgress || textLayerMode === TextLayerMode.ENABLE_PERMISSIONS) {
        event.preventDefault();
        event.stopPropagation();
        return;
      }
      this.#getAllTextInProgress = true;
      const savedCursor = this.container.style.cursor;
      this.container.style.cursor = "wait";
      const interruptCopy = (ev) => this.#interruptCopyCondition = ev.key === "Escape";
      window.addEventListener("keydown", interruptCopy);
      this.getAllText().then(async (text) => {
        if (text !== null) {
          await navigator.clipboard.writeText(text);
        }
      }).catch((reason) => {
        console.warn(`Something goes wrong when extracting the text: ${reason.message}`);
      }).finally(() => {
        this.#getAllTextInProgress = false;
        this.#interruptCopyCondition = false;
        window.removeEventListener("keydown", interruptCopy);
        this.container.style.cursor = savedCursor;
      });
      event.preventDefault();
      event.stopPropagation();
    }
  }
  setDocument(pdfDocument) {
    if (this.pdfDocument) {
      this.eventBus.dispatch("pagesdestroy", {
        source: this
      });
      this._cancelRendering();
      this._resetView();
      this.findController?.setDocument(null);
      this._scriptingManager?.setDocument(null);
      if (this.#annotationEditorUIManager) {
        this.#annotationEditorUIManager.destroy();
        this.#annotationEditorUIManager = null;
      }
    }
    this.pdfDocument = pdfDocument;
    if (!pdfDocument) {
      return;
    }
    const pagesCount = pdfDocument.numPages;
    const firstPagePromise = pdfDocument.getPage(1);
    const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig({
      intent: "display"
    });
    const permissionsPromise = this.#enablePermissions ? pdfDocument.getPermissions() : Promise.resolve();
    const {
      eventBus,
      pageColors,
      viewer
    } = this;
    this.#eventAbortController = new AbortController();
    const {
      signal
    } = this.#eventAbortController;
    if (pagesCount > PagesCountLimit.FORCE_SCROLL_MODE_PAGE) {
      console.warn("Forcing PAGE-scrolling for performance reasons, given the length of the document.");
      const mode = this._scrollMode = ScrollMode.PAGE;
      eventBus.dispatch("scrollmodechanged", {
        source: this,
        mode
      });
    }
    this._pagesCapability.promise.then(() => {
      eventBus.dispatch("pagesloaded", {
        source: this,
        pagesCount
      });
    }, () => {
    });
    const onBeforeDraw = (evt) => {
      const pageView = this._pages[evt.pageNumber - 1];
      if (!pageView) {
        return;
      }
      this.#buffer.push(pageView);
    };
    eventBus._on("pagerender", onBeforeDraw, {
      signal
    });
    const onAfterDraw = (evt) => {
      if (evt.cssTransform) {
        return;
      }
      this._onePageRenderedCapability.resolve({
        timestamp: evt.timestamp
      });
      eventBus._off("pagerendered", onAfterDraw);
    };
    eventBus._on("pagerendered", onAfterDraw, {
      signal
    });
    Promise.all([firstPagePromise, permissionsPromise]).then(([firstPdfPage, permissions]) => {
      if (pdfDocument !== this.pdfDocument) {
        return;
      }
      this._firstPageCapability.resolve(firstPdfPage);
      this._optionalContentConfigPromise = optionalContentConfigPromise;
      const {
        annotationEditorMode,
        annotationMode,
        textLayerMode
      } = this.#initializePermissions(permissions);
      if (textLayerMode !== TextLayerMode.DISABLE) {
        const element = this.#hiddenCopyElement = document.createElement("div");
        element.id = "hiddenCopyElement";
        viewer.before(element);
      }
      if (annotationEditorMode !== AnnotationEditorType.DISABLE) {
        const mode = annotationEditorMode;
        if (pdfDocument.isPureXfa) {
          console.warn("Warning: XFA-editing is not implemented.");
        } else if (isValidAnnotationEditorMode(mode)) {
          this.#annotationEditorUIManager = new AnnotationEditorUIManager2(this.container, viewer, this.#altTextManager, eventBus, pdfDocument, pageColors, this.#annotationEditorHighlightColors, this.#enableHighlightFloatingButton, this.#mlManager);
          eventBus.dispatch("annotationeditoruimanager", {
            source: this,
            uiManager: this.#annotationEditorUIManager
          });
          if (mode !== AnnotationEditorType.NONE) {
            this.#annotationEditorUIManager.updateMode(mode);
          }
        } else {
          console.error(`Invalid AnnotationEditor mode: ${mode}`);
        }
      }
      const viewerElement = this._scrollMode === ScrollMode.PAGE ? null : viewer;
      const scale = this.currentScale;
      const viewport = firstPdfPage.getViewport({
        scale: scale * PixelsPerInch2.PDF_TO_CSS_UNITS
      });
      viewer.style.setProperty("--scale-factor", viewport.scale);
      if (pageColors?.foreground === "CanvasText" || pageColors?.background === "Canvas") {
        viewer.style.setProperty("--hcm-highlight-filter", pdfDocument.filterFactory.addHighlightHCMFilter("highlight", "CanvasText", "Canvas", "HighlightText", "Highlight"));
        viewer.style.setProperty("--hcm-highlight-selected-filter", pdfDocument.filterFactory.addHighlightHCMFilter("highlight_selected", "CanvasText", "Canvas", "HighlightText", "ButtonText"));
      }
      for (let pageNum = 1; pageNum <= pagesCount; ++pageNum) {
        const pageView = new PDFPageView({
          container: viewerElement,
          eventBus,
          id: pageNum,
          scale,
          defaultViewport: viewport.clone(),
          optionalContentConfigPromise,
          renderingQueue: this.renderingQueue,
          textLayerMode,
          annotationMode,
          imageResourcesPath: this.imageResourcesPath,
          maxCanvasPixels: this.maxCanvasPixels,
          pageColors,
          l10n: this.l10n,
          layerProperties: this._layerProperties
        });
        this._pages.push(pageView);
      }
      this._pages[0]?.setPdfPage(firstPdfPage);
      if (this._scrollMode === ScrollMode.PAGE) {
        this.#ensurePageViewVisible();
      } else if (this._spreadMode !== SpreadMode.NONE) {
        this._updateSpreadMode();
      }
      this.#onePageRenderedOrForceFetch(signal).then(async () => {
        if (pdfDocument !== this.pdfDocument) {
          return;
        }
        this.findController?.setDocument(pdfDocument);
        this._scriptingManager?.setDocument(pdfDocument);
        if (this.#hiddenCopyElement) {
          document.addEventListener("copy", this.#copyCallback.bind(this, textLayerMode), {
            signal
          });
        }
        if (this.#annotationEditorUIManager) {
          eventBus.dispatch("annotationeditormodechanged", {
            source: this,
            mode: this.#annotationEditorMode
          });
        }
        if (pdfDocument.loadingParams.disableAutoFetch || pagesCount > PagesCountLimit.FORCE_LAZY_PAGE_INIT) {
          this._pagesCapability.resolve();
          return;
        }
        let getPagesLeft = pagesCount - 1;
        if (getPagesLeft <= 0) {
          this._pagesCapability.resolve();
          return;
        }
        for (let pageNum = 2; pageNum <= pagesCount; ++pageNum) {
          const promise = pdfDocument.getPage(pageNum).then((pdfPage) => {
            const pageView = this._pages[pageNum - 1];
            if (!pageView.pdfPage) {
              pageView.setPdfPage(pdfPage);
            }
            if (--getPagesLeft === 0) {
              this._pagesCapability.resolve();
            }
          }, (reason) => {
            console.error(`Unable to get page ${pageNum} to initialize viewer`, reason);
            if (--getPagesLeft === 0) {
              this._pagesCapability.resolve();
            }
          });
          if (pageNum % PagesCountLimit.PAUSE_EAGER_PAGE_INIT === 0) {
            await promise;
          }
        }
      });
      eventBus.dispatch("pagesinit", {
        source: this
      });
      pdfDocument.getMetadata().then(({
        info: info2
      }) => {
        if (pdfDocument !== this.pdfDocument) {
          return;
        }
        if (info2.Language) {
          viewer.lang = info2.Language;
        }
      });
      if (this.defaultRenderingQueue) {
        this.update();
      }
    }).catch((reason) => {
      console.error("Unable to initialize viewer", reason);
      this._pagesCapability.reject(reason);
    });
  }
  setPageLabels(labels) {
    if (!this.pdfDocument) {
      return;
    }
    if (!labels) {
      this._pageLabels = null;
    } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) {
      this._pageLabels = null;
      console.error(`setPageLabels: Invalid page labels.`);
    } else {
      this._pageLabels = labels;
    }
    for (let i2 = 0, ii = this._pages.length; i2 < ii; i2++) {
      this._pages[i2].setPageLabel(this._pageLabels?.[i2] ?? null);
    }
  }
  _resetView() {
    this._pages = [];
    this._currentPageNumber = 1;
    this._currentScale = UNKNOWN_SCALE;
    this._currentScaleValue = null;
    this._pageLabels = null;
    this.#buffer = new PDFPageViewBuffer(DEFAULT_CACHE_SIZE);
    this._location = null;
    this._pagesRotation = 0;
    this._optionalContentConfigPromise = null;
    this._firstPageCapability = Promise.withResolvers();
    this._onePageRenderedCapability = Promise.withResolvers();
    this._pagesCapability = Promise.withResolvers();
    this._scrollMode = ScrollMode.VERTICAL;
    this._previousScrollMode = ScrollMode.UNKNOWN;
    this._spreadMode = SpreadMode.NONE;
    this.#scrollModePageState = {
      previousPageNumber: 1,
      scrollDown: true,
      pages: []
    };
    this.#eventAbortController?.abort();
    this.#eventAbortController = null;
    this.viewer.textContent = "";
    this._updateScrollMode();
    this.viewer.removeAttribute("lang");
    this.#hiddenCopyElement?.remove();
    this.#hiddenCopyElement = null;
  }
  #ensurePageViewVisible() {
    if (this._scrollMode !== ScrollMode.PAGE) {
      throw new Error("#ensurePageViewVisible: Invalid scrollMode value.");
    }
    const pageNumber = this._currentPageNumber, state = this.#scrollModePageState, viewer = this.viewer;
    viewer.textContent = "";
    state.pages.length = 0;
    if (this._spreadMode === SpreadMode.NONE && !this.isInPresentationMode) {
      const pageView = this._pages[pageNumber - 1];
      viewer.append(pageView.div);
      state.pages.push(pageView);
    } else {
      const pageIndexSet = /* @__PURE__ */ new Set(), parity = this._spreadMode - 1;
      if (parity === -1) {
        pageIndexSet.add(pageNumber - 1);
      } else if (pageNumber % 2 !== parity) {
        pageIndexSet.add(pageNumber - 1);
        pageIndexSet.add(pageNumber);
      } else {
        pageIndexSet.add(pageNumber - 2);
        pageIndexSet.add(pageNumber - 1);
      }
      const spread = document.createElement("div");
      spread.className = "spread";
      if (this.isInPresentationMode) {
        const dummyPage = document.createElement("div");
        dummyPage.className = "dummyPage";
        spread.append(dummyPage);
      }
      for (const i2 of pageIndexSet) {
        const pageView = this._pages[i2];
        if (!pageView) {
          continue;
        }
        spread.append(pageView.div);
        state.pages.push(pageView);
      }
      viewer.append(spread);
    }
    state.scrollDown = pageNumber >= state.previousPageNumber;
    state.previousPageNumber = pageNumber;
  }
  _scrollUpdate() {
    if (this.pagesCount === 0) {
      return;
    }
    this.update();
  }
  #scrollIntoView(pageView, pageSpot = null) {
    const {
      div,
      id: id2
    } = pageView;
    if (this._currentPageNumber !== id2) {
      this._setCurrentPageNumber(id2);
    }
    if (this._scrollMode === ScrollMode.PAGE) {
      this.#ensurePageViewVisible();
      this.update();
    }
    if (!pageSpot && !this.isInPresentationMode) {
      const left = div.offsetLeft + div.clientLeft, right = left + div.clientWidth;
      const {
        scrollLeft,
        clientWidth
      } = this.container;
      if (this._scrollMode === ScrollMode.HORIZONTAL || left < scrollLeft || right > scrollLeft + clientWidth) {
        pageSpot = {
          left: 0,
          top: 0
        };
      }
    }
    scrollIntoView(div, pageSpot);
    if (!this._currentScaleValue && this._location) {
      this._location = null;
    }
  }
  #isSameScale(newScale) {
    return newScale === this._currentScale || Math.abs(newScale - this._currentScale) < 1e-15;
  }
  #setScaleUpdatePages(newScale, newValue, {
    noScroll = false,
    preset = false,
    drawingDelay = -1,
    origin = null
  }) {
    this._currentScaleValue = newValue.toString();
    if (this.#isSameScale(newScale)) {
      if (preset) {
        this.eventBus.dispatch("scalechanging", {
          source: this,
          scale: newScale,
          presetValue: newValue
        });
      }
      return;
    }
    this.viewer.style.setProperty("--scale-factor", newScale * PixelsPerInch2.PDF_TO_CSS_UNITS);
    const postponeDrawing = drawingDelay >= 0 && drawingDelay < 1e3;
    this.refresh(true, {
      scale: newScale,
      drawingDelay: postponeDrawing ? drawingDelay : -1
    });
    if (postponeDrawing) {
      this.#scaleTimeoutId = setTimeout(() => {
        this.#scaleTimeoutId = null;
        this.refresh();
      }, drawingDelay);
    }
    const previousScale = this._currentScale;
    this._currentScale = newScale;
    if (!noScroll) {
      let page = this._currentPageNumber, dest;
      if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode)) {
        page = this._location.pageNumber;
        dest = [null, {
          name: "XYZ"
        }, this._location.left, this._location.top, null];
      }
      this.scrollPageIntoView({
        pageNumber: page,
        destArray: dest,
        allowNegativeOffset: true
      });
      if (Array.isArray(origin)) {
        const scaleDiff = newScale / previousScale - 1;
        const [top, left] = this.containerTopLeft;
        this.container.scrollLeft += (origin[0] - left) * scaleDiff;
        this.container.scrollTop += (origin[1] - top) * scaleDiff;
      }
    }
    this.eventBus.dispatch("scalechanging", {
      source: this,
      scale: newScale,
      presetValue: preset ? newValue : void 0
    });
    if (this.defaultRenderingQueue) {
      this.update();
    }
  }
  get #pageWidthScaleFactor() {
    if (this._spreadMode !== SpreadMode.NONE && this._scrollMode !== ScrollMode.HORIZONTAL) {
      return 2;
    }
    return 1;
  }
  #setScale(value, options) {
    let scale = parseFloat(value);
    if (scale > 0) {
      options.preset = false;
      this.#setScaleUpdatePages(scale, value, options);
    } else {
      const currentPage = this._pages[this._currentPageNumber - 1];
      if (!currentPage) {
        return;
      }
      let hPadding = SCROLLBAR_PADDING, vPadding = VERTICAL_PADDING;
      if (this.isInPresentationMode) {
        hPadding = vPadding = 4;
        if (this._spreadMode !== SpreadMode.NONE) {
          hPadding *= 2;
        }
      } else if (this.removePageBorders) {
        hPadding = vPadding = 0;
      } else if (this._scrollMode === ScrollMode.HORIZONTAL) {
        [hPadding, vPadding] = [vPadding, hPadding];
      }
      const pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale / this.#pageWidthScaleFactor;
      const pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale;
      switch (value) {
        case "page-actual":
          scale = 1;
          break;
        case "page-width":
          scale = pageWidthScale;
          break;
        case "page-height":
          scale = pageHeightScale;
          break;
        case "page-fit":
          scale = Math.min(pageWidthScale, pageHeightScale);
          break;
        case "auto":
          const horizontalScale = isPortraitOrientation(currentPage) ? pageWidthScale : Math.min(pageHeightScale, pageWidthScale);
          scale = Math.min(MAX_AUTO_SCALE, horizontalScale);
          break;
        default:
          console.error(`#setScale: "${value}" is an unknown zoom value.`);
          return;
      }
      options.preset = true;
      this.#setScaleUpdatePages(scale, value, options);
    }
  }
  #resetCurrentPageView() {
    const pageView = this._pages[this._currentPageNumber - 1];
    if (this.isInPresentationMode) {
      this.#setScale(this._currentScaleValue, {
        noScroll: true
      });
    }
    this.#scrollIntoView(pageView);
  }
  pageLabelToPageNumber(label) {
    if (!this._pageLabels) {
      return null;
    }
    const i2 = this._pageLabels.indexOf(label);
    if (i2 < 0) {
      return null;
    }
    return i2 + 1;
  }
  scrollPageIntoView({
    pageNumber,
    destArray = null,
    allowNegativeOffset = false,
    ignoreDestinationZoom = false
  }) {
    if (!this.pdfDocument) {
      return;
    }
    const pageView = Number.isInteger(pageNumber) && this._pages[pageNumber - 1];
    if (!pageView) {
      console.error(`scrollPageIntoView: "${pageNumber}" is not a valid pageNumber parameter.`);
      return;
    }
    if (this.isInPresentationMode || !destArray) {
      this._setCurrentPageNumber(pageNumber, true);
      return;
    }
    let x2 = 0, y2 = 0;
    let width = 0, height = 0, widthScale, heightScale;
    const changeOrientation = pageView.rotation % 180 !== 0;
    const pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / PixelsPerInch2.PDF_TO_CSS_UNITS;
    const pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / PixelsPerInch2.PDF_TO_CSS_UNITS;
    let scale = 0;
    switch (destArray[1].name) {
      case "XYZ":
        x2 = destArray[2];
        y2 = destArray[3];
        scale = destArray[4];
        x2 = x2 !== null ? x2 : 0;
        y2 = y2 !== null ? y2 : pageHeight;
        break;
      case "Fit":
      case "FitB":
        scale = "page-fit";
        break;
      case "FitH":
      case "FitBH":
        y2 = destArray[2];
        scale = "page-width";
        if (y2 === null && this._location) {
          x2 = this._location.left;
          y2 = this._location.top;
        } else if (typeof y2 !== "number" || y2 < 0) {
          y2 = pageHeight;
        }
        break;
      case "FitV":
      case "FitBV":
        x2 = destArray[2];
        width = pageWidth;
        height = pageHeight;
        scale = "page-height";
        break;
      case "FitR":
        x2 = destArray[2];
        y2 = destArray[3];
        width = destArray[4] - x2;
        height = destArray[5] - y2;
        let hPadding = SCROLLBAR_PADDING, vPadding = VERTICAL_PADDING;
        if (this.removePageBorders) {
          hPadding = vPadding = 0;
        }
        widthScale = (this.container.clientWidth - hPadding) / width / PixelsPerInch2.PDF_TO_CSS_UNITS;
        heightScale = (this.container.clientHeight - vPadding) / height / PixelsPerInch2.PDF_TO_CSS_UNITS;
        scale = Math.min(Math.abs(widthScale), Math.abs(heightScale));
        break;
      default:
        console.error(`scrollPageIntoView: "${destArray[1].name}" is not a valid destination type.`);
        return;
    }
    if (!ignoreDestinationZoom) {
      if (scale && scale !== this._currentScale) {
        this.currentScaleValue = scale;
      } else if (this._currentScale === UNKNOWN_SCALE) {
        this.currentScaleValue = DEFAULT_SCALE_VALUE;
      }
    }
    if (scale === "page-fit" && !destArray[4]) {
      this.#scrollIntoView(pageView);
      return;
    }
    const boundingRect = [pageView.viewport.convertToViewportPoint(x2, y2), pageView.viewport.convertToViewportPoint(x2 + width, y2 + height)];
    let left = Math.min(boundingRect[0][0], boundingRect[1][0]);
    let top = Math.min(boundingRect[0][1], boundingRect[1][1]);
    if (!allowNegativeOffset) {
      left = Math.max(left, 0);
      top = Math.max(top, 0);
    }
    this.#scrollIntoView(pageView, {
      left,
      top
    });
  }
  _updateLocation(firstPage) {
    const currentScale = this._currentScale;
    const currentScaleValue = this._currentScaleValue;
    const normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 1e4) / 100 : currentScaleValue;
    const pageNumber = firstPage.id;
    const currentPageView = this._pages[pageNumber - 1];
    const container = this.container;
    const topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y);
    const intLeft = Math.round(topLeft[0]);
    const intTop = Math.round(topLeft[1]);
    let pdfOpenParams = `#page=${pageNumber}`;
    if (!this.isInPresentationMode) {
      pdfOpenParams += `&zoom=${normalizedScaleValue},${intLeft},${intTop}`;
    }
    this._location = {
      pageNumber,
      scale: normalizedScaleValue,
      top: intTop,
      left: intLeft,
      rotation: this._pagesRotation,
      pdfOpenParams
    };
  }
  update() {
    const visible = this._getVisiblePages();
    const visiblePages = visible.views, numVisiblePages = visiblePages.length;
    if (numVisiblePages === 0) {
      return;
    }
    const newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1);
    this.#buffer.resize(newCacheSize, visible.ids);
    this.renderingQueue.renderHighestPriority(visible);
    const isSimpleLayout = this._spreadMode === SpreadMode.NONE && (this._scrollMode === ScrollMode.PAGE || this._scrollMode === ScrollMode.VERTICAL);
    const currentId = this._currentPageNumber;
    let stillFullyVisible = false;
    for (const page of visiblePages) {
      if (page.percent < 100) {
        break;
      }
      if (page.id === currentId && isSimpleLayout) {
        stillFullyVisible = true;
        break;
      }
    }
    this._setCurrentPageNumber(stillFullyVisible ? currentId : visiblePages[0].id);
    this._updateLocation(visible.first);
    this.eventBus.dispatch("updateviewarea", {
      source: this,
      location: this._location
    });
  }
  containsElement(element) {
    return this.container.contains(element);
  }
  focus() {
    this.container.focus();
  }
  get _isContainerRtl() {
    return getComputedStyle(this.container).direction === "rtl";
  }
  get isInPresentationMode() {
    return this.presentationModeState === PresentationModeState.FULLSCREEN;
  }
  get isChangingPresentationMode() {
    return this.presentationModeState === PresentationModeState.CHANGING;
  }
  get isHorizontalScrollbarEnabled() {
    return this.isInPresentationMode ? false : this.container.scrollWidth > this.container.clientWidth;
  }
  get isVerticalScrollbarEnabled() {
    return this.isInPresentationMode ? false : this.container.scrollHeight > this.container.clientHeight;
  }
  _getVisiblePages() {
    const views = this._scrollMode === ScrollMode.PAGE ? this.#scrollModePageState.pages : this._pages, horizontal = this._scrollMode === ScrollMode.HORIZONTAL, rtl = horizontal && this._isContainerRtl;
    return getVisibleElements({
      scrollEl: this.container,
      views,
      sortByVisibility: true,
      horizontal,
      rtl
    });
  }
  cleanup() {
    for (const pageView of this._pages) {
      if (pageView.renderingState !== RenderingStates.FINISHED) {
        pageView.reset();
      }
    }
  }
  _cancelRendering() {
    for (const pageView of this._pages) {
      pageView.cancelRendering();
    }
  }
  async #ensurePdfPageLoaded(pageView) {
    if (pageView.pdfPage) {
      return pageView.pdfPage;
    }
    try {
      const pdfPage = await this.pdfDocument.getPage(pageView.id);
      if (!pageView.pdfPage) {
        pageView.setPdfPage(pdfPage);
      }
      return pdfPage;
    } catch (reason) {
      console.error("Unable to get page for page view", reason);
      return null;
    }
  }
  #getScrollAhead(visible) {
    if (visible.first?.id === 1) {
      return true;
    } else if (visible.last?.id === this.pagesCount) {
      return false;
    }
    switch (this._scrollMode) {
      case ScrollMode.PAGE:
        return this.#scrollModePageState.scrollDown;
      case ScrollMode.HORIZONTAL:
        return this.scroll.right;
    }
    return this.scroll.down;
  }
  forceRendering(currentlyVisiblePages) {
    const visiblePages = currentlyVisiblePages || this._getVisiblePages();
    const scrollAhead = this.#getScrollAhead(visiblePages);
    const preRenderExtra = this._spreadMode !== SpreadMode.NONE && this._scrollMode !== ScrollMode.HORIZONTAL;
    const pageView = this.renderingQueue.getHighestPriority(visiblePages, this._pages, scrollAhead, preRenderExtra);
    if (pageView) {
      this.#ensurePdfPageLoaded(pageView).then(() => {
        this.renderingQueue.renderView(pageView);
      });
      return true;
    }
    return false;
  }
  get hasEqualPageSizes() {
    const firstPageView = this._pages[0];
    for (let i2 = 1, ii = this._pages.length; i2 < ii; ++i2) {
      const pageView = this._pages[i2];
      if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) {
        return false;
      }
    }
    return true;
  }
  getPagesOverview() {
    let initialOrientation;
    return this._pages.map((pageView) => {
      const viewport = pageView.pdfPage.getViewport({
        scale: 1
      });
      const orientation = isPortraitOrientation(viewport);
      if (initialOrientation === void 0) {
        initialOrientation = orientation;
      } else if (this.enablePrintAutoRotate && orientation !== initialOrientation) {
        return {
          width: viewport.height,
          height: viewport.width,
          rotation: (viewport.rotation - 90) % 360
        };
      }
      return {
        width: viewport.width,
        height: viewport.height,
        rotation: viewport.rotation
      };
    });
  }
  get optionalContentConfigPromise() {
    if (!this.pdfDocument) {
      return Promise.resolve(null);
    }
    if (!this._optionalContentConfigPromise) {
      console.error("optionalContentConfigPromise: Not initialized yet.");
      return this.pdfDocument.getOptionalContentConfig({
        intent: "display"
      });
    }
    return this._optionalContentConfigPromise;
  }
  set optionalContentConfigPromise(promise) {
    if (!(promise instanceof Promise)) {
      throw new Error(`Invalid optionalContentConfigPromise: ${promise}`);
    }
    if (!this.pdfDocument) {
      return;
    }
    if (!this._optionalContentConfigPromise) {
      return;
    }
    this._optionalContentConfigPromise = promise;
    this.refresh(false, {
      optionalContentConfigPromise: promise
    });
    this.eventBus.dispatch("optionalcontentconfigchanged", {
      source: this,
      promise
    });
  }
  get scrollMode() {
    return this._scrollMode;
  }
  set scrollMode(mode) {
    if (this._scrollMode === mode) {
      return;
    }
    if (!isValidScrollMode(mode)) {
      throw new Error(`Invalid scroll mode: ${mode}`);
    }
    if (this.pagesCount > PagesCountLimit.FORCE_SCROLL_MODE_PAGE) {
      return;
    }
    this._previousScrollMode = this._scrollMode;
    this._scrollMode = mode;
    this.eventBus.dispatch("scrollmodechanged", {
      source: this,
      mode
    });
    this._updateScrollMode(this._currentPageNumber);
  }
  _updateScrollMode(pageNumber = null) {
    const scrollMode = this._scrollMode, viewer = this.viewer;
    viewer.classList.toggle("scrollHorizontal", scrollMode === ScrollMode.HORIZONTAL);
    viewer.classList.toggle("scrollWrapped", scrollMode === ScrollMode.WRAPPED);
    if (!this.pdfDocument || !pageNumber) {
      return;
    }
    if (scrollMode === ScrollMode.PAGE) {
      this.#ensurePageViewVisible();
    } else if (this._previousScrollMode === ScrollMode.PAGE) {
      this._updateSpreadMode();
    }
    if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
      this.#setScale(this._currentScaleValue, {
        noScroll: true
      });
    }
    this._setCurrentPageNumber(pageNumber, true);
    this.update();
  }
  get spreadMode() {
    return this._spreadMode;
  }
  set spreadMode(mode) {
    if (this._spreadMode === mode) {
      return;
    }
    if (!isValidSpreadMode(mode)) {
      throw new Error(`Invalid spread mode: ${mode}`);
    }
    this._spreadMode = mode;
    this.eventBus.dispatch("spreadmodechanged", {
      source: this,
      mode
    });
    this._updateSpreadMode(this._currentPageNumber);
  }
  _updateSpreadMode(pageNumber = null) {
    if (!this.pdfDocument) {
      return;
    }
    const viewer = this.viewer, pages = this._pages;
    if (this._scrollMode === ScrollMode.PAGE) {
      this.#ensurePageViewVisible();
    } else {
      viewer.textContent = "";
      if (this._spreadMode === SpreadMode.NONE) {
        for (const pageView of this._pages) {
          viewer.append(pageView.div);
        }
      } else {
        const parity = this._spreadMode - 1;
        let spread = null;
        for (let i2 = 0, ii = pages.length; i2 < ii; ++i2) {
          if (spread === null) {
            spread = document.createElement("div");
            spread.className = "spread";
            viewer.append(spread);
          } else if (i2 % 2 === parity) {
            spread = spread.cloneNode(false);
            viewer.append(spread);
          }
          spread.append(pages[i2].div);
        }
      }
    }
    if (!pageNumber) {
      return;
    }
    if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
      this.#setScale(this._currentScaleValue, {
        noScroll: true
      });
    }
    this._setCurrentPageNumber(pageNumber, true);
    this.update();
  }
  _getPageAdvance(currentPageNumber, previous = false) {
    switch (this._scrollMode) {
      case ScrollMode.WRAPPED: {
        const {
          views
        } = this._getVisiblePages(), pageLayout = /* @__PURE__ */ new Map();
        for (const {
          id: id2,
          y: y2,
          percent,
          widthPercent
        } of views) {
          if (percent === 0 || widthPercent < 100) {
            continue;
          }
          let yArray = pageLayout.get(y2);
          if (!yArray) {
            pageLayout.set(y2, yArray ||= []);
          }
          yArray.push(id2);
        }
        for (const yArray of pageLayout.values()) {
          const currentIndex = yArray.indexOf(currentPageNumber);
          if (currentIndex === -1) {
            continue;
          }
          const numPages = yArray.length;
          if (numPages === 1) {
            break;
          }
          if (previous) {
            for (let i2 = currentIndex - 1, ii = 0; i2 >= ii; i2--) {
              const currentId = yArray[i2], expectedId = yArray[i2 + 1] - 1;
              if (currentId < expectedId) {
                return currentPageNumber - expectedId;
              }
            }
          } else {
            for (let i2 = currentIndex + 1, ii = numPages; i2 < ii; i2++) {
              const currentId = yArray[i2], expectedId = yArray[i2 - 1] + 1;
              if (currentId > expectedId) {
                return expectedId - currentPageNumber;
              }
            }
          }
          if (previous) {
            const firstId = yArray[0];
            if (firstId < currentPageNumber) {
              return currentPageNumber - firstId + 1;
            }
          } else {
            const lastId = yArray[numPages - 1];
            if (lastId > currentPageNumber) {
              return lastId - currentPageNumber + 1;
            }
          }
          break;
        }
        break;
      }
      case ScrollMode.HORIZONTAL: {
        break;
      }
      case ScrollMode.PAGE:
      case ScrollMode.VERTICAL: {
        if (this._spreadMode === SpreadMode.NONE) {
          break;
        }
        const parity = this._spreadMode - 1;
        if (previous && currentPageNumber % 2 !== parity) {
          break;
        } else if (!previous && currentPageNumber % 2 === parity) {
          break;
        }
        const {
          views
        } = this._getVisiblePages(), expectedId = previous ? currentPageNumber - 1 : currentPageNumber + 1;
        for (const {
          id: id2,
          percent,
          widthPercent
        } of views) {
          if (id2 !== expectedId) {
            continue;
          }
          if (percent > 0 && widthPercent === 100) {
            return 2;
          }
          break;
        }
        break;
      }
    }
    return 1;
  }
  nextPage() {
    const currentPageNumber = this._currentPageNumber, pagesCount = this.pagesCount;
    if (currentPageNumber >= pagesCount) {
      return false;
    }
    const advance = this._getPageAdvance(currentPageNumber, false) || 1;
    this.currentPageNumber = Math.min(currentPageNumber + advance, pagesCount);
    return true;
  }
  previousPage() {
    const currentPageNumber = this._currentPageNumber;
    if (currentPageNumber <= 1) {
      return false;
    }
    const advance = this._getPageAdvance(currentPageNumber, true) || 1;
    this.currentPageNumber = Math.max(currentPageNumber - advance, 1);
    return true;
  }
  updateScale({
    drawingDelay,
    scaleFactor = null,
    steps = null,
    origin
  }) {
    if (steps === null && scaleFactor === null) {
      throw new Error("Invalid updateScale options: either `steps` or `scaleFactor` must be provided.");
    }
    if (!this.pdfDocument) {
      return;
    }
    let newScale = this._currentScale;
    if (scaleFactor > 0 && scaleFactor !== 1) {
      newScale = Math.round(newScale * scaleFactor * 100) / 100;
    } else if (steps) {
      const delta = steps > 0 ? DEFAULT_SCALE_DELTA : 1 / DEFAULT_SCALE_DELTA;
      const round = steps > 0 ? Math.ceil : Math.floor;
      steps = Math.abs(steps);
      do {
        newScale = round((newScale * delta).toFixed(2) * 10) / 10;
      } while (--steps > 0);
    }
    newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
    this.#setScale(newScale, {
      noScroll: false,
      drawingDelay,
      origin
    });
  }
  increaseScale(options = {}) {
    this.updateScale({
      ...options,
      steps: options.steps ?? 1
    });
  }
  decreaseScale(options = {}) {
    this.updateScale({
      ...options,
      steps: -(options.steps ?? 1)
    });
  }
  #updateContainerHeightCss(height = this.container.clientHeight) {
    if (height !== this.#previousContainerHeight) {
      this.#previousContainerHeight = height;
      docStyle.setProperty("--viewer-container-height", `${height}px`);
    }
  }
  #resizeObserverCallback(entries) {
    for (const entry of entries) {
      if (entry.target === this.container) {
        this.#updateContainerHeightCss(Math.floor(entry.borderBoxSize[0].blockSize));
        this.#containerTopLeft = null;
        break;
      }
    }
  }
  get containerTopLeft() {
    return this.#containerTopLeft ||= [this.container.offsetTop, this.container.offsetLeft];
  }
  get annotationEditorMode() {
    return this.#annotationEditorUIManager ? this.#annotationEditorMode : AnnotationEditorType.DISABLE;
  }
  set annotationEditorMode({
    mode,
    editId = null,
    isFromKeyboard = false
  }) {
    if (!this.#annotationEditorUIManager) {
      throw new Error(`The AnnotationEditor is not enabled.`);
    }
    if (this.#annotationEditorMode === mode) {
      return;
    }
    if (!isValidAnnotationEditorMode(mode)) {
      throw new Error(`Invalid AnnotationEditor mode: ${mode}`);
    }
    if (!this.pdfDocument) {
      return;
    }
    this.#annotationEditorMode = mode;
    this.eventBus.dispatch("annotationeditormodechanged", {
      source: this,
      mode
    });
    this.#annotationEditorUIManager.updateMode(mode, editId, isFromKeyboard);
  }
  set annotationEditorParams({
    type,
    value
  }) {
    if (!this.#annotationEditorUIManager) {
      throw new Error(`The AnnotationEditor is not enabled.`);
    }
    this.#annotationEditorUIManager.updateParams(type, value);
  }
  refresh(noUpdate = false, updateArgs = /* @__PURE__ */ Object.create(null)) {
    if (!this.pdfDocument) {
      return;
    }
    for (const pageView of this._pages) {
      pageView.update(updateArgs);
    }
    if (this.#scaleTimeoutId !== null) {
      clearTimeout(this.#scaleTimeoutId);
      this.#scaleTimeoutId = null;
    }
    if (!noUpdate) {
      this.update();
    }
  }
}
class PDFSinglePageViewer extends PDFViewer {
  _resetView() {
    super._resetView();
    this._scrollMode = ScrollMode.PAGE;
    this._spreadMode = SpreadMode.NONE;
  }
  set scrollMode(mode) {
  }
  _updateScrollMode() {
  }
  set spreadMode(mode) {
  }
  _updateSpreadMode() {
  }
}
__webpack_exports__.AnnotationLayerBuilder;
__webpack_exports__.DownloadManager;
var __webpack_exports__EventBus = __webpack_exports__.EventBus;
__webpack_exports__.FindState;
var __webpack_exports__GenericL10n = __webpack_exports__.GenericL10n;
__webpack_exports__.LinkTarget;
var __webpack_exports__PDFFindController = __webpack_exports__.PDFFindController;
__webpack_exports__.PDFHistory;
var __webpack_exports__PDFLinkService = __webpack_exports__.PDFLinkService;
__webpack_exports__.PDFPageView;
__webpack_exports__.PDFScriptingManager;
__webpack_exports__.PDFSinglePageViewer;
var __webpack_exports__PDFViewer = __webpack_exports__.PDFViewer;
__webpack_exports__.ProgressBar;
__webpack_exports__.RenderingStates;
__webpack_exports__.ScrollMode;
__webpack_exports__.SimpleLinkService;
__webpack_exports__.SpreadMode;
__webpack_exports__.StructTreeLayerBuilder;
__webpack_exports__.TextLayerBuilder;
__webpack_exports__.XfaLayerBuilder;
__webpack_exports__.parseQueryString;
__webpack_exports__GlobalWorkerOptions.workerSrc = new URL("" + new URL("pdf.worker-Bb9YoAiU.mjs", import.meta.url).href, import.meta.url).href;
class PDFTool {
  pdfViewer = null;
  // pdf 
  pdfDocument = null;
  bookId = null;
  async render(content, bookId) {
    this.bookId = bookId;
    return new Promise(async (resolve2, reject) => {
      try {
        const container = $(`#viewerContainer`);
        const eventBus = new __webpack_exports__EventBus();
        const linkService = new __webpack_exports__PDFLinkService({ eventBus });
        const findController = new __webpack_exports__PDFFindController({ eventBus, linkService });
        const l10n = new __webpack_exports__GenericL10n("zh-CN");
        const view = new __webpack_exports__PDFViewer({
          container,
          eventBus,
          linkService,
          findController,
          l10n
        });
        view.currentScale = settingStore.value.pdfScale;
        linkService.setViewer(view);
        const loadingTask = __webpack_exports__getDocument(content);
        const pdfDocument = await loadingTask.promise;
        view.setDocument(pdfDocument);
        linkService.setDocument(pdfDocument, null);
        this.pdfViewer = view;
        this.pdfDocument = pdfDocument;
        eventBus.on("textlayerrendered", (value) => {
          this.drawHighlight(value.pageNumber.toString());
        });
        eventBus.on("pagesloaded", () => {
          view.currentScaleValue = "auto";
          setSpreadMode(settingStore.value.readMode);
          resolve2("");
        });
      } catch (error) {
        reject(error);
      }
    });
  }
  async getOutline() {
    const outline = await this.pdfDocument?.getOutline() || [];
    const result = outline.map(this.makeTOCItem);
    await this.handleToc(result);
    return result;
  }
  async pageJump(pageNumber, id2) {
    this.pdfViewer.scrollPageIntoView({ pageNumber });
    if (id2) {
      const target = getSourceTarget(pageNumber, id2);
      console.log(target);
      if (!target)
        return;
      target.scrollIntoView();
    }
    return;
  }
  async drawHighlight(page) {
    try {
      if (!this.bookId)
        return;
      const notes = await NoteAction.findBookPageNotes(this.bookId, page);
      const domSource = notes.map((note2) => NoteAction.noteToDomSource(note2));
      highlighter?.fromSource(domSource);
    } catch (err) {
      console.log(err);
    }
  }
  getCurrentPageNumber() {
    return this.pdfViewer?.currentPageNumber;
  }
  // 
  setSpreadMode(mode) {
    if (this.pdfViewer) {
      this.pdfViewer.spreadMode = mode;
    }
  }
  resize() {
    const pdfViewer = this.pdfViewer;
    if (!pdfViewer)
      return;
    const currentScaleValue = pdfViewer.currentScaleValue;
    if (currentScaleValue === "auto" || currentScaleValue === "page-fit" || currentScaleValue === "page-width") {
      pdfViewer.currentScaleValue = currentScaleValue;
    }
    pdfViewer.update();
  }
  setScale(val) {
    const pdfViewer = this.pdfViewer;
    if (!pdfViewer)
      return;
    pdfViewer.currentScaleValue = val;
  }
  zoomIn() {
    this.updateZoom(1);
    return this.pdfViewer?.currentScale || 1;
  }
  zoomOut() {
    this.updateZoom(-1);
    return this.pdfViewer?.currentScale || 1;
  }
  async resolveHref(href) {
    const parsed = JSON.parse(href);
    const pdf2 = this.pdfDocument;
    const dest = typeof parsed === "string" ? await pdf2.getDestination(parsed) : parsed;
    const index = await pdf2.getPageIndex(dest[0]);
    return { index };
  }
  destroy() {
    this.pdfDocument?.destroy();
    this.pdfViewer = null;
    this.pdfDocument = null;
  }
  finishRender() {
    return new Promise((resovle) => {
      this.pdfViewer.eventBus.on("textlayerrendered", () => {
        console.log("================");
        resovle("ok");
      });
    });
  }
  async spreadMode() {
  }
  async handleToc(toc) {
    const list = [];
    const eachToc = (data2) => {
      data2.forEach((item) => {
        list.push(item);
        if (Array.isArray(item.subitems)) {
          eachToc(item.subitems);
        }
      });
    };
    eachToc(toc);
    await Promise.all(
      list.map(async (item) => {
        const res = await this.resolveHref(item.href);
        item.page = res.index + 1;
      })
    );
    for (let i2 = 0; i2 < list.length; i2++) {
      const currunt = list[i2];
      const next = list[i2 + 1];
      if (next) {
        currunt.nextPage = next.page;
      } else {
        currunt.nextPage = this.pdfDocument.numPages + 1;
      }
    }
  }
  makeTOCItem = (item) => ({
    label: item.title,
    href: JSON.stringify(item.dest),
    subitems: item.items.length ? item.items.map(this.makeTOCItem) : null
  });
  updateZoom(steps) {
    const pdfViewer = this.pdfViewer;
    if (!pdfViewer)
      return;
    if (pdfViewer.isInPresentationMode) {
      return;
    }
    pdfViewer.updateScale({
      drawingDelay: { value: 400, kind: 2 + 128 },
      steps,
      scaleFactor: void 0,
      originL: void 0
    });
  }
}
const PDF = new PDFTool();
function setSpreadMode(mode) {
  if (mode === ReadMode.sroll) {
    PDF.setSpreadMode(0);
  } else if (mode === ReadMode.section) {
    PDF.setSpreadMode(2);
  } else if (mode === ReadMode.double) {
    PDF.setSpreadMode(1);
  } else {
    PDF.setSpreadMode(0);
  }
}
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "ReadView",
  props: {
    isScrollLocked: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const PDFContainerRef = ref(null);
    const contentRef = ref(null);
    const bookPageStore = useBookPageStore();
    useResizeObserver(PDFContainerRef, () => PDF.resize());
    watchEffect(async () => {
      setSpreadMode(settingStore.value.readMode);
    });
    onUnmounted(() => PDF.destroy());
    const getScrollData = () => {
      const dom = PDFContainerRef.value;
      const { height } = dom.getBoundingClientRect();
      return { dom, height, scrollTop: dom.scrollTop };
    };
    const prewView = useThrottleFn(() => {
      if (props.isScrollLocked)
        return;
      if (!get(PDFContainerRef))
        return;
      const { dom, height, scrollTop } = getScrollData();
      toPrewView(dom, scrollTop, height);
    }, 300);
    const { height: totalHeight } = useElementSize(contentRef);
    const nextView = useThrottleFn(() => {
      if (props.isScrollLocked)
        return;
      if (!get(PDFContainerRef))
        return;
      const { dom, height, scrollTop } = getScrollData();
      toNextView(dom, scrollTop, height, get(totalHeight));
    }, 300);
    onKeyStroke(["ArrowRight"], nextView);
    onKeyStroke(["ArrowLeft"], prewView);
    const scroll = useDebounceFn(() => {
      const page = PDF.getCurrentPageNumber();
      bookPageStore.setPage(page);
    }, 200);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        id: "viewerContainer",
        ref_key: "PDFContainerRef",
        ref: PDFContainerRef,
        class: "h-full w-full bg-base-200 absolute overflow-auto scroll-smooth scrollbar-thin",
        onScroll: _cache[0] || (_cache[0] = //@ts-ignore
        (...args) => unref(scroll) && unref(scroll)(...args))
      }, [
        createBaseVNode("div", {
          ref_key: "contentRef",
          ref: contentRef,
          id: "viewer",
          class: "pdfViewer scrollWrapped"
        }, null, 512)
      ], 544);
    };
  }
});
const _hoisted_1$4 = { class: "p-2 mt-2 dropdown-content z-[10] w-full overflow-auto border border-accent rounded-md menu flex-nowrap bg-base-100 shadow-2xl gap-1 scrollbar-thin" };
const _hoisted_2$3 = ["onClick"];
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "Toobar",
  setup(__props) {
    const detailsRef = ref(null);
    const summaryRef = ref(null);
    const containerRef = ref(null);
    const state = useStorage(
      "__book__wise_pdf_zoom",
      "auto",
      localStorage,
      { mergeDefaults: true }
    );
    const list = computed(() => {
      return [
        { id: "auto", value: t$2("pdf.auto") },
        { id: "page-actual", value: t$2("pdf.pageActual") },
        { id: "page-fit", value: t$2("pdf.pageFit") },
        { id: "page-width", value: t$2("pdf.pageWidth") },
        { id: "50%", value: "50%" },
        { id: "75%", value: "75%" },
        { id: "100%", value: "100%" },
        { id: "125%", value: "125%" },
        { id: "150%", value: "150%" },
        { id: "200%", value: "200%" },
        { id: "300%", value: "300%" },
        { id: "400%", value: "400%" }
      ];
    });
    const value = computed(() => list.value.find((item) => item.id === state.value)?.value ?? state.value);
    const onCloce = () => {
      if (detailsRef.value && detailsRef.value.open) {
        detailsRef.value.open = false;
      }
    };
    const onClick = (id2) => {
      if (id2 === "auto") {
        PDF.setScale("auto");
      } else if (id2 === "page-actual") {
        PDF.setScale("page-actual");
      } else if (id2 === "page-fit") {
        PDF.setScale("page-fit");
      } else if (id2 === "page-width") {
        PDF.setScale("page-width");
      } else {
        PDF.setScale(+id2.replace("%", "") / 100);
      }
      onCloce();
      set$1(state, id2);
    };
    const add2 = () => {
      const val = PDF.zoomIn();
      set$1(state, (val * 100).toFixed(0) + "%");
    };
    const minus = () => {
      const val = PDF.zoomOut();
      set$1(state, (val * 100).toFixed(0) + "%");
    };
    onClickOutside$1(containerRef, onCloce);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "join",
        ref_key: "containerRef",
        ref: containerRef
      }, [
        createBaseVNode("button", {
          class: "btn btn-sm btn-ghost",
          onClick: minus
        }, [
          createVNode(unref(Minus))
        ]),
        createBaseVNode("details", {
          class: "dropdown dropdown-bottom",
          ref_key: "detailsRef",
          ref: detailsRef
        }, [
          createBaseVNode("summary", {
            ref_key: "summaryRef",
            ref: summaryRef,
            class: "cursor-pointer select select-bordered select-sm w-44 items-center"
          }, toDisplayString$1(value.value), 513),
          createBaseVNode("ul", _hoisted_1$4, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(list.value, (item) => {
              return openBlock(), createElementBlock("li", {
                key: item.value,
                onClick: ($event) => onClick(item.id),
                class: "text-base-content"
              }, [
                createBaseVNode("a", {
                  class: normalizeClass({ "active": unref(state) === item.id })
                }, toDisplayString$1(item.value), 3)
              ], 8, _hoisted_2$3);
            }), 128))
          ])
        ], 512),
        createBaseVNode("button", {
          class: "btn btn-sm btn-ghost",
          onClick: add2
        }, [
          createVNode(unref(Plus))
        ])
      ], 512);
    };
  }
});
const _withScopeId = (n2) => (pushScopeId("data-v-bee056a4"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$3 = { class: "fixed inset-0 transition ease-in-out" };
const _hoisted_2$2 = { class: "card-body" };
const _hoisted_3$2 = { class: "flex flex-row justify-between items-center mb-2" };
const _hoisted_4$2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("h3", { class: "font-bold text-lg" }, "", -1));
const _hoisted_5$2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("kbd", { class: "kbd" }, "Esc", -1));
const _hoisted_6$2 = [
  _hoisted_5$2
];
const _hoisted_7$2 = { class: "card-actions justify-end" };
const _hoisted_8$2 = {
  key: 0,
  class: "loading loading-spinner"
};
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "NoteRich",
  setup(__props) {
    const parentEl = useParentElement();
    const cardRef = ref(null);
    const textareatRef = ref(null);
    const textareaValue = ref("");
    onClickOutside$1(cardRef, () => {
      closeNoteRich();
    });
    onKeyStroke("Escape", () => {
      closeNoteRich();
    });
    const [loading, setLoading] = useToggle(false);
    const [submitLoading, setSubmitLoading] = useToggle(false);
    const { width, left } = useElementBounding(parentEl);
    const bookParam = useRouteParams("id");
    const noteRichAction = new NoteRichAction(bookParam, textareaValue);
    const style2 = computed(() => {
      const w2 = width.value;
      const l2 = left.value;
      const isLG = w2 > 180;
      const padding = 80;
      const _width = isLG ? w2 - padding * 2 : w2;
      const _left = isLG ? l2 + padding : l2;
      return { width: `${_width}px`, left: `${_left}px` };
    });
    const source = NoteBarStyle.source;
    const noteList = noteRichAction.notes;
    const tags = ref([]);
    let note2 = void 0;
    function closeNoteRich() {
      if (!NoteBarStyle.isPainted) {
        if (get(source).length) {
          highlighter.remove(get(source)[0].id);
        }
      }
      NoteBarStyle.close();
    }
    async function init() {
      try {
        setLoading(true);
        if (!NoteBarStyle.isPainted) {
          return;
        }
        const domSource = get(source);
        if (domSource.length === 0)
          return;
        note2 = await NoteAction.findBySourceId(domSource[0].id);
        if (!note2) {
          toastError("");
          NoteBarStyle.close();
        } else {
          set$1(tags, TagAction.toTag(note2.tag));
          noteRichAction.setNotes(note2);
        }
      } catch (err) {
        toastError(`${err}`);
      } finally {
        setLoading(false);
      }
    }
    async function submit() {
      const value = get(textareaValue);
      if (!value && get(tags).length === 0) {
        toastWarning("");
        return;
      }
      try {
        if (get(submitLoading))
          return;
        setSubmitLoading(true);
        if (NoteBarStyle.isPainted) {
          await noteRichAction.addInNoNotes(get(tags));
        } else {
          await noteRichAction.firstAdd(get(source), get(tags));
        }
      } catch (error) {
        console.log(error);
      } finally {
        setSubmitLoading(false);
        NoteBarStyle.close();
      }
    }
    async function remove2(_2, index) {
      noteRichAction.remove(index);
    }
    onMounted(() => {
      textareatRef.value?.focus();
    });
    init();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        createBaseVNode("div", {
          class: "card w-96 bg-base-100 border border-primary absolute bottom-8 cursor-pointer bar-shadow select-none max-h-full overflow-auto",
          style: normalizeStyle(style2.value),
          ref_key: "cardRef",
          ref: cardRef
        }, [
          createBaseVNode("div", _hoisted_2$2, [
            createBaseVNode("div", _hoisted_3$2, [
              _hoisted_4$2,
              createBaseVNode("div", {
                onClick: _cache[0] || (_cache[0] = ($event) => closeNoteRich())
              }, _hoisted_6$2)
            ]),
            unref(loading) ? (openBlock(), createBlock(unref(SkeletonView), { key: 0 })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createVNode(_sfc_main$b, { data: unref(source) }, null, 8, ["data"]),
              createVNode(_sfc_main$c, {
                "class-name": "rounded-md",
                data: unref(noteList),
                onRemove: remove2
              }, null, 8, ["data"]),
              withDirectives(createBaseVNode("textarea", {
                ref_key: "textareatRef",
                ref: textareatRef,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => textareaValue.value = $event),
                rows: "6",
                class: "textarea textarea-accent w-full bg-base-200 my-3 rounded-lg",
                placeholder: "..."
              }, null, 512), [
                [vModelText, textareaValue.value]
              ]),
              createBaseVNode("div", null, [
                createVNode(unref(_sfc_main$p), {
                  modelValue: tags.value,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => tags.value = $event)
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_7$2, [
                createBaseVNode("button", {
                  class: "btn btn-success",
                  onClick: submit
                }, [
                  unref(submitLoading) ? (openBlock(), createElementBlock("span", _hoisted_8$2)) : createCommentVNode("", true),
                  createTextVNode(" ")
                ])
              ])
            ], 64))
          ])
        ], 4)
      ]);
    };
  }
});
const NoteRichView = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-bee056a4"]]);
const _hoisted_1$2 = { class: "fixed inset-0" };
const _hoisted_2$1 = { class: "flex flex-row justify-between items-center" };
const _hoisted_3$1 = { class: "flex flex-row gap-3 cursor-pointer p-2.5" };
const _hoisted_4$1 = ["onClick"];
const _hoisted_5$1 = { class: "flex pr-2.5" };
const _hoisted_6$1 = ["data-tip"];
const _hoisted_7$1 = ["checked"];
const _hoisted_8$1 = { class: "menu menu-horizontal p-1 m-0" };
const _hoisted_9$1 = ["onClick", "data-tip"];
const _hoisted_10$1 = ["data-tip"];
const _hoisted_11$1 = {
  key: 0,
  class: "p-2 bg-base-200 flex flex-wrap flex-row gap-2",
  style: { "--tw-bg-opacity": 0.5 }
};
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "Toolbar",
  setup(__props) {
    const container = ref(null);
    const { width, height } = useElementSize(container);
    const style2 = computed(() => {
      const { top, left } = ToolbarStyle.style;
      const _top = top - height.value - 10;
      return { top: `${top === 0 ? -1e3 : _top > 0 ? _top : 0}px`, left: `${left - width.value / 2}px` };
    });
    const isEdite = ToolbarStyle.isEdite;
    const bookParam = useRouteParams("id");
    const noteToolBar = new NoteToolBarAction(ToolbarStyle.source, isEdite, bookParam);
    const activeTextDecoration = noteToolBar.decoration;
    const activeColor = noteToolBar.color;
    const closeDom = (val, e2) => {
      const dom = get(val);
      if (dom && dom.contains(e2.target))
        return;
      ToolbarStyle.close();
    };
    onClickOutside$1(container, (e2) => {
      closeDom(noteRef, e2);
    });
    const tags = ref([]);
    const removeTag = async (index) => {
      tags.value.splice(index, 1);
      const tag2 = TagAction.toJSON(get(tags));
      await NoteAction.update(get(note2).id, { tag: tag2 });
      toastSuccess(t$2("tag.removeTagSuccess"));
    };
    const note2 = ref();
    const noteRef = ref(null);
    const noteList = ref([]);
    const { height: noteHeight } = useElementSize(noteRef);
    const noteStyle = computed(() => {
      const top = +get(style2).top.replace("px", "");
      const space = 10;
      const h2 = get(noteHeight);
      const source = ToolbarStyle.source;
      if (!source.length)
        return { top: "0px", left: "0px" };
      const content = getSectionContainer(source[0].page);
      if (!content)
        return { top: "0px", left: "0px" };
      const { left: cLeft } = content.getBoundingClientRect();
      const w2 = content.offsetWidth;
      if (top >= h2 + space) {
        return { top: `${top - space - h2}px`, left: `${cLeft}px`, width: `${w2}px` };
      } else {
        return { bottom: "20px", left: `${cLeft}px`, width: `${w2}px` };
      }
    });
    const findNote = async () => {
      if (get(isEdite) && ToolbarStyle.source.length) {
        const val = await NoteAction.findBySourceId(ToolbarStyle.source[0].id);
        if (val) {
          set$1(tags, TagAction.toTag(val.tag));
          set$1(note2, val);
          set$1(noteList, NoteAction.getNoteText(val.notes));
        }
      }
    };
    const removeNote = async (_2, index) => {
      noteList.value.splice(index, 1);
      await NoteAction.update(get(note2).id, { notes: JSON.stringify(get(noteList)) });
      toastSuccess(t$2("note.removeSuccess"));
    };
    onClickOutside$1(noteRef, (e2) => {
      closeDom(container, e2);
    });
    findNote();
    const openNoteRich = () => {
      if (!get(isEdite)) {
        const source = ToolbarStyle.source.map((item) => {
          return { ...item, className: "selection-info" };
        });
        highlighter?.fromSource(source);
      }
      NoteBarStyle.open(ToolbarStyle.source, get(isEdite));
      ToolbarStyle.close();
    };
    const list = computed(() => {
      return [
        { name: t$2("common.copy"), icon: Copy, click: () => noteToolBar.copySource(), active: "copy" },
        { name: t$2("line.marker"), icon: Highlighter, click: () => noteToolBar.marker(), active: HighlightType.marker },
        { name: t$2("line.beeline"), icon: Baseline, click: () => noteToolBar.beeline(), active: HighlightType.beeline },
        { name: t$2("line.wavy"), icon: SpellCheck2, click: () => noteToolBar.wavy(), active: HighlightType.wavy },
        { name: t$2("note.write"), icon: MessageSquareMore, click: openNoteRich, active: "note" }
      ];
    });
    const onRemove = () => {
      noteToolBar.remove();
      ToolbarStyle.close();
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$2, [
        createBaseVNode("div", {
          ref_key: "container",
          ref: container,
          class: "absolute bg-base-100 border border-info z-50 bar-shadow rounded-md flex flex-col divide-y ease-in-out shadow-cyan-500/50",
          style: normalizeStyle(style2.value),
          onClick: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["stop"]))
        }, [
          createBaseVNode("div", _hoisted_2$1, [
            createBaseVNode("div", _hoisted_3$1, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(highlightColor).getColors(), (item) => {
                return openBlock(), createElementBlock("div", {
                  class: normalizeClass(["badge badge-lg", unref(highlightColor).getBadgeColor(item)]),
                  onClick: ($event) => unref(noteToolBar).changeColor(item),
                  key: item
                }, toDisplayString$1(item === unref(activeColor) ? "" : ""), 11, _hoisted_4$1);
              }), 128))
            ]),
            createBaseVNode("div", _hoisted_5$1, [
              createBaseVNode("div", {
                class: "tooltip flex",
                "data-tip": unref(t$2)("setting.autoHighlight")
              }, [
                withDirectives(createBaseVNode("input", {
                  type: "checkbox",
                  class: "toggle toggle-sm toggle-success",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(settingStore).isAutoHighlight = $event),
                  checked: unref(settingStore).isAutoHighlight
                }, null, 8, _hoisted_7$1), [
                  [vModelCheckbox, unref(settingStore).isAutoHighlight]
                ])
              ], 8, _hoisted_6$1)
            ])
          ]),
          createBaseVNode("ul", _hoisted_8$1, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(list.value, (item) => {
              return openBlock(), createElementBlock("li", {
                onClick: withModifiers(item.click, ["stop"]),
                key: item.name,
                class: "tooltip",
                "data-tip": item.name
              }, [
                createBaseVNode("a", {
                  class: normalizeClass({ active: item.active === unref(activeTextDecoration) })
                }, [
                  (openBlock(), createBlock(resolveDynamicComponent(item.icon)))
                ], 2)
              ], 8, _hoisted_9$1);
            }), 128)),
            unref(isEdite) ? (openBlock(), createElementBlock("li", {
              key: 0,
              onClick: _cache[1] || (_cache[1] = withModifiers(($event) => onRemove(), ["stop"])),
              class: "tooltip",
              "data-tip": unref(t$2)("common.remove")
            }, [
              createBaseVNode("a", null, [
                createVNode(unref(Trash))
              ])
            ], 8, _hoisted_10$1)) : createCommentVNode("", true)
          ])
        ], 4),
        noteList.value.length ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref_key: "noteRef",
          ref: noteRef,
          class: "absolute bg-base-100 border border-info bar-shadow rounded-md flex flex-col ease-in-out divide-y",
          onClick: _cache[3] || (_cache[3] = withModifiers(() => {
          }, ["stop"])),
          style: normalizeStyle(noteStyle.value)
        }, [
          createVNode(_sfc_main$c, {
            "class-name": "rounded-md",
            data: noteList.value,
            onRemove: removeNote
          }, null, 8, ["data"]),
          tags.value.length ? (openBlock(), createElementBlock("div", _hoisted_11$1, [
            createVNode(unref(_sfc_main$q), {
              tag: tags.value,
              onRemove: removeTag
            }, null, 8, ["tag"])
          ])) : createCommentVNode("", true)
        ], 4)) : createCommentVNode("", true)
      ]);
    };
  }
});
const ToolbarView = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-4be8bee1"]]);
const _hoisted_1$1 = { class: "block lg:hidden" };
const _hoisted_2 = { class: "hidden lg:block" };
const _hoisted_3 = { class: "w-full max-w-full h-screen" };
const _hoisted_4 = ["value"];
const _hoisted_5 = { class: "flex h-full flex-col" };
const _hoisted_6 = {
  role: "navigation",
  id: "book-view_nav_bar",
  "aria-label": "Navbar",
  class: "navbar justify-between border-b border-base-200 px-3 py-0 min-h-12"
};
const _hoisted_7 = { class: "gap-3 flex" };
const _hoisted_8 = ["for"];
const _hoisted_9 = {
  key: 2,
  class: "tooltip tooltip-bottom",
  "data-tip": ""
};
const _hoisted_10 = /* @__PURE__ */ createBaseVNode("div", null, null, -1);
const _hoisted_11 = { class: "flex gap-4" };
const _hoisted_12 = { class: "dropdown-content z-[1] menu p-2 mt-1 shadow bg-base-100 border border-accent rounded-box divide-y" };
const _hoisted_13 = { class: "flex flex-row justify-between py-1" };
const _hoisted_14 = { class: "flex flex-row justify-between py-1" };
const _hoisted_15 = { class: "!p-0 my-1" };
const _hoisted_16 = { class: "stat-title" };
const _hoisted_17 = { class: "badge badge-outline" };
const _hoisted_18 = { class: "!p-0 my-1" };
const _hoisted_19 = { class: "stat-title" };
const _hoisted_20 = { class: "badge badge-outline" };
const _hoisted_21 = ["for"];
const _hoisted_22 = ["id"];
const _hoisted_23 = { class: "block lg:hidden" };
const _hoisted_24 = { class: "hidden lg:block" };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "reader",
  props: {
    id: String
  },
  setup(__props) {
    const props = __props;
    const router2 = useRouter();
    const book2 = BookAction.observableOne(props.id);
    const bookContent = ref();
    const [isLoading, setLoading] = useToggle(false);
    const section = ref([]);
    const tocList = ref([]);
    const { width } = useWindowSize();
    const isSM = computed(() => width.value < 1024);
    const { isLG: isCatalog, toggleDrawer: toggleCatalog } = useToggleDrawer();
    const { isLG: isNote, toggleDrawer: toggleNote } = useToggleDrawer();
    const readMode2 = ref(settingStore.value.readMode);
    const scrollReaderViewRef = ref();
    const sectionReaderViewRef = ref();
    const doubleReaderViewRef = ref();
    const isPDF2 = DPFUtil.isPDF;
    const isNoteRichShow = NoteBarStyle.show;
    const isShowToolBar = ToolbarStyle.show;
    const isScrollLocked = computed(() => get(isNoteRichShow) || get(isShowToolBar));
    async function getBookContent(bookId, url) {
      try {
        if (isElectron) {
          const content = await window.api.readFile(url);
          return { content, bookId };
        } else {
          return BookContentAction.findOne(bookId);
        }
      } catch (err) {
        return null;
      }
    }
    async function loadData() {
      try {
        setLoading(true);
        const bookId = props.id;
        if (!bookId)
          return;
        const info2 = await BookAction.fineOne(bookId);
        if (!info2)
          return;
        const content = await getBookContent(bookId, info2.path);
        if (!content)
          return;
        const file2 = arrayBufferToFile(content.content, info2.name || "");
        const { sections, toc } = await render(file2);
        section.value = sections;
        tocList.value = toc;
        bookContent.value = content;
        setLoading(false);
        await nextTick();
        if (get(isPDF2)) {
          await PDF.render(content.content, props.id);
          const outline = await PDF.getOutline();
          set$1(tocList, outline);
        }
        initHighlight(info2);
        const note2 = localStorage.getItem("__note__");
        if (note2) {
          noteJump(JSON.parse(note2));
          localStorage.removeItem("__note__");
        } else {
          if (settingStore.value.isRemeberPosition) {
            restorePostion();
          }
        }
        const count = (info2.count || 0) + 1;
        BookAction.update(info2.id, { count });
      } catch (err) {
        console.log(err);
      } finally {
        setLoading(false);
      }
    }
    async function jumpAction(index, id2, position) {
      if (get(isPDF2)) {
        await PDF.pageJump(index, id2);
      } else {
        const mode = get(readMode2);
        if (mode === ReadMode.sroll) {
          scrollReaderViewRef.value?.jump(index, id2, position);
        } else if (mode === ReadMode.section) {
          sectionReaderViewRef.value?.jump(index, id2, position);
        } else {
          doubleReaderViewRef.value?.jump(index, id2, position);
        }
      }
    }
    async function catalogJump({ page }) {
      if (get(isPDF2)) {
        await jumpAction(page);
      } else {
        jumpAction(page || 0);
      }
    }
    async function noteJump(note2) {
      console.log("note", note2);
      const source = NoteAction.getDomSource(note2.domSource);
      if (source.length === 0)
        return;
      const { page, id: id2 } = source[0];
      if (page === "-1")
        return;
      jumpAction(+page, id2);
    }
    const showBack = ref(router2.options.routes.length > 1 && !settingStore.value.isOpenNew);
    function goBack() {
      router2.go(-1);
    }
    const zoomSize = useCssVar("--prose-max-width", document.documentElement);
    function zoomIn() {
      const doms = $$(".prose-width");
      if (doms.length === 0)
        return;
      const sectionDom = $(`#${CONTINAER_ID}`);
      if (!sectionDom)
        return;
      const { width: width2 } = doms[0].getBoundingClientRect();
      const { width: sectionWidth } = sectionDom.getBoundingClientRect();
      if (width2 < sectionWidth - 200) {
        const val = +get(zoomSize.value).replace("ch", "");
        console.log(val);
        set$1(zoomSize, `${val + 2}ch`);
      }
    }
    function zoomOut() {
      const val = +get(zoomSize.value).replace("ch", "");
      if (val > 8) {
        set$1(zoomSize, `${val - 2}ch`);
      }
    }
    watchEffect(async () => {
      const mode = settingStore.value.readMode;
      if (mode === ReadMode.double) {
        set$1(zoomSize, `${65 * 2}ch`);
      }
      if (mode === get(readMode2))
        return;
      await recordPosition();
      set$1(readMode2, mode);
      await nextTick();
      restorePostion();
    });
    const fontSize = useCssVar("--prose-font-size", document.documentElement);
    const lineHeight = useCssVar("--prose-line-height", document.documentElement);
    const fontSizeList = [
      { size: "0.75rem", lineHeight: "1rem" },
      { size: "0.875rem", lineHeight: "1.25rem" },
      { size: "1rem", lineHeight: "1.5rem" },
      { size: "1.125rem", lineHeight: "1.75rem" },
      { size: "1.25rem", lineHeight: "1.75rem" },
      { size: "1.5rem", lineHeight: "2rem" },
      { size: "1.875rem", lineHeight: "2.25rem" },
      { size: "2.25rem", lineHeight: "2.5rem" },
      { size: "3rem", lineHeight: "1" }
    ];
    const updateSize = (i2) => {
      set$1(fontSize, fontSizeList[i2].size);
      set$1(lineHeight, fontSizeList[i2].lineHeight);
    };
    function sizeOut() {
      const index = fontSizeList.findIndex((item) => item.size === get(fontSize));
      if (index === -1) {
        updateSize(2);
        return;
      }
      if (index === 0)
        return;
      updateSize(index - 1);
    }
    function sizeIn() {
      const index = fontSizeList.findIndex((item) => item.size === get(fontSize));
      if (index === -1) {
        updateSize(2);
        return;
      }
      if (index === fontSizeList.length - 1)
        return;
      updateSize(index + 1);
    }
    const bookPageStore = useBookPageStore();
    async function recordPosition() {
      const info2 = get(book2);
      if (!info2)
        return;
      let postion = null;
      if (get(isPDF2)) {
        const page = PDF.getCurrentPageNumber() || 0;
        postion = { page, index: -1, tagName: "" };
      } else {
        const page = get(bookPageStore.page);
        const contianer = getSectionContainer(page);
        if (!contianer)
          return;
        if (get(readMode2) === ReadMode.double) {
          postion = getSectionLeftFfirstChild(contianer, page);
        } else {
          postion = getSectionFirstChild(page);
        }
        postion = postion || { page, index: -1, tagName: "" };
      }
      const lastReadPosition = JSON.stringify(postion);
      sessionStorage.setItem("book-wise_refrersh", lastReadPosition);
      if (get(showBack)) {
        await BookAction.update(info2.id, { lastReadPosition });
      } else {
        bookPositionStore.value[info2.id] = lastReadPosition;
      }
    }
    function restorePostion() {
      let postion = void 0;
      if (isReload()) {
        postion = sessionStorage.getItem("book-wise_refrersh");
      } else {
        postion = get(book2)?.lastReadPosition;
      }
      sessionStorage.removeItem("book-wise_refrersh");
      if (!postion)
        return;
      toastSuccess(t$2("book.jumpToLastPosition"));
      const data2 = JSON.parse(postion);
      if (get(isPDF2)) {
        PDF.pageJump(data2.page);
        return;
      } else {
        jumpAction(data2.page, void 0, data2);
      }
    }
    const updateProgress = (val) => {
      BookAction.update(get(book2).id, { progress: val });
    };
    const startTime = ref(0);
    const endTime = ref(0);
    const readTime = computed(() => getInterval(get(startTime), get(endTime)));
    let timer = null;
    const startReading = () => set$1(startTime, now());
    const endReading = () => set$1(endTime, now());
    function resetReadTime() {
      if (timer) {
        clearInterval(timer);
      }
      timer = setInterval(endReading, 1e3 * 60);
      startReading();
      endReading();
    }
    function recordReadTime() {
      const info2 = get(book2);
      if (!info2)
        return;
      const spaceTime = +get(readTime);
      if (spaceTime >= 1) {
        const data2 = {
          startTime: get(startTime),
          endTime: get(endTime),
          eBookId: info2.id
        };
        bookReadTimeStore.value[info2.id] = JSON.stringify(data2);
      }
    }
    const viewVisibityChange = () => {
      recordReadTime();
      resetReadTime();
    };
    function recordAction() {
      recordPosition();
      recordReadTime();
    }
    onMounted(() => {
      loadData();
      resetReadTime();
      window.addEventListener("beforeunload", recordAction);
      document.addEventListener("visibilitychange", viewVisibityChange);
    });
    onBeforeUnmount(() => {
      recordAction();
      window.removeEventListener("beforeunload", recordAction);
      document.removeEventListener("visibilitychange", viewVisibityChange);
      if (timer) {
        clearInterval(timer);
      }
      unMountedBookRender();
      highlighter?.dispose();
    });
    return (_ctx, _cache) => {
      return unref(isLoading) ? (openBlock(), createBlock(unref(RingLoadingView), {
        key: 0,
        class: "min-h-screen"
      })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        unref(book2) && bookContent.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("div", _hoisted_1$1, [
            createVNode(unref(_sfc_main$B), { id: unref(CETALOG_DRAWER) }, {
              default: withCtx(() => [
                createVNode(CatalogView, {
                  data: tocList.value,
                  onClick: catalogJump
                }, null, 8, ["data"])
              ]),
              _: 1
            }, 8, ["id"])
          ]),
          createBaseVNode("div", _hoisted_2, [
            createVNode(CatalogView, {
              class: normalizeClass({ "hide": unref(isCatalog) }),
              data: tocList.value,
              onClick: catalogJump
            }, null, 8, ["class", "data"])
          ]),
          createBaseVNode("div", _hoisted_3, [
            unref(book2).progress ? (openBlock(), createElementBlock("progress", {
              key: 0,
              class: "progress progress-primary w-full fixed top-0 left-0 right-0 z-[9999999] h-[2px]",
              value: unref(book2).progress * 100,
              max: "100"
            }, null, 8, _hoisted_4)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_5, [
              createBaseVNode("div", _hoisted_6, [
                createBaseVNode("div", _hoisted_7, [
                  isSM.value ? (openBlock(), createElementBlock("label", {
                    key: 0,
                    for: unref(CETALOG_DRAWER),
                    class: "cursor-pointer"
                  }, [
                    createVNode(unref(AlignJustify), { class: "w-5 h-5" })
                  ], 8, _hoisted_8)) : (openBlock(), createElementBlock("button", {
                    key: 1,
                    "aria-label": "Leftmenu toggle",
                    onClick: _cache[0] || (_cache[0] = //@ts-ignore
                    (...args) => unref(toggleCatalog) && unref(toggleCatalog)(...args)),
                    class: "btn btn-sm btn-square btn-ghost"
                  }, [
                    createVNode(unref(AlignJustify), { class: "w-5 h-5" })
                  ])),
                  showBack.value ? (openBlock(), createElementBlock("div", _hoisted_9, [
                    createBaseVNode("button", {
                      class: "btn btn-sm btn-square btn-ghost",
                      onClick: _cache[1] || (_cache[1] = ($event) => goBack())
                    }, [
                      createVNode(unref(SkipBack))
                    ])
                  ])) : createCommentVNode("", true)
                ]),
                _hoisted_10,
                createBaseVNode("div", _hoisted_11, [
                  unref(isPDF2) ? (openBlock(), createBlock(_sfc_main$4, { key: 0 })) : createCommentVNode("", true),
                  createVNode(unref(_sfc_main$A), {
                    "details-class": "dropdown-bottom dropdown-end",
                    "summary-class": "btn btn-sm m-1"
                  }, {
                    summary: withCtx(() => [
                      createVNode(unref(Bolt))
                    ]),
                    default: withCtx(() => [
                      createBaseVNode("ul", _hoisted_12, [
                        !unref(isPDF2) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                          createBaseVNode("li", _hoisted_13, [
                            createBaseVNode("a", {
                              onClick: _cache[2] || (_cache[2] = ($event) => zoomOut())
                            }, [
                              createVNode(unref(ZoomOut))
                            ]),
                            createBaseVNode("a", {
                              onClick: _cache[3] || (_cache[3] = ($event) => zoomIn())
                            }, [
                              createVNode(unref(ZoomIn))
                            ])
                          ]),
                          createBaseVNode("li", _hoisted_14, [
                            createBaseVNode("a", {
                              onClick: _cache[4] || (_cache[4] = ($event) => sizeOut())
                            }, [
                              createVNode(unref(AArrowDown))
                            ]),
                            createBaseVNode("a", {
                              onClick: _cache[5] || (_cache[5] = ($event) => sizeIn())
                            }, [
                              createVNode(unref(AArrowUp))
                            ])
                          ])
                        ], 64)) : createCommentVNode("", true),
                        createBaseVNode("li", null, [
                          createBaseVNode("a", _hoisted_15, [
                            createVNode(unref(_sfc_main$A), { "summary-class": "flex flex-row justify-between  w-52 dropdown-left px-4 py-2" }, {
                              summary: withCtx(() => [
                                createBaseVNode("span", _hoisted_16, toDisplayString$1(unref(t$2)("setting.theme")), 1),
                                createBaseVNode("div", _hoisted_17, toDisplayString$1(unref(settingStore).theme), 1)
                              ]),
                              default: withCtx(() => [
                                createVNode(unref(_sfc_main$y), {
                                  class: "dropdown-content !top-0 !right-[13.5rem] !border-secondary rounded-s-lg rounded-ee-lg z-[2] w-52",
                                  list: unref(themes),
                                  modelValue: unref(settingStore).theme,
                                  "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(settingStore).theme = $event)
                                }, null, 8, ["list", "modelValue"])
                              ]),
                              _: 1
                            })
                          ])
                        ]),
                        createBaseVNode("li", null, [
                          createBaseVNode("a", _hoisted_18, [
                            createVNode(unref(_sfc_main$A), { "summary-class": "flex flex-row justify-between  w-52  dropdown-left px-4 py-2" }, {
                              summary: withCtx(() => [
                                createBaseVNode("span", _hoisted_19, toDisplayString$1(unref(t$2)("setting.readMode")), 1),
                                createBaseVNode("div", _hoisted_20, toDisplayString$1(unref(getSelectReadMode)(unref(settingStore).readMode)), 1)
                              ]),
                              default: withCtx(() => [
                                createVNode(unref(_sfc_main$y), {
                                  class: "dropdown-content !top-0 !right-[13.5rem] !border-secondary rounded-s-lg rounded-ee-lg z-[2] w-52",
                                  list: unref(readModeList),
                                  modelValue: unref(settingStore).readMode,
                                  "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => unref(settingStore).readMode = $event)
                                }, null, 8, ["list", "modelValue"])
                              ]),
                              _: 1
                            })
                          ])
                        ])
                      ])
                    ]),
                    _: 1
                  }),
                  isSM.value ? (openBlock(), createElementBlock("label", {
                    key: 1,
                    for: unref(NOTE_DRAWER),
                    class: "cursor-pointer"
                  }, [
                    createVNode(unref(AlignJustify), { class: "w-5 h-5" })
                  ], 8, _hoisted_21)) : (openBlock(), createElementBlock("button", {
                    key: 2,
                    "aria-label": "Leftmenu toggle",
                    onClick: _cache[8] || (_cache[8] = //@ts-ignore
                    (...args) => unref(toggleNote) && unref(toggleNote)(...args)),
                    class: "btn btn-sm btn-square btn-ghost"
                  }, [
                    createVNode(unref(AlignJustify), { class: "w-5 h-5" })
                  ]))
                ])
              ]),
              createBaseVNode("div", {
                class: "flex-1 overflow-hidden relative selection:bg-info selection:text-base-content",
                id: unref(CONTINAER_ID)
              }, [
                unref(isPDF2) ? (openBlock(), createBlock(_sfc_main$5, {
                  key: 0,
                  isScrollLocked: isScrollLocked.value
                }, null, 8, ["isScrollLocked"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  readMode2.value === unref(ReadMode).sroll ? (openBlock(), createBlock(_sfc_main$7, {
                    key: 0,
                    section: section.value,
                    isScrollLocked: isScrollLocked.value,
                    ref_key: "scrollReaderViewRef",
                    ref: scrollReaderViewRef,
                    onProgress: updateProgress
                  }, null, 8, ["section", "isScrollLocked"])) : createCommentVNode("", true),
                  readMode2.value === unref(ReadMode).section ? (openBlock(), createBlock(_sfc_main$6, {
                    key: 1,
                    section: section.value,
                    isScrollLocked: isScrollLocked.value,
                    ref_key: "sectionReaderViewRef",
                    ref: sectionReaderViewRef,
                    onProgress: updateProgress
                  }, null, 8, ["section", "isScrollLocked"])) : createCommentVNode("", true),
                  readMode2.value === unref(ReadMode).double ? (openBlock(), createBlock(DoubleReaderView, {
                    key: 2,
                    section: section.value,
                    isScrollLocked: isScrollLocked.value,
                    ref_key: "doubleReaderViewRef",
                    ref: doubleReaderViewRef,
                    onProgress: updateProgress
                  }, null, 8, ["section", "isScrollLocked"])) : createCommentVNode("", true)
                ], 64)),
                unref(isShowToolBar) ? (openBlock(), createBlock(ToolbarView, { key: 2 })) : createCommentVNode("", true),
                unref(isNoteRichShow) ? (openBlock(), createBlock(NoteRichView, { key: 3 })) : createCommentVNode("", true)
              ], 8, _hoisted_22)
            ])
          ]),
          createBaseVNode("div", _hoisted_23, [
            createVNode(unref(_sfc_main$B), {
              id: unref(NOTE_DRAWER),
              "is-right": true
            }, {
              default: withCtx(() => [
                createVNode(NoteView, {
                  book: unref(book2),
                  onJump: noteJump,
                  "read-time": readTime.value
                }, null, 8, ["book", "read-time"])
              ]),
              _: 1
            }, 8, ["id"])
          ]),
          createBaseVNode("div", _hoisted_24, [
            createVNode(NoteView, {
              book: unref(book2),
              "read-time": readTime.value,
              onJump: noteJump,
              class: normalizeClass({ "hide": unref(isNote) })
            }, null, 8, ["book", "read-time", "class"])
          ])
        ], 64)) : (openBlock(), createBlock(unref(ErrorView), { key: 1 }))
      ], 64));
    };
  }
});
const RouterName = {
  Home: "home",
  Book: "book",
  Note: "note",
  Setting: "setting",
  Reader: "reader",
  Layout: "layout",
  RecycleBin: "recycle-bin"
};
const routes = [
  // { path: '/', redirect: '/menu/' },
  {
    path: "/",
    name: RouterName.Layout,
    component: _sfc_main$j,
    redirect: "/home",
    // 
    children: [
      { path: "home", name: RouterName.Home, component: _sfc_main$h },
      { path: "book", name: RouterName.Book, component: _sfc_main$i },
      { path: "note", name: RouterName.Note, component: _sfc_main$g },
      { path: "recycle-bin", name: RouterName.RecycleBin, component: _sfc_main$f },
      { path: "setting", name: RouterName.Setting, component: _sfc_main$K }
    ]
  },
  { path: "/reader:id", name: RouterName.Reader, component: _sfc_main$1, props: true }
];
const router = createRouter({
  history: createWebHashHistory(),
  routes
});
const favicon = "" + new URL("favicon-Buz3RJa0.ico", import.meta.url).href;
var ar = { exports: {} };
(function(module, exports) {
  !function(e2, t2) {
    module.exports = t2(requireDayjs_min());
  }(commonjsGlobal, function(e2) {
    function t2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var n2 = t2(e2), r2 = "___________".split("_"), d = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, _2 = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" }, o2 = { name: "ar", weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), months: r2, monthsShort: r2, weekStart: 6, meridiem: function(e3) {
      return e3 > 12 ? "" : "";
    }, relativeTime: { future: " %s", past: " %s", s: " ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, preparse: function(e3) {
      return e3.replace(/[]/g, function(e4) {
        return _2[e4];
      }).replace(//g, ",");
    }, postformat: function(e3) {
      return e3.replace(/\d/g, function(e4) {
        return d[e4];
      }).replace(/,/g, "");
    }, ordinal: function(e3) {
      return e3;
    }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/M/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" } };
    return n2.default.locale(o2, null, true), o2;
  });
})(ar);
var de = { exports: {} };
(function(module, exports) {
  !function(e2, n2) {
    module.exports = n2(requireDayjs_min());
  }(commonjsGlobal, function(e2) {
    function n2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var t2 = n2(e2), a2 = { s: "ein paar Sekunden", m: ["eine Minute", "einer Minute"], mm: "%d Minuten", h: ["eine Stunde", "einer Stunde"], hh: "%d Stunden", d: ["ein Tag", "einem Tag"], dd: ["%d Tage", "%d Tagen"], M: ["ein Monat", "einem Monat"], MM: ["%d Monate", "%d Monaten"], y: ["ein Jahr", "einem Jahr"], yy: ["%d Jahre", "%d Jahren"] };
    function i2(e3, n3, t3) {
      var i3 = a2[t3];
      return Array.isArray(i3) && (i3 = i3[n3 ? 0 : 1]), i3.replace("%d", e3);
    }
    var r2 = { name: "de", weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"), weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"), weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), months: "Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sept._Okt._Nov._Dez.".split("_"), ordinal: function(e3) {
      return e3 + ".";
    }, weekStart: 1, yearStart: 4, formats: { LTS: "HH:mm:ss", LT: "HH:mm", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" }, relativeTime: { future: "in %s", past: "vor %s", s: i2, m: i2, mm: i2, h: i2, hh: i2, d: i2, dd: i2, M: i2, MM: i2, y: i2, yy: i2 } };
    return t2.default.locale(r2, null, true), r2;
  });
})(de);
var en = { exports: {} };
(function(module, exports) {
  !function(e2, n2) {
    module.exports = n2();
  }(commonjsGlobal, function() {
    return { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(e2) {
      var n2 = ["th", "st", "nd", "rd"], t2 = e2 % 100;
      return "[" + e2 + (n2[(t2 - 20) % 10] || n2[t2] || n2[0]) + "]";
    } };
  });
})(en);
var es = { exports: {} };
(function(module, exports) {
  !function(e2, o2) {
    module.exports = o2(requireDayjs_min());
  }(commonjsGlobal, function(e2) {
    function o2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var s = o2(e2), d = { name: "es", monthsShort: "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"), weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"), months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), weekStart: 1, formats: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un da", dd: "%d das", M: "un mes", MM: "%d meses", y: "un ao", yy: "%d aos" }, ordinal: function(e3) {
      return e3 + "";
    } };
    return s.default.locale(d, null, true), d;
  });
})(es);
var fa = { exports: {} };
(function(module, exports) {
  !function(_2, e2) {
    module.exports = e2(requireDayjs_min());
  }(commonjsGlobal, function(_2) {
    function e2(_3) {
      return _3 && "object" == typeof _3 && "default" in _3 ? _3 : { default: _3 };
    }
    var t2 = e2(_2), d = { name: "fa", weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), weekStart: 6, months: "___________".split("_"), monthsShort: "___________".split("_"), ordinal: function(_3) {
      return _3;
    }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, relativeTime: { future: " %s", past: "%s ", s: " ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " } };
    return t2.default.locale(d, null, true), d;
  });
})(fa);
var fr = { exports: {} };
(function(module, exports) {
  !function(e2, n2) {
    module.exports = n2(requireDayjs_min());
  }(commonjsGlobal, function(e2) {
    function n2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var t2 = n2(e2), i2 = { name: "fr", weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"), weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"), weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"), months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"), monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"), weekStart: 1, yearStart: 4, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, relativeTime: { future: "dans %s", past: "il y a %s", s: "quelques secondes", m: "une minute", mm: "%d minutes", h: "une heure", hh: "%d heures", d: "un jour", dd: "%d jours", M: "un mois", MM: "%d mois", y: "un an", yy: "%d ans" }, ordinal: function(e3) {
      return "" + e3 + (1 === e3 ? "er" : "");
    } };
    return t2.default.locale(i2, null, true), i2;
  });
})(fr);
var id = { exports: {} };
(function(module, exports) {
  !function(e2, a2) {
    module.exports = a2(requireDayjs_min());
  }(commonjsGlobal, function(e2) {
    function a2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var t2 = a2(e2), _2 = { name: "id", weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"), months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"), weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"), monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des".split("_"), weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"), weekStart: 1, formats: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, relativeTime: { future: "dalam %s", past: "%s yang lalu", s: "beberapa detik", m: "semenit", mm: "%d menit", h: "sejam", hh: "%d jam", d: "sehari", dd: "%d hari", M: "sebulan", MM: "%d bulan", y: "setahun", yy: "%d tahun" }, ordinal: function(e3) {
      return e3 + ".";
    } };
    return t2.default.locale(_2, null, true), _2;
  });
})(id);
var it = { exports: {} };
(function(module, exports) {
  !function(e2, o2) {
    module.exports = o2(requireDayjs_min());
  }(commonjsGlobal, function(e2) {
    function o2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var t2 = o2(e2), n2 = { name: "it", weekdays: "domenica_luned_marted_mercoled_gioved_venerd_sabato".split("_"), weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"), weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"), months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"), weekStart: 1, monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"), formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, relativeTime: { future: "tra %s", past: "%s fa", s: "qualche secondo", m: "un minuto", mm: "%d minuti", h: "un' ora", hh: "%d ore", d: "un giorno", dd: "%d giorni", M: "un mese", MM: "%d mesi", y: "un anno", yy: "%d anni" }, ordinal: function(e3) {
      return e3 + "";
    } };
    return t2.default.locale(n2, null, true), n2;
  });
})(it);
var ja = { exports: {} };
(function(module, exports) {
  !function(e2, _2) {
    module.exports = _2(requireDayjs_min());
  }(commonjsGlobal, function(e2) {
    function _2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var t2 = _2(e2), d = { name: "ja", weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"), monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"), ordinal: function(e3) {
      return e3 + "";
    }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYYMD", LLL: "YYYYMD HH:mm", LLLL: "YYYYMD dddd HH:mm", l: "YYYY/MM/DD", ll: "YYYYMD", lll: "YYYYMD HH:mm", llll: "YYYYMD(ddd) HH:mm" }, meridiem: function(e3) {
      return e3 < 12 ? "" : "";
    }, relativeTime: { future: "%s", past: "%s", s: "", m: "1", mm: "%d", h: "1", hh: "%d", d: "1", dd: "%d", M: "1", MM: "%d", y: "1", yy: "%d" } };
    return t2.default.locale(d, null, true), d;
  });
})(ja);
var ko = { exports: {} };
(function(module, exports) {
  !function(e2, _2) {
    module.exports = _2(requireDayjs_min());
  }(commonjsGlobal, function(e2) {
    function _2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var d = _2(e2), t2 = { name: "ko", weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"), monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"), ordinal: function(e3) {
      return e3 + "";
    }, formats: { LT: "A h:mm", LTS: "A h:mm:ss", L: "YYYY.MM.DD.", LL: "YYYY MMMM D", LLL: "YYYY MMMM D A h:mm", LLLL: "YYYY MMMM D dddd A h:mm", l: "YYYY.MM.DD.", ll: "YYYY MMMM D", lll: "YYYY MMMM D A h:mm", llll: "YYYY MMMM D dddd A h:mm" }, meridiem: function(e3) {
      return e3 < 12 ? "" : "";
    }, relativeTime: { future: "%s ", past: "%s ", s: " ", m: "1", mm: "%d", h: " ", hh: "%d", d: "", dd: "%d", M: " ", MM: "%d", y: " ", yy: "%d" } };
    return d.default.locale(t2, null, true), t2;
  });
})(ko);
var ms = { exports: {} };
(function(module, exports) {
  !function(e2, a2) {
    module.exports = a2(requireDayjs_min());
  }(commonjsGlobal, function(e2) {
    function a2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var t2 = a2(e2), s = { name: "ms", weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"), weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"), weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"), months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"), monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"), weekStart: 1, formats: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH.mm", LLLL: "dddd, D MMMM YYYY HH.mm" }, relativeTime: { future: "dalam %s", past: "%s yang lepas", s: "beberapa saat", m: "seminit", mm: "%d minit", h: "sejam", hh: "%d jam", d: "sehari", dd: "%d hari", M: "sebulan", MM: "%d bulan", y: "setahun", yy: "%d tahun" }, ordinal: function(e3) {
      return e3 + ".";
    } };
    return t2.default.locale(s, null, true), s;
  });
})(ms);
var nl = { exports: {} };
(function(module, exports) {
  !function(e2, a2) {
    module.exports = a2(requireDayjs_min());
  }(commonjsGlobal, function(e2) {
    function a2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var d = a2(e2), n2 = { name: "nl", weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"), weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"), weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"), months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"), monthsShort: "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), ordinal: function(e3) {
      return "[" + e3 + (1 === e3 || 8 === e3 || e3 >= 20 ? "ste" : "de") + "]";
    }, weekStart: 1, yearStart: 4, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, relativeTime: { future: "over %s", past: "%s geleden", s: "een paar seconden", m: "een minuut", mm: "%d minuten", h: "een uur", hh: "%d uur", d: "een dag", dd: "%d dagen", M: "een maand", MM: "%d maanden", y: "een jaar", yy: "%d jaar" } };
    return d.default.locale(n2, null, true), n2;
  });
})(nl);
var pl = { exports: {} };
(function(module, exports) {
  !function(e2, t2) {
    module.exports = t2(requireDayjs_min());
  }(commonjsGlobal, function(e2) {
    function t2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var i2 = t2(e2);
    function a2(e3) {
      return e3 % 10 < 5 && e3 % 10 > 1 && ~~(e3 / 10) % 10 != 1;
    }
    function n2(e3, t3, i3) {
      var n3 = e3 + " ";
      switch (i3) {
        case "m":
          return t3 ? "minuta" : "minut";
        case "mm":
          return n3 + (a2(e3) ? "minuty" : "minut");
        case "h":
          return t3 ? "godzina" : "godzin";
        case "hh":
          return n3 + (a2(e3) ? "godziny" : "godzin");
        case "MM":
          return n3 + (a2(e3) ? "miesice" : "miesicy");
        case "yy":
          return n3 + (a2(e3) ? "lata" : "lat");
      }
    }
    var r2 = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia".split("_"), _2 = "stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie".split("_"), s = /D MMMM/, d = function(e3, t3) {
      return s.test(t3) ? r2[e3.month()] : _2[e3.month()];
    };
    d.s = _2, d.f = r2;
    var o2 = { name: "pl", weekdays: "niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota".split("_"), weekdaysShort: "ndz_pon_wt_r_czw_pt_sob".split("_"), weekdaysMin: "Nd_Pn_Wt_r_Cz_Pt_So".split("_"), months: d, monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru".split("_"), ordinal: function(e3) {
      return e3 + ".";
    }, weekStart: 1, yearStart: 4, relativeTime: { future: "za %s", past: "%s temu", s: "kilka sekund", m: n2, mm: n2, h: n2, hh: n2, d: "1 dzie", dd: "%d dni", M: "miesic", MM: n2, y: "rok", yy: n2 }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" } };
    return i2.default.locale(o2, null, true), o2;
  });
})(pl);
var pt = { exports: {} };
(function(module, exports) {
  !function(e2, a2) {
    module.exports = a2(requireDayjs_min());
  }(commonjsGlobal, function(e2) {
    function a2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var o2 = a2(e2), t2 = { name: "pt", weekdays: "domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado".split("_"), weekdaysShort: "dom_seg_ter_qua_qui_sex_sab".split("_"), weekdaysMin: "Do_2_3_4_5_6_Sa".split("_"), months: "janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"), monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"), ordinal: function(e3) {
      return e3 + "";
    }, weekStart: 1, yearStart: 4, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY [s] HH:mm", LLLL: "dddd, D [de] MMMM [de] YYYY [s] HH:mm" }, relativeTime: { future: "em %s", past: "h %s", s: "alguns segundos", m: "um minuto", mm: "%d minutos", h: "uma hora", hh: "%d horas", d: "um dia", dd: "%d dias", M: "um ms", MM: "%d meses", y: "um ano", yy: "%d anos" } };
    return o2.default.locale(t2, null, true), t2;
  });
})(pt);
var ru = { exports: {} };
(function(module, exports) {
  !function(_2, t2) {
    module.exports = t2(requireDayjs_min());
  }(commonjsGlobal, function(_2) {
    function t2(_3) {
      return _3 && "object" == typeof _3 && "default" in _3 ? _3 : { default: _3 };
    }
    var e2 = t2(_2), n2 = "___________".split("_"), s = "___________".split("_"), r2 = "._._._.____._._._._.".split("_"), o2 = "._.__.____._._._._.".split("_"), i2 = /D[oD]?(\[[^[\]]*\]|\s)+MMMM?/;
    function d(_3, t3, e3) {
      var n3, s2;
      return "m" === e3 ? t3 ? "" : "" : _3 + " " + (n3 = +_3, s2 = { mm: t3 ? "__" : "__", hh: "__", dd: "__", MM: "__", yy: "__" }[e3].split("_"), n3 % 10 == 1 && n3 % 100 != 11 ? s2[0] : n3 % 10 >= 2 && n3 % 10 <= 4 && (n3 % 100 < 10 || n3 % 100 >= 20) ? s2[1] : s2[2]);
    }
    var u = function(_3, t3) {
      return i2.test(t3) ? n2[_3.month()] : s[_3.month()];
    };
    u.s = s, u.f = n2;
    var a2 = function(_3, t3) {
      return i2.test(t3) ? r2[_3.month()] : o2[_3.month()];
    };
    a2.s = o2, a2.f = r2;
    var m2 = { name: "ru", weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), months: u, monthsShort: a2, weekStart: 1, yearStart: 4, formats: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY .", LLL: "D MMMM YYYY ., H:mm", LLLL: "dddd, D MMMM YYYY ., H:mm" }, relativeTime: { future: " %s", past: "%s ", s: " ", m: d, mm: d, h: "", hh: d, d: "", dd: d, M: "", MM: d, y: "", yy: d }, ordinal: function(_3) {
      return _3;
    }, meridiem: function(_3) {
      return _3 < 4 ? "" : _3 < 12 ? "" : _3 < 17 ? "" : "";
    } };
    return e2.default.locale(m2, null, true), m2;
  });
})(ru);
var sv = { exports: {} };
(function(module, exports) {
  !function(e2, t2) {
    module.exports = t2(requireDayjs_min());
  }(commonjsGlobal, function(e2) {
    function t2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var a2 = t2(e2), d = { name: "sv", weekdays: "sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag".split("_"), weekdaysShort: "sn_mn_tis_ons_tor_fre_lr".split("_"), weekdaysMin: "s_m_ti_on_to_fr_l".split("_"), months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"), monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"), weekStart: 1, yearStart: 4, ordinal: function(e3) {
      var t3 = e3 % 10;
      return "[" + e3 + (1 === t3 || 2 === t3 ? "a" : "e") + "]";
    }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [kl.] HH:mm", LLLL: "dddd D MMMM YYYY [kl.] HH:mm", lll: "D MMM YYYY HH:mm", llll: "ddd D MMM YYYY HH:mm" }, relativeTime: { future: "om %s", past: "fr %s sedan", s: "ngra sekunder", m: "en minut", mm: "%d minuter", h: "en timme", hh: "%d timmar", d: "en dag", dd: "%d dagar", M: "en mnad", MM: "%d mnader", y: "ett r", yy: "%d r" } };
    return a2.default.locale(d, null, true), d;
  });
})(sv);
var tr = { exports: {} };
(function(module, exports) {
  !function(a2, e2) {
    module.exports = e2(requireDayjs_min());
  }(commonjsGlobal, function(a2) {
    function e2(a3) {
      return a3 && "object" == typeof a3 && "default" in a3 ? a3 : { default: a3 };
    }
    var t2 = e2(a2), _2 = { name: "tr", weekdays: "Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi".split("_"), weekdaysShort: "Paz_Pts_Sal_ar_Per_Cum_Cts".split("_"), weekdaysMin: "Pz_Pt_Sa_a_Pe_Cu_Ct".split("_"), months: "Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk".split("_"), monthsShort: "Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara".split("_"), weekStart: 1, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, relativeTime: { future: "%s sonra", past: "%s nce", s: "birka saniye", m: "bir dakika", mm: "%d dakika", h: "bir saat", hh: "%d saat", d: "bir gn", dd: "%d gn", M: "bir ay", MM: "%d ay", y: "bir yl", yy: "%d yl" }, ordinal: function(a3) {
      return a3 + ".";
    } };
    return t2.default.locale(_2, null, true), _2;
  });
})(tr);
var uk = { exports: {} };
(function(module, exports) {
  !function(_2, e2) {
    module.exports = e2(requireDayjs_min());
  }(commonjsGlobal, function(_2) {
    function e2(_3) {
      return _3 && "object" == typeof _3 && "default" in _3 ? _3 : { default: _3 };
    }
    var t2 = e2(_2), s = "___________".split("_"), n2 = "___________".split("_"), o2 = /D[oD]?(\[[^[\]]*\]|\s)+MMMM?/;
    function d(_3, e3, t3) {
      var s2, n3;
      return "m" === t3 ? e3 ? "" : "" : "h" === t3 ? e3 ? "" : "" : _3 + " " + (s2 = +_3, n3 = { ss: e3 ? "__" : "__", mm: e3 ? "__" : "__", hh: e3 ? "__" : "__", dd: "__", MM: "__", yy: "__" }[t3].split("_"), s2 % 10 == 1 && s2 % 100 != 11 ? n3[0] : s2 % 10 >= 2 && s2 % 10 <= 4 && (s2 % 100 < 10 || s2 % 100 >= 20) ? n3[1] : n3[2]);
    }
    var i2 = function(_3, e3) {
      return o2.test(e3) ? s[_3.month()] : n2[_3.month()];
    };
    i2.s = n2, i2.f = s;
    var r2 = { name: "uk", weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), months: i2, monthsShort: "___________".split("_"), weekStart: 1, relativeTime: { future: " %s", past: "%s ", s: " ", m: d, mm: d, h: d, hh: d, d: "", dd: d, M: "", MM: d, y: "", yy: d }, ordinal: function(_3) {
      return _3;
    }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY .", LLL: "D MMMM YYYY ., HH:mm", LLLL: "dddd, D MMMM YYYY ., HH:mm" } };
    return t2.default.locale(r2, null, true), r2;
  });
})(uk);
var vi = { exports: {} };
(function(module, exports) {
  !function(t2, n2) {
    module.exports = n2(requireDayjs_min());
  }(commonjsGlobal, function(t2) {
    function n2(t3) {
      return t3 && "object" == typeof t3 && "default" in t3 ? t3 : { default: t3 };
    }
    var h2 = n2(t2), _2 = { name: "vi", weekdays: "ch nht_th hai_th ba_th t_th nm_th su_th by".split("_"), months: "thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12".split("_"), weekStart: 1, weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"), monthsShort: "Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12".split("_"), weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"), ordinal: function(t3) {
      return t3;
    }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM [nm] YYYY", LLL: "D MMMM [nm] YYYY HH:mm", LLLL: "dddd, D MMMM [nm] YYYY HH:mm", l: "DD/M/YYYY", ll: "D MMM YYYY", lll: "D MMM YYYY HH:mm", llll: "ddd, D MMM YYYY HH:mm" }, relativeTime: { future: "%s ti", past: "%s trc", s: "vi giy", m: "mt pht", mm: "%d pht", h: "mt gi", hh: "%d gi", d: "mt ngy", dd: "%d ngy", M: "mt thng", MM: "%d thng", y: "mt nm", yy: "%d nm" } };
    return h2.default.locale(_2, null, true), _2;
  });
})(vi);
var zhCn = { exports: {} };
(function(module, exports) {
  !function(e2, _2) {
    module.exports = _2(requireDayjs_min());
  }(commonjsGlobal, function(e2) {
    function _2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var t2 = _2(e2), d = { name: "zh-cn", weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), months: "___________".split("_"), monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"), ordinal: function(e3, _3) {
      return "W" === _3 ? e3 + "" : e3 + "";
    }, weekStart: 1, yearStart: 4, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYYMD", LLL: "YYYYMDAhmm", LLLL: "YYYYMDddddAhmm", l: "YYYY/M/D", ll: "YYYYMD", lll: "YYYYMD HH:mm", llll: "YYYYMDdddd HH:mm" }, relativeTime: { future: "%s", past: "%s", s: "", m: "1 ", mm: "%d ", h: "1 ", hh: "%d ", d: "1 ", dd: "%d ", M: "1 ", MM: "%d ", y: "1 ", yy: "%d " }, meridiem: function(e3, _3) {
      var t3 = 100 * e3 + _3;
      return t3 < 600 ? "" : t3 < 900 ? "" : t3 < 1100 ? "" : t3 < 1300 ? "" : t3 < 1800 ? "" : "";
    } };
    return t2.default.locale(d, null, true), d;
  });
})(zhCn);
var zhHk = { exports: {} };
(function(module, exports) {
  !function(_2, e2) {
    module.exports = e2(requireDayjs_min());
  }(commonjsGlobal, function(_2) {
    function e2(_3) {
      return _3 && "object" == typeof _3 && "default" in _3 ? _3 : { default: _3 };
    }
    var d = e2(_2), t2 = { name: "zh-hk", months: "___________".split("_"), monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), ordinal: function(_3, e3) {
      return "W" === e3 ? _3 + "" : _3 + "";
    }, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYYMD", LLL: "YYYYMD HH:mm", LLLL: "YYYYMDdddd HH:mm", l: "YYYY/M/D", ll: "YYYYMD", lll: "YYYYMD HH:mm", llll: "YYYYMDdddd HH:mm" }, relativeTime: { future: "%s", past: "%s", s: "", m: "", mm: "%d ", h: "", hh: "%d ", d: "", dd: "%d ", M: "", MM: "%d ", y: "", yy: "%d " }, meridiem: function(_3, e3) {
      var d2 = 100 * _3 + e3;
      return d2 < 600 ? "" : d2 < 900 ? "" : d2 < 1100 ? "" : d2 < 1300 ? "" : d2 < 1800 ? "" : "";
    } };
    return d.default.locale(t2, null, true), t2;
  });
})(zhHk);
var localizedFormat$1 = { exports: {} };
(function(module, exports) {
  !function(e2, t2) {
    module.exports = t2();
  }(commonjsGlobal, function() {
    var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
    return function(t2, o2, n2) {
      var r2 = o2.prototype, i2 = r2.format;
      n2.en.formats = e2, r2.format = function(t3) {
        void 0 === t3 && (t3 = "YYYY-MM-DDTHH:mm:ssZ");
        var o3 = this.$locale().formats, n3 = function(t4, o4) {
          return t4.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t5, n4, r3) {
            var i3 = r3 && r3.toUpperCase();
            return n4 || o4[r3] || e2[r3] || o4[i3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t6, o5) {
              return t6 || o5.slice(1);
            });
          });
        }(t3, void 0 === o3 ? {} : o3);
        return i2.call(this, n3);
      };
    };
  });
})(localizedFormat$1);
var localizedFormatExports = localizedFormat$1.exports;
const localizedFormat = /* @__PURE__ */ getDefaultExportFromCjs(localizedFormatExports);
dayjs.extend(localizedFormat);
watchEffect(() => {
  const lang = i18n.global.locale.value;
  if (lang === "zh_hans") {
    dayjs.locale("zh-cn");
  } else if (lang === "zh_hant") {
    dayjs.locale("zh-hk");
  } else if (lang === "no") {
    dayjs.locale("en");
  } else {
    dayjs.locale(lang);
  }
});
const _hoisted_1 = { class: "flex overflow-hidden" };
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    watchEffect(() => {
      const theme = settingStore.value.theme;
      document.querySelector("html")?.setAttribute("data-theme", theme);
      const lang = settingStore.value.lang;
      setI18nLanguage(lang);
    });
    const icon = useFavicon();
    set$1(icon, favicon);
    watchEffect(async () => {
      for (let key in bookPositionStore.value) {
        await BookAction.update(key, { lastReadPosition: bookPositionStore.value[key] });
      }
      bookPositionStore.value = {};
    });
    watchEffect(async () => {
      for (let key in bookReadTimeStore.value) {
        await BookReadTimeAction.add(JSON.parse(bookReadTimeStore.value[key]));
      }
      bookReadTimeStore.value = {};
    });
    return (_ctx, _cache) => {
      const _component_router_view = resolveComponent("router-view");
      return openBlock(), createElementBlock("div", {
        class: "size-full",
        onContextmenu: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createBaseVNode("div", _hoisted_1, [
          createVNode(_component_router_view, null, {
            default: withCtx(({ Component }) => [
              Component ? (openBlock(), createBlock(Suspense, { key: 0 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(Component)))
                ]),
                _: 2
              }, 1024)) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ])
      ], 32);
    };
  }
});
const pinia = createPinia();
createApp(_sfc_main).use(pinia).use(i18n).use(router).component("FoldTreeView", _sfc_main$n).component("ExpandTreeView", _sfc_main$o).mount("#app");
